(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);new MutationObserver(s=>{for(const a of s)if(a.type==="childList")for(const i of a.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&r(i)}).observe(document,{childList:!0,subtree:!0});function n(s){const a={};return s.integrity&&(a.integrity=s.integrity),s.referrerPolicy&&(a.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?a.credentials="include":s.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function r(s){if(s.ep)return;s.ep=!0;const a=n(s);fetch(s.href,a)}})();const mL="modulepreload",gL=function(t){return"/"+t},TS={},yL=function(e,n,r){let s=Promise.resolve();if(n&&n.length>0){document.getElementsByTagName("link");const i=document.querySelector("meta[property=csp-nonce]"),o=(i==null?void 0:i.nonce)||(i==null?void 0:i.getAttribute("nonce"));s=Promise.allSettled(n.map(l=>{if(l=gL(l),l in TS)return;TS[l]=!0;const u=l.endsWith(".css"),c=u?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${l}"]${c}`))return;const h=document.createElement("link");if(h.rel=u?"stylesheet":mL,u||(h.as="script"),h.crossOrigin="",h.href=l,o&&h.setAttribute("nonce",o),document.head.appendChild(h),u)return new Promise((d,p)=>{h.addEventListener("load",d),h.addEventListener("error",()=>p(new Error(`Unable to preload CSS for ${l}`)))})}))}function a(i){const o=new Event("vite:preloadError",{cancelable:!0});if(o.payload=i,window.dispatchEvent(o),!o.defaultPrevented)throw i}return s.then(i=>{for(const o of i||[])o.status==="rejected"&&a(o.reason);return e().catch(a)})};(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))n(r);new MutationObserver(r=>{for(const s of r)if(s.type==="childList")for(const a of s.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&n(a)}).observe(document,{childList:!0,subtree:!0});function e(r){const s={};return r.integrity&&(s.integrity=r.integrity),r.referrerPolicy&&(s.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?s.credentials="include":r.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function n(r){if(r.ep)return;r.ep=!0;const s=e(r);fetch(r.href,s)}})();const bL="modulepreload",xL=function(t){return"/"+t},ES={},vL=function(t,e,n){let r=Promise.resolve();if(e&&e.length>0){document.getElementsByTagName("link");const a=document.querySelector("meta[property=csp-nonce]"),i=(a==null?void 0:a.nonce)||(a==null?void 0:a.getAttribute("nonce"));r=Promise.allSettled(e.map(o=>{if(o=xL(o),o in ES)return;ES[o]=!0;const l=o.endsWith(".css"),u=l?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${o}"]${u}`))return;const c=document.createElement("link");if(c.rel=l?"stylesheet":bL,l||(c.as="script"),c.crossOrigin="",c.href=o,i&&c.setAttribute("nonce",i),document.head.appendChild(c),l)return new Promise((h,d)=>{c.addEventListener("load",h),c.addEventListener("error",()=>d(new Error(`Unable to preload CSS for ${o}`)))})}))}function s(a){const i=new Event("vite:preloadError",{cancelable:!0});if(i.payload=a,window.dispatchEvent(i),!i.defaultPrevented)throw a}return r.then(a=>{for(const i of a||[])i.status==="rejected"&&s(i.reason);return t().catch(s)})};(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))n(r);new MutationObserver(r=>{for(const s of r)if(s.type==="childList")for(const a of s.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&n(a)}).observe(document,{childList:!0,subtree:!0});function e(r){const s={};return r.integrity&&(s.integrity=r.integrity),r.referrerPolicy&&(s.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?s.credentials="include":r.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function n(r){if(r.ep)return;r.ep=!0;const s=e(r);fetch(r.href,s)}})();const wL="modulepreload",kL=function(t){return"/"+t},$S={},SL=function(t,e,n){let r=Promise.resolve();if(e&&e.length>0){document.getElementsByTagName("link");const a=document.querySelector("meta[property=csp-nonce]"),i=(a==null?void 0:a.nonce)||(a==null?void 0:a.getAttribute("nonce"));r=Promise.allSettled(e.map(o=>{if(o=kL(o),o in $S)return;$S[o]=!0;const l=o.endsWith(".css"),u=l?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${o}"]${u}`))return;const c=document.createElement("link");if(c.rel=l?"stylesheet":wL,l||(c.as="script"),c.crossOrigin="",c.href=o,i&&c.setAttribute("nonce",i),document.head.appendChild(c),l)return new Promise((h,d)=>{c.addEventListener("load",h),c.addEventListener("error",()=>d(new Error(`Unable to preload CSS for ${o}`)))})}))}function s(a){const i=new Event("vite:preloadError",{cancelable:!0});if(i.payload=a,window.dispatchEvent(i),!i.defaultPrevented)throw a}return r.then(a=>{for(const i of a||[])i.status==="rejected"&&s(i.reason);return t().catch(s)})};var IL=Object.defineProperty,NL=(t,e,n)=>e in t?IL(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,mt=(t,e,n)=>NL(t,typeof e!="symbol"?e+"":e,n);function CL(t,e){for(var n=0;n<e.length;n++){const r=e[n];if(typeof r!="string"&&!Array.isArray(r)){for(const s in r)if(s!=="default"&&!(s in t)){const a=Object.getOwnPropertyDescriptor(r,s);a&&Object.defineProperty(t,s,a.get?a:{enumerable:!0,get:()=>r[s]})}}}return Object.freeze(Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}))}(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))n(r);new MutationObserver(r=>{for(const s of r)if(s.type==="childList")for(const a of s.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&n(a)}).observe(document,{childList:!0,subtree:!0});function e(r){const s={};return r.integrity&&(s.integrity=r.integrity),r.referrerPolicy&&(s.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?s.credentials="include":r.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function n(r){if(r.ep)return;r.ep=!0;const s=e(r);fetch(r.href,s)}})();var aa=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Dv(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}function TL(t){if(t.__esModule)return t;var e=t.default;if(typeof e=="function"){var n=function r(){return this instanceof r?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};n.prototype=e.prototype}else n={};return Object.defineProperty(n,"__esModule",{value:!0}),Object.keys(t).forEach(function(r){var s=Object.getOwnPropertyDescriptor(t,r);Object.defineProperty(n,r,s.get?s:{enumerable:!0,get:function(){return t[r]}})}),n}var gT={exports:{}},zg={},yT={exports:{}},lt={};/**
* @license React
* react.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/var Hd=Symbol.for("react.element"),EL=Symbol.for("react.portal"),$L=Symbol.for("react.fragment"),RL=Symbol.for("react.strict_mode"),AL=Symbol.for("react.profiler"),_L=Symbol.for("react.provider"),FL=Symbol.for("react.context"),OL=Symbol.for("react.forward_ref"),DL=Symbol.for("react.suspense"),ML=Symbol.for("react.memo"),PL=Symbol.for("react.lazy"),RS=Symbol.iterator;function LL(t){return t===null||typeof t!="object"?null:(t=RS&&t[RS]||t["@@iterator"],typeof t=="function"?t:null)}var bT={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},xT=Object.assign,vT={};function Ku(t,e,n){this.props=t,this.context=e,this.refs=vT,this.updater=n||bT}Ku.prototype.isReactComponent={};Ku.prototype.setState=function(t,e){if(typeof t!="object"&&typeof t!="function"&&t!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,t,e,"setState")};Ku.prototype.forceUpdate=function(t){this.updater.enqueueForceUpdate(this,t,"forceUpdate")};function wT(){}wT.prototype=Ku.prototype;function Mv(t,e,n){this.props=t,this.context=e,this.refs=vT,this.updater=n||bT}var Pv=Mv.prototype=new wT;Pv.constructor=Mv;xT(Pv,Ku.prototype);Pv.isPureReactComponent=!0;var AS=Array.isArray,kT=Object.prototype.hasOwnProperty,Lv={current:null},ST={key:!0,ref:!0,__self:!0,__source:!0};function IT(t,e,n){var r,s={},a=null,i=null;if(e!=null)for(r in e.ref!==void 0&&(i=e.ref),e.key!==void 0&&(a=""+e.key),e)kT.call(e,r)&&!ST.hasOwnProperty(r)&&(s[r]=e[r]);var o=arguments.length-2;if(o===1)s.children=n;else if(1<o){for(var l=Array(o),u=0;u<o;u++)l[u]=arguments[u+2];s.children=l}if(t&&t.defaultProps)for(r in o=t.defaultProps,o)s[r]===void 0&&(s[r]=o[r]);return{$$typeof:Hd,type:t,key:a,ref:i,props:s,_owner:Lv.current}}function zL(t,e){return{$$typeof:Hd,type:t.type,key:e,ref:t.ref,props:t.props,_owner:t._owner}}function zv(t){return typeof t=="object"&&t!==null&&t.$$typeof===Hd}function BL(t){var e={"=":"=0",":":"=2"};return"$"+t.replace(/[=:]/g,function(n){return e[n]})}var _S=/\/+/g;function U0(t,e){return typeof t=="object"&&t!==null&&t.key!=null?BL(""+t.key):e.toString(36)}function hm(t,e,n,r,s){var a=typeof t;(a==="undefined"||a==="boolean")&&(t=null);var i=!1;if(t===null)i=!0;else switch(a){case"string":case"number":i=!0;break;case"object":switch(t.$$typeof){case Hd:case EL:i=!0}}if(i)return i=t,s=s(i),t=r===""?"."+U0(i,0):r,AS(s)?(n="",t!=null&&(n=t.replace(_S,"$&/")+"/"),hm(s,e,n,"",function(u){return u})):s!=null&&(zv(s)&&(s=zL(s,n+(!s.key||i&&i.key===s.key?"":(""+s.key).replace(_S,"$&/")+"/")+t)),e.push(s)),1;if(i=0,r=r===""?".":r+":",AS(t))for(var o=0;o<t.length;o++){a=t[o];var l=r+U0(a,o);i+=hm(a,e,n,l,s)}else if(l=LL(t),typeof l=="function")for(t=l.call(t),o=0;!(a=t.next()).done;)a=a.value,l=r+U0(a,o++),i+=hm(a,e,n,l,s);else if(a==="object")throw e=String(t),Error("Objects are not valid as a React child (found: "+(e==="[object Object]"?"object with keys {"+Object.keys(t).join(", ")+"}":e)+"). If you meant to render a collection of children, use an array instead.");return i}function Pf(t,e,n){if(t==null)return t;var r=[],s=0;return hm(t,r,"","",function(a){return e.call(n,a,s++)}),r}function WL(t){if(t._status===-1){var e=t._result;e=e(),e.then(function(n){(t._status===0||t._status===-1)&&(t._status=1,t._result=n)},function(n){(t._status===0||t._status===-1)&&(t._status=2,t._result=n)}),t._status===-1&&(t._status=0,t._result=e)}if(t._status===1)return t._result.default;throw t._result}var Rr={current:null},dm={transition:null},UL={ReactCurrentDispatcher:Rr,ReactCurrentBatchConfig:dm,ReactCurrentOwner:Lv};function NT(){throw Error("act(...) is not supported in production builds of React.")}lt.Children={map:Pf,forEach:function(t,e,n){Pf(t,function(){e.apply(this,arguments)},n)},count:function(t){var e=0;return Pf(t,function(){e++}),e},toArray:function(t){return Pf(t,function(e){return e})||[]},only:function(t){if(!zv(t))throw Error("React.Children.only expected to receive a single React element child.");return t}};lt.Component=Ku;lt.Fragment=$L;lt.Profiler=AL;lt.PureComponent=Mv;lt.StrictMode=RL;lt.Suspense=DL;lt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=UL;lt.act=NT;lt.cloneElement=function(t,e,n){if(t==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+t+".");var r=xT({},t.props),s=t.key,a=t.ref,i=t._owner;if(e!=null){if(e.ref!==void 0&&(a=e.ref,i=Lv.current),e.key!==void 0&&(s=""+e.key),t.type&&t.type.defaultProps)var o=t.type.defaultProps;for(l in e)kT.call(e,l)&&!ST.hasOwnProperty(l)&&(r[l]=e[l]===void 0&&o!==void 0?o[l]:e[l])}var l=arguments.length-2;if(l===1)r.children=n;else if(1<l){o=Array(l);for(var u=0;u<l;u++)o[u]=arguments[u+2];r.children=o}return{$$typeof:Hd,type:t.type,key:s,ref:a,props:r,_owner:i}};lt.createContext=function(t){return t={$$typeof:FL,_currentValue:t,_currentValue2:t,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},t.Provider={$$typeof:_L,_context:t},t.Consumer=t};lt.createElement=IT;lt.createFactory=function(t){var e=IT.bind(null,t);return e.type=t,e};lt.createRef=function(){return{current:null}};lt.forwardRef=function(t){return{$$typeof:OL,render:t}};lt.isValidElement=zv;lt.lazy=function(t){return{$$typeof:PL,_payload:{_status:-1,_result:t},_init:WL}};lt.memo=function(t,e){return{$$typeof:ML,type:t,compare:e===void 0?null:e}};lt.startTransition=function(t){var e=dm.transition;dm.transition={};try{t()}finally{dm.transition=e}};lt.unstable_act=NT;lt.useCallback=function(t,e){return Rr.current.useCallback(t,e)};lt.useContext=function(t){return Rr.current.useContext(t)};lt.useDebugValue=function(){};lt.useDeferredValue=function(t){return Rr.current.useDeferredValue(t)};lt.useEffect=function(t,e){return Rr.current.useEffect(t,e)};lt.useId=function(){return Rr.current.useId()};lt.useImperativeHandle=function(t,e,n){return Rr.current.useImperativeHandle(t,e,n)};lt.useInsertionEffect=function(t,e){return Rr.current.useInsertionEffect(t,e)};lt.useLayoutEffect=function(t,e){return Rr.current.useLayoutEffect(t,e)};lt.useMemo=function(t,e){return Rr.current.useMemo(t,e)};lt.useReducer=function(t,e,n){return Rr.current.useReducer(t,e,n)};lt.useRef=function(t){return Rr.current.useRef(t)};lt.useState=function(t){return Rr.current.useState(t)};lt.useSyncExternalStore=function(t,e,n){return Rr.current.useSyncExternalStore(t,e,n)};lt.useTransition=function(){return Rr.current.useTransition()};lt.version="18.3.1";yT.exports=lt;var ze=yT.exports;const VL=Dv(ze);/**
* @license React
* react-jsx-runtime.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/var jL=ze,GL=Symbol.for("react.element"),HL=Symbol.for("react.fragment"),KL=Object.prototype.hasOwnProperty,qL=jL.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,XL={key:!0,ref:!0,__self:!0,__source:!0};function CT(t,e,n){var r,s={},a=null,i=null;n!==void 0&&(a=""+n),e.key!==void 0&&(a=""+e.key),e.ref!==void 0&&(i=e.ref);for(r in e)KL.call(e,r)&&!XL.hasOwnProperty(r)&&(s[r]=e[r]);if(t&&t.defaultProps)for(r in e=t.defaultProps,e)s[r]===void 0&&(s[r]=e[r]);return{$$typeof:GL,type:t,key:a,ref:i,props:s,_owner:qL.current}}zg.Fragment=HL;zg.jsx=CT;zg.jsxs=CT;gT.exports=zg;var $=gT.exports,Bx={},TT={exports:{}},bs={},ET={exports:{}},$T={};/**
* @license React
* scheduler.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/(function(t){function e(G,J){var ne=G.length;G.push(J);e:for(;0<ne;){var ae=ne-1>>>1,oe=G[ae];if(0<s(oe,J))G[ae]=J,G[ne]=oe,ne=ae;else break e}}function n(G){return G.length===0?null:G[0]}function r(G){if(G.length===0)return null;var J=G[0],ne=G.pop();if(ne!==J){G[0]=ne;e:for(var ae=0,oe=G.length,ue=oe>>>1;ae<ue;){var ce=2*(ae+1)-1,de=G[ce],Te=ce+1,Ee=G[Te];if(0>s(de,ne))Te<oe&&0>s(Ee,de)?(G[ae]=Ee,G[Te]=ne,ae=Te):(G[ae]=de,G[ce]=ne,ae=ce);else if(Te<oe&&0>s(Ee,ne))G[ae]=Ee,G[Te]=ne,ae=Te;else break e}}return J}function s(G,J){var ne=G.sortIndex-J.sortIndex;return ne!==0?ne:G.id-J.id}if(typeof performance=="object"&&typeof performance.now=="function"){var a=performance;t.unstable_now=function(){return a.now()}}else{var i=Date,o=i.now();t.unstable_now=function(){return i.now()-o}}var l=[],u=[],c=1,h=null,d=3,p=!1,f=!1,m=!1,y=typeof setTimeout=="function"?setTimeout:null,g=typeof clearTimeout=="function"?clearTimeout:null,b=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function v(G){for(var J=n(u);J!==null;){if(J.callback===null)r(u);else if(J.startTime<=G)r(u),J.sortIndex=J.expirationTime,e(l,J);else break;J=n(u)}}function w(G){if(m=!1,v(G),!f)if(n(l)!==null)f=!0,ee(k);else{var J=n(u);J!==null&&te(w,J.startTime-G)}}function k(G,J){f=!1,m&&(m=!1,g(E),E=-1),p=!0;var ne=d;try{for(v(J),h=n(l);h!==null&&(!(h.expirationTime>J)||G&&!M());){var ae=h.callback;if(typeof ae=="function"){h.callback=null,d=h.priorityLevel;var oe=ae(h.expirationTime<=J);J=t.unstable_now(),typeof oe=="function"?h.callback=oe:h===n(l)&&r(l),v(J)}else r(l);h=n(l)}if(h!==null)var ue=!0;else{var ce=n(u);ce!==null&&te(w,ce.startTime-J),ue=!1}return ue}finally{h=null,d=ne,p=!1}}var N=!1,T=null,E=-1,_=5,O=-1;function M(){return!(t.unstable_now()-O<_)}function V(){if(T!==null){var G=t.unstable_now();O=G;var J=!0;try{J=T(!0,G)}finally{J?W():(N=!1,T=null)}}else N=!1}var W;if(typeof b=="function")W=function(){b(V)};else if(typeof MessageChannel<"u"){var K=new MessageChannel,q=K.port2;K.port1.onmessage=V,W=function(){q.postMessage(null)}}else W=function(){y(V,0)};function ee(G){T=G,N||(N=!0,W())}function te(G,J){E=y(function(){G(t.unstable_now())},J)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(G){G.callback=null},t.unstable_continueExecution=function(){f||p||(f=!0,ee(k))},t.unstable_forceFrameRate=function(G){0>G||125<G?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):_=0<G?Math.floor(1e3/G):5},t.unstable_getCurrentPriorityLevel=function(){return d},t.unstable_getFirstCallbackNode=function(){return n(l)},t.unstable_next=function(G){switch(d){case 1:case 2:case 3:var J=3;break;default:J=d}var ne=d;d=J;try{return G()}finally{d=ne}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(G,J){switch(G){case 1:case 2:case 3:case 4:case 5:break;default:G=3}var ne=d;d=G;try{return J()}finally{d=ne}},t.unstable_scheduleCallback=function(G,J,ne){var ae=t.unstable_now();switch(typeof ne=="object"&&ne!==null?(ne=ne.delay,ne=typeof ne=="number"&&0<ne?ae+ne:ae):ne=ae,G){case 1:var oe=-1;break;case 2:oe=250;break;case 5:oe=1073741823;break;case 4:oe=1e4;break;default:oe=5e3}return oe=ne+oe,G={id:c++,callback:J,priorityLevel:G,startTime:ne,expirationTime:oe,sortIndex:-1},ne>ae?(G.sortIndex=ne,e(u,G),n(l)===null&&G===n(u)&&(m?(g(E),E=-1):m=!0,te(w,ne-ae))):(G.sortIndex=oe,e(l,G),f||p||(f=!0,ee(k))),G},t.unstable_shouldYield=M,t.unstable_wrapCallback=function(G){var J=d;return function(){var ne=d;d=J;try{return G.apply(this,arguments)}finally{d=ne}}}})($T);ET.exports=$T;var YL=ET.exports;/**
* @license React
* react-dom.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/var QL=ze,fs=YL;function pe(t){for(var e="https://reactjs.org/docs/error-decoder.html?invariant="+t,n=1;n<arguments.length;n++)e+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+t+"; visit "+e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var RT=new Set,nd={};function kl(t,e){Tu(t,e),Tu(t+"Capture",e)}function Tu(t,e){for(nd[t]=e,t=0;t<e.length;t++)RT.add(e[t])}var li=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Wx=Object.prototype.hasOwnProperty,ZL=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,FS={},OS={};function JL(t){return Wx.call(OS,t)?!0:Wx.call(FS,t)?!1:ZL.test(t)?OS[t]=!0:(FS[t]=!0,!1)}function ez(t,e,n,r){if(n!==null&&n.type===0)return!1;switch(typeof e){case"function":case"symbol":return!0;case"boolean":return r?!1:n!==null?!n.acceptsBooleans:(t=t.toLowerCase().slice(0,5),t!=="data-"&&t!=="aria-");default:return!1}}function tz(t,e,n,r){if(e===null||typeof e>"u"||ez(t,e,n,r))return!0;if(r)return!1;if(n!==null)switch(n.type){case 3:return!e;case 4:return e===!1;case 5:return isNaN(e);case 6:return isNaN(e)||1>e}return!1}function Ar(t,e,n,r,s,a,i){this.acceptsBooleans=e===2||e===3||e===4,this.attributeName=r,this.attributeNamespace=s,this.mustUseProperty=n,this.propertyName=t,this.type=e,this.sanitizeURL=a,this.removeEmptyString=i}var Jn={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(t){Jn[t]=new Ar(t,0,!1,t,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(t){var e=t[0];Jn[e]=new Ar(e,1,!1,t[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(t){Jn[t]=new Ar(t,2,!1,t.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(t){Jn[t]=new Ar(t,2,!1,t,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(t){Jn[t]=new Ar(t,3,!1,t.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(t){Jn[t]=new Ar(t,3,!0,t,null,!1,!1)});["capture","download"].forEach(function(t){Jn[t]=new Ar(t,4,!1,t,null,!1,!1)});["cols","rows","size","span"].forEach(function(t){Jn[t]=new Ar(t,6,!1,t,null,!1,!1)});["rowSpan","start"].forEach(function(t){Jn[t]=new Ar(t,5,!1,t.toLowerCase(),null,!1,!1)});var Bv=/[\-:]([a-z])/g;function Wv(t){return t[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(t){var e=t.replace(Bv,Wv);Jn[e]=new Ar(e,1,!1,t,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(t){var e=t.replace(Bv,Wv);Jn[e]=new Ar(e,1,!1,t,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(t){var e=t.replace(Bv,Wv);Jn[e]=new Ar(e,1,!1,t,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(t){Jn[t]=new Ar(t,1,!1,t.toLowerCase(),null,!1,!1)});Jn.xlinkHref=new Ar("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(t){Jn[t]=new Ar(t,1,!1,t.toLowerCase(),null,!0,!0)});function Uv(t,e,n,r){var s=Jn.hasOwnProperty(e)?Jn[e]:null;(s!==null?s.type!==0:r||!(2<e.length)||e[0]!=="o"&&e[0]!=="O"||e[1]!=="n"&&e[1]!=="N")&&(tz(e,n,s,r)&&(n=null),r||s===null?JL(e)&&(n===null?t.removeAttribute(e):t.setAttribute(e,""+n)):s.mustUseProperty?t[s.propertyName]=n===null?s.type===3?!1:"":n:(e=s.attributeName,r=s.attributeNamespace,n===null?t.removeAttribute(e):(s=s.type,n=s===3||s===4&&n===!0?"":""+n,r?t.setAttributeNS(r,e,n):t.setAttribute(e,n))))}var bi=QL.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,Lf=Symbol.for("react.element"),ru=Symbol.for("react.portal"),su=Symbol.for("react.fragment"),Vv=Symbol.for("react.strict_mode"),Ux=Symbol.for("react.profiler"),AT=Symbol.for("react.provider"),_T=Symbol.for("react.context"),jv=Symbol.for("react.forward_ref"),Vx=Symbol.for("react.suspense"),jx=Symbol.for("react.suspense_list"),Gv=Symbol.for("react.memo"),Ti=Symbol.for("react.lazy"),FT=Symbol.for("react.offscreen"),DS=Symbol.iterator;function yh(t){return t===null||typeof t!="object"?null:(t=DS&&t[DS]||t["@@iterator"],typeof t=="function"?t:null)}var Jt=Object.assign,V0;function Rh(t){if(V0===void 0)try{throw Error()}catch(n){var e=n.stack.trim().match(/\n( *(at )?)/);V0=e&&e[1]||""}return`
`+V0+t}var j0=!1;function G0(t,e){if(!t||j0)return"";j0=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(e)if(e=function(){throw Error()},Object.defineProperty(e.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(e,[])}catch(u){var r=u}Reflect.construct(t,[],e)}else{try{e.call()}catch(u){r=u}t.call(e.prototype)}else{try{throw Error()}catch(u){r=u}t()}}catch(u){if(u&&r&&typeof u.stack=="string"){for(var s=u.stack.split(`
`),a=r.stack.split(`
`),i=s.length-1,o=a.length-1;1<=i&&0<=o&&s[i]!==a[o];)o--;for(;1<=i&&0<=o;i--,o--)if(s[i]!==a[o]){if(i!==1||o!==1)do if(i--,o--,0>o||s[i]!==a[o]){var l=`
`+s[i].replace(" at new "," at ");return t.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",t.displayName)),l}while(1<=i&&0<=o);break}}}finally{j0=!1,Error.prepareStackTrace=n}return(t=t?t.displayName||t.name:"")?Rh(t):""}function nz(t){switch(t.tag){case 5:return Rh(t.type);case 16:return Rh("Lazy");case 13:return Rh("Suspense");case 19:return Rh("SuspenseList");case 0:case 2:case 15:return t=G0(t.type,!1),t;case 11:return t=G0(t.type.render,!1),t;case 1:return t=G0(t.type,!0),t;default:return""}}function Gx(t){if(t==null)return null;if(typeof t=="function")return t.displayName||t.name||null;if(typeof t=="string")return t;switch(t){case su:return"Fragment";case ru:return"Portal";case Ux:return"Profiler";case Vv:return"StrictMode";case Vx:return"Suspense";case jx:return"SuspenseList"}if(typeof t=="object")switch(t.$$typeof){case _T:return(t.displayName||"Context")+".Consumer";case AT:return(t._context.displayName||"Context")+".Provider";case jv:var e=t.render;return t=t.displayName,t||(t=e.displayName||e.name||"",t=t!==""?"ForwardRef("+t+")":"ForwardRef"),t;case Gv:return e=t.displayName||null,e!==null?e:Gx(t.type)||"Memo";case Ti:e=t._payload,t=t._init;try{return Gx(t(e))}catch{}}return null}function rz(t){var e=t.type;switch(t.tag){case 24:return"Cache";case 9:return(e.displayName||"Context")+".Consumer";case 10:return(e._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return t=e.render,t=t.displayName||t.name||"",e.displayName||(t!==""?"ForwardRef("+t+")":"ForwardRef");case 7:return"Fragment";case 5:return e;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Gx(e);case 8:return e===Vv?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof e=="function")return e.displayName||e.name||null;if(typeof e=="string")return e}return null}function Qi(t){switch(typeof t){case"boolean":case"number":case"string":case"undefined":return t;case"object":return t;default:return""}}function OT(t){var e=t.type;return(t=t.nodeName)&&t.toLowerCase()==="input"&&(e==="checkbox"||e==="radio")}function sz(t){var e=OT(t)?"checked":"value",n=Object.getOwnPropertyDescriptor(t.constructor.prototype,e),r=""+t[e];if(!t.hasOwnProperty(e)&&typeof n<"u"&&typeof n.get=="function"&&typeof n.set=="function"){var s=n.get,a=n.set;return Object.defineProperty(t,e,{configurable:!0,get:function(){return s.call(this)},set:function(i){r=""+i,a.call(this,i)}}),Object.defineProperty(t,e,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(i){r=""+i},stopTracking:function(){t._valueTracker=null,delete t[e]}}}}function zf(t){t._valueTracker||(t._valueTracker=sz(t))}function DT(t){if(!t)return!1;var e=t._valueTracker;if(!e)return!0;var n=e.getValue(),r="";return t&&(r=OT(t)?t.checked?"true":"false":t.value),t=r,t!==n?(e.setValue(t),!0):!1}function _m(t){if(t=t||(typeof document<"u"?document:void 0),typeof t>"u")return null;try{return t.activeElement||t.body}catch{return t.body}}function Hx(t,e){var n=e.checked;return Jt({},e,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:n??t._wrapperState.initialChecked})}function MS(t,e){var n=e.defaultValue==null?"":e.defaultValue,r=e.checked!=null?e.checked:e.defaultChecked;n=Qi(e.value!=null?e.value:n),t._wrapperState={initialChecked:r,initialValue:n,controlled:e.type==="checkbox"||e.type==="radio"?e.checked!=null:e.value!=null}}function MT(t,e){e=e.checked,e!=null&&Uv(t,"checked",e,!1)}function Kx(t,e){MT(t,e);var n=Qi(e.value),r=e.type;if(n!=null)r==="number"?(n===0&&t.value===""||t.value!=n)&&(t.value=""+n):t.value!==""+n&&(t.value=""+n);else if(r==="submit"||r==="reset"){t.removeAttribute("value");return}e.hasOwnProperty("value")?qx(t,e.type,n):e.hasOwnProperty("defaultValue")&&qx(t,e.type,Qi(e.defaultValue)),e.checked==null&&e.defaultChecked!=null&&(t.defaultChecked=!!e.defaultChecked)}function PS(t,e,n){if(e.hasOwnProperty("value")||e.hasOwnProperty("defaultValue")){var r=e.type;if(!(r!=="submit"&&r!=="reset"||e.value!==void 0&&e.value!==null))return;e=""+t._wrapperState.initialValue,n||e===t.value||(t.value=e),t.defaultValue=e}n=t.name,n!==""&&(t.name=""),t.defaultChecked=!!t._wrapperState.initialChecked,n!==""&&(t.name=n)}function qx(t,e,n){(e!=="number"||_m(t.ownerDocument)!==t)&&(n==null?t.defaultValue=""+t._wrapperState.initialValue:t.defaultValue!==""+n&&(t.defaultValue=""+n))}var Ah=Array.isArray;function gu(t,e,n,r){if(t=t.options,e){e={};for(var s=0;s<n.length;s++)e["$"+n[s]]=!0;for(n=0;n<t.length;n++)s=e.hasOwnProperty("$"+t[n].value),t[n].selected!==s&&(t[n].selected=s),s&&r&&(t[n].defaultSelected=!0)}else{for(n=""+Qi(n),e=null,s=0;s<t.length;s++){if(t[s].value===n){t[s].selected=!0,r&&(t[s].defaultSelected=!0);return}e!==null||t[s].disabled||(e=t[s])}e!==null&&(e.selected=!0)}}function Xx(t,e){if(e.dangerouslySetInnerHTML!=null)throw Error(pe(91));return Jt({},e,{value:void 0,defaultValue:void 0,children:""+t._wrapperState.initialValue})}function LS(t,e){var n=e.value;if(n==null){if(n=e.children,e=e.defaultValue,n!=null){if(e!=null)throw Error(pe(92));if(Ah(n)){if(1<n.length)throw Error(pe(93));n=n[0]}e=n}e==null&&(e=""),n=e}t._wrapperState={initialValue:Qi(n)}}function PT(t,e){var n=Qi(e.value),r=Qi(e.defaultValue);n!=null&&(n=""+n,n!==t.value&&(t.value=n),e.defaultValue==null&&t.defaultValue!==n&&(t.defaultValue=n)),r!=null&&(t.defaultValue=""+r)}function zS(t){var e=t.textContent;e===t._wrapperState.initialValue&&e!==""&&e!==null&&(t.value=e)}function LT(t){switch(t){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Yx(t,e){return t==null||t==="http://www.w3.org/1999/xhtml"?LT(e):t==="http://www.w3.org/2000/svg"&&e==="foreignObject"?"http://www.w3.org/1999/xhtml":t}var Bf,zT=function(t){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(e,n,r,s){MSApp.execUnsafeLocalFunction(function(){return t(e,n,r,s)})}:t}(function(t,e){if(t.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in t)t.innerHTML=e;else{for(Bf=Bf||document.createElement("div"),Bf.innerHTML="<svg>"+e.valueOf().toString()+"</svg>",e=Bf.firstChild;t.firstChild;)t.removeChild(t.firstChild);for(;e.firstChild;)t.appendChild(e.firstChild)}});function rd(t,e){if(e){var n=t.firstChild;if(n&&n===t.lastChild&&n.nodeType===3){n.nodeValue=e;return}}t.textContent=e}var jh={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},az=["Webkit","ms","Moz","O"];Object.keys(jh).forEach(function(t){az.forEach(function(e){e=e+t.charAt(0).toUpperCase()+t.substring(1),jh[e]=jh[t]})});function BT(t,e,n){return e==null||typeof e=="boolean"||e===""?"":n||typeof e!="number"||e===0||jh.hasOwnProperty(t)&&jh[t]?(""+e).trim():e+"px"}function WT(t,e){t=t.style;for(var n in e)if(e.hasOwnProperty(n)){var r=n.indexOf("--")===0,s=BT(n,e[n],r);n==="float"&&(n="cssFloat"),r?t.setProperty(n,s):t[n]=s}}var iz=Jt({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function Qx(t,e){if(e){if(iz[t]&&(e.children!=null||e.dangerouslySetInnerHTML!=null))throw Error(pe(137,t));if(e.dangerouslySetInnerHTML!=null){if(e.children!=null)throw Error(pe(60));if(typeof e.dangerouslySetInnerHTML!="object"||!("__html"in e.dangerouslySetInnerHTML))throw Error(pe(61))}if(e.style!=null&&typeof e.style!="object")throw Error(pe(62))}}function Zx(t,e){if(t.indexOf("-")===-1)return typeof e.is=="string";switch(t){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Jx=null;function Hv(t){return t=t.target||t.srcElement||window,t.correspondingUseElement&&(t=t.correspondingUseElement),t.nodeType===3?t.parentNode:t}var e1=null,yu=null,bu=null;function BS(t){if(t=Xd(t)){if(typeof e1!="function")throw Error(pe(280));var e=t.stateNode;e&&(e=jg(e),e1(t.stateNode,t.type,e))}}function UT(t){yu?bu?bu.push(t):bu=[t]:yu=t}function VT(){if(yu){var t=yu,e=bu;if(bu=yu=null,BS(t),e)for(t=0;t<e.length;t++)BS(e[t])}}function jT(t,e){return t(e)}function GT(){}var H0=!1;function HT(t,e,n){if(H0)return t(e,n);H0=!0;try{return jT(t,e,n)}finally{H0=!1,(yu!==null||bu!==null)&&(GT(),VT())}}function sd(t,e){var n=t.stateNode;if(n===null)return null;var r=jg(n);if(r===null)return null;n=r[e];e:switch(e){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(t=t.type,r=!(t==="button"||t==="input"||t==="select"||t==="textarea")),t=!r;break e;default:t=!1}if(t)return null;if(n&&typeof n!="function")throw Error(pe(231,e,typeof n));return n}var t1=!1;if(li)try{var bh={};Object.defineProperty(bh,"passive",{get:function(){t1=!0}}),window.addEventListener("test",bh,bh),window.removeEventListener("test",bh,bh)}catch{t1=!1}function oz(t,e,n,r,s,a,i,o,l){var u=Array.prototype.slice.call(arguments,3);try{e.apply(n,u)}catch(c){this.onError(c)}}var Gh=!1,Fm=null,Om=!1,n1=null,lz={onError:function(t){Gh=!0,Fm=t}};function uz(t,e,n,r,s,a,i,o,l){Gh=!1,Fm=null,oz.apply(lz,arguments)}function cz(t,e,n,r,s,a,i,o,l){if(uz.apply(this,arguments),Gh){if(Gh){var u=Fm;Gh=!1,Fm=null}else throw Error(pe(198));Om||(Om=!0,n1=u)}}function Sl(t){var e=t,n=t;if(t.alternate)for(;e.return;)e=e.return;else{t=e;do e=t,e.flags&4098&&(n=e.return),t=e.return;while(t)}return e.tag===3?n:null}function KT(t){if(t.tag===13){var e=t.memoizedState;if(e===null&&(t=t.alternate,t!==null&&(e=t.memoizedState)),e!==null)return e.dehydrated}return null}function WS(t){if(Sl(t)!==t)throw Error(pe(188))}function hz(t){var e=t.alternate;if(!e){if(e=Sl(t),e===null)throw Error(pe(188));return e!==t?null:t}for(var n=t,r=e;;){var s=n.return;if(s===null)break;var a=s.alternate;if(a===null){if(r=s.return,r!==null){n=r;continue}break}if(s.child===a.child){for(a=s.child;a;){if(a===n)return WS(s),t;if(a===r)return WS(s),e;a=a.sibling}throw Error(pe(188))}if(n.return!==r.return)n=s,r=a;else{for(var i=!1,o=s.child;o;){if(o===n){i=!0,n=s,r=a;break}if(o===r){i=!0,r=s,n=a;break}o=o.sibling}if(!i){for(o=a.child;o;){if(o===n){i=!0,n=a,r=s;break}if(o===r){i=!0,r=a,n=s;break}o=o.sibling}if(!i)throw Error(pe(189))}}if(n.alternate!==r)throw Error(pe(190))}if(n.tag!==3)throw Error(pe(188));return n.stateNode.current===n?t:e}function qT(t){return t=hz(t),t!==null?XT(t):null}function XT(t){if(t.tag===5||t.tag===6)return t;for(t=t.child;t!==null;){var e=XT(t);if(e!==null)return e;t=t.sibling}return null}var YT=fs.unstable_scheduleCallback,US=fs.unstable_cancelCallback,dz=fs.unstable_shouldYield,pz=fs.unstable_requestPaint,cn=fs.unstable_now,fz=fs.unstable_getCurrentPriorityLevel,Kv=fs.unstable_ImmediatePriority,QT=fs.unstable_UserBlockingPriority,Dm=fs.unstable_NormalPriority,mz=fs.unstable_LowPriority,ZT=fs.unstable_IdlePriority,Bg=null,Pa=null;function gz(t){if(Pa&&typeof Pa.onCommitFiberRoot=="function")try{Pa.onCommitFiberRoot(Bg,t,void 0,(t.current.flags&128)===128)}catch{}}var ia=Math.clz32?Math.clz32:xz,yz=Math.log,bz=Math.LN2;function xz(t){return t>>>=0,t===0?32:31-(yz(t)/bz|0)|0}var Wf=64,Uf=4194304;function _h(t){switch(t&-t){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return t&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return t}}function Mm(t,e){var n=t.pendingLanes;if(n===0)return 0;var r=0,s=t.suspendedLanes,a=t.pingedLanes,i=n&268435455;if(i!==0){var o=i&~s;o!==0?r=_h(o):(a&=i,a!==0&&(r=_h(a)))}else i=n&~s,i!==0?r=_h(i):a!==0&&(r=_h(a));if(r===0)return 0;if(e!==0&&e!==r&&!(e&s)&&(s=r&-r,a=e&-e,s>=a||s===16&&(a&4194240)!==0))return e;if(r&4&&(r|=n&16),e=t.entangledLanes,e!==0)for(t=t.entanglements,e&=r;0<e;)n=31-ia(e),s=1<<n,r|=t[n],e&=~s;return r}function vz(t,e){switch(t){case 1:case 2:case 4:return e+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function wz(t,e){for(var n=t.suspendedLanes,r=t.pingedLanes,s=t.expirationTimes,a=t.pendingLanes;0<a;){var i=31-ia(a),o=1<<i,l=s[i];l===-1?(!(o&n)||o&r)&&(s[i]=vz(o,e)):l<=e&&(t.expiredLanes|=o),a&=~o}}function r1(t){return t=t.pendingLanes&-1073741825,t!==0?t:t&1073741824?1073741824:0}function JT(){var t=Wf;return Wf<<=1,!(Wf&4194240)&&(Wf=64),t}function K0(t){for(var e=[],n=0;31>n;n++)e.push(t);return e}function Kd(t,e,n){t.pendingLanes|=e,e!==536870912&&(t.suspendedLanes=0,t.pingedLanes=0),t=t.eventTimes,e=31-ia(e),t[e]=n}function kz(t,e){var n=t.pendingLanes&~e;t.pendingLanes=e,t.suspendedLanes=0,t.pingedLanes=0,t.expiredLanes&=e,t.mutableReadLanes&=e,t.entangledLanes&=e,e=t.entanglements;var r=t.eventTimes;for(t=t.expirationTimes;0<n;){var s=31-ia(n),a=1<<s;e[s]=0,r[s]=-1,t[s]=-1,n&=~a}}function qv(t,e){var n=t.entangledLanes|=e;for(t=t.entanglements;n;){var r=31-ia(n),s=1<<r;s&e|t[r]&e&&(t[r]|=e),n&=~s}}var Nt=0;function eE(t){return t&=-t,1<t?4<t?t&268435455?16:536870912:4:1}var tE,Xv,nE,rE,sE,s1=!1,Vf=[],zi=null,Bi=null,Wi=null,ad=new Map,id=new Map,Ri=[],Sz="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function VS(t,e){switch(t){case"focusin":case"focusout":zi=null;break;case"dragenter":case"dragleave":Bi=null;break;case"mouseover":case"mouseout":Wi=null;break;case"pointerover":case"pointerout":ad.delete(e.pointerId);break;case"gotpointercapture":case"lostpointercapture":id.delete(e.pointerId)}}function xh(t,e,n,r,s,a){return t===null||t.nativeEvent!==a?(t={blockedOn:e,domEventName:n,eventSystemFlags:r,nativeEvent:a,targetContainers:[s]},e!==null&&(e=Xd(e),e!==null&&Xv(e)),t):(t.eventSystemFlags|=r,e=t.targetContainers,s!==null&&e.indexOf(s)===-1&&e.push(s),t)}function Iz(t,e,n,r,s){switch(e){case"focusin":return zi=xh(zi,t,e,n,r,s),!0;case"dragenter":return Bi=xh(Bi,t,e,n,r,s),!0;case"mouseover":return Wi=xh(Wi,t,e,n,r,s),!0;case"pointerover":var a=s.pointerId;return ad.set(a,xh(ad.get(a)||null,t,e,n,r,s)),!0;case"gotpointercapture":return a=s.pointerId,id.set(a,xh(id.get(a)||null,t,e,n,r,s)),!0}return!1}function aE(t){var e=Wo(t.target);if(e!==null){var n=Sl(e);if(n!==null){if(e=n.tag,e===13){if(e=KT(n),e!==null){t.blockedOn=e,sE(t.priority,function(){nE(n)});return}}else if(e===3&&n.stateNode.current.memoizedState.isDehydrated){t.blockedOn=n.tag===3?n.stateNode.containerInfo:null;return}}}t.blockedOn=null}function pm(t){if(t.blockedOn!==null)return!1;for(var e=t.targetContainers;0<e.length;){var n=a1(t.domEventName,t.eventSystemFlags,e[0],t.nativeEvent);if(n===null){n=t.nativeEvent;var r=new n.constructor(n.type,n);Jx=r,n.target.dispatchEvent(r),Jx=null}else return e=Xd(n),e!==null&&Xv(e),t.blockedOn=n,!1;e.shift()}return!0}function jS(t,e,n){pm(t)&&n.delete(e)}function Nz(){s1=!1,zi!==null&&pm(zi)&&(zi=null),Bi!==null&&pm(Bi)&&(Bi=null),Wi!==null&&pm(Wi)&&(Wi=null),ad.forEach(jS),id.forEach(jS)}function vh(t,e){t.blockedOn===e&&(t.blockedOn=null,s1||(s1=!0,fs.unstable_scheduleCallback(fs.unstable_NormalPriority,Nz)))}function od(t){function e(s){return vh(s,t)}if(0<Vf.length){vh(Vf[0],t);for(var n=1;n<Vf.length;n++){var r=Vf[n];r.blockedOn===t&&(r.blockedOn=null)}}for(zi!==null&&vh(zi,t),Bi!==null&&vh(Bi,t),Wi!==null&&vh(Wi,t),ad.forEach(e),id.forEach(e),n=0;n<Ri.length;n++)r=Ri[n],r.blockedOn===t&&(r.blockedOn=null);for(;0<Ri.length&&(n=Ri[0],n.blockedOn===null);)aE(n),n.blockedOn===null&&Ri.shift()}var xu=bi.ReactCurrentBatchConfig,Pm=!0;function Cz(t,e,n,r){var s=Nt,a=xu.transition;xu.transition=null;try{Nt=1,Yv(t,e,n,r)}finally{Nt=s,xu.transition=a}}function Tz(t,e,n,r){var s=Nt,a=xu.transition;xu.transition=null;try{Nt=4,Yv(t,e,n,r)}finally{Nt=s,xu.transition=a}}function Yv(t,e,n,r){if(Pm){var s=a1(t,e,n,r);if(s===null)rx(t,e,r,Lm,n),VS(t,r);else if(Iz(s,t,e,n,r))r.stopPropagation();else if(VS(t,r),e&4&&-1<Sz.indexOf(t)){for(;s!==null;){var a=Xd(s);if(a!==null&&tE(a),a=a1(t,e,n,r),a===null&&rx(t,e,r,Lm,n),a===s)break;s=a}s!==null&&r.stopPropagation()}else rx(t,e,r,null,n)}}var Lm=null;function a1(t,e,n,r){if(Lm=null,t=Hv(r),t=Wo(t),t!==null)if(e=Sl(t),e===null)t=null;else if(n=e.tag,n===13){if(t=KT(e),t!==null)return t;t=null}else if(n===3){if(e.stateNode.current.memoizedState.isDehydrated)return e.tag===3?e.stateNode.containerInfo:null;t=null}else e!==t&&(t=null);return Lm=t,null}function iE(t){switch(t){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(fz()){case Kv:return 1;case QT:return 4;case Dm:case mz:return 16;case ZT:return 536870912;default:return 16}default:return 16}}var _i=null,Qv=null,fm=null;function oE(){if(fm)return fm;var t,e=Qv,n=e.length,r,s="value"in _i?_i.value:_i.textContent,a=s.length;for(t=0;t<n&&e[t]===s[t];t++);var i=n-t;for(r=1;r<=i&&e[n-r]===s[a-r];r++);return fm=s.slice(t,1<r?1-r:void 0)}function mm(t){var e=t.keyCode;return"charCode"in t?(t=t.charCode,t===0&&e===13&&(t=13)):t=e,t===10&&(t=13),32<=t||t===13?t:0}function jf(){return!0}function GS(){return!1}function xs(t){function e(n,r,s,a,i){this._reactName=n,this._targetInst=s,this.type=r,this.nativeEvent=a,this.target=i,this.currentTarget=null;for(var o in t)t.hasOwnProperty(o)&&(n=t[o],this[o]=n?n(a):a[o]);return this.isDefaultPrevented=(a.defaultPrevented!=null?a.defaultPrevented:a.returnValue===!1)?jf:GS,this.isPropagationStopped=GS,this}return Jt(e.prototype,{preventDefault:function(){this.defaultPrevented=!0;var n=this.nativeEvent;n&&(n.preventDefault?n.preventDefault():typeof n.returnValue!="unknown"&&(n.returnValue=!1),this.isDefaultPrevented=jf)},stopPropagation:function(){var n=this.nativeEvent;n&&(n.stopPropagation?n.stopPropagation():typeof n.cancelBubble!="unknown"&&(n.cancelBubble=!0),this.isPropagationStopped=jf)},persist:function(){},isPersistent:jf}),e}var qu={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(t){return t.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Zv=xs(qu),qd=Jt({},qu,{view:0,detail:0}),Ez=xs(qd),q0,X0,wh,Wg=Jt({},qd,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Jv,button:0,buttons:0,relatedTarget:function(t){return t.relatedTarget===void 0?t.fromElement===t.srcElement?t.toElement:t.fromElement:t.relatedTarget},movementX:function(t){return"movementX"in t?t.movementX:(t!==wh&&(wh&&t.type==="mousemove"?(q0=t.screenX-wh.screenX,X0=t.screenY-wh.screenY):X0=q0=0,wh=t),q0)},movementY:function(t){return"movementY"in t?t.movementY:X0}}),HS=xs(Wg),$z=Jt({},Wg,{dataTransfer:0}),Rz=xs($z),Az=Jt({},qd,{relatedTarget:0}),Y0=xs(Az),_z=Jt({},qu,{animationName:0,elapsedTime:0,pseudoElement:0}),Fz=xs(_z),Oz=Jt({},qu,{clipboardData:function(t){return"clipboardData"in t?t.clipboardData:window.clipboardData}}),Dz=xs(Oz),Mz=Jt({},qu,{data:0}),KS=xs(Mz),Pz={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Lz={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},zz={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Bz(t){var e=this.nativeEvent;return e.getModifierState?e.getModifierState(t):(t=zz[t])?!!e[t]:!1}function Jv(){return Bz}var Wz=Jt({},qd,{key:function(t){if(t.key){var e=Pz[t.key]||t.key;if(e!=="Unidentified")return e}return t.type==="keypress"?(t=mm(t),t===13?"Enter":String.fromCharCode(t)):t.type==="keydown"||t.type==="keyup"?Lz[t.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Jv,charCode:function(t){return t.type==="keypress"?mm(t):0},keyCode:function(t){return t.type==="keydown"||t.type==="keyup"?t.keyCode:0},which:function(t){return t.type==="keypress"?mm(t):t.type==="keydown"||t.type==="keyup"?t.keyCode:0}}),Uz=xs(Wz),Vz=Jt({},Wg,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),qS=xs(Vz),jz=Jt({},qd,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Jv}),Gz=xs(jz),Hz=Jt({},qu,{propertyName:0,elapsedTime:0,pseudoElement:0}),Kz=xs(Hz),qz=Jt({},Wg,{deltaX:function(t){return"deltaX"in t?t.deltaX:"wheelDeltaX"in t?-t.wheelDeltaX:0},deltaY:function(t){return"deltaY"in t?t.deltaY:"wheelDeltaY"in t?-t.wheelDeltaY:"wheelDelta"in t?-t.wheelDelta:0},deltaZ:0,deltaMode:0}),Xz=xs(qz),Yz=[9,13,27,32],ew=li&&"CompositionEvent"in window,Hh=null;li&&"documentMode"in document&&(Hh=document.documentMode);var Qz=li&&"TextEvent"in window&&!Hh,lE=li&&(!ew||Hh&&8<Hh&&11>=Hh),XS=" ",YS=!1;function uE(t,e){switch(t){case"keyup":return Yz.indexOf(e.keyCode)!==-1;case"keydown":return e.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function cE(t){return t=t.detail,typeof t=="object"&&"data"in t?t.data:null}var au=!1;function Zz(t,e){switch(t){case"compositionend":return cE(e);case"keypress":return e.which!==32?null:(YS=!0,XS);case"textInput":return t=e.data,t===XS&&YS?null:t;default:return null}}function Jz(t,e){if(au)return t==="compositionend"||!ew&&uE(t,e)?(t=oE(),fm=Qv=_i=null,au=!1,t):null;switch(t){case"paste":return null;case"keypress":if(!(e.ctrlKey||e.altKey||e.metaKey)||e.ctrlKey&&e.altKey){if(e.char&&1<e.char.length)return e.char;if(e.which)return String.fromCharCode(e.which)}return null;case"compositionend":return lE&&e.locale!=="ko"?null:e.data;default:return null}}var e4={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function QS(t){var e=t&&t.nodeName&&t.nodeName.toLowerCase();return e==="input"?!!e4[t.type]:e==="textarea"}function hE(t,e,n,r){UT(r),e=zm(e,"onChange"),0<e.length&&(n=new Zv("onChange","change",null,n,r),t.push({event:n,listeners:e}))}var Kh=null,ld=null;function t4(t){kE(t,0)}function Ug(t){var e=lu(t);if(DT(e))return t}function n4(t,e){if(t==="change")return e}var dE=!1;if(li){var Q0;if(li){var Z0="oninput"in document;if(!Z0){var ZS=document.createElement("div");ZS.setAttribute("oninput","return;"),Z0=typeof ZS.oninput=="function"}Q0=Z0}else Q0=!1;dE=Q0&&(!document.documentMode||9<document.documentMode)}function JS(){Kh&&(Kh.detachEvent("onpropertychange",pE),ld=Kh=null)}function pE(t){if(t.propertyName==="value"&&Ug(ld)){var e=[];hE(e,ld,t,Hv(t)),HT(t4,e)}}function r4(t,e,n){t==="focusin"?(JS(),Kh=e,ld=n,Kh.attachEvent("onpropertychange",pE)):t==="focusout"&&JS()}function s4(t){if(t==="selectionchange"||t==="keyup"||t==="keydown")return Ug(ld)}function a4(t,e){if(t==="click")return Ug(e)}function i4(t,e){if(t==="input"||t==="change")return Ug(e)}function o4(t,e){return t===e&&(t!==0||1/t===1/e)||t!==t&&e!==e}var ha=typeof Object.is=="function"?Object.is:o4;function ud(t,e){if(ha(t,e))return!0;if(typeof t!="object"||t===null||typeof e!="object"||e===null)return!1;var n=Object.keys(t),r=Object.keys(e);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var s=n[r];if(!Wx.call(e,s)||!ha(t[s],e[s]))return!1}return!0}function eI(t){for(;t&&t.firstChild;)t=t.firstChild;return t}function tI(t,e){var n=eI(t);t=0;for(var r;n;){if(n.nodeType===3){if(r=t+n.textContent.length,t<=e&&r>=e)return{node:n,offset:e-t};t=r}e:{for(;n;){if(n.nextSibling){n=n.nextSibling;break e}n=n.parentNode}n=void 0}n=eI(n)}}function fE(t,e){return t&&e?t===e?!0:t&&t.nodeType===3?!1:e&&e.nodeType===3?fE(t,e.parentNode):"contains"in t?t.contains(e):t.compareDocumentPosition?!!(t.compareDocumentPosition(e)&16):!1:!1}function mE(){for(var t=window,e=_m();e instanceof t.HTMLIFrameElement;){try{var n=typeof e.contentWindow.location.href=="string"}catch{n=!1}if(n)t=e.contentWindow;else break;e=_m(t.document)}return e}function tw(t){var e=t&&t.nodeName&&t.nodeName.toLowerCase();return e&&(e==="input"&&(t.type==="text"||t.type==="search"||t.type==="tel"||t.type==="url"||t.type==="password")||e==="textarea"||t.contentEditable==="true")}function l4(t){var e=mE(),n=t.focusedElem,r=t.selectionRange;if(e!==n&&n&&n.ownerDocument&&fE(n.ownerDocument.documentElement,n)){if(r!==null&&tw(n)){if(e=r.start,t=r.end,t===void 0&&(t=e),"selectionStart"in n)n.selectionStart=e,n.selectionEnd=Math.min(t,n.value.length);else if(t=(e=n.ownerDocument||document)&&e.defaultView||window,t.getSelection){t=t.getSelection();var s=n.textContent.length,a=Math.min(r.start,s);r=r.end===void 0?a:Math.min(r.end,s),!t.extend&&a>r&&(s=r,r=a,a=s),s=tI(n,a);var i=tI(n,r);s&&i&&(t.rangeCount!==1||t.anchorNode!==s.node||t.anchorOffset!==s.offset||t.focusNode!==i.node||t.focusOffset!==i.offset)&&(e=e.createRange(),e.setStart(s.node,s.offset),t.removeAllRanges(),a>r?(t.addRange(e),t.extend(i.node,i.offset)):(e.setEnd(i.node,i.offset),t.addRange(e)))}}for(e=[],t=n;t=t.parentNode;)t.nodeType===1&&e.push({element:t,left:t.scrollLeft,top:t.scrollTop});for(typeof n.focus=="function"&&n.focus(),n=0;n<e.length;n++)t=e[n],t.element.scrollLeft=t.left,t.element.scrollTop=t.top}}var u4=li&&"documentMode"in document&&11>=document.documentMode,iu=null,i1=null,qh=null,o1=!1;function nI(t,e,n){var r=n.window===n?n.document:n.nodeType===9?n:n.ownerDocument;o1||iu==null||iu!==_m(r)||(r=iu,"selectionStart"in r&&tw(r)?r={start:r.selectionStart,end:r.selectionEnd}:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection(),r={anchorNode:r.anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset}),qh&&ud(qh,r)||(qh=r,r=zm(i1,"onSelect"),0<r.length&&(e=new Zv("onSelect","select",null,e,n),t.push({event:e,listeners:r}),e.target=iu)))}function Gf(t,e){var n={};return n[t.toLowerCase()]=e.toLowerCase(),n["Webkit"+t]="webkit"+e,n["Moz"+t]="moz"+e,n}var ou={animationend:Gf("Animation","AnimationEnd"),animationiteration:Gf("Animation","AnimationIteration"),animationstart:Gf("Animation","AnimationStart"),transitionend:Gf("Transition","TransitionEnd")},J0={},gE={};li&&(gE=document.createElement("div").style,"AnimationEvent"in window||(delete ou.animationend.animation,delete ou.animationiteration.animation,delete ou.animationstart.animation),"TransitionEvent"in window||delete ou.transitionend.transition);function Vg(t){if(J0[t])return J0[t];if(!ou[t])return t;var e=ou[t],n;for(n in e)if(e.hasOwnProperty(n)&&n in gE)return J0[t]=e[n];return t}var yE=Vg("animationend"),bE=Vg("animationiteration"),xE=Vg("animationstart"),vE=Vg("transitionend"),wE=new Map,rI="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function ho(t,e){wE.set(t,e),kl(e,[t])}for(var ex=0;ex<rI.length;ex++){var tx=rI[ex],c4=tx.toLowerCase(),h4=tx[0].toUpperCase()+tx.slice(1);ho(c4,"on"+h4)}ho(yE,"onAnimationEnd");ho(bE,"onAnimationIteration");ho(xE,"onAnimationStart");ho("dblclick","onDoubleClick");ho("focusin","onFocus");ho("focusout","onBlur");ho(vE,"onTransitionEnd");Tu("onMouseEnter",["mouseout","mouseover"]);Tu("onMouseLeave",["mouseout","mouseover"]);Tu("onPointerEnter",["pointerout","pointerover"]);Tu("onPointerLeave",["pointerout","pointerover"]);kl("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));kl("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));kl("onBeforeInput",["compositionend","keypress","textInput","paste"]);kl("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));kl("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));kl("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Fh="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),d4=new Set("cancel close invalid load scroll toggle".split(" ").concat(Fh));function sI(t,e,n){var r=t.type||"unknown-event";t.currentTarget=n,cz(r,e,void 0,t),t.currentTarget=null}function kE(t,e){e=(e&4)!==0;for(var n=0;n<t.length;n++){var r=t[n],s=r.event;r=r.listeners;e:{var a=void 0;if(e)for(var i=r.length-1;0<=i;i--){var o=r[i],l=o.instance,u=o.currentTarget;if(o=o.listener,l!==a&&s.isPropagationStopped())break e;sI(s,o,u),a=l}else for(i=0;i<r.length;i++){if(o=r[i],l=o.instance,u=o.currentTarget,o=o.listener,l!==a&&s.isPropagationStopped())break e;sI(s,o,u),a=l}}}if(Om)throw t=n1,Om=!1,n1=null,t}function Bt(t,e){var n=e[d1];n===void 0&&(n=e[d1]=new Set);var r=t+"__bubble";n.has(r)||(SE(e,t,2,!1),n.add(r))}function nx(t,e,n){var r=0;e&&(r|=4),SE(n,t,r,e)}var Hf="_reactListening"+Math.random().toString(36).slice(2);function cd(t){if(!t[Hf]){t[Hf]=!0,RT.forEach(function(n){n!=="selectionchange"&&(d4.has(n)||nx(n,!1,t),nx(n,!0,t))});var e=t.nodeType===9?t:t.ownerDocument;e===null||e[Hf]||(e[Hf]=!0,nx("selectionchange",!1,e))}}function SE(t,e,n,r){switch(iE(e)){case 1:var s=Cz;break;case 4:s=Tz;break;default:s=Yv}n=s.bind(null,e,n,t),s=void 0,!t1||e!=="touchstart"&&e!=="touchmove"&&e!=="wheel"||(s=!0),r?s!==void 0?t.addEventListener(e,n,{capture:!0,passive:s}):t.addEventListener(e,n,!0):s!==void 0?t.addEventListener(e,n,{passive:s}):t.addEventListener(e,n,!1)}function rx(t,e,n,r,s){var a=r;if(!(e&1)&&!(e&2)&&r!==null)e:for(;;){if(r===null)return;var i=r.tag;if(i===3||i===4){var o=r.stateNode.containerInfo;if(o===s||o.nodeType===8&&o.parentNode===s)break;if(i===4)for(i=r.return;i!==null;){var l=i.tag;if((l===3||l===4)&&(l=i.stateNode.containerInfo,l===s||l.nodeType===8&&l.parentNode===s))return;i=i.return}for(;o!==null;){if(i=Wo(o),i===null)return;if(l=i.tag,l===5||l===6){r=a=i;continue e}o=o.parentNode}}r=r.return}HT(function(){var u=a,c=Hv(n),h=[];e:{var d=wE.get(t);if(d!==void 0){var p=Zv,f=t;switch(t){case"keypress":if(mm(n)===0)break e;case"keydown":case"keyup":p=Uz;break;case"focusin":f="focus",p=Y0;break;case"focusout":f="blur",p=Y0;break;case"beforeblur":case"afterblur":p=Y0;break;case"click":if(n.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":p=HS;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":p=Rz;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":p=Gz;break;case yE:case bE:case xE:p=Fz;break;case vE:p=Kz;break;case"scroll":p=Ez;break;case"wheel":p=Xz;break;case"copy":case"cut":case"paste":p=Dz;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":p=qS}var m=(e&4)!==0,y=!m&&t==="scroll",g=m?d!==null?d+"Capture":null:d;m=[];for(var b=u,v;b!==null;){v=b;var w=v.stateNode;if(v.tag===5&&w!==null&&(v=w,g!==null&&(w=sd(b,g),w!=null&&m.push(hd(b,w,v)))),y)break;b=b.return}0<m.length&&(d=new p(d,f,null,n,c),h.push({event:d,listeners:m}))}}if(!(e&7)){e:{if(d=t==="mouseover"||t==="pointerover",p=t==="mouseout"||t==="pointerout",d&&n!==Jx&&(f=n.relatedTarget||n.fromElement)&&(Wo(f)||f[ui]))break e;if((p||d)&&(d=c.window===c?c:(d=c.ownerDocument)?d.defaultView||d.parentWindow:window,p?(f=n.relatedTarget||n.toElement,p=u,f=f?Wo(f):null,f!==null&&(y=Sl(f),f!==y||f.tag!==5&&f.tag!==6)&&(f=null)):(p=null,f=u),p!==f)){if(m=HS,w="onMouseLeave",g="onMouseEnter",b="mouse",(t==="pointerout"||t==="pointerover")&&(m=qS,w="onPointerLeave",g="onPointerEnter",b="pointer"),y=p==null?d:lu(p),v=f==null?d:lu(f),d=new m(w,b+"leave",p,n,c),d.target=y,d.relatedTarget=v,w=null,Wo(c)===u&&(m=new m(g,b+"enter",f,n,c),m.target=v,m.relatedTarget=y,w=m),y=w,p&&f)t:{for(m=p,g=f,b=0,v=m;v;v=Kl(v))b++;for(v=0,w=g;w;w=Kl(w))v++;for(;0<b-v;)m=Kl(m),b--;for(;0<v-b;)g=Kl(g),v--;for(;b--;){if(m===g||g!==null&&m===g.alternate)break t;m=Kl(m),g=Kl(g)}m=null}else m=null;p!==null&&aI(h,d,p,m,!1),f!==null&&y!==null&&aI(h,y,f,m,!0)}}e:{if(d=u?lu(u):window,p=d.nodeName&&d.nodeName.toLowerCase(),p==="select"||p==="input"&&d.type==="file")var k=n4;else if(QS(d))if(dE)k=i4;else{k=s4;var N=r4}else(p=d.nodeName)&&p.toLowerCase()==="input"&&(d.type==="checkbox"||d.type==="radio")&&(k=a4);if(k&&(k=k(t,u))){hE(h,k,n,c);break e}N&&N(t,d,u),t==="focusout"&&(N=d._wrapperState)&&N.controlled&&d.type==="number"&&qx(d,"number",d.value)}switch(N=u?lu(u):window,t){case"focusin":(QS(N)||N.contentEditable==="true")&&(iu=N,i1=u,qh=null);break;case"focusout":qh=i1=iu=null;break;case"mousedown":o1=!0;break;case"contextmenu":case"mouseup":case"dragend":o1=!1,nI(h,n,c);break;case"selectionchange":if(u4)break;case"keydown":case"keyup":nI(h,n,c)}var T;if(ew)e:{switch(t){case"compositionstart":var E="onCompositionStart";break e;case"compositionend":E="onCompositionEnd";break e;case"compositionupdate":E="onCompositionUpdate";break e}E=void 0}else au?uE(t,n)&&(E="onCompositionEnd"):t==="keydown"&&n.keyCode===229&&(E="onCompositionStart");E&&(lE&&n.locale!=="ko"&&(au||E!=="onCompositionStart"?E==="onCompositionEnd"&&au&&(T=oE()):(_i=c,Qv="value"in _i?_i.value:_i.textContent,au=!0)),N=zm(u,E),0<N.length&&(E=new KS(E,t,null,n,c),h.push({event:E,listeners:N}),T?E.data=T:(T=cE(n),T!==null&&(E.data=T)))),(T=Qz?Zz(t,n):Jz(t,n))&&(u=zm(u,"onBeforeInput"),0<u.length&&(c=new KS("onBeforeInput","beforeinput",null,n,c),h.push({event:c,listeners:u}),c.data=T))}kE(h,e)})}function hd(t,e,n){return{instance:t,listener:e,currentTarget:n}}function zm(t,e){for(var n=e+"Capture",r=[];t!==null;){var s=t,a=s.stateNode;s.tag===5&&a!==null&&(s=a,a=sd(t,n),a!=null&&r.unshift(hd(t,a,s)),a=sd(t,e),a!=null&&r.push(hd(t,a,s))),t=t.return}return r}function Kl(t){if(t===null)return null;do t=t.return;while(t&&t.tag!==5);return t||null}function aI(t,e,n,r,s){for(var a=e._reactName,i=[];n!==null&&n!==r;){var o=n,l=o.alternate,u=o.stateNode;if(l!==null&&l===r)break;o.tag===5&&u!==null&&(o=u,s?(l=sd(n,a),l!=null&&i.unshift(hd(n,l,o))):s||(l=sd(n,a),l!=null&&i.push(hd(n,l,o)))),n=n.return}i.length!==0&&t.push({event:e,listeners:i})}var p4=/\r\n?/g,f4=/\u0000|\uFFFD/g;function iI(t){return(typeof t=="string"?t:""+t).replace(p4,`
`).replace(f4,"")}function Kf(t,e,n){if(e=iI(e),iI(t)!==e&&n)throw Error(pe(425))}function Bm(){}var l1=null,u1=null;function c1(t,e){return t==="textarea"||t==="noscript"||typeof e.children=="string"||typeof e.children=="number"||typeof e.dangerouslySetInnerHTML=="object"&&e.dangerouslySetInnerHTML!==null&&e.dangerouslySetInnerHTML.__html!=null}var h1=typeof setTimeout=="function"?setTimeout:void 0,m4=typeof clearTimeout=="function"?clearTimeout:void 0,oI=typeof Promise=="function"?Promise:void 0,g4=typeof queueMicrotask=="function"?queueMicrotask:typeof oI<"u"?function(t){return oI.resolve(null).then(t).catch(y4)}:h1;function y4(t){setTimeout(function(){throw t})}function sx(t,e){var n=e,r=0;do{var s=n.nextSibling;if(t.removeChild(n),s&&s.nodeType===8)if(n=s.data,n==="/$"){if(r===0){t.removeChild(s),od(e);return}r--}else n!=="$"&&n!=="$?"&&n!=="$!"||r++;n=s}while(n);od(e)}function Ui(t){for(;t!=null;t=t.nextSibling){var e=t.nodeType;if(e===1||e===3)break;if(e===8){if(e=t.data,e==="$"||e==="$!"||e==="$?")break;if(e==="/$")return null}}return t}function lI(t){t=t.previousSibling;for(var e=0;t;){if(t.nodeType===8){var n=t.data;if(n==="$"||n==="$!"||n==="$?"){if(e===0)return t;e--}else n==="/$"&&e++}t=t.previousSibling}return null}var Xu=Math.random().toString(36).slice(2),Da="__reactFiber$"+Xu,dd="__reactProps$"+Xu,ui="__reactContainer$"+Xu,d1="__reactEvents$"+Xu,b4="__reactListeners$"+Xu,x4="__reactHandles$"+Xu;function Wo(t){var e=t[Da];if(e)return e;for(var n=t.parentNode;n;){if(e=n[ui]||n[Da]){if(n=e.alternate,e.child!==null||n!==null&&n.child!==null)for(t=lI(t);t!==null;){if(n=t[Da])return n;t=lI(t)}return e}t=n,n=t.parentNode}return null}function Xd(t){return t=t[Da]||t[ui],!t||t.tag!==5&&t.tag!==6&&t.tag!==13&&t.tag!==3?null:t}function lu(t){if(t.tag===5||t.tag===6)return t.stateNode;throw Error(pe(33))}function jg(t){return t[dd]||null}var p1=[],uu=-1;function po(t){return{current:t}}function Wt(t){0>uu||(t.current=p1[uu],p1[uu]=null,uu--)}function Dt(t,e){uu++,p1[uu]=t.current,t.current=e}var Zi={},dr=po(Zi),qr=po(!1),tl=Zi;function Eu(t,e){var n=t.type.contextTypes;if(!n)return Zi;var r=t.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===e)return r.__reactInternalMemoizedMaskedChildContext;var s={},a;for(a in n)s[a]=e[a];return r&&(t=t.stateNode,t.__reactInternalMemoizedUnmaskedChildContext=e,t.__reactInternalMemoizedMaskedChildContext=s),s}function Xr(t){return t=t.childContextTypes,t!=null}function Wm(){Wt(qr),Wt(dr)}function uI(t,e,n){if(dr.current!==Zi)throw Error(pe(168));Dt(dr,e),Dt(qr,n)}function IE(t,e,n){var r=t.stateNode;if(e=e.childContextTypes,typeof r.getChildContext!="function")return n;r=r.getChildContext();for(var s in r)if(!(s in e))throw Error(pe(108,rz(t)||"Unknown",s));return Jt({},n,r)}function Um(t){return t=(t=t.stateNode)&&t.__reactInternalMemoizedMergedChildContext||Zi,tl=dr.current,Dt(dr,t),Dt(qr,qr.current),!0}function cI(t,e,n){var r=t.stateNode;if(!r)throw Error(pe(169));n?(t=IE(t,e,tl),r.__reactInternalMemoizedMergedChildContext=t,Wt(qr),Wt(dr),Dt(dr,t)):Wt(qr),Dt(qr,n)}var Qa=null,Gg=!1,ax=!1;function NE(t){Qa===null?Qa=[t]:Qa.push(t)}function v4(t){Gg=!0,NE(t)}function fo(){if(!ax&&Qa!==null){ax=!0;var t=0,e=Nt;try{var n=Qa;for(Nt=1;t<n.length;t++){var r=n[t];do r=r(!0);while(r!==null)}Qa=null,Gg=!1}catch(s){throw Qa!==null&&(Qa=Qa.slice(t+1)),YT(Kv,fo),s}finally{Nt=e,ax=!1}}return null}var cu=[],hu=0,Vm=null,jm=0,$s=[],Rs=0,nl=null,ri=1,si="";function _o(t,e){cu[hu++]=jm,cu[hu++]=Vm,Vm=t,jm=e}function CE(t,e,n){$s[Rs++]=ri,$s[Rs++]=si,$s[Rs++]=nl,nl=t;var r=ri;t=si;var s=32-ia(r)-1;r&=~(1<<s),n+=1;var a=32-ia(e)+s;if(30<a){var i=s-s%5;a=(r&(1<<i)-1).toString(32),r>>=i,s-=i,ri=1<<32-ia(e)+s|n<<s|r,si=a+t}else ri=1<<a|n<<s|r,si=t}function nw(t){t.return!==null&&(_o(t,1),CE(t,1,0))}function rw(t){for(;t===Vm;)Vm=cu[--hu],cu[hu]=null,jm=cu[--hu],cu[hu]=null;for(;t===nl;)nl=$s[--Rs],$s[Rs]=null,si=$s[--Rs],$s[Rs]=null,ri=$s[--Rs],$s[Rs]=null}var hs=null,ls=null,Gt=!1,na=null;function TE(t,e){var n=As(5,null,null,0);n.elementType="DELETED",n.stateNode=e,n.return=t,e=t.deletions,e===null?(t.deletions=[n],t.flags|=16):e.push(n)}function hI(t,e){switch(t.tag){case 5:var n=t.type;return e=e.nodeType!==1||n.toLowerCase()!==e.nodeName.toLowerCase()?null:e,e!==null?(t.stateNode=e,hs=t,ls=Ui(e.firstChild),!0):!1;case 6:return e=t.pendingProps===""||e.nodeType!==3?null:e,e!==null?(t.stateNode=e,hs=t,ls=null,!0):!1;case 13:return e=e.nodeType!==8?null:e,e!==null?(n=nl!==null?{id:ri,overflow:si}:null,t.memoizedState={dehydrated:e,treeContext:n,retryLane:1073741824},n=As(18,null,null,0),n.stateNode=e,n.return=t,t.child=n,hs=t,ls=null,!0):!1;default:return!1}}function f1(t){return(t.mode&1)!==0&&(t.flags&128)===0}function m1(t){if(Gt){var e=ls;if(e){var n=e;if(!hI(t,e)){if(f1(t))throw Error(pe(418));e=Ui(n.nextSibling);var r=hs;e&&hI(t,e)?TE(r,n):(t.flags=t.flags&-4097|2,Gt=!1,hs=t)}}else{if(f1(t))throw Error(pe(418));t.flags=t.flags&-4097|2,Gt=!1,hs=t}}}function dI(t){for(t=t.return;t!==null&&t.tag!==5&&t.tag!==3&&t.tag!==13;)t=t.return;hs=t}function qf(t){if(t!==hs)return!1;if(!Gt)return dI(t),Gt=!0,!1;var e;if((e=t.tag!==3)&&!(e=t.tag!==5)&&(e=t.type,e=e!=="head"&&e!=="body"&&!c1(t.type,t.memoizedProps)),e&&(e=ls)){if(f1(t))throw EE(),Error(pe(418));for(;e;)TE(t,e),e=Ui(e.nextSibling)}if(dI(t),t.tag===13){if(t=t.memoizedState,t=t!==null?t.dehydrated:null,!t)throw Error(pe(317));e:{for(t=t.nextSibling,e=0;t;){if(t.nodeType===8){var n=t.data;if(n==="/$"){if(e===0){ls=Ui(t.nextSibling);break e}e--}else n!=="$"&&n!=="$!"&&n!=="$?"||e++}t=t.nextSibling}ls=null}}else ls=hs?Ui(t.stateNode.nextSibling):null;return!0}function EE(){for(var t=ls;t;)t=Ui(t.nextSibling)}function $u(){ls=hs=null,Gt=!1}function sw(t){na===null?na=[t]:na.push(t)}var w4=bi.ReactCurrentBatchConfig;function kh(t,e,n){if(t=n.ref,t!==null&&typeof t!="function"&&typeof t!="object"){if(n._owner){if(n=n._owner,n){if(n.tag!==1)throw Error(pe(309));var r=n.stateNode}if(!r)throw Error(pe(147,t));var s=r,a=""+t;return e!==null&&e.ref!==null&&typeof e.ref=="function"&&e.ref._stringRef===a?e.ref:(e=function(i){var o=s.refs;i===null?delete o[a]:o[a]=i},e._stringRef=a,e)}if(typeof t!="string")throw Error(pe(284));if(!n._owner)throw Error(pe(290,t))}return t}function Xf(t,e){throw t=Object.prototype.toString.call(e),Error(pe(31,t==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":t))}function pI(t){var e=t._init;return e(t._payload)}function $E(t){function e(g,b){if(t){var v=g.deletions;v===null?(g.deletions=[b],g.flags|=16):v.push(b)}}function n(g,b){if(!t)return null;for(;b!==null;)e(g,b),b=b.sibling;return null}function r(g,b){for(g=new Map;b!==null;)b.key!==null?g.set(b.key,b):g.set(b.index,b),b=b.sibling;return g}function s(g,b){return g=Hi(g,b),g.index=0,g.sibling=null,g}function a(g,b,v){return g.index=v,t?(v=g.alternate,v!==null?(v=v.index,v<b?(g.flags|=2,b):v):(g.flags|=2,b)):(g.flags|=1048576,b)}function i(g){return t&&g.alternate===null&&(g.flags|=2),g}function o(g,b,v,w){return b===null||b.tag!==6?(b=dx(v,g.mode,w),b.return=g,b):(b=s(b,v),b.return=g,b)}function l(g,b,v,w){var k=v.type;return k===su?c(g,b,v.props.children,w,v.key):b!==null&&(b.elementType===k||typeof k=="object"&&k!==null&&k.$$typeof===Ti&&pI(k)===b.type)?(w=s(b,v.props),w.ref=kh(g,b,v),w.return=g,w):(w=km(v.type,v.key,v.props,null,g.mode,w),w.ref=kh(g,b,v),w.return=g,w)}function u(g,b,v,w){return b===null||b.tag!==4||b.stateNode.containerInfo!==v.containerInfo||b.stateNode.implementation!==v.implementation?(b=px(v,g.mode,w),b.return=g,b):(b=s(b,v.children||[]),b.return=g,b)}function c(g,b,v,w,k){return b===null||b.tag!==7?(b=Xo(v,g.mode,w,k),b.return=g,b):(b=s(b,v),b.return=g,b)}function h(g,b,v){if(typeof b=="string"&&b!==""||typeof b=="number")return b=dx(""+b,g.mode,v),b.return=g,b;if(typeof b=="object"&&b!==null){switch(b.$$typeof){case Lf:return v=km(b.type,b.key,b.props,null,g.mode,v),v.ref=kh(g,null,b),v.return=g,v;case ru:return b=px(b,g.mode,v),b.return=g,b;case Ti:var w=b._init;return h(g,w(b._payload),v)}if(Ah(b)||yh(b))return b=Xo(b,g.mode,v,null),b.return=g,b;Xf(g,b)}return null}function d(g,b,v,w){var k=b!==null?b.key:null;if(typeof v=="string"&&v!==""||typeof v=="number")return k!==null?null:o(g,b,""+v,w);if(typeof v=="object"&&v!==null){switch(v.$$typeof){case Lf:return v.key===k?l(g,b,v,w):null;case ru:return v.key===k?u(g,b,v,w):null;case Ti:return k=v._init,d(g,b,k(v._payload),w)}if(Ah(v)||yh(v))return k!==null?null:c(g,b,v,w,null);Xf(g,v)}return null}function p(g,b,v,w,k){if(typeof w=="string"&&w!==""||typeof w=="number")return g=g.get(v)||null,o(b,g,""+w,k);if(typeof w=="object"&&w!==null){switch(w.$$typeof){case Lf:return g=g.get(w.key===null?v:w.key)||null,l(b,g,w,k);case ru:return g=g.get(w.key===null?v:w.key)||null,u(b,g,w,k);case Ti:var N=w._init;return p(g,b,v,N(w._payload),k)}if(Ah(w)||yh(w))return g=g.get(v)||null,c(b,g,w,k,null);Xf(b,w)}return null}function f(g,b,v,w){for(var k=null,N=null,T=b,E=b=0,_=null;T!==null&&E<v.length;E++){T.index>E?(_=T,T=null):_=T.sibling;var O=d(g,T,v[E],w);if(O===null){T===null&&(T=_);break}t&&T&&O.alternate===null&&e(g,T),b=a(O,b,E),N===null?k=O:N.sibling=O,N=O,T=_}if(E===v.length)return n(g,T),Gt&&_o(g,E),k;if(T===null){for(;E<v.length;E++)T=h(g,v[E],w),T!==null&&(b=a(T,b,E),N===null?k=T:N.sibling=T,N=T);return Gt&&_o(g,E),k}for(T=r(g,T);E<v.length;E++)_=p(T,g,E,v[E],w),_!==null&&(t&&_.alternate!==null&&T.delete(_.key===null?E:_.key),b=a(_,b,E),N===null?k=_:N.sibling=_,N=_);return t&&T.forEach(function(M){return e(g,M)}),Gt&&_o(g,E),k}function m(g,b,v,w){var k=yh(v);if(typeof k!="function")throw Error(pe(150));if(v=k.call(v),v==null)throw Error(pe(151));for(var N=k=null,T=b,E=b=0,_=null,O=v.next();T!==null&&!O.done;E++,O=v.next()){T.index>E?(_=T,T=null):_=T.sibling;var M=d(g,T,O.value,w);if(M===null){T===null&&(T=_);break}t&&T&&M.alternate===null&&e(g,T),b=a(M,b,E),N===null?k=M:N.sibling=M,N=M,T=_}if(O.done)return n(g,T),Gt&&_o(g,E),k;if(T===null){for(;!O.done;E++,O=v.next())O=h(g,O.value,w),O!==null&&(b=a(O,b,E),N===null?k=O:N.sibling=O,N=O);return Gt&&_o(g,E),k}for(T=r(g,T);!O.done;E++,O=v.next())O=p(T,g,E,O.value,w),O!==null&&(t&&O.alternate!==null&&T.delete(O.key===null?E:O.key),b=a(O,b,E),N===null?k=O:N.sibling=O,N=O);return t&&T.forEach(function(V){return e(g,V)}),Gt&&_o(g,E),k}function y(g,b,v,w){if(typeof v=="object"&&v!==null&&v.type===su&&v.key===null&&(v=v.props.children),typeof v=="object"&&v!==null){switch(v.$$typeof){case Lf:e:{for(var k=v.key,N=b;N!==null;){if(N.key===k){if(k=v.type,k===su){if(N.tag===7){n(g,N.sibling),b=s(N,v.props.children),b.return=g,g=b;break e}}else if(N.elementType===k||typeof k=="object"&&k!==null&&k.$$typeof===Ti&&pI(k)===N.type){n(g,N.sibling),b=s(N,v.props),b.ref=kh(g,N,v),b.return=g,g=b;break e}n(g,N);break}else e(g,N);N=N.sibling}v.type===su?(b=Xo(v.props.children,g.mode,w,v.key),b.return=g,g=b):(w=km(v.type,v.key,v.props,null,g.mode,w),w.ref=kh(g,b,v),w.return=g,g=w)}return i(g);case ru:e:{for(N=v.key;b!==null;){if(b.key===N)if(b.tag===4&&b.stateNode.containerInfo===v.containerInfo&&b.stateNode.implementation===v.implementation){n(g,b.sibling),b=s(b,v.children||[]),b.return=g,g=b;break e}else{n(g,b);break}else e(g,b);b=b.sibling}b=px(v,g.mode,w),b.return=g,g=b}return i(g);case Ti:return N=v._init,y(g,b,N(v._payload),w)}if(Ah(v))return f(g,b,v,w);if(yh(v))return m(g,b,v,w);Xf(g,v)}return typeof v=="string"&&v!==""||typeof v=="number"?(v=""+v,b!==null&&b.tag===6?(n(g,b.sibling),b=s(b,v),b.return=g,g=b):(n(g,b),b=dx(v,g.mode,w),b.return=g,g=b),i(g)):n(g,b)}return y}var Ru=$E(!0),RE=$E(!1),Gm=po(null),Hm=null,du=null,aw=null;function iw(){aw=du=Hm=null}function ow(t){var e=Gm.current;Wt(Gm),t._currentValue=e}function g1(t,e,n){for(;t!==null;){var r=t.alternate;if((t.childLanes&e)!==e?(t.childLanes|=e,r!==null&&(r.childLanes|=e)):r!==null&&(r.childLanes&e)!==e&&(r.childLanes|=e),t===n)break;t=t.return}}function vu(t,e){Hm=t,aw=du=null,t=t.dependencies,t!==null&&t.firstContext!==null&&(t.lanes&e&&(Gr=!0),t.firstContext=null)}function Ws(t){var e=t._currentValue;if(aw!==t)if(t={context:t,memoizedValue:e,next:null},du===null){if(Hm===null)throw Error(pe(308));du=t,Hm.dependencies={lanes:0,firstContext:t}}else du=du.next=t;return e}var Uo=null;function lw(t){Uo===null?Uo=[t]:Uo.push(t)}function AE(t,e,n,r){var s=e.interleaved;return s===null?(n.next=n,lw(e)):(n.next=s.next,s.next=n),e.interleaved=n,ci(t,r)}function ci(t,e){t.lanes|=e;var n=t.alternate;for(n!==null&&(n.lanes|=e),n=t,t=t.return;t!==null;)t.childLanes|=e,n=t.alternate,n!==null&&(n.childLanes|=e),n=t,t=t.return;return n.tag===3?n.stateNode:null}var Ei=!1;function uw(t){t.updateQueue={baseState:t.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function _E(t,e){t=t.updateQueue,e.updateQueue===t&&(e.updateQueue={baseState:t.baseState,firstBaseUpdate:t.firstBaseUpdate,lastBaseUpdate:t.lastBaseUpdate,shared:t.shared,effects:t.effects})}function ai(t,e){return{eventTime:t,lane:e,tag:0,payload:null,callback:null,next:null}}function Vi(t,e,n){var r=t.updateQueue;if(r===null)return null;if(r=r.shared,bt&2){var s=r.pending;return s===null?e.next=e:(e.next=s.next,s.next=e),r.pending=e,ci(t,n)}return s=r.interleaved,s===null?(e.next=e,lw(r)):(e.next=s.next,s.next=e),r.interleaved=e,ci(t,n)}function gm(t,e,n){if(e=e.updateQueue,e!==null&&(e=e.shared,(n&4194240)!==0)){var r=e.lanes;r&=t.pendingLanes,n|=r,e.lanes=n,qv(t,n)}}function fI(t,e){var n=t.updateQueue,r=t.alternate;if(r!==null&&(r=r.updateQueue,n===r)){var s=null,a=null;if(n=n.firstBaseUpdate,n!==null){do{var i={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};a===null?s=a=i:a=a.next=i,n=n.next}while(n!==null);a===null?s=a=e:a=a.next=e}else s=a=e;n={baseState:r.baseState,firstBaseUpdate:s,lastBaseUpdate:a,shared:r.shared,effects:r.effects},t.updateQueue=n;return}t=n.lastBaseUpdate,t===null?n.firstBaseUpdate=e:t.next=e,n.lastBaseUpdate=e}function Km(t,e,n,r){var s=t.updateQueue;Ei=!1;var a=s.firstBaseUpdate,i=s.lastBaseUpdate,o=s.shared.pending;if(o!==null){s.shared.pending=null;var l=o,u=l.next;l.next=null,i===null?a=u:i.next=u,i=l;var c=t.alternate;c!==null&&(c=c.updateQueue,o=c.lastBaseUpdate,o!==i&&(o===null?c.firstBaseUpdate=u:o.next=u,c.lastBaseUpdate=l))}if(a!==null){var h=s.baseState;i=0,c=u=l=null,o=a;do{var d=o.lane,p=o.eventTime;if((r&d)===d){c!==null&&(c=c.next={eventTime:p,lane:0,tag:o.tag,payload:o.payload,callback:o.callback,next:null});e:{var f=t,m=o;switch(d=e,p=n,m.tag){case 1:if(f=m.payload,typeof f=="function"){h=f.call(p,h,d);break e}h=f;break e;case 3:f.flags=f.flags&-65537|128;case 0:if(f=m.payload,d=typeof f=="function"?f.call(p,h,d):f,d==null)break e;h=Jt({},h,d);break e;case 2:Ei=!0}}o.callback!==null&&o.lane!==0&&(t.flags|=64,d=s.effects,d===null?s.effects=[o]:d.push(o))}else p={eventTime:p,lane:d,tag:o.tag,payload:o.payload,callback:o.callback,next:null},c===null?(u=c=p,l=h):c=c.next=p,i|=d;if(o=o.next,o===null){if(o=s.shared.pending,o===null)break;d=o,o=d.next,d.next=null,s.lastBaseUpdate=d,s.shared.pending=null}}while(!0);if(c===null&&(l=h),s.baseState=l,s.firstBaseUpdate=u,s.lastBaseUpdate=c,e=s.shared.interleaved,e!==null){s=e;do i|=s.lane,s=s.next;while(s!==e)}else a===null&&(s.shared.lanes=0);sl|=i,t.lanes=i,t.memoizedState=h}}function mI(t,e,n){if(t=e.effects,e.effects=null,t!==null)for(e=0;e<t.length;e++){var r=t[e],s=r.callback;if(s!==null){if(r.callback=null,r=n,typeof s!="function")throw Error(pe(191,s));s.call(r)}}}var Yd={},La=po(Yd),pd=po(Yd),fd=po(Yd);function Vo(t){if(t===Yd)throw Error(pe(174));return t}function cw(t,e){switch(Dt(fd,e),Dt(pd,t),Dt(La,Yd),t=e.nodeType,t){case 9:case 11:e=(e=e.documentElement)?e.namespaceURI:Yx(null,"");break;default:t=t===8?e.parentNode:e,e=t.namespaceURI||null,t=t.tagName,e=Yx(e,t)}Wt(La),Dt(La,e)}function Au(){Wt(La),Wt(pd),Wt(fd)}function FE(t){Vo(fd.current);var e=Vo(La.current),n=Yx(e,t.type);e!==n&&(Dt(pd,t),Dt(La,n))}function hw(t){pd.current===t&&(Wt(La),Wt(pd))}var Yt=po(0);function qm(t){for(var e=t;e!==null;){if(e.tag===13){var n=e.memoizedState;if(n!==null&&(n=n.dehydrated,n===null||n.data==="$?"||n.data==="$!"))return e}else if(e.tag===19&&e.memoizedProps.revealOrder!==void 0){if(e.flags&128)return e}else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===t)break;for(;e.sibling===null;){if(e.return===null||e.return===t)return null;e=e.return}e.sibling.return=e.return,e=e.sibling}return null}var ix=[];function dw(){for(var t=0;t<ix.length;t++)ix[t]._workInProgressVersionPrimary=null;ix.length=0}var ym=bi.ReactCurrentDispatcher,ox=bi.ReactCurrentBatchConfig,rl=0,Zt=null,En=null,Pn=null,Xm=!1,Xh=!1,md=0,k4=0;function rr(){throw Error(pe(321))}function pw(t,e){if(e===null)return!1;for(var n=0;n<e.length&&n<t.length;n++)if(!ha(t[n],e[n]))return!1;return!0}function fw(t,e,n,r,s,a){if(rl=a,Zt=e,e.memoizedState=null,e.updateQueue=null,e.lanes=0,ym.current=t===null||t.memoizedState===null?C4:T4,t=n(r,s),Xh){a=0;do{if(Xh=!1,md=0,25<=a)throw Error(pe(301));a+=1,Pn=En=null,e.updateQueue=null,ym.current=E4,t=n(r,s)}while(Xh)}if(ym.current=Ym,e=En!==null&&En.next!==null,rl=0,Pn=En=Zt=null,Xm=!1,e)throw Error(pe(300));return t}function mw(){var t=md!==0;return md=0,t}function Ra(){var t={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Pn===null?Zt.memoizedState=Pn=t:Pn=Pn.next=t,Pn}function Us(){if(En===null){var t=Zt.alternate;t=t!==null?t.memoizedState:null}else t=En.next;var e=Pn===null?Zt.memoizedState:Pn.next;if(e!==null)Pn=e,En=t;else{if(t===null)throw Error(pe(310));En=t,t={memoizedState:En.memoizedState,baseState:En.baseState,baseQueue:En.baseQueue,queue:En.queue,next:null},Pn===null?Zt.memoizedState=Pn=t:Pn=Pn.next=t}return Pn}function gd(t,e){return typeof e=="function"?e(t):e}function lx(t){var e=Us(),n=e.queue;if(n===null)throw Error(pe(311));n.lastRenderedReducer=t;var r=En,s=r.baseQueue,a=n.pending;if(a!==null){if(s!==null){var i=s.next;s.next=a.next,a.next=i}r.baseQueue=s=a,n.pending=null}if(s!==null){a=s.next,r=r.baseState;var o=i=null,l=null,u=a;do{var c=u.lane;if((rl&c)===c)l!==null&&(l=l.next={lane:0,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null}),r=u.hasEagerState?u.eagerState:t(r,u.action);else{var h={lane:c,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null};l===null?(o=l=h,i=r):l=l.next=h,Zt.lanes|=c,sl|=c}u=u.next}while(u!==null&&u!==a);l===null?i=r:l.next=o,ha(r,e.memoizedState)||(Gr=!0),e.memoizedState=r,e.baseState=i,e.baseQueue=l,n.lastRenderedState=r}if(t=n.interleaved,t!==null){s=t;do a=s.lane,Zt.lanes|=a,sl|=a,s=s.next;while(s!==t)}else s===null&&(n.lanes=0);return[e.memoizedState,n.dispatch]}function ux(t){var e=Us(),n=e.queue;if(n===null)throw Error(pe(311));n.lastRenderedReducer=t;var r=n.dispatch,s=n.pending,a=e.memoizedState;if(s!==null){n.pending=null;var i=s=s.next;do a=t(a,i.action),i=i.next;while(i!==s);ha(a,e.memoizedState)||(Gr=!0),e.memoizedState=a,e.baseQueue===null&&(e.baseState=a),n.lastRenderedState=a}return[a,r]}function OE(){}function DE(t,e){var n=Zt,r=Us(),s=e(),a=!ha(r.memoizedState,s);if(a&&(r.memoizedState=s,Gr=!0),r=r.queue,gw(LE.bind(null,n,r,t),[t]),r.getSnapshot!==e||a||Pn!==null&&Pn.memoizedState.tag&1){if(n.flags|=2048,yd(9,PE.bind(null,n,r,s,e),void 0,null),Wn===null)throw Error(pe(349));rl&30||ME(n,e,s)}return s}function ME(t,e,n){t.flags|=16384,t={getSnapshot:e,value:n},e=Zt.updateQueue,e===null?(e={lastEffect:null,stores:null},Zt.updateQueue=e,e.stores=[t]):(n=e.stores,n===null?e.stores=[t]:n.push(t))}function PE(t,e,n,r){e.value=n,e.getSnapshot=r,zE(e)&&BE(t)}function LE(t,e,n){return n(function(){zE(e)&&BE(t)})}function zE(t){var e=t.getSnapshot;t=t.value;try{var n=e();return!ha(t,n)}catch{return!0}}function BE(t){var e=ci(t,1);e!==null&&oa(e,t,1,-1)}function gI(t){var e=Ra();return typeof t=="function"&&(t=t()),e.memoizedState=e.baseState=t,t={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:gd,lastRenderedState:t},e.queue=t,t=t.dispatch=N4.bind(null,Zt,t),[e.memoizedState,t]}function yd(t,e,n,r){return t={tag:t,create:e,destroy:n,deps:r,next:null},e=Zt.updateQueue,e===null?(e={lastEffect:null,stores:null},Zt.updateQueue=e,e.lastEffect=t.next=t):(n=e.lastEffect,n===null?e.lastEffect=t.next=t:(r=n.next,n.next=t,t.next=r,e.lastEffect=t)),t}function WE(){return Us().memoizedState}function bm(t,e,n,r){var s=Ra();Zt.flags|=t,s.memoizedState=yd(1|e,n,void 0,r===void 0?null:r)}function Hg(t,e,n,r){var s=Us();r=r===void 0?null:r;var a=void 0;if(En!==null){var i=En.memoizedState;if(a=i.destroy,r!==null&&pw(r,i.deps)){s.memoizedState=yd(e,n,a,r);return}}Zt.flags|=t,s.memoizedState=yd(1|e,n,a,r)}function yI(t,e){return bm(8390656,8,t,e)}function gw(t,e){return Hg(2048,8,t,e)}function UE(t,e){return Hg(4,2,t,e)}function VE(t,e){return Hg(4,4,t,e)}function jE(t,e){if(typeof e=="function")return t=t(),e(t),function(){e(null)};if(e!=null)return t=t(),e.current=t,function(){e.current=null}}function GE(t,e,n){return n=n!=null?n.concat([t]):null,Hg(4,4,jE.bind(null,e,t),n)}function yw(){}function HE(t,e){var n=Us();e=e===void 0?null:e;var r=n.memoizedState;return r!==null&&e!==null&&pw(e,r[1])?r[0]:(n.memoizedState=[t,e],t)}function KE(t,e){var n=Us();e=e===void 0?null:e;var r=n.memoizedState;return r!==null&&e!==null&&pw(e,r[1])?r[0]:(t=t(),n.memoizedState=[t,e],t)}function qE(t,e,n){return rl&21?(ha(n,e)||(n=JT(),Zt.lanes|=n,sl|=n,t.baseState=!0),e):(t.baseState&&(t.baseState=!1,Gr=!0),t.memoizedState=n)}function S4(t,e){var n=Nt;Nt=n!==0&&4>n?n:4,t(!0);var r=ox.transition;ox.transition={};try{t(!1),e()}finally{Nt=n,ox.transition=r}}function XE(){return Us().memoizedState}function I4(t,e,n){var r=Gi(t);if(n={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null},YE(t))QE(e,n);else if(n=AE(t,e,n,r),n!==null){var s=kr();oa(n,t,r,s),ZE(n,e,r)}}function N4(t,e,n){var r=Gi(t),s={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null};if(YE(t))QE(e,s);else{var a=t.alternate;if(t.lanes===0&&(a===null||a.lanes===0)&&(a=e.lastRenderedReducer,a!==null))try{var i=e.lastRenderedState,o=a(i,n);if(s.hasEagerState=!0,s.eagerState=o,ha(o,i)){var l=e.interleaved;l===null?(s.next=s,lw(e)):(s.next=l.next,l.next=s),e.interleaved=s;return}}catch{}finally{}n=AE(t,e,s,r),n!==null&&(s=kr(),oa(n,t,r,s),ZE(n,e,r))}}function YE(t){var e=t.alternate;return t===Zt||e!==null&&e===Zt}function QE(t,e){Xh=Xm=!0;var n=t.pending;n===null?e.next=e:(e.next=n.next,n.next=e),t.pending=e}function ZE(t,e,n){if(n&4194240){var r=e.lanes;r&=t.pendingLanes,n|=r,e.lanes=n,qv(t,n)}}var Ym={readContext:Ws,useCallback:rr,useContext:rr,useEffect:rr,useImperativeHandle:rr,useInsertionEffect:rr,useLayoutEffect:rr,useMemo:rr,useReducer:rr,useRef:rr,useState:rr,useDebugValue:rr,useDeferredValue:rr,useTransition:rr,useMutableSource:rr,useSyncExternalStore:rr,useId:rr,unstable_isNewReconciler:!1},C4={readContext:Ws,useCallback:function(t,e){return Ra().memoizedState=[t,e===void 0?null:e],t},useContext:Ws,useEffect:yI,useImperativeHandle:function(t,e,n){return n=n!=null?n.concat([t]):null,bm(4194308,4,jE.bind(null,e,t),n)},useLayoutEffect:function(t,e){return bm(4194308,4,t,e)},useInsertionEffect:function(t,e){return bm(4,2,t,e)},useMemo:function(t,e){var n=Ra();return e=e===void 0?null:e,t=t(),n.memoizedState=[t,e],t},useReducer:function(t,e,n){var r=Ra();return e=n!==void 0?n(e):e,r.memoizedState=r.baseState=e,t={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:t,lastRenderedState:e},r.queue=t,t=t.dispatch=I4.bind(null,Zt,t),[r.memoizedState,t]},useRef:function(t){var e=Ra();return t={current:t},e.memoizedState=t},useState:gI,useDebugValue:yw,useDeferredValue:function(t){return Ra().memoizedState=t},useTransition:function(){var t=gI(!1),e=t[0];return t=S4.bind(null,t[1]),Ra().memoizedState=t,[e,t]},useMutableSource:function(){},useSyncExternalStore:function(t,e,n){var r=Zt,s=Ra();if(Gt){if(n===void 0)throw Error(pe(407));n=n()}else{if(n=e(),Wn===null)throw Error(pe(349));rl&30||ME(r,e,n)}s.memoizedState=n;var a={value:n,getSnapshot:e};return s.queue=a,yI(LE.bind(null,r,a,t),[t]),r.flags|=2048,yd(9,PE.bind(null,r,a,n,e),void 0,null),n},useId:function(){var t=Ra(),e=Wn.identifierPrefix;if(Gt){var n=si,r=ri;n=(r&~(1<<32-ia(r)-1)).toString(32)+n,e=":"+e+"R"+n,n=md++,0<n&&(e+="H"+n.toString(32)),e+=":"}else n=k4++,e=":"+e+"r"+n.toString(32)+":";return t.memoizedState=e},unstable_isNewReconciler:!1},T4={readContext:Ws,useCallback:HE,useContext:Ws,useEffect:gw,useImperativeHandle:GE,useInsertionEffect:UE,useLayoutEffect:VE,useMemo:KE,useReducer:lx,useRef:WE,useState:function(){return lx(gd)},useDebugValue:yw,useDeferredValue:function(t){var e=Us();return qE(e,En.memoizedState,t)},useTransition:function(){var t=lx(gd)[0],e=Us().memoizedState;return[t,e]},useMutableSource:OE,useSyncExternalStore:DE,useId:XE,unstable_isNewReconciler:!1},E4={readContext:Ws,useCallback:HE,useContext:Ws,useEffect:gw,useImperativeHandle:GE,useInsertionEffect:UE,useLayoutEffect:VE,useMemo:KE,useReducer:ux,useRef:WE,useState:function(){return ux(gd)},useDebugValue:yw,useDeferredValue:function(t){var e=Us();return En===null?e.memoizedState=t:qE(e,En.memoizedState,t)},useTransition:function(){var t=ux(gd)[0],e=Us().memoizedState;return[t,e]},useMutableSource:OE,useSyncExternalStore:DE,useId:XE,unstable_isNewReconciler:!1};function ea(t,e){if(t&&t.defaultProps){e=Jt({},e),t=t.defaultProps;for(var n in t)e[n]===void 0&&(e[n]=t[n]);return e}return e}function y1(t,e,n,r){e=t.memoizedState,n=n(r,e),n=n==null?e:Jt({},e,n),t.memoizedState=n,t.lanes===0&&(t.updateQueue.baseState=n)}var Kg={isMounted:function(t){return(t=t._reactInternals)?Sl(t)===t:!1},enqueueSetState:function(t,e,n){t=t._reactInternals;var r=kr(),s=Gi(t),a=ai(r,s);a.payload=e,n!=null&&(a.callback=n),e=Vi(t,a,s),e!==null&&(oa(e,t,s,r),gm(e,t,s))},enqueueReplaceState:function(t,e,n){t=t._reactInternals;var r=kr(),s=Gi(t),a=ai(r,s);a.tag=1,a.payload=e,n!=null&&(a.callback=n),e=Vi(t,a,s),e!==null&&(oa(e,t,s,r),gm(e,t,s))},enqueueForceUpdate:function(t,e){t=t._reactInternals;var n=kr(),r=Gi(t),s=ai(n,r);s.tag=2,e!=null&&(s.callback=e),e=Vi(t,s,r),e!==null&&(oa(e,t,r,n),gm(e,t,r))}};function bI(t,e,n,r,s,a,i){return t=t.stateNode,typeof t.shouldComponentUpdate=="function"?t.shouldComponentUpdate(r,a,i):e.prototype&&e.prototype.isPureReactComponent?!ud(n,r)||!ud(s,a):!0}function JE(t,e,n){var r=!1,s=Zi,a=e.contextType;return typeof a=="object"&&a!==null?a=Ws(a):(s=Xr(e)?tl:dr.current,r=e.contextTypes,a=(r=r!=null)?Eu(t,s):Zi),e=new e(n,a),t.memoizedState=e.state!==null&&e.state!==void 0?e.state:null,e.updater=Kg,t.stateNode=e,e._reactInternals=t,r&&(t=t.stateNode,t.__reactInternalMemoizedUnmaskedChildContext=s,t.__reactInternalMemoizedMaskedChildContext=a),e}function xI(t,e,n,r){t=e.state,typeof e.componentWillReceiveProps=="function"&&e.componentWillReceiveProps(n,r),typeof e.UNSAFE_componentWillReceiveProps=="function"&&e.UNSAFE_componentWillReceiveProps(n,r),e.state!==t&&Kg.enqueueReplaceState(e,e.state,null)}function b1(t,e,n,r){var s=t.stateNode;s.props=n,s.state=t.memoizedState,s.refs={},uw(t);var a=e.contextType;typeof a=="object"&&a!==null?s.context=Ws(a):(a=Xr(e)?tl:dr.current,s.context=Eu(t,a)),s.state=t.memoizedState,a=e.getDerivedStateFromProps,typeof a=="function"&&(y1(t,e,a,n),s.state=t.memoizedState),typeof e.getDerivedStateFromProps=="function"||typeof s.getSnapshotBeforeUpdate=="function"||typeof s.UNSAFE_componentWillMount!="function"&&typeof s.componentWillMount!="function"||(e=s.state,typeof s.componentWillMount=="function"&&s.componentWillMount(),typeof s.UNSAFE_componentWillMount=="function"&&s.UNSAFE_componentWillMount(),e!==s.state&&Kg.enqueueReplaceState(s,s.state,null),Km(t,n,s,r),s.state=t.memoizedState),typeof s.componentDidMount=="function"&&(t.flags|=4194308)}function _u(t,e){try{var n="",r=e;do n+=nz(r),r=r.return;while(r);var s=n}catch(a){s=`
Error generating stack: `+a.message+`
`+a.stack}return{value:t,source:e,stack:s,digest:null}}function cx(t,e,n){return{value:t,source:null,stack:n??null,digest:e??null}}function x1(t,e){try{console.error(e.value)}catch(n){setTimeout(function(){throw n})}}var $4=typeof WeakMap=="function"?WeakMap:Map;function e$(t,e,n){n=ai(-1,n),n.tag=3,n.payload={element:null};var r=e.value;return n.callback=function(){Zm||(Zm=!0,E1=r),x1(t,e)},n}function t$(t,e,n){n=ai(-1,n),n.tag=3;var r=t.type.getDerivedStateFromError;if(typeof r=="function"){var s=e.value;n.payload=function(){return r(s)},n.callback=function(){x1(t,e)}}var a=t.stateNode;return a!==null&&typeof a.componentDidCatch=="function"&&(n.callback=function(){x1(t,e),typeof r!="function"&&(ji===null?ji=new Set([this]):ji.add(this));var i=e.stack;this.componentDidCatch(e.value,{componentStack:i!==null?i:""})}),n}function vI(t,e,n){var r=t.pingCache;if(r===null){r=t.pingCache=new $4;var s=new Set;r.set(e,s)}else s=r.get(e),s===void 0&&(s=new Set,r.set(e,s));s.has(n)||(s.add(n),t=V4.bind(null,t,e,n),e.then(t,t))}function wI(t){do{var e;if((e=t.tag===13)&&(e=t.memoizedState,e=e!==null?e.dehydrated!==null:!0),e)return t;t=t.return}while(t!==null);return null}function kI(t,e,n,r,s){return t.mode&1?(t.flags|=65536,t.lanes=s,t):(t===e?t.flags|=65536:(t.flags|=128,n.flags|=131072,n.flags&=-52805,n.tag===1&&(n.alternate===null?n.tag=17:(e=ai(-1,1),e.tag=2,Vi(n,e,1))),n.lanes|=1),t)}var R4=bi.ReactCurrentOwner,Gr=!1;function xr(t,e,n,r){e.child=t===null?RE(e,null,n,r):Ru(e,t.child,n,r)}function SI(t,e,n,r,s){n=n.render;var a=e.ref;return vu(e,s),r=fw(t,e,n,r,a,s),n=mw(),t!==null&&!Gr?(e.updateQueue=t.updateQueue,e.flags&=-2053,t.lanes&=~s,hi(t,e,s)):(Gt&&n&&nw(e),e.flags|=1,xr(t,e,r,s),e.child)}function II(t,e,n,r,s){if(t===null){var a=n.type;return typeof a=="function"&&!Nw(a)&&a.defaultProps===void 0&&n.compare===null&&n.defaultProps===void 0?(e.tag=15,e.type=a,n$(t,e,a,r,s)):(t=km(n.type,null,r,e,e.mode,s),t.ref=e.ref,t.return=e,e.child=t)}if(a=t.child,!(t.lanes&s)){var i=a.memoizedProps;if(n=n.compare,n=n!==null?n:ud,n(i,r)&&t.ref===e.ref)return hi(t,e,s)}return e.flags|=1,t=Hi(a,r),t.ref=e.ref,t.return=e,e.child=t}function n$(t,e,n,r,s){if(t!==null){var a=t.memoizedProps;if(ud(a,r)&&t.ref===e.ref)if(Gr=!1,e.pendingProps=r=a,(t.lanes&s)!==0)t.flags&131072&&(Gr=!0);else return e.lanes=t.lanes,hi(t,e,s)}return v1(t,e,n,r,s)}function r$(t,e,n){var r=e.pendingProps,s=r.children,a=t!==null?t.memoizedState:null;if(r.mode==="hidden")if(!(e.mode&1))e.memoizedState={baseLanes:0,cachePool:null,transitions:null},Dt(fu,as),as|=n;else{if(!(n&1073741824))return t=a!==null?a.baseLanes|n:n,e.lanes=e.childLanes=1073741824,e.memoizedState={baseLanes:t,cachePool:null,transitions:null},e.updateQueue=null,Dt(fu,as),as|=t,null;e.memoizedState={baseLanes:0,cachePool:null,transitions:null},r=a!==null?a.baseLanes:n,Dt(fu,as),as|=r}else a!==null?(r=a.baseLanes|n,e.memoizedState=null):r=n,Dt(fu,as),as|=r;return xr(t,e,s,n),e.child}function s$(t,e){var n=e.ref;(t===null&&n!==null||t!==null&&t.ref!==n)&&(e.flags|=512,e.flags|=2097152)}function v1(t,e,n,r,s){var a=Xr(n)?tl:dr.current;return a=Eu(e,a),vu(e,s),n=fw(t,e,n,r,a,s),r=mw(),t!==null&&!Gr?(e.updateQueue=t.updateQueue,e.flags&=-2053,t.lanes&=~s,hi(t,e,s)):(Gt&&r&&nw(e),e.flags|=1,xr(t,e,n,s),e.child)}function NI(t,e,n,r,s){if(Xr(n)){var a=!0;Um(e)}else a=!1;if(vu(e,s),e.stateNode===null)xm(t,e),JE(e,n,r),b1(e,n,r,s),r=!0;else if(t===null){var i=e.stateNode,o=e.memoizedProps;i.props=o;var l=i.context,u=n.contextType;typeof u=="object"&&u!==null?u=Ws(u):(u=Xr(n)?tl:dr.current,u=Eu(e,u));var c=n.getDerivedStateFromProps,h=typeof c=="function"||typeof i.getSnapshotBeforeUpdate=="function";h||typeof i.UNSAFE_componentWillReceiveProps!="function"&&typeof i.componentWillReceiveProps!="function"||(o!==r||l!==u)&&xI(e,i,r,u),Ei=!1;var d=e.memoizedState;i.state=d,Km(e,r,i,s),l=e.memoizedState,o!==r||d!==l||qr.current||Ei?(typeof c=="function"&&(y1(e,n,c,r),l=e.memoizedState),(o=Ei||bI(e,n,o,r,d,l,u))?(h||typeof i.UNSAFE_componentWillMount!="function"&&typeof i.componentWillMount!="function"||(typeof i.componentWillMount=="function"&&i.componentWillMount(),typeof i.UNSAFE_componentWillMount=="function"&&i.UNSAFE_componentWillMount()),typeof i.componentDidMount=="function"&&(e.flags|=4194308)):(typeof i.componentDidMount=="function"&&(e.flags|=4194308),e.memoizedProps=r,e.memoizedState=l),i.props=r,i.state=l,i.context=u,r=o):(typeof i.componentDidMount=="function"&&(e.flags|=4194308),r=!1)}else{i=e.stateNode,_E(t,e),o=e.memoizedProps,u=e.type===e.elementType?o:ea(e.type,o),i.props=u,h=e.pendingProps,d=i.context,l=n.contextType,typeof l=="object"&&l!==null?l=Ws(l):(l=Xr(n)?tl:dr.current,l=Eu(e,l));var p=n.getDerivedStateFromProps;(c=typeof p=="function"||typeof i.getSnapshotBeforeUpdate=="function")||typeof i.UNSAFE_componentWillReceiveProps!="function"&&typeof i.componentWillReceiveProps!="function"||(o!==h||d!==l)&&xI(e,i,r,l),Ei=!1,d=e.memoizedState,i.state=d,Km(e,r,i,s);var f=e.memoizedState;o!==h||d!==f||qr.current||Ei?(typeof p=="function"&&(y1(e,n,p,r),f=e.memoizedState),(u=Ei||bI(e,n,u,r,d,f,l)||!1)?(c||typeof i.UNSAFE_componentWillUpdate!="function"&&typeof i.componentWillUpdate!="function"||(typeof i.componentWillUpdate=="function"&&i.componentWillUpdate(r,f,l),typeof i.UNSAFE_componentWillUpdate=="function"&&i.UNSAFE_componentWillUpdate(r,f,l)),typeof i.componentDidUpdate=="function"&&(e.flags|=4),typeof i.getSnapshotBeforeUpdate=="function"&&(e.flags|=1024)):(typeof i.componentDidUpdate!="function"||o===t.memoizedProps&&d===t.memoizedState||(e.flags|=4),typeof i.getSnapshotBeforeUpdate!="function"||o===t.memoizedProps&&d===t.memoizedState||(e.flags|=1024),e.memoizedProps=r,e.memoizedState=f),i.props=r,i.state=f,i.context=l,r=u):(typeof i.componentDidUpdate!="function"||o===t.memoizedProps&&d===t.memoizedState||(e.flags|=4),typeof i.getSnapshotBeforeUpdate!="function"||o===t.memoizedProps&&d===t.memoizedState||(e.flags|=1024),r=!1)}return w1(t,e,n,r,a,s)}function w1(t,e,n,r,s,a){s$(t,e);var i=(e.flags&128)!==0;if(!r&&!i)return s&&cI(e,n,!1),hi(t,e,a);r=e.stateNode,R4.current=e;var o=i&&typeof n.getDerivedStateFromError!="function"?null:r.render();return e.flags|=1,t!==null&&i?(e.child=Ru(e,t.child,null,a),e.child=Ru(e,null,o,a)):xr(t,e,o,a),e.memoizedState=r.state,s&&cI(e,n,!0),e.child}function a$(t){var e=t.stateNode;e.pendingContext?uI(t,e.pendingContext,e.pendingContext!==e.context):e.context&&uI(t,e.context,!1),cw(t,e.containerInfo)}function CI(t,e,n,r,s){return $u(),sw(s),e.flags|=256,xr(t,e,n,r),e.child}var k1={dehydrated:null,treeContext:null,retryLane:0};function S1(t){return{baseLanes:t,cachePool:null,transitions:null}}function i$(t,e,n){var r=e.pendingProps,s=Yt.current,a=!1,i=(e.flags&128)!==0,o;if((o=i)||(o=t!==null&&t.memoizedState===null?!1:(s&2)!==0),o?(a=!0,e.flags&=-129):(t===null||t.memoizedState!==null)&&(s|=1),Dt(Yt,s&1),t===null)return m1(e),t=e.memoizedState,t!==null&&(t=t.dehydrated,t!==null)?(e.mode&1?t.data==="$!"?e.lanes=8:e.lanes=1073741824:e.lanes=1,null):(i=r.children,t=r.fallback,a?(r=e.mode,a=e.child,i={mode:"hidden",children:i},!(r&1)&&a!==null?(a.childLanes=0,a.pendingProps=i):a=Yg(i,r,0,null),t=Xo(t,r,n,null),a.return=e,t.return=e,a.sibling=t,e.child=a,e.child.memoizedState=S1(n),e.memoizedState=k1,t):bw(e,i));if(s=t.memoizedState,s!==null&&(o=s.dehydrated,o!==null))return A4(t,e,i,r,o,s,n);if(a){a=r.fallback,i=e.mode,s=t.child,o=s.sibling;var l={mode:"hidden",children:r.children};return!(i&1)&&e.child!==s?(r=e.child,r.childLanes=0,r.pendingProps=l,e.deletions=null):(r=Hi(s,l),r.subtreeFlags=s.subtreeFlags&14680064),o!==null?a=Hi(o,a):(a=Xo(a,i,n,null),a.flags|=2),a.return=e,r.return=e,r.sibling=a,e.child=r,r=a,a=e.child,i=t.child.memoizedState,i=i===null?S1(n):{baseLanes:i.baseLanes|n,cachePool:null,transitions:i.transitions},a.memoizedState=i,a.childLanes=t.childLanes&~n,e.memoizedState=k1,r}return a=t.child,t=a.sibling,r=Hi(a,{mode:"visible",children:r.children}),!(e.mode&1)&&(r.lanes=n),r.return=e,r.sibling=null,t!==null&&(n=e.deletions,n===null?(e.deletions=[t],e.flags|=16):n.push(t)),e.child=r,e.memoizedState=null,r}function bw(t,e){return e=Yg({mode:"visible",children:e},t.mode,0,null),e.return=t,t.child=e}function Yf(t,e,n,r){return r!==null&&sw(r),Ru(e,t.child,null,n),t=bw(e,e.pendingProps.children),t.flags|=2,e.memoizedState=null,t}function A4(t,e,n,r,s,a,i){if(n)return e.flags&256?(e.flags&=-257,r=cx(Error(pe(422))),Yf(t,e,i,r)):e.memoizedState!==null?(e.child=t.child,e.flags|=128,null):(a=r.fallback,s=e.mode,r=Yg({mode:"visible",children:r.children},s,0,null),a=Xo(a,s,i,null),a.flags|=2,r.return=e,a.return=e,r.sibling=a,e.child=r,e.mode&1&&Ru(e,t.child,null,i),e.child.memoizedState=S1(i),e.memoizedState=k1,a);if(!(e.mode&1))return Yf(t,e,i,null);if(s.data==="$!"){if(r=s.nextSibling&&s.nextSibling.dataset,r)var o=r.dgst;return r=o,a=Error(pe(419)),r=cx(a,r,void 0),Yf(t,e,i,r)}if(o=(i&t.childLanes)!==0,Gr||o){if(r=Wn,r!==null){switch(i&-i){case 4:s=2;break;case 16:s=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:s=32;break;case 536870912:s=268435456;break;default:s=0}s=s&(r.suspendedLanes|i)?0:s,s!==0&&s!==a.retryLane&&(a.retryLane=s,ci(t,s),oa(r,t,s,-1))}return Iw(),r=cx(Error(pe(421))),Yf(t,e,i,r)}return s.data==="$?"?(e.flags|=128,e.child=t.child,e=j4.bind(null,t),s._reactRetry=e,null):(t=a.treeContext,ls=Ui(s.nextSibling),hs=e,Gt=!0,na=null,t!==null&&($s[Rs++]=ri,$s[Rs++]=si,$s[Rs++]=nl,ri=t.id,si=t.overflow,nl=e),e=bw(e,r.children),e.flags|=4096,e)}function TI(t,e,n){t.lanes|=e;var r=t.alternate;r!==null&&(r.lanes|=e),g1(t.return,e,n)}function hx(t,e,n,r,s){var a=t.memoizedState;a===null?t.memoizedState={isBackwards:e,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:s}:(a.isBackwards=e,a.rendering=null,a.renderingStartTime=0,a.last=r,a.tail=n,a.tailMode=s)}function o$(t,e,n){var r=e.pendingProps,s=r.revealOrder,a=r.tail;if(xr(t,e,r.children,n),r=Yt.current,r&2)r=r&1|2,e.flags|=128;else{if(t!==null&&t.flags&128)e:for(t=e.child;t!==null;){if(t.tag===13)t.memoizedState!==null&&TI(t,n,e);else if(t.tag===19)TI(t,n,e);else if(t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break e;for(;t.sibling===null;){if(t.return===null||t.return===e)break e;t=t.return}t.sibling.return=t.return,t=t.sibling}r&=1}if(Dt(Yt,r),!(e.mode&1))e.memoizedState=null;else switch(s){case"forwards":for(n=e.child,s=null;n!==null;)t=n.alternate,t!==null&&qm(t)===null&&(s=n),n=n.sibling;n=s,n===null?(s=e.child,e.child=null):(s=n.sibling,n.sibling=null),hx(e,!1,s,n,a);break;case"backwards":for(n=null,s=e.child,e.child=null;s!==null;){if(t=s.alternate,t!==null&&qm(t)===null){e.child=s;break}t=s.sibling,s.sibling=n,n=s,s=t}hx(e,!0,n,null,a);break;case"together":hx(e,!1,null,null,void 0);break;default:e.memoizedState=null}return e.child}function xm(t,e){!(e.mode&1)&&t!==null&&(t.alternate=null,e.alternate=null,e.flags|=2)}function hi(t,e,n){if(t!==null&&(e.dependencies=t.dependencies),sl|=e.lanes,!(n&e.childLanes))return null;if(t!==null&&e.child!==t.child)throw Error(pe(153));if(e.child!==null){for(t=e.child,n=Hi(t,t.pendingProps),e.child=n,n.return=e;t.sibling!==null;)t=t.sibling,n=n.sibling=Hi(t,t.pendingProps),n.return=e;n.sibling=null}return e.child}function _4(t,e,n){switch(e.tag){case 3:a$(e),$u();break;case 5:FE(e);break;case 1:Xr(e.type)&&Um(e);break;case 4:cw(e,e.stateNode.containerInfo);break;case 10:var r=e.type._context,s=e.memoizedProps.value;Dt(Gm,r._currentValue),r._currentValue=s;break;case 13:if(r=e.memoizedState,r!==null)return r.dehydrated!==null?(Dt(Yt,Yt.current&1),e.flags|=128,null):n&e.child.childLanes?i$(t,e,n):(Dt(Yt,Yt.current&1),t=hi(t,e,n),t!==null?t.sibling:null);Dt(Yt,Yt.current&1);break;case 19:if(r=(n&e.childLanes)!==0,t.flags&128){if(r)return o$(t,e,n);e.flags|=128}if(s=e.memoizedState,s!==null&&(s.rendering=null,s.tail=null,s.lastEffect=null),Dt(Yt,Yt.current),r)break;return null;case 22:case 23:return e.lanes=0,r$(t,e,n)}return hi(t,e,n)}var l$,I1,u$,c$;l$=function(t,e){for(var n=e.child;n!==null;){if(n.tag===5||n.tag===6)t.appendChild(n.stateNode);else if(n.tag!==4&&n.child!==null){n.child.return=n,n=n.child;continue}if(n===e)break;for(;n.sibling===null;){if(n.return===null||n.return===e)return;n=n.return}n.sibling.return=n.return,n=n.sibling}};I1=function(){};u$=function(t,e,n,r){var s=t.memoizedProps;if(s!==r){t=e.stateNode,Vo(La.current);var a=null;switch(n){case"input":s=Hx(t,s),r=Hx(t,r),a=[];break;case"select":s=Jt({},s,{value:void 0}),r=Jt({},r,{value:void 0}),a=[];break;case"textarea":s=Xx(t,s),r=Xx(t,r),a=[];break;default:typeof s.onClick!="function"&&typeof r.onClick=="function"&&(t.onclick=Bm)}Qx(n,r);var i;n=null;for(u in s)if(!r.hasOwnProperty(u)&&s.hasOwnProperty(u)&&s[u]!=null)if(u==="style"){var o=s[u];for(i in o)o.hasOwnProperty(i)&&(n||(n={}),n[i]="")}else u!=="dangerouslySetInnerHTML"&&u!=="children"&&u!=="suppressContentEditableWarning"&&u!=="suppressHydrationWarning"&&u!=="autoFocus"&&(nd.hasOwnProperty(u)?a||(a=[]):(a=a||[]).push(u,null));for(u in r){var l=r[u];if(o=s!=null?s[u]:void 0,r.hasOwnProperty(u)&&l!==o&&(l!=null||o!=null))if(u==="style")if(o){for(i in o)!o.hasOwnProperty(i)||l&&l.hasOwnProperty(i)||(n||(n={}),n[i]="");for(i in l)l.hasOwnProperty(i)&&o[i]!==l[i]&&(n||(n={}),n[i]=l[i])}else n||(a||(a=[]),a.push(u,n)),n=l;else u==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,o=o?o.__html:void 0,l!=null&&o!==l&&(a=a||[]).push(u,l)):u==="children"?typeof l!="string"&&typeof l!="number"||(a=a||[]).push(u,""+l):u!=="suppressContentEditableWarning"&&u!=="suppressHydrationWarning"&&(nd.hasOwnProperty(u)?(l!=null&&u==="onScroll"&&Bt("scroll",t),a||o===l||(a=[])):(a=a||[]).push(u,l))}n&&(a=a||[]).push("style",n);var u=a;(e.updateQueue=u)&&(e.flags|=4)}};c$=function(t,e,n,r){n!==r&&(e.flags|=4)};function Sh(t,e){if(!Gt)switch(t.tailMode){case"hidden":e=t.tail;for(var n=null;e!==null;)e.alternate!==null&&(n=e),e=e.sibling;n===null?t.tail=null:n.sibling=null;break;case"collapsed":n=t.tail;for(var r=null;n!==null;)n.alternate!==null&&(r=n),n=n.sibling;r===null?e||t.tail===null?t.tail=null:t.tail.sibling=null:r.sibling=null}}function sr(t){var e=t.alternate!==null&&t.alternate.child===t.child,n=0,r=0;if(e)for(var s=t.child;s!==null;)n|=s.lanes|s.childLanes,r|=s.subtreeFlags&14680064,r|=s.flags&14680064,s.return=t,s=s.sibling;else for(s=t.child;s!==null;)n|=s.lanes|s.childLanes,r|=s.subtreeFlags,r|=s.flags,s.return=t,s=s.sibling;return t.subtreeFlags|=r,t.childLanes=n,e}function F4(t,e,n){var r=e.pendingProps;switch(rw(e),e.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return sr(e),null;case 1:return Xr(e.type)&&Wm(),sr(e),null;case 3:return r=e.stateNode,Au(),Wt(qr),Wt(dr),dw(),r.pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),(t===null||t.child===null)&&(qf(e)?e.flags|=4:t===null||t.memoizedState.isDehydrated&&!(e.flags&256)||(e.flags|=1024,na!==null&&(A1(na),na=null))),I1(t,e),sr(e),null;case 5:hw(e);var s=Vo(fd.current);if(n=e.type,t!==null&&e.stateNode!=null)u$(t,e,n,r,s),t.ref!==e.ref&&(e.flags|=512,e.flags|=2097152);else{if(!r){if(e.stateNode===null)throw Error(pe(166));return sr(e),null}if(t=Vo(La.current),qf(e)){r=e.stateNode,n=e.type;var a=e.memoizedProps;switch(r[Da]=e,r[dd]=a,t=(e.mode&1)!==0,n){case"dialog":Bt("cancel",r),Bt("close",r);break;case"iframe":case"object":case"embed":Bt("load",r);break;case"video":case"audio":for(s=0;s<Fh.length;s++)Bt(Fh[s],r);break;case"source":Bt("error",r);break;case"img":case"image":case"link":Bt("error",r),Bt("load",r);break;case"details":Bt("toggle",r);break;case"input":MS(r,a),Bt("invalid",r);break;case"select":r._wrapperState={wasMultiple:!!a.multiple},Bt("invalid",r);break;case"textarea":LS(r,a),Bt("invalid",r)}Qx(n,a),s=null;for(var i in a)if(a.hasOwnProperty(i)){var o=a[i];i==="children"?typeof o=="string"?r.textContent!==o&&(a.suppressHydrationWarning!==!0&&Kf(r.textContent,o,t),s=["children",o]):typeof o=="number"&&r.textContent!==""+o&&(a.suppressHydrationWarning!==!0&&Kf(r.textContent,o,t),s=["children",""+o]):nd.hasOwnProperty(i)&&o!=null&&i==="onScroll"&&Bt("scroll",r)}switch(n){case"input":zf(r),PS(r,a,!0);break;case"textarea":zf(r),zS(r);break;case"select":case"option":break;default:typeof a.onClick=="function"&&(r.onclick=Bm)}r=s,e.updateQueue=r,r!==null&&(e.flags|=4)}else{i=s.nodeType===9?s:s.ownerDocument,t==="http://www.w3.org/1999/xhtml"&&(t=LT(n)),t==="http://www.w3.org/1999/xhtml"?n==="script"?(t=i.createElement("div"),t.innerHTML="<script><\/script>",t=t.removeChild(t.firstChild)):typeof r.is=="string"?t=i.createElement(n,{is:r.is}):(t=i.createElement(n),n==="select"&&(i=t,r.multiple?i.multiple=!0:r.size&&(i.size=r.size))):t=i.createElementNS(t,n),t[Da]=e,t[dd]=r,l$(t,e,!1,!1),e.stateNode=t;e:{switch(i=Zx(n,r),n){case"dialog":Bt("cancel",t),Bt("close",t),s=r;break;case"iframe":case"object":case"embed":Bt("load",t),s=r;break;case"video":case"audio":for(s=0;s<Fh.length;s++)Bt(Fh[s],t);s=r;break;case"source":Bt("error",t),s=r;break;case"img":case"image":case"link":Bt("error",t),Bt("load",t),s=r;break;case"details":Bt("toggle",t),s=r;break;case"input":MS(t,r),s=Hx(t,r),Bt("invalid",t);break;case"option":s=r;break;case"select":t._wrapperState={wasMultiple:!!r.multiple},s=Jt({},r,{value:void 0}),Bt("invalid",t);break;case"textarea":LS(t,r),s=Xx(t,r),Bt("invalid",t);break;default:s=r}Qx(n,s),o=s;for(a in o)if(o.hasOwnProperty(a)){var l=o[a];a==="style"?WT(t,l):a==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,l!=null&&zT(t,l)):a==="children"?typeof l=="string"?(n!=="textarea"||l!=="")&&rd(t,l):typeof l=="number"&&rd(t,""+l):a!=="suppressContentEditableWarning"&&a!=="suppressHydrationWarning"&&a!=="autoFocus"&&(nd.hasOwnProperty(a)?l!=null&&a==="onScroll"&&Bt("scroll",t):l!=null&&Uv(t,a,l,i))}switch(n){case"input":zf(t),PS(t,r,!1);break;case"textarea":zf(t),zS(t);break;case"option":r.value!=null&&t.setAttribute("value",""+Qi(r.value));break;case"select":t.multiple=!!r.multiple,a=r.value,a!=null?gu(t,!!r.multiple,a,!1):r.defaultValue!=null&&gu(t,!!r.multiple,r.defaultValue,!0);break;default:typeof s.onClick=="function"&&(t.onclick=Bm)}switch(n){case"button":case"input":case"select":case"textarea":r=!!r.autoFocus;break e;case"img":r=!0;break e;default:r=!1}}r&&(e.flags|=4)}e.ref!==null&&(e.flags|=512,e.flags|=2097152)}return sr(e),null;case 6:if(t&&e.stateNode!=null)c$(t,e,t.memoizedProps,r);else{if(typeof r!="string"&&e.stateNode===null)throw Error(pe(166));if(n=Vo(fd.current),Vo(La.current),qf(e)){if(r=e.stateNode,n=e.memoizedProps,r[Da]=e,(a=r.nodeValue!==n)&&(t=hs,t!==null))switch(t.tag){case 3:Kf(r.nodeValue,n,(t.mode&1)!==0);break;case 5:t.memoizedProps.suppressHydrationWarning!==!0&&Kf(r.nodeValue,n,(t.mode&1)!==0)}a&&(e.flags|=4)}else r=(n.nodeType===9?n:n.ownerDocument).createTextNode(r),r[Da]=e,e.stateNode=r}return sr(e),null;case 13:if(Wt(Yt),r=e.memoizedState,t===null||t.memoizedState!==null&&t.memoizedState.dehydrated!==null){if(Gt&&ls!==null&&e.mode&1&&!(e.flags&128))EE(),$u(),e.flags|=98560,a=!1;else if(a=qf(e),r!==null&&r.dehydrated!==null){if(t===null){if(!a)throw Error(pe(318));if(a=e.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(pe(317));a[Da]=e}else $u(),!(e.flags&128)&&(e.memoizedState=null),e.flags|=4;sr(e),a=!1}else na!==null&&(A1(na),na=null),a=!0;if(!a)return e.flags&65536?e:null}return e.flags&128?(e.lanes=n,e):(r=r!==null,r!==(t!==null&&t.memoizedState!==null)&&r&&(e.child.flags|=8192,e.mode&1&&(t===null||Yt.current&1?Rn===0&&(Rn=3):Iw())),e.updateQueue!==null&&(e.flags|=4),sr(e),null);case 4:return Au(),I1(t,e),t===null&&cd(e.stateNode.containerInfo),sr(e),null;case 10:return ow(e.type._context),sr(e),null;case 17:return Xr(e.type)&&Wm(),sr(e),null;case 19:if(Wt(Yt),a=e.memoizedState,a===null)return sr(e),null;if(r=(e.flags&128)!==0,i=a.rendering,i===null)if(r)Sh(a,!1);else{if(Rn!==0||t!==null&&t.flags&128)for(t=e.child;t!==null;){if(i=qm(t),i!==null){for(e.flags|=128,Sh(a,!1),r=i.updateQueue,r!==null&&(e.updateQueue=r,e.flags|=4),e.subtreeFlags=0,r=n,n=e.child;n!==null;)a=n,t=r,a.flags&=14680066,i=a.alternate,i===null?(a.childLanes=0,a.lanes=t,a.child=null,a.subtreeFlags=0,a.memoizedProps=null,a.memoizedState=null,a.updateQueue=null,a.dependencies=null,a.stateNode=null):(a.childLanes=i.childLanes,a.lanes=i.lanes,a.child=i.child,a.subtreeFlags=0,a.deletions=null,a.memoizedProps=i.memoizedProps,a.memoizedState=i.memoizedState,a.updateQueue=i.updateQueue,a.type=i.type,t=i.dependencies,a.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext}),n=n.sibling;return Dt(Yt,Yt.current&1|2),e.child}t=t.sibling}a.tail!==null&&cn()>Fu&&(e.flags|=128,r=!0,Sh(a,!1),e.lanes=4194304)}else{if(!r)if(t=qm(i),t!==null){if(e.flags|=128,r=!0,n=t.updateQueue,n!==null&&(e.updateQueue=n,e.flags|=4),Sh(a,!0),a.tail===null&&a.tailMode==="hidden"&&!i.alternate&&!Gt)return sr(e),null}else 2*cn()-a.renderingStartTime>Fu&&n!==1073741824&&(e.flags|=128,r=!0,Sh(a,!1),e.lanes=4194304);a.isBackwards?(i.sibling=e.child,e.child=i):(n=a.last,n!==null?n.sibling=i:e.child=i,a.last=i)}return a.tail!==null?(e=a.tail,a.rendering=e,a.tail=e.sibling,a.renderingStartTime=cn(),e.sibling=null,n=Yt.current,Dt(Yt,r?n&1|2:n&1),e):(sr(e),null);case 22:case 23:return Sw(),r=e.memoizedState!==null,t!==null&&t.memoizedState!==null!==r&&(e.flags|=8192),r&&e.mode&1?as&1073741824&&(sr(e),e.subtreeFlags&6&&(e.flags|=8192)):sr(e),null;case 24:return null;case 25:return null}throw Error(pe(156,e.tag))}function O4(t,e){switch(rw(e),e.tag){case 1:return Xr(e.type)&&Wm(),t=e.flags,t&65536?(e.flags=t&-65537|128,e):null;case 3:return Au(),Wt(qr),Wt(dr),dw(),t=e.flags,t&65536&&!(t&128)?(e.flags=t&-65537|128,e):null;case 5:return hw(e),null;case 13:if(Wt(Yt),t=e.memoizedState,t!==null&&t.dehydrated!==null){if(e.alternate===null)throw Error(pe(340));$u()}return t=e.flags,t&65536?(e.flags=t&-65537|128,e):null;case 19:return Wt(Yt),null;case 4:return Au(),null;case 10:return ow(e.type._context),null;case 22:case 23:return Sw(),null;case 24:return null;default:return null}}var Qf=!1,lr=!1,D4=typeof WeakSet=="function"?WeakSet:Set,$e=null;function pu(t,e){var n=t.ref;if(n!==null)if(typeof n=="function")try{n(null)}catch(r){nn(t,e,r)}else n.current=null}function h$(t,e,n){try{n()}catch(r){nn(t,e,r)}}var EI=!1;function M4(t,e){if(l1=Pm,t=mE(),tw(t)){if("selectionStart"in t)var n={start:t.selectionStart,end:t.selectionEnd};else e:{n=(n=t.ownerDocument)&&n.defaultView||window;var r=n.getSelection&&n.getSelection();if(r&&r.rangeCount!==0){n=r.anchorNode;var s=r.anchorOffset,a=r.focusNode;r=r.focusOffset;try{n.nodeType,a.nodeType}catch{n=null;break e}var i=0,o=-1,l=-1,u=0,c=0,h=t,d=null;t:for(;;){for(var p;h!==n||s!==0&&h.nodeType!==3||(o=i+s),h!==a||r!==0&&h.nodeType!==3||(l=i+r),h.nodeType===3&&(i+=h.nodeValue.length),(p=h.firstChild)!==null;)d=h,h=p;for(;;){if(h===t)break t;if(d===n&&++u===s&&(o=i),d===a&&++c===r&&(l=i),(p=h.nextSibling)!==null)break;h=d,d=h.parentNode}h=p}n=o===-1||l===-1?null:{start:o,end:l}}else n=null}n=n||{start:0,end:0}}else n=null;for(u1={focusedElem:t,selectionRange:n},Pm=!1,$e=e;$e!==null;)if(e=$e,t=e.child,(e.subtreeFlags&1028)!==0&&t!==null)t.return=e,$e=t;else for(;$e!==null;){e=$e;try{var f=e.alternate;if(e.flags&1024)switch(e.tag){case 0:case 11:case 15:break;case 1:if(f!==null){var m=f.memoizedProps,y=f.memoizedState,g=e.stateNode,b=g.getSnapshotBeforeUpdate(e.elementType===e.type?m:ea(e.type,m),y);g.__reactInternalSnapshotBeforeUpdate=b}break;case 3:var v=e.stateNode.containerInfo;v.nodeType===1?v.textContent="":v.nodeType===9&&v.documentElement&&v.removeChild(v.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(pe(163))}}catch(w){nn(e,e.return,w)}if(t=e.sibling,t!==null){t.return=e.return,$e=t;break}$e=e.return}return f=EI,EI=!1,f}function Yh(t,e,n){var r=e.updateQueue;if(r=r!==null?r.lastEffect:null,r!==null){var s=r=r.next;do{if((s.tag&t)===t){var a=s.destroy;s.destroy=void 0,a!==void 0&&h$(e,n,a)}s=s.next}while(s!==r)}}function qg(t,e){if(e=e.updateQueue,e=e!==null?e.lastEffect:null,e!==null){var n=e=e.next;do{if((n.tag&t)===t){var r=n.create;n.destroy=r()}n=n.next}while(n!==e)}}function N1(t){var e=t.ref;if(e!==null){var n=t.stateNode;switch(t.tag){case 5:t=n;break;default:t=n}typeof e=="function"?e(t):e.current=t}}function d$(t){var e=t.alternate;e!==null&&(t.alternate=null,d$(e)),t.child=null,t.deletions=null,t.sibling=null,t.tag===5&&(e=t.stateNode,e!==null&&(delete e[Da],delete e[dd],delete e[d1],delete e[b4],delete e[x4])),t.stateNode=null,t.return=null,t.dependencies=null,t.memoizedProps=null,t.memoizedState=null,t.pendingProps=null,t.stateNode=null,t.updateQueue=null}function p$(t){return t.tag===5||t.tag===3||t.tag===4}function $I(t){e:for(;;){for(;t.sibling===null;){if(t.return===null||p$(t.return))return null;t=t.return}for(t.sibling.return=t.return,t=t.sibling;t.tag!==5&&t.tag!==6&&t.tag!==18;){if(t.flags&2||t.child===null||t.tag===4)continue e;t.child.return=t,t=t.child}if(!(t.flags&2))return t.stateNode}}function C1(t,e,n){var r=t.tag;if(r===5||r===6)t=t.stateNode,e?n.nodeType===8?n.parentNode.insertBefore(t,e):n.insertBefore(t,e):(n.nodeType===8?(e=n.parentNode,e.insertBefore(t,n)):(e=n,e.appendChild(t)),n=n._reactRootContainer,n!=null||e.onclick!==null||(e.onclick=Bm));else if(r!==4&&(t=t.child,t!==null))for(C1(t,e,n),t=t.sibling;t!==null;)C1(t,e,n),t=t.sibling}function T1(t,e,n){var r=t.tag;if(r===5||r===6)t=t.stateNode,e?n.insertBefore(t,e):n.appendChild(t);else if(r!==4&&(t=t.child,t!==null))for(T1(t,e,n),t=t.sibling;t!==null;)T1(t,e,n),t=t.sibling}var Yn=null,ta=!1;function Ci(t,e,n){for(n=n.child;n!==null;)f$(t,e,n),n=n.sibling}function f$(t,e,n){if(Pa&&typeof Pa.onCommitFiberUnmount=="function")try{Pa.onCommitFiberUnmount(Bg,n)}catch{}switch(n.tag){case 5:lr||pu(n,e);case 6:var r=Yn,s=ta;Yn=null,Ci(t,e,n),Yn=r,ta=s,Yn!==null&&(ta?(t=Yn,n=n.stateNode,t.nodeType===8?t.parentNode.removeChild(n):t.removeChild(n)):Yn.removeChild(n.stateNode));break;case 18:Yn!==null&&(ta?(t=Yn,n=n.stateNode,t.nodeType===8?sx(t.parentNode,n):t.nodeType===1&&sx(t,n),od(t)):sx(Yn,n.stateNode));break;case 4:r=Yn,s=ta,Yn=n.stateNode.containerInfo,ta=!0,Ci(t,e,n),Yn=r,ta=s;break;case 0:case 11:case 14:case 15:if(!lr&&(r=n.updateQueue,r!==null&&(r=r.lastEffect,r!==null))){s=r=r.next;do{var a=s,i=a.destroy;a=a.tag,i!==void 0&&(a&2||a&4)&&h$(n,e,i),s=s.next}while(s!==r)}Ci(t,e,n);break;case 1:if(!lr&&(pu(n,e),r=n.stateNode,typeof r.componentWillUnmount=="function"))try{r.props=n.memoizedProps,r.state=n.memoizedState,r.componentWillUnmount()}catch(o){nn(n,e,o)}Ci(t,e,n);break;case 21:Ci(t,e,n);break;case 22:n.mode&1?(lr=(r=lr)||n.memoizedState!==null,Ci(t,e,n),lr=r):Ci(t,e,n);break;default:Ci(t,e,n)}}function RI(t){var e=t.updateQueue;if(e!==null){t.updateQueue=null;var n=t.stateNode;n===null&&(n=t.stateNode=new D4),e.forEach(function(r){var s=G4.bind(null,t,r);n.has(r)||(n.add(r),r.then(s,s))})}}function Qs(t,e){var n=e.deletions;if(n!==null)for(var r=0;r<n.length;r++){var s=n[r];try{var a=t,i=e,o=i;e:for(;o!==null;){switch(o.tag){case 5:Yn=o.stateNode,ta=!1;break e;case 3:Yn=o.stateNode.containerInfo,ta=!0;break e;case 4:Yn=o.stateNode.containerInfo,ta=!0;break e}o=o.return}if(Yn===null)throw Error(pe(160));f$(a,i,s),Yn=null,ta=!1;var l=s.alternate;l!==null&&(l.return=null),s.return=null}catch(u){nn(s,e,u)}}if(e.subtreeFlags&12854)for(e=e.child;e!==null;)m$(e,t),e=e.sibling}function m$(t,e){var n=t.alternate,r=t.flags;switch(t.tag){case 0:case 11:case 14:case 15:if(Qs(e,t),$a(t),r&4){try{Yh(3,t,t.return),qg(3,t)}catch(m){nn(t,t.return,m)}try{Yh(5,t,t.return)}catch(m){nn(t,t.return,m)}}break;case 1:Qs(e,t),$a(t),r&512&&n!==null&&pu(n,n.return);break;case 5:if(Qs(e,t),$a(t),r&512&&n!==null&&pu(n,n.return),t.flags&32){var s=t.stateNode;try{rd(s,"")}catch(m){nn(t,t.return,m)}}if(r&4&&(s=t.stateNode,s!=null)){var a=t.memoizedProps,i=n!==null?n.memoizedProps:a,o=t.type,l=t.updateQueue;if(t.updateQueue=null,l!==null)try{o==="input"&&a.type==="radio"&&a.name!=null&&MT(s,a),Zx(o,i);var u=Zx(o,a);for(i=0;i<l.length;i+=2){var c=l[i],h=l[i+1];c==="style"?WT(s,h):c==="dangerouslySetInnerHTML"?zT(s,h):c==="children"?rd(s,h):Uv(s,c,h,u)}switch(o){case"input":Kx(s,a);break;case"textarea":PT(s,a);break;case"select":var d=s._wrapperState.wasMultiple;s._wrapperState.wasMultiple=!!a.multiple;var p=a.value;p!=null?gu(s,!!a.multiple,p,!1):d!==!!a.multiple&&(a.defaultValue!=null?gu(s,!!a.multiple,a.defaultValue,!0):gu(s,!!a.multiple,a.multiple?[]:"",!1))}s[dd]=a}catch(m){nn(t,t.return,m)}}break;case 6:if(Qs(e,t),$a(t),r&4){if(t.stateNode===null)throw Error(pe(162));s=t.stateNode,a=t.memoizedProps;try{s.nodeValue=a}catch(m){nn(t,t.return,m)}}break;case 3:if(Qs(e,t),$a(t),r&4&&n!==null&&n.memoizedState.isDehydrated)try{od(e.containerInfo)}catch(m){nn(t,t.return,m)}break;case 4:Qs(e,t),$a(t);break;case 13:Qs(e,t),$a(t),s=t.child,s.flags&8192&&(a=s.memoizedState!==null,s.stateNode.isHidden=a,!a||s.alternate!==null&&s.alternate.memoizedState!==null||(ww=cn())),r&4&&RI(t);break;case 22:if(c=n!==null&&n.memoizedState!==null,t.mode&1?(lr=(u=lr)||c,Qs(e,t),lr=u):Qs(e,t),$a(t),r&8192){if(u=t.memoizedState!==null,(t.stateNode.isHidden=u)&&!c&&t.mode&1)for($e=t,c=t.child;c!==null;){for(h=$e=c;$e!==null;){switch(d=$e,p=d.child,d.tag){case 0:case 11:case 14:case 15:Yh(4,d,d.return);break;case 1:pu(d,d.return);var f=d.stateNode;if(typeof f.componentWillUnmount=="function"){r=d,n=d.return;try{e=r,f.props=e.memoizedProps,f.state=e.memoizedState,f.componentWillUnmount()}catch(m){nn(r,n,m)}}break;case 5:pu(d,d.return);break;case 22:if(d.memoizedState!==null){_I(h);continue}}p!==null?(p.return=d,$e=p):_I(h)}c=c.sibling}e:for(c=null,h=t;;){if(h.tag===5){if(c===null){c=h;try{s=h.stateNode,u?(a=s.style,typeof a.setProperty=="function"?a.setProperty("display","none","important"):a.display="none"):(o=h.stateNode,l=h.memoizedProps.style,i=l!=null&&l.hasOwnProperty("display")?l.display:null,o.style.display=BT("display",i))}catch(m){nn(t,t.return,m)}}}else if(h.tag===6){if(c===null)try{h.stateNode.nodeValue=u?"":h.memoizedProps}catch(m){nn(t,t.return,m)}}else if((h.tag!==22&&h.tag!==23||h.memoizedState===null||h===t)&&h.child!==null){h.child.return=h,h=h.child;continue}if(h===t)break e;for(;h.sibling===null;){if(h.return===null||h.return===t)break e;c===h&&(c=null),h=h.return}c===h&&(c=null),h.sibling.return=h.return,h=h.sibling}}break;case 19:Qs(e,t),$a(t),r&4&&RI(t);break;case 21:break;default:Qs(e,t),$a(t)}}function $a(t){var e=t.flags;if(e&2){try{e:{for(var n=t.return;n!==null;){if(p$(n)){var r=n;break e}n=n.return}throw Error(pe(160))}switch(r.tag){case 5:var s=r.stateNode;r.flags&32&&(rd(s,""),r.flags&=-33);var a=$I(t);T1(t,a,s);break;case 3:case 4:var i=r.stateNode.containerInfo,o=$I(t);C1(t,o,i);break;default:throw Error(pe(161))}}catch(l){nn(t,t.return,l)}t.flags&=-3}e&4096&&(t.flags&=-4097)}function P4(t,e,n){$e=t,g$(t)}function g$(t,e,n){for(var r=(t.mode&1)!==0;$e!==null;){var s=$e,a=s.child;if(s.tag===22&&r){var i=s.memoizedState!==null||Qf;if(!i){var o=s.alternate,l=o!==null&&o.memoizedState!==null||lr;o=Qf;var u=lr;if(Qf=i,(lr=l)&&!u)for($e=s;$e!==null;)i=$e,l=i.child,i.tag===22&&i.memoizedState!==null?FI(s):l!==null?(l.return=i,$e=l):FI(s);for(;a!==null;)$e=a,g$(a),a=a.sibling;$e=s,Qf=o,lr=u}AI(t)}else s.subtreeFlags&8772&&a!==null?(a.return=s,$e=a):AI(t)}}function AI(t){for(;$e!==null;){var e=$e;if(e.flags&8772){var n=e.alternate;try{if(e.flags&8772)switch(e.tag){case 0:case 11:case 15:lr||qg(5,e);break;case 1:var r=e.stateNode;if(e.flags&4&&!lr)if(n===null)r.componentDidMount();else{var s=e.elementType===e.type?n.memoizedProps:ea(e.type,n.memoizedProps);r.componentDidUpdate(s,n.memoizedState,r.__reactInternalSnapshotBeforeUpdate)}var a=e.updateQueue;a!==null&&mI(e,a,r);break;case 3:var i=e.updateQueue;if(i!==null){if(n=null,e.child!==null)switch(e.child.tag){case 5:n=e.child.stateNode;break;case 1:n=e.child.stateNode}mI(e,i,n)}break;case 5:var o=e.stateNode;if(n===null&&e.flags&4){n=o;var l=e.memoizedProps;switch(e.type){case"button":case"input":case"select":case"textarea":l.autoFocus&&n.focus();break;case"img":l.src&&(n.src=l.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(e.memoizedState===null){var u=e.alternate;if(u!==null){var c=u.memoizedState;if(c!==null){var h=c.dehydrated;h!==null&&od(h)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(pe(163))}lr||e.flags&512&&N1(e)}catch(d){nn(e,e.return,d)}}if(e===t){$e=null;break}if(n=e.sibling,n!==null){n.return=e.return,$e=n;break}$e=e.return}}function _I(t){for(;$e!==null;){var e=$e;if(e===t){$e=null;break}var n=e.sibling;if(n!==null){n.return=e.return,$e=n;break}$e=e.return}}function FI(t){for(;$e!==null;){var e=$e;try{switch(e.tag){case 0:case 11:case 15:var n=e.return;try{qg(4,e)}catch(l){nn(e,n,l)}break;case 1:var r=e.stateNode;if(typeof r.componentDidMount=="function"){var s=e.return;try{r.componentDidMount()}catch(l){nn(e,s,l)}}var a=e.return;try{N1(e)}catch(l){nn(e,a,l)}break;case 5:var i=e.return;try{N1(e)}catch(l){nn(e,i,l)}}}catch(l){nn(e,e.return,l)}if(e===t){$e=null;break}var o=e.sibling;if(o!==null){o.return=e.return,$e=o;break}$e=e.return}}var L4=Math.ceil,Qm=bi.ReactCurrentDispatcher,xw=bi.ReactCurrentOwner,Ps=bi.ReactCurrentBatchConfig,bt=0,Wn=null,bn=null,Zn=0,as=0,fu=po(0),Rn=0,bd=null,sl=0,Xg=0,vw=0,Qh=null,Vr=null,ww=0,Fu=1/0,Ya=null,Zm=!1,E1=null,ji=null,Zf=!1,Fi=null,Jm=0,Zh=0,$1=null,vm=-1,wm=0;function kr(){return bt&6?cn():vm!==-1?vm:vm=cn()}function Gi(t){return t.mode&1?bt&2&&Zn!==0?Zn&-Zn:w4.transition!==null?(wm===0&&(wm=JT()),wm):(t=Nt,t!==0||(t=window.event,t=t===void 0?16:iE(t.type)),t):1}function oa(t,e,n,r){if(50<Zh)throw Zh=0,$1=null,Error(pe(185));Kd(t,n,r),(!(bt&2)||t!==Wn)&&(t===Wn&&(!(bt&2)&&(Xg|=n),Rn===4&&Ai(t,Zn)),Yr(t,r),n===1&&bt===0&&!(e.mode&1)&&(Fu=cn()+500,Gg&&fo()))}function Yr(t,e){var n=t.callbackNode;wz(t,e);var r=Mm(t,t===Wn?Zn:0);if(r===0)n!==null&&US(n),t.callbackNode=null,t.callbackPriority=0;else if(e=r&-r,t.callbackPriority!==e){if(n!=null&&US(n),e===1)t.tag===0?v4(OI.bind(null,t)):NE(OI.bind(null,t)),g4(function(){!(bt&6)&&fo()}),n=null;else{switch(eE(r)){case 1:n=Kv;break;case 4:n=QT;break;case 16:n=Dm;break;case 536870912:n=ZT;break;default:n=Dm}n=I$(n,y$.bind(null,t))}t.callbackPriority=e,t.callbackNode=n}}function y$(t,e){if(vm=-1,wm=0,bt&6)throw Error(pe(327));var n=t.callbackNode;if(wu()&&t.callbackNode!==n)return null;var r=Mm(t,t===Wn?Zn:0);if(r===0)return null;if(r&30||r&t.expiredLanes||e)e=eg(t,r);else{e=r;var s=bt;bt|=2;var a=x$();(Wn!==t||Zn!==e)&&(Ya=null,Fu=cn()+500,qo(t,e));do try{W4();break}catch(o){b$(t,o)}while(!0);iw(),Qm.current=a,bt=s,bn!==null?e=0:(Wn=null,Zn=0,e=Rn)}if(e!==0){if(e===2&&(s=r1(t),s!==0&&(r=s,e=R1(t,s))),e===1)throw n=bd,qo(t,0),Ai(t,r),Yr(t,cn()),n;if(e===6)Ai(t,r);else{if(s=t.current.alternate,!(r&30)&&!z4(s)&&(e=eg(t,r),e===2&&(a=r1(t),a!==0&&(r=a,e=R1(t,a))),e===1))throw n=bd,qo(t,0),Ai(t,r),Yr(t,cn()),n;switch(t.finishedWork=s,t.finishedLanes=r,e){case 0:case 1:throw Error(pe(345));case 2:Fo(t,Vr,Ya);break;case 3:if(Ai(t,r),(r&130023424)===r&&(e=ww+500-cn(),10<e)){if(Mm(t,0)!==0)break;if(s=t.suspendedLanes,(s&r)!==r){kr(),t.pingedLanes|=t.suspendedLanes&s;break}t.timeoutHandle=h1(Fo.bind(null,t,Vr,Ya),e);break}Fo(t,Vr,Ya);break;case 4:if(Ai(t,r),(r&4194240)===r)break;for(e=t.eventTimes,s=-1;0<r;){var i=31-ia(r);a=1<<i,i=e[i],i>s&&(s=i),r&=~a}if(r=s,r=cn()-r,r=(120>r?120:480>r?480:1080>r?1080:1920>r?1920:3e3>r?3e3:4320>r?4320:1960*L4(r/1960))-r,10<r){t.timeoutHandle=h1(Fo.bind(null,t,Vr,Ya),r);break}Fo(t,Vr,Ya);break;case 5:Fo(t,Vr,Ya);break;default:throw Error(pe(329))}}}return Yr(t,cn()),t.callbackNode===n?y$.bind(null,t):null}function R1(t,e){var n=Qh;return t.current.memoizedState.isDehydrated&&(qo(t,e).flags|=256),t=eg(t,e),t!==2&&(e=Vr,Vr=n,e!==null&&A1(e)),t}function A1(t){Vr===null?Vr=t:Vr.push.apply(Vr,t)}function z4(t){for(var e=t;;){if(e.flags&16384){var n=e.updateQueue;if(n!==null&&(n=n.stores,n!==null))for(var r=0;r<n.length;r++){var s=n[r],a=s.getSnapshot;s=s.value;try{if(!ha(a(),s))return!1}catch{return!1}}}if(n=e.child,e.subtreeFlags&16384&&n!==null)n.return=e,e=n;else{if(e===t)break;for(;e.sibling===null;){if(e.return===null||e.return===t)return!0;e=e.return}e.sibling.return=e.return,e=e.sibling}}return!0}function Ai(t,e){for(e&=~vw,e&=~Xg,t.suspendedLanes|=e,t.pingedLanes&=~e,t=t.expirationTimes;0<e;){var n=31-ia(e),r=1<<n;t[n]=-1,e&=~r}}function OI(t){if(bt&6)throw Error(pe(327));wu();var e=Mm(t,0);if(!(e&1))return Yr(t,cn()),null;var n=eg(t,e);if(t.tag!==0&&n===2){var r=r1(t);r!==0&&(e=r,n=R1(t,r))}if(n===1)throw n=bd,qo(t,0),Ai(t,e),Yr(t,cn()),n;if(n===6)throw Error(pe(345));return t.finishedWork=t.current.alternate,t.finishedLanes=e,Fo(t,Vr,Ya),Yr(t,cn()),null}function kw(t,e){var n=bt;bt|=1;try{return t(e)}finally{bt=n,bt===0&&(Fu=cn()+500,Gg&&fo())}}function al(t){Fi!==null&&Fi.tag===0&&!(bt&6)&&wu();var e=bt;bt|=1;var n=Ps.transition,r=Nt;try{if(Ps.transition=null,Nt=1,t)return t()}finally{Nt=r,Ps.transition=n,bt=e,!(bt&6)&&fo()}}function Sw(){as=fu.current,Wt(fu)}function qo(t,e){t.finishedWork=null,t.finishedLanes=0;var n=t.timeoutHandle;if(n!==-1&&(t.timeoutHandle=-1,m4(n)),bn!==null)for(n=bn.return;n!==null;){var r=n;switch(rw(r),r.tag){case 1:r=r.type.childContextTypes,r!=null&&Wm();break;case 3:Au(),Wt(qr),Wt(dr),dw();break;case 5:hw(r);break;case 4:Au();break;case 13:Wt(Yt);break;case 19:Wt(Yt);break;case 10:ow(r.type._context);break;case 22:case 23:Sw()}n=n.return}if(Wn=t,bn=t=Hi(t.current,null),Zn=as=e,Rn=0,bd=null,vw=Xg=sl=0,Vr=Qh=null,Uo!==null){for(e=0;e<Uo.length;e++)if(n=Uo[e],r=n.interleaved,r!==null){n.interleaved=null;var s=r.next,a=n.pending;if(a!==null){var i=a.next;a.next=s,r.next=i}n.pending=r}Uo=null}return t}function b$(t,e){do{var n=bn;try{if(iw(),ym.current=Ym,Xm){for(var r=Zt.memoizedState;r!==null;){var s=r.queue;s!==null&&(s.pending=null),r=r.next}Xm=!1}if(rl=0,Pn=En=Zt=null,Xh=!1,md=0,xw.current=null,n===null||n.return===null){Rn=1,bd=e,bn=null;break}e:{var a=t,i=n.return,o=n,l=e;if(e=Zn,o.flags|=32768,l!==null&&typeof l=="object"&&typeof l.then=="function"){var u=l,c=o,h=c.tag;if(!(c.mode&1)&&(h===0||h===11||h===15)){var d=c.alternate;d?(c.updateQueue=d.updateQueue,c.memoizedState=d.memoizedState,c.lanes=d.lanes):(c.updateQueue=null,c.memoizedState=null)}var p=wI(i);if(p!==null){p.flags&=-257,kI(p,i,o,a,e),p.mode&1&&vI(a,u,e),e=p,l=u;var f=e.updateQueue;if(f===null){var m=new Set;m.add(l),e.updateQueue=m}else f.add(l);break e}else{if(!(e&1)){vI(a,u,e),Iw();break e}l=Error(pe(426))}}else if(Gt&&o.mode&1){var y=wI(i);if(y!==null){!(y.flags&65536)&&(y.flags|=256),kI(y,i,o,a,e),sw(_u(l,o));break e}}a=l=_u(l,o),Rn!==4&&(Rn=2),Qh===null?Qh=[a]:Qh.push(a),a=i;do{switch(a.tag){case 3:a.flags|=65536,e&=-e,a.lanes|=e;var g=e$(a,l,e);fI(a,g);break e;case 1:o=l;var b=a.type,v=a.stateNode;if(!(a.flags&128)&&(typeof b.getDerivedStateFromError=="function"||v!==null&&typeof v.componentDidCatch=="function"&&(ji===null||!ji.has(v)))){a.flags|=65536,e&=-e,a.lanes|=e;var w=t$(a,o,e);fI(a,w);break e}}a=a.return}while(a!==null)}w$(n)}catch(k){e=k,bn===n&&n!==null&&(bn=n=n.return);continue}break}while(!0)}function x$(){var t=Qm.current;return Qm.current=Ym,t===null?Ym:t}function Iw(){(Rn===0||Rn===3||Rn===2)&&(Rn=4),Wn===null||!(sl&268435455)&&!(Xg&268435455)||Ai(Wn,Zn)}function eg(t,e){var n=bt;bt|=2;var r=x$();(Wn!==t||Zn!==e)&&(Ya=null,qo(t,e));do try{B4();break}catch(s){b$(t,s)}while(!0);if(iw(),bt=n,Qm.current=r,bn!==null)throw Error(pe(261));return Wn=null,Zn=0,Rn}function B4(){for(;bn!==null;)v$(bn)}function W4(){for(;bn!==null&&!dz();)v$(bn)}function v$(t){var e=S$(t.alternate,t,as);t.memoizedProps=t.pendingProps,e===null?w$(t):bn=e,xw.current=null}function w$(t){var e=t;do{var n=e.alternate;if(t=e.return,e.flags&32768){if(n=O4(n,e),n!==null){n.flags&=32767,bn=n;return}if(t!==null)t.flags|=32768,t.subtreeFlags=0,t.deletions=null;else{Rn=6,bn=null;return}}else if(n=F4(n,e,as),n!==null){bn=n;return}if(e=e.sibling,e!==null){bn=e;return}bn=e=t}while(e!==null);Rn===0&&(Rn=5)}function Fo(t,e,n){var r=Nt,s=Ps.transition;try{Ps.transition=null,Nt=1,U4(t,e,n,r)}finally{Ps.transition=s,Nt=r}return null}function U4(t,e,n,r){do wu();while(Fi!==null);if(bt&6)throw Error(pe(327));n=t.finishedWork;var s=t.finishedLanes;if(n===null)return null;if(t.finishedWork=null,t.finishedLanes=0,n===t.current)throw Error(pe(177));t.callbackNode=null,t.callbackPriority=0;var a=n.lanes|n.childLanes;if(kz(t,a),t===Wn&&(bn=Wn=null,Zn=0),!(n.subtreeFlags&2064)&&!(n.flags&2064)||Zf||(Zf=!0,I$(Dm,function(){return wu(),null})),a=(n.flags&15990)!==0,n.subtreeFlags&15990||a){a=Ps.transition,Ps.transition=null;var i=Nt;Nt=1;var o=bt;bt|=4,xw.current=null,M4(t,n),m$(n,t),l4(u1),Pm=!!l1,u1=l1=null,t.current=n,P4(n),pz(),bt=o,Nt=i,Ps.transition=a}else t.current=n;if(Zf&&(Zf=!1,Fi=t,Jm=s),a=t.pendingLanes,a===0&&(ji=null),gz(n.stateNode),Yr(t,cn()),e!==null)for(r=t.onRecoverableError,n=0;n<e.length;n++)s=e[n],r(s.value,{componentStack:s.stack,digest:s.digest});if(Zm)throw Zm=!1,t=E1,E1=null,t;return Jm&1&&t.tag!==0&&wu(),a=t.pendingLanes,a&1?t===$1?Zh++:(Zh=0,$1=t):Zh=0,fo(),null}function wu(){if(Fi!==null){var t=eE(Jm),e=Ps.transition,n=Nt;try{if(Ps.transition=null,Nt=16>t?16:t,Fi===null)var r=!1;else{if(t=Fi,Fi=null,Jm=0,bt&6)throw Error(pe(331));var s=bt;for(bt|=4,$e=t.current;$e!==null;){var a=$e,i=a.child;if($e.flags&16){var o=a.deletions;if(o!==null){for(var l=0;l<o.length;l++){var u=o[l];for($e=u;$e!==null;){var c=$e;switch(c.tag){case 0:case 11:case 15:Yh(8,c,a)}var h=c.child;if(h!==null)h.return=c,$e=h;else for(;$e!==null;){c=$e;var d=c.sibling,p=c.return;if(d$(c),c===u){$e=null;break}if(d!==null){d.return=p,$e=d;break}$e=p}}}var f=a.alternate;if(f!==null){var m=f.child;if(m!==null){f.child=null;do{var y=m.sibling;m.sibling=null,m=y}while(m!==null)}}$e=a}}if(a.subtreeFlags&2064&&i!==null)i.return=a,$e=i;else e:for(;$e!==null;){if(a=$e,a.flags&2048)switch(a.tag){case 0:case 11:case 15:Yh(9,a,a.return)}var g=a.sibling;if(g!==null){g.return=a.return,$e=g;break e}$e=a.return}}var b=t.current;for($e=b;$e!==null;){i=$e;var v=i.child;if(i.subtreeFlags&2064&&v!==null)v.return=i,$e=v;else e:for(i=b;$e!==null;){if(o=$e,o.flags&2048)try{switch(o.tag){case 0:case 11:case 15:qg(9,o)}}catch(k){nn(o,o.return,k)}if(o===i){$e=null;break e}var w=o.sibling;if(w!==null){w.return=o.return,$e=w;break e}$e=o.return}}if(bt=s,fo(),Pa&&typeof Pa.onPostCommitFiberRoot=="function")try{Pa.onPostCommitFiberRoot(Bg,t)}catch{}r=!0}return r}finally{Nt=n,Ps.transition=e}}return!1}function DI(t,e,n){e=_u(n,e),e=e$(t,e,1),t=Vi(t,e,1),e=kr(),t!==null&&(Kd(t,1,e),Yr(t,e))}function nn(t,e,n){if(t.tag===3)DI(t,t,n);else for(;e!==null;){if(e.tag===3){DI(e,t,n);break}else if(e.tag===1){var r=e.stateNode;if(typeof e.type.getDerivedStateFromError=="function"||typeof r.componentDidCatch=="function"&&(ji===null||!ji.has(r))){t=_u(n,t),t=t$(e,t,1),e=Vi(e,t,1),t=kr(),e!==null&&(Kd(e,1,t),Yr(e,t));break}}e=e.return}}function V4(t,e,n){var r=t.pingCache;r!==null&&r.delete(e),e=kr(),t.pingedLanes|=t.suspendedLanes&n,Wn===t&&(Zn&n)===n&&(Rn===4||Rn===3&&(Zn&130023424)===Zn&&500>cn()-ww?qo(t,0):vw|=n),Yr(t,e)}function k$(t,e){e===0&&(t.mode&1?(e=Uf,Uf<<=1,!(Uf&130023424)&&(Uf=4194304)):e=1);var n=kr();t=ci(t,e),t!==null&&(Kd(t,e,n),Yr(t,n))}function j4(t){var e=t.memoizedState,n=0;e!==null&&(n=e.retryLane),k$(t,n)}function G4(t,e){var n=0;switch(t.tag){case 13:var r=t.stateNode,s=t.memoizedState;s!==null&&(n=s.retryLane);break;case 19:r=t.stateNode;break;default:throw Error(pe(314))}r!==null&&r.delete(e),k$(t,n)}var S$;S$=function(t,e,n){if(t!==null)if(t.memoizedProps!==e.pendingProps||qr.current)Gr=!0;else{if(!(t.lanes&n)&&!(e.flags&128))return Gr=!1,_4(t,e,n);Gr=!!(t.flags&131072)}else Gr=!1,Gt&&e.flags&1048576&&CE(e,jm,e.index);switch(e.lanes=0,e.tag){case 2:var r=e.type;xm(t,e),t=e.pendingProps;var s=Eu(e,dr.current);vu(e,n),s=fw(null,e,r,t,s,n);var a=mw();return e.flags|=1,typeof s=="object"&&s!==null&&typeof s.render=="function"&&s.$$typeof===void 0?(e.tag=1,e.memoizedState=null,e.updateQueue=null,Xr(r)?(a=!0,Um(e)):a=!1,e.memoizedState=s.state!==null&&s.state!==void 0?s.state:null,uw(e),s.updater=Kg,e.stateNode=s,s._reactInternals=e,b1(e,r,t,n),e=w1(null,e,r,!0,a,n)):(e.tag=0,Gt&&a&&nw(e),xr(null,e,s,n),e=e.child),e;case 16:r=e.elementType;e:{switch(xm(t,e),t=e.pendingProps,s=r._init,r=s(r._payload),e.type=r,s=e.tag=K4(r),t=ea(r,t),s){case 0:e=v1(null,e,r,t,n);break e;case 1:e=NI(null,e,r,t,n);break e;case 11:e=SI(null,e,r,t,n);break e;case 14:e=II(null,e,r,ea(r.type,t),n);break e}throw Error(pe(306,r,""))}return e;case 0:return r=e.type,s=e.pendingProps,s=e.elementType===r?s:ea(r,s),v1(t,e,r,s,n);case 1:return r=e.type,s=e.pendingProps,s=e.elementType===r?s:ea(r,s),NI(t,e,r,s,n);case 3:e:{if(a$(e),t===null)throw Error(pe(387));r=e.pendingProps,a=e.memoizedState,s=a.element,_E(t,e),Km(e,r,null,n);var i=e.memoizedState;if(r=i.element,a.isDehydrated)if(a={element:r,isDehydrated:!1,cache:i.cache,pendingSuspenseBoundaries:i.pendingSuspenseBoundaries,transitions:i.transitions},e.updateQueue.baseState=a,e.memoizedState=a,e.flags&256){s=_u(Error(pe(423)),e),e=CI(t,e,r,n,s);break e}else if(r!==s){s=_u(Error(pe(424)),e),e=CI(t,e,r,n,s);break e}else for(ls=Ui(e.stateNode.containerInfo.firstChild),hs=e,Gt=!0,na=null,n=RE(e,null,r,n),e.child=n;n;)n.flags=n.flags&-3|4096,n=n.sibling;else{if($u(),r===s){e=hi(t,e,n);break e}xr(t,e,r,n)}e=e.child}return e;case 5:return FE(e),t===null&&m1(e),r=e.type,s=e.pendingProps,a=t!==null?t.memoizedProps:null,i=s.children,c1(r,s)?i=null:a!==null&&c1(r,a)&&(e.flags|=32),s$(t,e),xr(t,e,i,n),e.child;case 6:return t===null&&m1(e),null;case 13:return i$(t,e,n);case 4:return cw(e,e.stateNode.containerInfo),r=e.pendingProps,t===null?e.child=Ru(e,null,r,n):xr(t,e,r,n),e.child;case 11:return r=e.type,s=e.pendingProps,s=e.elementType===r?s:ea(r,s),SI(t,e,r,s,n);case 7:return xr(t,e,e.pendingProps,n),e.child;case 8:return xr(t,e,e.pendingProps.children,n),e.child;case 12:return xr(t,e,e.pendingProps.children,n),e.child;case 10:e:{if(r=e.type._context,s=e.pendingProps,a=e.memoizedProps,i=s.value,Dt(Gm,r._currentValue),r._currentValue=i,a!==null)if(ha(a.value,i)){if(a.children===s.children&&!qr.current){e=hi(t,e,n);break e}}else for(a=e.child,a!==null&&(a.return=e);a!==null;){var o=a.dependencies;if(o!==null){i=a.child;for(var l=o.firstContext;l!==null;){if(l.context===r){if(a.tag===1){l=ai(-1,n&-n),l.tag=2;var u=a.updateQueue;if(u!==null){u=u.shared;var c=u.pending;c===null?l.next=l:(l.next=c.next,c.next=l),u.pending=l}}a.lanes|=n,l=a.alternate,l!==null&&(l.lanes|=n),g1(a.return,n,e),o.lanes|=n;break}l=l.next}}else if(a.tag===10)i=a.type===e.type?null:a.child;else if(a.tag===18){if(i=a.return,i===null)throw Error(pe(341));i.lanes|=n,o=i.alternate,o!==null&&(o.lanes|=n),g1(i,n,e),i=a.sibling}else i=a.child;if(i!==null)i.return=a;else for(i=a;i!==null;){if(i===e){i=null;break}if(a=i.sibling,a!==null){a.return=i.return,i=a;break}i=i.return}a=i}xr(t,e,s.children,n),e=e.child}return e;case 9:return s=e.type,r=e.pendingProps.children,vu(e,n),s=Ws(s),r=r(s),e.flags|=1,xr(t,e,r,n),e.child;case 14:return r=e.type,s=ea(r,e.pendingProps),s=ea(r.type,s),II(t,e,r,s,n);case 15:return n$(t,e,e.type,e.pendingProps,n);case 17:return r=e.type,s=e.pendingProps,s=e.elementType===r?s:ea(r,s),xm(t,e),e.tag=1,Xr(r)?(t=!0,Um(e)):t=!1,vu(e,n),JE(e,r,s),b1(e,r,s,n),w1(null,e,r,!0,t,n);case 19:return o$(t,e,n);case 22:return r$(t,e,n)}throw Error(pe(156,e.tag))};function I$(t,e){return YT(t,e)}function H4(t,e,n,r){this.tag=t,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=e,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function As(t,e,n,r){return new H4(t,e,n,r)}function Nw(t){return t=t.prototype,!(!t||!t.isReactComponent)}function K4(t){if(typeof t=="function")return Nw(t)?1:0;if(t!=null){if(t=t.$$typeof,t===jv)return 11;if(t===Gv)return 14}return 2}function Hi(t,e){var n=t.alternate;return n===null?(n=As(t.tag,e,t.key,t.mode),n.elementType=t.elementType,n.type=t.type,n.stateNode=t.stateNode,n.alternate=t,t.alternate=n):(n.pendingProps=e,n.type=t.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=t.flags&14680064,n.childLanes=t.childLanes,n.lanes=t.lanes,n.child=t.child,n.memoizedProps=t.memoizedProps,n.memoizedState=t.memoizedState,n.updateQueue=t.updateQueue,e=t.dependencies,n.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext},n.sibling=t.sibling,n.index=t.index,n.ref=t.ref,n}function km(t,e,n,r,s,a){var i=2;if(r=t,typeof t=="function")Nw(t)&&(i=1);else if(typeof t=="string")i=5;else e:switch(t){case su:return Xo(n.children,s,a,e);case Vv:i=8,s|=8;break;case Ux:return t=As(12,n,e,s|2),t.elementType=Ux,t.lanes=a,t;case Vx:return t=As(13,n,e,s),t.elementType=Vx,t.lanes=a,t;case jx:return t=As(19,n,e,s),t.elementType=jx,t.lanes=a,t;case FT:return Yg(n,s,a,e);default:if(typeof t=="object"&&t!==null)switch(t.$$typeof){case AT:i=10;break e;case _T:i=9;break e;case jv:i=11;break e;case Gv:i=14;break e;case Ti:i=16,r=null;break e}throw Error(pe(130,t==null?t:typeof t,""))}return e=As(i,n,e,s),e.elementType=t,e.type=r,e.lanes=a,e}function Xo(t,e,n,r){return t=As(7,t,r,e),t.lanes=n,t}function Yg(t,e,n,r){return t=As(22,t,r,e),t.elementType=FT,t.lanes=n,t.stateNode={isHidden:!1},t}function dx(t,e,n){return t=As(6,t,null,e),t.lanes=n,t}function px(t,e,n){return e=As(4,t.children!==null?t.children:[],t.key,e),e.lanes=n,e.stateNode={containerInfo:t.containerInfo,pendingChildren:null,implementation:t.implementation},e}function q4(t,e,n,r,s){this.tag=e,this.containerInfo=t,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=K0(0),this.expirationTimes=K0(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=K0(0),this.identifierPrefix=r,this.onRecoverableError=s,this.mutableSourceEagerHydrationData=null}function Cw(t,e,n,r,s,a,i,o,l){return t=new q4(t,e,n,o,l),e===1?(e=1,a===!0&&(e|=8)):e=0,a=As(3,null,null,e),t.current=a,a.stateNode=t,a.memoizedState={element:r,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},uw(a),t}function X4(t,e,n){var r=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:ru,key:r==null?null:""+r,children:t,containerInfo:e,implementation:n}}function N$(t){if(!t)return Zi;t=t._reactInternals;e:{if(Sl(t)!==t||t.tag!==1)throw Error(pe(170));var e=t;do{switch(e.tag){case 3:e=e.stateNode.context;break e;case 1:if(Xr(e.type)){e=e.stateNode.__reactInternalMemoizedMergedChildContext;break e}}e=e.return}while(e!==null);throw Error(pe(171))}if(t.tag===1){var n=t.type;if(Xr(n))return IE(t,n,e)}return e}function C$(t,e,n,r,s,a,i,o,l){return t=Cw(n,r,!0,t,s,a,i,o,l),t.context=N$(null),n=t.current,r=kr(),s=Gi(n),a=ai(r,s),a.callback=e??null,Vi(n,a,s),t.current.lanes=s,Kd(t,s,r),Yr(t,r),t}function Qg(t,e,n,r){var s=e.current,a=kr(),i=Gi(s);return n=N$(n),e.context===null?e.context=n:e.pendingContext=n,e=ai(a,i),e.payload={element:t},r=r===void 0?null:r,r!==null&&(e.callback=r),t=Vi(s,e,i),t!==null&&(oa(t,s,i,a),gm(t,s,i)),i}function tg(t){if(t=t.current,!t.child)return null;switch(t.child.tag){case 5:return t.child.stateNode;default:return t.child.stateNode}}function MI(t,e){if(t=t.memoizedState,t!==null&&t.dehydrated!==null){var n=t.retryLane;t.retryLane=n!==0&&n<e?n:e}}function Tw(t,e){MI(t,e),(t=t.alternate)&&MI(t,e)}function Y4(){return null}var T$=typeof reportError=="function"?reportError:function(t){console.error(t)};function Ew(t){this._internalRoot=t}Zg.prototype.render=Ew.prototype.render=function(t){var e=this._internalRoot;if(e===null)throw Error(pe(409));Qg(t,e,null,null)};Zg.prototype.unmount=Ew.prototype.unmount=function(){var t=this._internalRoot;if(t!==null){this._internalRoot=null;var e=t.containerInfo;al(function(){Qg(null,t,null,null)}),e[ui]=null}};function Zg(t){this._internalRoot=t}Zg.prototype.unstable_scheduleHydration=function(t){if(t){var e=rE();t={blockedOn:null,target:t,priority:e};for(var n=0;n<Ri.length&&e!==0&&e<Ri[n].priority;n++);Ri.splice(n,0,t),n===0&&aE(t)}};function $w(t){return!(!t||t.nodeType!==1&&t.nodeType!==9&&t.nodeType!==11)}function Jg(t){return!(!t||t.nodeType!==1&&t.nodeType!==9&&t.nodeType!==11&&(t.nodeType!==8||t.nodeValue!==" react-mount-point-unstable "))}function PI(){}function Q4(t,e,n,r,s){if(s){if(typeof r=="function"){var a=r;r=function(){var u=tg(i);a.call(u)}}var i=C$(e,r,t,0,null,!1,!1,"",PI);return t._reactRootContainer=i,t[ui]=i.current,cd(t.nodeType===8?t.parentNode:t),al(),i}for(;s=t.lastChild;)t.removeChild(s);if(typeof r=="function"){var o=r;r=function(){var u=tg(l);o.call(u)}}var l=Cw(t,0,!1,null,null,!1,!1,"",PI);return t._reactRootContainer=l,t[ui]=l.current,cd(t.nodeType===8?t.parentNode:t),al(function(){Qg(e,l,n,r)}),l}function ey(t,e,n,r,s){var a=n._reactRootContainer;if(a){var i=a;if(typeof s=="function"){var o=s;s=function(){var l=tg(i);o.call(l)}}Qg(e,i,t,s)}else i=Q4(n,e,t,s,r);return tg(i)}tE=function(t){switch(t.tag){case 3:var e=t.stateNode;if(e.current.memoizedState.isDehydrated){var n=_h(e.pendingLanes);n!==0&&(qv(e,n|1),Yr(e,cn()),!(bt&6)&&(Fu=cn()+500,fo()))}break;case 13:al(function(){var r=ci(t,1);if(r!==null){var s=kr();oa(r,t,1,s)}}),Tw(t,1)}};Xv=function(t){if(t.tag===13){var e=ci(t,134217728);if(e!==null){var n=kr();oa(e,t,134217728,n)}Tw(t,134217728)}};nE=function(t){if(t.tag===13){var e=Gi(t),n=ci(t,e);if(n!==null){var r=kr();oa(n,t,e,r)}Tw(t,e)}};rE=function(){return Nt};sE=function(t,e){var n=Nt;try{return Nt=t,e()}finally{Nt=n}};e1=function(t,e,n){switch(e){case"input":if(Kx(t,n),e=n.name,n.type==="radio"&&e!=null){for(n=t;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+e)+'][type="radio"]'),e=0;e<n.length;e++){var r=n[e];if(r!==t&&r.form===t.form){var s=jg(r);if(!s)throw Error(pe(90));DT(r),Kx(r,s)}}}break;case"textarea":PT(t,n);break;case"select":e=n.value,e!=null&&gu(t,!!n.multiple,e,!1)}};jT=kw;GT=al;var Z4={usingClientEntryPoint:!1,Events:[Xd,lu,jg,UT,VT,kw]},Ih={findFiberByHostInstance:Wo,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},J4={bundleType:Ih.bundleType,version:Ih.version,rendererPackageName:Ih.rendererPackageName,rendererConfig:Ih.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:bi.ReactCurrentDispatcher,findHostInstanceByFiber:function(t){return t=qT(t),t===null?null:t.stateNode},findFiberByHostInstance:Ih.findFiberByHostInstance||Y4,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Jf=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Jf.isDisabled&&Jf.supportsFiber)try{Bg=Jf.inject(J4),Pa=Jf}catch{}}bs.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Z4;bs.createPortal=function(t,e){var n=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!$w(e))throw Error(pe(200));return X4(t,e,null,n)};bs.createRoot=function(t,e){if(!$w(t))throw Error(pe(299));var n=!1,r="",s=T$;return e!=null&&(e.unstable_strictMode===!0&&(n=!0),e.identifierPrefix!==void 0&&(r=e.identifierPrefix),e.onRecoverableError!==void 0&&(s=e.onRecoverableError)),e=Cw(t,1,!1,null,null,n,!1,r,s),t[ui]=e.current,cd(t.nodeType===8?t.parentNode:t),new Ew(e)};bs.findDOMNode=function(t){if(t==null)return null;if(t.nodeType===1)return t;var e=t._reactInternals;if(e===void 0)throw typeof t.render=="function"?Error(pe(188)):(t=Object.keys(t).join(","),Error(pe(268,t)));return t=qT(e),t=t===null?null:t.stateNode,t};bs.flushSync=function(t){return al(t)};bs.hydrate=function(t,e,n){if(!Jg(e))throw Error(pe(200));return ey(null,t,e,!0,n)};bs.hydrateRoot=function(t,e,n){if(!$w(t))throw Error(pe(405));var r=n!=null&&n.hydratedSources||null,s=!1,a="",i=T$;if(n!=null&&(n.unstable_strictMode===!0&&(s=!0),n.identifierPrefix!==void 0&&(a=n.identifierPrefix),n.onRecoverableError!==void 0&&(i=n.onRecoverableError)),e=C$(e,null,t,1,n??null,s,!1,a,i),t[ui]=e.current,cd(t),r)for(t=0;t<r.length;t++)n=r[t],s=n._getVersion,s=s(n._source),e.mutableSourceEagerHydrationData==null?e.mutableSourceEagerHydrationData=[n,s]:e.mutableSourceEagerHydrationData.push(n,s);return new Zg(e)};bs.render=function(t,e,n){if(!Jg(e))throw Error(pe(200));return ey(null,t,e,!1,n)};bs.unmountComponentAtNode=function(t){if(!Jg(t))throw Error(pe(40));return t._reactRootContainer?(al(function(){ey(null,null,t,!1,function(){t._reactRootContainer=null,t[ui]=null})}),!0):!1};bs.unstable_batchedUpdates=kw;bs.unstable_renderSubtreeIntoContainer=function(t,e,n,r){if(!Jg(n))throw Error(pe(200));if(t==null||t._reactInternals===void 0)throw Error(pe(38));return ey(t,e,n,!1,r)};bs.version="18.3.1-next-f1338f8080-20240426";function E$(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(E$)}catch(t){console.error(t)}}E$(),TT.exports=bs;var eB=TT.exports,LI=eB;Bx.createRoot=LI.createRoot,Bx.hydrateRoot=LI.hydrateRoot;const tB=t=>t&&t.length>10&&t.startsWith("AIza"),nB=()=>{const t="AIzaSyDZUNHi24TAbgqGYZWFXmF_S34_Y62dok4",e=t;if(console.log("API Key Debug:",{envKey:"undefined",fallbackKey:`${t.substring(0,10)}...`,usingKey:"fallback"}),!tB(e))throw new Error("Invalid Gemini API key. Please check your environment configuration.");return e};class rB{constructor(){mt(this,"apiKey"),mt(this,"baseUrl","https://generativelanguage.googleapis.com/v1beta"),mt(this,"previousSuggestions",[]);try{this.apiKey=nB(),console.log("GeminiService: API key loaded:",this.apiKey?`${this.apiKey.substring(0,10)}...`:"undefined"),console.log("GeminiService: API key validation:",this.apiKey&&this.apiKey.length>10&&this.apiKey.startsWith("AIza")),console.log("GeminiService: Constructor completed successfully")}catch(e){throw console.error("GeminiService: Failed to load API key:",e),e}}async testApiConnection(){try{console.log("GeminiService: Testing API connection..."),console.log("GeminiService: API key being used:",this.apiKey?`${this.apiKey.substring(0,10)}...`:"undefined"),console.log("GeminiService: Base URL:",this.baseUrl);const e=`${this.baseUrl}/models?key=${this.apiKey}`;console.log("GeminiService: Test URL:",e.substring(0,100)+"...");const n=await fetch(e);if(console.log("GeminiService: Test API response status:",n.status),console.log("GeminiService: Test API response ok:",n.ok),!n.ok){const r=await n.text();console.error("GeminiService: API test error response:",r)}return n.ok}catch(e){return console.error("GeminiService: Test API connection failed:",e),!1}}async generateStretchSuggestions(e){var n,r,s,a,i;console.log("GeminiService: Starting to generate suggestions with data:",e),console.log("GeminiService: API key available:",!!this.apiKey),console.log("GeminiService: Base URL:",this.baseUrl),console.log("GeminiService: Previous suggestions count:",this.previousSuggestions.length),console.log("GeminiService: About to test API connection...");const o=await this.testApiConnection();if(console.log("GeminiService: API connection test result:",o),!o)throw console.error("GeminiService: API connection test failed, throwing error"),new Error("Gemini API connection test failed");console.log("GeminiService: API connection test passed, proceeding with generation...");const l=this.createPrompt(e);console.log("GeminiService: Created prompt, making API request..."),console.log("GeminiService: Prompt length:",l.length),console.log("GeminiService: Prompt preview:",l.substring(0,200)+"...");const u=["gemini-2.5-pro","gemini-1.5-flash-latest","gemini-1.5-flash","gemini-pro"];for(const c of u)try{console.log(`GeminiService: Trying model: ${c}`);const h=`${this.baseUrl}/models/${c}:generateContent?key=${this.apiKey}`;console.log(`GeminiService: Making request to: ${h.substring(0,100)}...`);const d=await fetch(h,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({contents:[{parts:[{text:l}]}],generationConfig:{temperature:.9,topK:40,topP:.95,maxOutputTokens:2048}})});if(console.log(`GeminiService: API response status for ${c}:`,d.status),!d.ok){const y=await d.text();if(console.error(`GeminiService: API error response for ${c}:`,y),c===u[u.length-1])throw new Error(`Gemini API error: ${d.status}`);continue}const p=await d.json();console.log(`GeminiService: API response data for ${c}:`,p);const f=(i=(a=(s=(r=(n=p.candidates)==null?void 0:n[0])==null?void 0:r.content)==null?void 0:s.parts)==null?void 0:a[0])==null?void 0:i.text;if(!f){if(console.error(`GeminiService: No content generated from API for ${c}`),c===u[u.length-1])throw new Error("No content generated from Gemini API");continue}console.log(`GeminiService: Generated text from ${c}:`,f);const m=this.parseStretchSuggestions(f);return console.log(`GeminiService: Parsed suggestions from ${c}:`,m),m}catch(h){if(console.error(`GeminiService: Error with model ${c}:`,h),c===u[u.length-1]){console.error("GeminiService: All models failed, returning fallback suggestions");const d=this.getFallbackSuggestions(e);return console.log("GeminiService: Returning fallback suggestions:",d),d}continue}return console.error("GeminiService: All models failed unexpectedly"),this.getFallbackSuggestions(e)}getSpecificPostureIssues(e,n,r,s,a,i){const o=[];e>15?o.push(`🔴 CRITICAL: Forward Head Posture (${e.toFixed(1)}°) - Head is significantly forward of shoulders, causing "tech neck"`):e>10?o.push(`🟡 MODERATE: Forward Head Posture (${e.toFixed(1)}°) - Head is slightly forward, needs correction`):e>5&&o.push(`🟢 MILD: Slight Forward Head (${e.toFixed(1)}°) - Minor forward positioning`),s>20?o.push(`🔴 CRITICAL: Severe Head Tilt (${s.toFixed(1)}°) - Head is significantly tilted to one side`):s>15?o.push(`🟡 MODERATE: Head Tilt (${s.toFixed(1)}°) - Head is tilted, may indicate neck muscle imbalance`):s>8&&o.push(`🟢 MILD: Slight Head Tilt (${s.toFixed(1)}°) - Minor head positioning issue`),n>12?o.push(`🔴 CRITICAL: Severe Shoulder Misalignment (${n.toFixed(1)}°) - One shoulder significantly higher than the other`):n>8?o.push(`🟡 MODERATE: Shoulder Misalignment (${n.toFixed(1)}°) - Shoulders are uneven, may indicate muscle imbalance`):n>4&&o.push(`🟢 MILD: Slight Shoulder Imbalance (${n.toFixed(1)}°) - Minor shoulder height difference`),a>15?o.push(`🔴 CRITICAL: Severe Shoulder Height Imbalance (${a.toFixed(1)}°) - Significant shoulder height difference`):a>12?o.push(`🟡 MODERATE: Shoulder Height Imbalance (${a.toFixed(1)}°) - Noticeable shoulder height difference`):a>8&&o.push(`🟢 MILD: Slight Shoulder Height Difference (${a.toFixed(1)}°) - Minor shoulder height variation`),r>20?o.push(`🔴 CRITICAL: Severe Spine Misalignment (${r.toFixed(1)}°) - Significant spinal deviation`):r>15?o.push(`🟡 MODERATE: Spine Misalignment (${r.toFixed(1)}°) - Noticeable spinal deviation`):r>10&&o.push(`🟢 MILD: Slight Spine Deviation (${r.toFixed(1)}°) - Minor spinal alignment issue`),i&&o.push("🔴 CRITICAL: Slouching Detected - Rounded shoulders and forward head position");const l=o.filter(h=>h.includes("🔴 CRITICAL")).length,u=o.filter(h=>h.includes("🟡 MODERATE")).length,c=o.filter(h=>h.includes("🟢 MILD")).length;return l>0?o.push(`
⚠️ OVERALL ASSESSMENT: ${l} critical issue(s) detected - Immediate attention required`):u>0?o.push(`
⚠️ OVERALL ASSESSMENT: ${u} moderate issue(s) detected - Regular correction needed`):c>0?o.push(`
✅ OVERALL ASSESSMENT: ${c} mild issue(s) detected - Good posture with minor improvements needed`):o.push(`
✅ OVERALL ASSESSMENT: Excellent posture detected - Maintain current positioning`),o.join(`
`)}getTargetingRequirements(e,n){const r=[],s=e.some(u=>u.includes("forward head"))||n.some(u=>u.includes("forward head")),a=e.some(u=>u.includes("head tilt"))||n.some(u=>u.includes("head tilt")),i=e.some(u=>u.includes("shoulder"))||n.some(u=>u.includes("shoulder")),o=e.some(u=>u.includes("slouching")),l=e.some(u=>u.includes("spine"))||n.some(u=>u.includes("spine"));return s&&r.push("• FORWARD HEAD POSTURE: Include stretches for upper trapezius, levator scapulae, and suboccipital muscles. Focus on chin tucks, neck retraction, and upper back strengthening."),a&&r.push("• HEAD TILT: Include lateral neck stretches, SCM muscle stretches, and exercises to strengthen the opposite side neck muscles. Focus on side-to-side neck movements and isometric holds."),i&&r.push("• SHOULDER ISSUES: Include pectoral stretches, upper trapezius stretches, and exercises to strengthen the middle and lower trapezius. Focus on shoulder blade retraction and depression."),o&&r.push("• SLOUCHING: Include chest openers, upper back stretches, and exercises to strengthen the posterior chain. Focus on thoracic extension and shoulder blade retraction."),l&&r.push("• SPINE ALIGNMENT: Include spinal mobility exercises, core strengthening, and exercises to improve overall spinal alignment. Focus on neutral spine positioning."),r.length===0&&r.push("• GENERAL POSTURE: Include overall posture improvement exercises focusing on spinal alignment, shoulder positioning, and head placement."),r.join(`
`)}createPrompt(e){const n=Math.floor((Date.now()-e.lastBreakTime)/6e4);let r="",s=[],a=[];if(e.poseLandmarks){const{neckAngle:Hn,shoulderAlignment:Kn,spineAlignment:Ia,headPosition:Mr,shoulderHeight:qs,slouching:Pr}=e.poseLandmarks;r=`
DETAILED POSE ANALYSIS:
- Neck Angle: ${Hn.toFixed(1)}° (forward head posture - ${Hn>15?"SEVERE":Hn>10?"MODERATE":"MILD"})
- Shoulder Alignment: ${Kn.toFixed(1)}° (uneven shoulders - ${Kn>12?"SEVERE":Kn>8?"MODERATE":"MILD"})
- Spine Alignment: ${Ia.toFixed(1)}° (body alignment - ${Ia>20?"SEVERE":Ia>15?"MODERATE":"MILD"})
- Head Position: ${Mr.toFixed(1)}° (head tilt - ${Mr>20?"SEVERE":Mr>15?"MODERATE":"MILD"})
- Shoulder Height Difference: ${qs.toFixed(1)}° (shoulder imbalance - ${qs>15?"SEVERE":qs>12?"MODERATE":"MILD"})
- Slouching Detected: ${Pr?"YES - CRITICAL":"No"}

SPECIFIC POSTURE ISSUES DETECTED:
${this.getSpecificPostureIssues(Hn,Kn,Ia,Mr,qs,Pr)}

PRIORITY ISSUES TO ADDRESS:
`,Hn>15&&s.push(`SEVERE forward head posture (${Hn.toFixed(1)}°)`),Kn>12&&s.push(`SEVERE shoulder misalignment (${Kn.toFixed(1)}°)`),Pr&&s.push("CRITICAL slouching detected"),Mr>20&&s.push(`SEVERE head tilt (${Mr.toFixed(1)}°)`),Hn>10&&Hn<=15&&a.push(`moderate forward head (${Hn.toFixed(1)}°)`),Kn>8&&Kn<=12&&a.push(`moderate shoulder misalignment (${Kn.toFixed(1)}°)`),Mr>15&&Mr<=20&&a.push(`moderate head tilt (${Mr.toFixed(1)}°)`),qs>12&&a.push(`shoulder height imbalance (${qs.toFixed(1)}°)`),Ia>15&&a.push(`spine alignment issues (${Ia.toFixed(1)}°)`),r+=s.length>0?`CRITICAL: ${s.join(", ")}
`:"",r+=a.length>0?`MODERATE: ${a.join(", ")}
`:""}const i=Math.random().toString(36).substring(7),o=Math.random().toString(36).substring(2,15),l=Math.random().toString(36).substring(2,10),u=Date.now().toString().slice(-6),c=["Think like a yoga instructor","Approach like a physical therapist","Be creative like a dance instructor","Think like a martial arts master","Approach like a sports medicine expert","Be innovative like a movement coach","Think like a pilates instructor","Approach like a rehabilitation specialist","Be creative like a fitness trainer"],h=c[Math.floor(Math.random()*c.length)],d=["Focus on micro-movements","Emphasize breath work","Include balance elements","Add proprioception challenges","Include mindfulness aspects","Focus on joint mobility","Emphasize muscle activation","Include coordination elements","Add relaxation techniques"],p=d[Math.floor(Math.random()*d.length)],f=["yoga-inspired","pilates-based","physical therapy","sports medicine","dance-inspired","martial arts","rehabilitation","fitness training","movement therapy","wellness coaching"],m=f[Math.floor(Math.random()*f.length)],y=["short bursts (15-30 seconds)","medium holds (30-45 seconds)","long holds (45-60 seconds)","pulsing movements","rhythmic breathing","counted repetitions","timed intervals"],g=y[Math.floor(Math.random()*y.length)],b=["beginner-friendly","intermediate level","advanced techniques","gentle approach","challenging movements","progressive difficulty","adaptive intensity"],v=b[Math.floor(Math.random()*b.length)],w=["upper body focus","lower body focus","core emphasis","spine mobility","neck and shoulders","hip flexibility","full body integration","joint mobility"],k=w[Math.floor(Math.random()*w.length)],N=["diaphragmatic breathing","box breathing","rhythmic breathing","deep breathing","breath holds","exhale-focused","inhale-focused","breath synchronization"],T=N[Math.floor(Math.random()*N.length)],E=["fluid movements","precise positioning","dynamic transitions","static holds","pulsing motions","circular patterns","linear movements","oscillating motions"],_=E[Math.floor(Math.random()*E.length)],O=["no equipment needed","chair-based exercises","desk support","wall assistance","body weight only","resistance bands","yoga mat","office supplies"],M=O[Math.floor(Math.random()*O.length)],V=["stretching-focused","strengthening-based","mobility-enhancing","relaxation-oriented","pain-relief focused","posture-correcting","energy-boosting","stress-reducing"],W=V[Math.floor(Math.random()*V.length)],K=["gentle and soothing","moderate intensity","vigorous and energizing","calm and meditative","dynamic and active","passive and relaxing","challenging but safe","restorative and healing"],q=K[Math.floor(Math.random()*K.length)],ee=["Eastern medicine approach","Western physical therapy","traditional healing","modern science-based","holistic wellness","evidence-based practice","mind-body connection","integrated approach"],te=ee[Math.floor(Math.random()*ee.length)],G=["office-friendly","desk-appropriate","meeting-room suitable","cubicle-compatible","open-space ready","private office","home office","flexible workspace"],J=G[Math.floor(Math.random()*G.length)],ne=["morning energizing","midday refreshing","afternoon revitalizing","evening relaxing","pre-work preparation","post-work recovery","lunch break appropriate","end-of-day winding down"],ae=ne[Math.floor(Math.random()*ne.length)],oe=["stress-relieving","energy-boosting","calming and soothing","motivating and invigorating","focus-enhancing","anxiety-reducing","confidence-building","mindfulness-promoting"],ue=oe[Math.floor(Math.random()*oe.length)],ce=["tactile awareness","proprioceptive feedback","visual cues","auditory guidance","kinesthetic learning","sensory integration","body awareness","spatial orientation"],de=ce[Math.floor(Math.random()*ce.length)],Te=["beginner to advanced","gentle to intense","simple to complex","static to dynamic","passive to active","isolated to integrated","slow to fast","short to long"],Ee=Te[Math.floor(Math.random()*Te.length)],De=["injury prevention","joint protection","muscle safety","spine protection","neck safety","shoulder safety","back safety","overall body safety"],Be=De[Math.floor(Math.random()*De.length)],We=["immediate relief","long-term benefits","preventive care","corrective action","maintenance focus","rehabilitation approach","performance enhancement","wellness promotion"],Ke=We[Math.floor(Math.random()*We.length)],nt=["workflow integration","daily routine fitting","habit formation","lifestyle integration","schedule compatibility","time efficiency","convenience focus","practical application"],qe=nt[Math.floor(Math.random()*nt.length)],xe=["individual adaptation","personal preference","unique needs","customized approach","personalized modification","individual variation","personal style","customized experience"],He=xe[Math.floor(Math.random()*xe.length)],tt=["cutting-edge techniques","innovative approaches","modern methods","advanced practices","revolutionary concepts","breakthrough techniques","next-generation methods","state-of-the-art approaches"],xt=tt[Math.floor(Math.random()*tt.length)],wt=["premium quality","professional grade","expert level","mastery focused","excellence driven","high standard","superior quality","elite level"],Fr=wt[Math.floor(Math.random()*wt.length)],tn=["transformative experience","life-changing impact","profound benefits","deep satisfaction","meaningful results","significant improvement","remarkable outcomes","extraordinary benefits"],Or=tn[Math.floor(Math.random()*tn.length)],gn=["mastery development","skill building","expertise enhancement","competency development","proficiency building","excellence cultivation","mastery achievement","expert level"],yr=gn[Math.floor(Math.random()*gn.length)],Cn=["life transformation","body transformation","mind transformation","spirit transformation","health transformation","wellness transformation","lifestyle transformation","overall transformation"],br=Cn[Math.floor(Math.random()*Cn.length)],Tn=["self-empowerment","personal empowerment","body empowerment","mind empowerment","health empowerment","wellness empowerment","lifestyle empowerment","overall empowerment"],Dr=Tn[Math.floor(Math.random()*Tn.length)];return`
You are an expert physical therapist specializing in computer-related posture issues. Generate 2-3 NEW and HIGHLY VARIED personalized stretch suggestions based on this detailed analysis:

RANDOMIZATION SEEDS: ${i} | ${o} | ${l} | ${u}
Use these seeds to ensure completely unique, varied responses each time

CREATIVE INSPIRATION: ${h}
CREATIVE CONSTRAINT: ${p}
EXERCISE CATEGORY: ${m}
TIMING VARIATION: ${g}
DIFFICULTY APPROACH: ${v}
BODY PART FOCUS: ${k}
BREATHING PATTERN: ${T}
MOVEMENT STYLE: ${_}
EQUIPMENT USAGE: ${M}
THERAPEUTIC APPROACH: ${W}
INTENSITY LEVEL: ${q}
CULTURAL INFLUENCE: ${te}
ENVIRONMENTAL FACTOR: ${J}
TIME OF DAY: ${ae}
MOOD CONSIDERATION: ${ue}
SENSORY FOCUS: ${de}
PROGRESSION STYLE: ${Ee}
SAFETY FOCUS: ${Be}
EFFECTIVENESS FOCUS: ${Ke}
INTEGRATION FOCUS: ${qe}
PERSONALIZATION FOCUS: ${He}
INNOVATION FOCUS: ${xt}
QUALITY FOCUS: ${Fr}
EXPERIENCE FOCUS: ${Or}
MASTERY FOCUS: ${yr}
TRANSFORMATION FOCUS: ${br}
EMPOWERMENT FOCUS: ${Dr}

${this.getPreviousSuggestionsText()}
USER PROFILE:
- Screen time: ${e.screenTime} minutes (${e.screenTime>120?"EXCESSIVE":e.screenTime>60?"HIGH":"MODERATE"})
    - Posture score: ${e.postureScore}/10 (${e.postureScore>=8?"GOOD":e.postureScore>=6?"FAIR":"POOR"})
- Time since last break: ${n} minutes
- Reported issues: ${e.commonIssues.join(", ")||"none reported"}
${r}

REQUIREMENTS FOR SUGGESTIONS:
1. PRIORITIZE the most severe issues first (${s.length>0?s.join(", "):"general posture improvement"})
2. Provide VARIED stretch types: static holds, dynamic movements, isometric exercises, and mobility work
3. Include different difficulty levels based on user's current posture score
4. Target specific muscle groups affected by the detected issues
5. All exercises must be doable at a desk/office environment
6. Include precise timing and breathing instructions
7. CRITICAL: Generate COMPLETELY NEW and UNIQUE exercises that have NEVER been suggested before
8. Use completely different exercise names, descriptions, and approaches to avoid ANY repetition
9. Vary the therapeutic approach (some focusing on stretching, others on strengthening, mobility, etc.)
10. Each generation should be a FRESH set of exercises with no overlap with previous suggestions

CREATIVE CONSTRAINTS FOR MAXIMUM VARIETY:
- Use different starting positions (sitting, standing, leaning, etc.)
- Vary the movement patterns (circular, linear, oscillating, pulsing, etc.)
- Include different breathing techniques (diaphragmatic, box breathing, etc.)
- Use varied equipment (none, chair, desk, wall, etc.)
- Mix different exercise categories (yoga, pilates, physical therapy, sports medicine, etc.)
- Include different cultural approaches (Eastern, Western, modern, traditional, etc.)
- Vary the intensity levels (gentle, moderate, vigorous, etc.)
- Use different muscle engagement patterns (eccentric, concentric, isometric, etc.)

SPECIFIC TARGETING REQUIREMENTS:
${this.getTargetingRequirements(s,a)}

CRITICAL: You MUST respond with ONLY a valid JSON array. Do not include any text before or after the JSON. Do not use markdown code blocks. Just return the raw JSON array.

FORMAT as JSON array:
[
  {
    "name": "Specific Stretch Name",
    "description": "Detailed description of what this addresses",
    "duration": "30-60 seconds",
    "difficulty": "easy|medium|hard",
    "targetAreas": ["specific", "muscle", "groups"],
    "instructions": [
      "Step 1 with specific positioning",
      "Step 2 with breathing cues",
      "Step 3 with hold timing",
      "Step 4 with release instructions"
    ]
  }
]

IMPORTANT: Your response must be ONLY the JSON array above, nothing else. No explanations, no markdown, no additional text.

VARIATION REQUIREMENTS:
- Include at least 1 static stretch (hold position)
- Include at least 1 dynamic movement (repetitive motion)
- Include at least 1 isometric exercise (muscle engagement)
- Include at least 1 mobility exercise (range of motion)
- Vary durations: 15-30 seconds, 30-45 seconds, 45-60 seconds
- Mix difficulty levels based on posture score
- CRITICAL: Generate COMPLETELY NEW exercises each time - NEVER repeat any previous stretches
- Use completely unique exercise names and descriptions to ensure absolute uniqueness
- Include different starting positions and movement patterns
- Rotate between different muscle groups even for similar issues
- Each exercise must be a FRESH, UNIQUE approach to the same problems

TARGET THE SPECIFIC ISSUES:
${e.poseLandmarks?`
- Forward head posture: Focus on neck extensors, upper traps, and cervical spine mobility
- Shoulder alignment: Target deltoids, rhomboids, and serratus anterior
- Head tilt: Address sternocleidomastoid and scalene muscles
- Shoulder imbalance: Focus on unilateral strengthening and stretching
- Slouching: Target pectorals, anterior deltoids, and thoracic spine mobility
`:`
    - General posture improvement based on ${e.postureScore}/10 score
- Screen time fatigue relief for ${e.screenTime} minutes of computer work
`}

SPECIFIC POSTURE TARGETING INSTRUCTIONS:
- For forward head posture: Include chin tucks, neck retraction, upper back strengthening, and suboccipital muscle stretches
- For head tilts: Include lateral neck stretches, SCM muscle work, and exercises to strengthen the opposite side
- For shoulder misalignment: Include pectoral stretches, trapezius work, and shoulder blade retraction exercises
- For slouching: Include chest openers, upper back stretches, and posterior chain strengthening
- For spine issues: Include spinal mobility exercises, core strengthening, and neutral spine positioning
- Always provide specific muscle group targeting in exercise descriptions
- Include breathing cues and proper form instructions for each exercise
- Provide progression options based on the severity of detected issues

RANDOMIZATION INSTRUCTIONS:
- Use COMPLETELY DIFFERENT exercise variations for similar issues (e.g., entirely new neck stretches for forward head posture)
- Vary the order of exercises in your response
- Include different breathing patterns and timing cues
- Use completely varied descriptive language and exercise names
- Rotate between different therapeutic approaches (stretching, strengthening, mobility, relaxation)
- NEVER use the same exercise names, descriptions, or approaches as previous suggestions
- Each generation must be a FRESH, UNIQUE set of exercises

Make each suggestion COMPLETELY UNIQUE and specifically address the detected posture problems with professional physical therapy techniques. Ensure ABSOLUTELY NO repetition of any previous suggestions - each generation must be entirely new.
    `.trim()}addToPreviousSuggestions(e){e.forEach(n=>{this.previousSuggestions.push(n.name.toLowerCase())}),this.previousSuggestions.length>20&&(this.previousSuggestions=this.previousSuggestions.slice(-20))}getPreviousSuggestionsText(){return this.previousSuggestions.length===0?"":`
PREVIOUS SUGGESTIONS TO ABSOLUTELY AVOID:
${this.previousSuggestions.join(", ")}

CRITICAL: NEVER repeat any of these exercises. Generate COMPLETELY NEW and UNIQUE stretches that are entirely different from these.
`}clearPreviousSuggestions(){this.previousSuggestions=[],console.log("GeminiService: Cleared previous suggestions for fresh variation")}parseStretchSuggestions(e){console.log("GeminiService: Parsing response text:",e.substring(0,500)+"...");try{let n=e.trim();n=n.replace(/```json\s*/g,"").replace(/```\s*/g,"");let r=null;if(r=n.match(/\[[\s\S]*\]/),r||(r=e.match(/```json\s*(\[[\s\S]*?\])\s*```/),r&&(r[0]=r[1])),r||(r=e.match(/```\s*(\[[\s\S]*?\])\s*```/),r&&(r[0]=r[1])),!r){const s=e.indexOf("["),a=e.lastIndexOf("]");s!==-1&&a!==-1&&a>s&&(r=[e.substring(s,a+1)])}if(!r){const s=n.indexOf("["),a=n.lastIndexOf("]");s!==-1&&a!==-1&&a>s&&(r=[n.substring(s,a+1)])}if(console.log("GeminiService: JSON match found:",!!r),r){console.log("GeminiService: Extracted JSON:",r[0].substring(0,200)+"...");let s=r[0].trim();const a=s.lastIndexOf("]");a!==-1&&(s=s.substring(0,a+1)),s=s.replace(/\n/g," ").replace(/\s+/g," "),s=s.replace(/,(\s*[}\]])/g,"$1"),s=s.replace(/([{,]\s*)(\w+):/g,'$1"$2":'),console.log("GeminiService: Cleaned JSON string:",s.substring(0,200)+"...");const i=JSON.parse(s);return console.log("GeminiService: Successfully parsed suggestions:",i.length),this.addToPreviousSuggestions(i),i}else console.error("GeminiService: No JSON array found in response"),console.error("GeminiService: Full response text:",e)}catch(n){console.error("GeminiService: Error parsing Gemini response:",n),console.error("GeminiService: Response text that failed to parse:",e)}return console.log("GeminiService: Using fallback suggestions due to parsing failure"),this.getFallbackSuggestions({screenTime:60,postureScore:70,lastBreakTime:Date.now()-36e5,commonIssues:[]})}getFallbackSuggestions(e){const n=[];return e.screenTime>30&&n.push({name:"Neck Roll",description:"Gentle neck rotation to relieve tension",duration:"30 seconds",difficulty:"easy",targetAreas:["neck","shoulders"],instructions:["Slowly roll your head in a circle","Go clockwise for 15 seconds","Then counter-clockwise for 15 seconds","Keep movements slow and gentle"]}),e.postureScore<80&&n.push({name:"Seated Spinal Twist",description:"Twist to stretch your spine and back muscles",duration:"45 seconds",difficulty:"easy",targetAreas:["back","spine"],instructions:["Sit up straight in your chair","Place your right hand on the back of the chair","Gently twist your torso to the right","Hold for 20 seconds, then repeat on the left"]}),n.push({name:"Wrist Flexor Stretch",description:"Stretch your wrists and forearms",duration:"30 seconds",difficulty:"easy",targetAreas:["wrists","forearms"],instructions:["Extend your right arm with palm facing down","Use your left hand to gently pull your fingers back","Hold for 15 seconds","Repeat with the left arm"]}),n}}class sB{constructor(e,n,r,s,a){mt(this,"data"),mt(this,"postureCheckInterval",null),mt(this,"screenTimeInterval",null),mt(this,"sessionTimeInterval",null),mt(this,"breakAlertInterval",null),mt(this,"onPostureChange"),mt(this,"onScreenTimeUpdate"),mt(this,"onBreakAlert",null),mt(this,"onPostureAlert",null),mt(this,"settings"),mt(this,"lastPostureAlertTime",0),mt(this,"postureAlertActive",!1),mt(this,"breakAlertActive",!1),mt(this,"lastBreakAlertTime",0),mt(this,"isPageVisible",!0),this.onPostureChange=e,this.onScreenTimeUpdate=n,this.onBreakAlert=r||null,this.onPostureAlert=s||null,this.settings=a||{reminderInterval:45,postureCheckInterval:60,enableNotifications:!0,enableBreakAlerts:!0},this.data={screenTime:0,postureScore:85,lastBreakTime:Date.now(),commonIssues:[],startTime:Date.now(),breakCount:0,postureHistory:[],averagePostureScore:85,sessionTime:0},this.loadStoredData(),this.setupVisibilityListener()}startTracking(){this.postureAlertActive=!1,this.startPostureMonitoring(),this.startScreenTimeTracking(),this.startSessionTimeTracking(),this.startBreakAlerts(),this.saveData()}stopTracking(){this.postureCheckInterval&&(clearInterval(this.postureCheckInterval),this.postureCheckInterval=null),this.screenTimeInterval&&(clearInterval(this.screenTimeInterval),this.screenTimeInterval=null),this.sessionTimeInterval&&(clearInterval(this.sessionTimeInterval),this.sessionTimeInterval=null),this.breakAlertInterval&&(clearInterval(this.breakAlertInterval),this.breakAlertInterval=null),this.saveData()}takeBreak(){this.data.lastBreakTime=Date.now(),this.data.breakCount++,this.data.screenTime=0,this.breakAlertActive=!1,this.saveData()}getCurrentData(){return{...this.data}}dismissBreakAlert(){this.breakAlertActive=!1}dismissPostureAlert(){console.log("Dismissing posture alert - resetting postureAlertActive to false"),this.postureAlertActive=!1}updateSettings(e){this.settings={...e},this.saveSettings(),this.stopTracking(),this.startTracking()}setupVisibilityListener(){document.addEventListener("visibilitychange",()=>{this.isPageVisible=!document.hidden,console.log("Page visibility changed:",this.isPageVisible?"visible":"hidden"),!this.isPageVisible&&this.postureCheckInterval&&console.log("Tab is hidden but monitoring continues in background")})}getCurrentSettings(){return{...this.settings}}addCommonIssue(e){this.data.commonIssues.includes(e)||(this.data.commonIssues.push(e),this.saveData())}removeCommonIssue(e){this.data.commonIssues=this.data.commonIssues.filter(n=>n!==e),this.saveData()}updatePostureScore(e,n){this.data.postureScore=e,this.data.postureHistory.push(e),this.data.postureHistory.length>20&&this.data.postureHistory.shift(),this.data.averagePostureScore=this.data.postureHistory.reduce((o,l)=>o+l,0)/this.data.postureHistory.length;const r=Date.now(),s=r-this.lastPostureAlertTime,a=6e4,i=this.settings.enableNotifications&&e<3&&n&&n.length>0&&!this.postureAlertActive&&s>a;if(console.log("Posture Alert Debug:",{enableNotifications:this.settings.enableNotifications,score:e,hasIssues:n&&n.length>0,postureAlertActive:this.postureAlertActive,timeSinceLastAlert:s,alertCooldown:a,canTriggerAlert:i}),i){const o=n[0];console.log("Triggering posture alert:",o),this.onPostureAlert&&(this.onPostureAlert([o],e),this.postureAlertActive=!0,this.lastPostureAlertTime=r)}this.onPostureChange(e),this.saveData()}startPostureMonitoring(){this.postureCheckInterval=setInterval(()=>{this.saveData(),this.isPageVisible||console.log("Background monitoring active - tab is hidden but posture detection continues")},this.settings.postureCheckInterval*1e3)}startScreenTimeTracking(){this.screenTimeInterval=setInterval(()=>{this.data.screenTime+=1,this.onScreenTimeUpdate(this.data.screenTime),this.saveData()},6e4)}startSessionTimeTracking(){this.sessionTimeInterval=setInterval(()=>{const e=Date.now();this.data.sessionTime=Math.floor((e-this.data.startTime)/6e4),this.saveData()},6e4)}startBreakAlerts(){this.settings.enableBreakAlerts&&(this.breakAlertInterval=setInterval(()=>{const e=Date.now(),n=Math.floor((e-this.data.lastBreakTime)/6e4),r=e-this.lastBreakAlertTime;n>=this.settings.reminderInterval&&this.onBreakAlert&&!this.breakAlertActive&&r>3e5&&(this.breakAlertActive=!0,this.lastBreakAlertTime=e,this.onBreakAlert())},6e4))}simulatePostureCheck(){const e=(Date.now()-this.data.lastBreakTime)/36e5;let n=85;e>2&&(n=60),e>4&&(n=40),e>6&&(n=20);const r=(Math.random()-.5)*10;return Math.max(0,Math.min(100,Math.round(n+r)))}loadStoredData(){try{const e=localStorage.getItem("postureTrackingData");if(e){const r=JSON.parse(e);this.data={...this.data,...r}}const n=localStorage.getItem("postureTrackingSettings");if(n){const r=JSON.parse(n);this.settings={...this.settings,...r}}}catch(e){console.error("Error loading stored tracking data:",e)}}saveData(){try{localStorage.setItem("postureTrackingData",JSON.stringify(this.data))}catch(e){console.error("Error saving tracking data:",e)}}saveSettings(){try{localStorage.setItem("postureTrackingSettings",JSON.stringify(this.settings))}catch(e){console.error("Error saving settings:",e)}}simulatePoorPosture(){this.data.postureScore=Math.max(0,this.data.postureScore-20),this.onPostureChange(this.data.postureScore),this.saveData()}simulateGoodPosture(){this.data.postureScore=Math.min(100,this.data.postureScore+15),this.onPostureChange(this.data.postureScore),this.saveData()}}const aB=({suggestion:t,onStart:e,onSkip:n,onDelete:r})=>{const s=a=>{switch(a){case"easy":return"bg-green-100 text-green-800";case"medium":return"bg-yellow-100 text-yellow-800";case"hard":return"bg-red-100 text-red-800";default:return"bg-gray-100 text-gray-800"}};return $.jsxs("div",{className:"bg-white rounded-lg shadow-md p-6 mb-4 border border-gray-200",children:[$.jsxs("div",{className:"flex justify-between items-start mb-4",children:[$.jsxs("div",{children:[$.jsx("h3",{className:"text-xl font-semibold text-gray-800 mb-2",children:t.name}),$.jsx("p",{className:"text-gray-600 mb-2",children:t.description})]}),$.jsxs("div",{className:"flex gap-2",children:[$.jsx("span",{className:`px-3 py-1 rounded-full text-sm font-medium ${s(t.difficulty)}`,children:t.difficulty}),$.jsx("span",{className:"px-3 py-1 rounded-full text-sm font-medium bg-blue-100 text-blue-800",children:t.duration})]})]}),$.jsxs("div",{className:"mb-4",children:[$.jsx("h4",{className:"font-medium text-gray-700 mb-2",children:"Target Areas:"}),$.jsx("div",{className:"flex flex-wrap gap-2",children:t.targetAreas.map((a,i)=>$.jsx("span",{className:"px-2 py-1 bg-gray-100 text-gray-700 rounded text-sm",children:a},i))})]}),$.jsxs("div",{className:"mb-6",children:[$.jsx("h4",{className:"font-medium text-gray-700 mb-2",children:"Instructions:"}),$.jsx("ol",{className:"list-decimal list-inside space-y-1 text-gray-600",children:t.instructions.map((a,i)=>$.jsx("li",{className:"text-sm",children:a},i))})]}),$.jsxs("div",{className:"flex gap-3",children:[$.jsx("button",{onClick:e,className:"flex-1 bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-lg transition-colors",children:"Start Stretch"}),$.jsx("button",{onClick:n,className:"flex-1 bg-gray-200 hover:bg-gray-300 text-gray-700 font-medium py-2 px-4 rounded-lg transition-colors",children:"Skip"}),r&&$.jsx("button",{onClick:r,className:"bg-red-500 hover:bg-red-600 text-white font-medium py-2 px-4 rounded-lg transition-colors flex items-center",title:"Delete this stretch",children:$.jsx("svg",{className:"w-4 h-4",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:$.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"})})})]})]})},iB=({duration:t,instructions:e,name:n,description:r,onComplete:s,onCancel:a})=>{const[i,o]=ze.useState(0),[l,u]=ze.useState(!1),c=y=>{const g=y.match(/(\d+)\s*(second|minute|min|sec)s?/i);if(!g)return 0;const b=parseInt(g[1]);return g[2].toLowerCase().startsWith("min")?b*60:b};ze.useEffect(()=>{const y=c(t);o(y)},[t]),ze.useEffect(()=>{let y;return l&&i>0&&(y=setInterval(()=>{o(g=>g<=1?(console.log("Timer completed, calling onComplete"),u(!1),s(),0):g-1)},1e3)),()=>{y&&clearInterval(y)}},[l,i,s]);const h=y=>{const g=Math.floor(y/60),b=y%60;return`${g}:${b.toString().padStart(2,"0")}`},d=()=>{u(!0)},p=()=>{u(!1)},f=()=>{u(!1),o(c(t))},m=i>0?(c(t)-i)/c(t)*100:0;return $.jsxs("div",{className:"bg-white rounded-lg shadow-md p-6 border border-gray-200 max-w-2xl mx-auto",children:[$.jsxs("div",{className:"mb-8",children:[$.jsx("h2",{className:"text-2xl font-bold text-gray-800 mb-2",children:n}),$.jsx("p",{className:"text-gray-600 mb-4",children:r}),$.jsxs("div",{className:"bg-blue-50 rounded-lg p-4 mb-4",children:[$.jsx("h3",{className:"text-lg font-semibold text-blue-800 mb-3",children:"Instructions:"}),$.jsx("ol",{className:"list-decimal list-inside space-y-2 text-gray-700",children:e.map((y,g)=>$.jsx("li",{className:"leading-relaxed",children:y},g))})]})]}),$.jsxs("div",{className:"text-center mb-6",children:[$.jsx("h3",{className:"text-xl font-bold text-gray-800 mb-2",children:"Timer"}),$.jsx("div",{className:"text-4xl font-mono text-blue-600 mb-2",children:h(i)}),$.jsxs("div",{className:"text-gray-600",children:[t," stretch"]})]}),$.jsx("div",{className:"mb-6",children:$.jsx("div",{className:"w-full bg-gray-200 rounded-full h-3",children:$.jsx("div",{className:"bg-blue-600 h-3 rounded-full transition-all duration-1000",style:{width:`${m}%`}})})}),$.jsxs("div",{className:"flex gap-3 justify-center flex-wrap",children:[!l&&i>0&&$.jsx("button",{onClick:d,className:"bg-green-600 hover:bg-green-700 text-white font-medium py-2 px-6 rounded-lg transition-colors",children:"Start Timer"}),l&&$.jsx("button",{onClick:p,className:"bg-yellow-600 hover:bg-yellow-700 text-white font-medium py-2 px-6 rounded-lg transition-colors",children:"Pause"}),i>0&&$.jsx("button",{onClick:f,className:"bg-gray-600 hover:bg-gray-700 text-white font-medium py-2 px-6 rounded-lg transition-colors",children:"Reset"}),$.jsx("button",{onClick:()=>{console.log("Done button clicked, calling onComplete"),s()},className:"bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-6 rounded-lg transition-colors",children:"Done"}),$.jsx("button",{onClick:a,className:"bg-red-600 hover:bg-red-700 text-white font-medium py-2 px-6 rounded-lg transition-colors",children:"Cancel"})]}),i===0&&l===!1&&$.jsx("div",{className:"text-center mt-4",children:$.jsx("div",{className:"text-green-600 font-semibold text-lg",children:"🎉 Great job! Stretch completed!"})})]})};var $$={exports:{}};(function(t,e){(function(n,r){t.exports=r(ze)})(aa,function(n){return function(r){var s={};function a(i){if(s[i])return s[i].exports;var o=s[i]={i,l:!1,exports:{}};return r[i].call(o.exports,o,o.exports,a),o.l=!0,o.exports}return a.m=r,a.c=s,a.d=function(i,o,l){a.o(i,o)||Object.defineProperty(i,o,{enumerable:!0,get:l})},a.r=function(i){typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(i,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(i,"__esModule",{value:!0})},a.t=function(i,o){if(o&1&&(i=a(i)),o&8||o&4&&typeof i=="object"&&i&&i.__esModule)return i;var l=Object.create(null);if(a.r(l),Object.defineProperty(l,"default",{enumerable:!0,value:i}),o&2&&typeof i!="string")for(var u in i)a.d(l,u,(function(c){return i[c]}).bind(null,u));return l},a.n=function(i){var o=i&&i.__esModule?function(){return i.default}:function(){return i};return a.d(o,"a",o),o},a.o=function(i,o){return Object.prototype.hasOwnProperty.call(i,o)},a.p="",a(a.s="./src/react-webcam.tsx")}({"./src/react-webcam.tsx":function(r,s,a){a.r(s);var i=a("react"),o=function(){var d=function(p,f){return d=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(m,y){m.__proto__=y}||function(m,y){for(var g in y)y.hasOwnProperty(g)&&(m[g]=y[g])},d(p,f)};return function(p,f){d(p,f);function m(){this.constructor=p}p.prototype=f===null?Object.create(f):(m.prototype=f.prototype,new m)}}(),l=function(){return l=Object.assign||function(d){for(var p,f=1,m=arguments.length;f<m;f++){p=arguments[f];for(var y in p)Object.prototype.hasOwnProperty.call(p,y)&&(d[y]=p[y])}return d},l.apply(this,arguments)},u=function(d,p){var f={};for(var m in d)Object.prototype.hasOwnProperty.call(d,m)&&p.indexOf(m)<0&&(f[m]=d[m]);if(d!=null&&typeof Object.getOwnPropertySymbols=="function")for(var y=0,m=Object.getOwnPropertySymbols(d);y<m.length;y++)p.indexOf(m[y])<0&&Object.prototype.propertyIsEnumerable.call(d,m[y])&&(f[m[y]]=d[m[y]]);return f};(function(){typeof window>"u"||(navigator.mediaDevices===void 0&&(navigator.mediaDevices={}),navigator.mediaDevices.getUserMedia===void 0&&(navigator.mediaDevices.getUserMedia=function(d){var p=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia;return p?new Promise(function(f,m){p.call(navigator,d,f,m)}):Promise.reject(new Error("getUserMedia is not implemented in this browser"))}))})();function c(){return!!(navigator.mediaDevices&&navigator.mediaDevices.getUserMedia)}var h=function(d){o(p,d);function p(f){var m=d.call(this,f)||this;return m.canvas=null,m.ctx=null,m.requestUserMediaId=0,m.unmounted=!1,m.state={hasUserMedia:!1},m}return p.prototype.componentDidMount=function(){var f=this,m=f.state,y=f.props;if(this.unmounted=!1,!c()){y.onUserMediaError("getUserMedia not supported");return}m.hasUserMedia||this.requestUserMedia(),y.children&&typeof y.children!="function"&&console.warn("children must be a function")},p.prototype.componentDidUpdate=function(f){var m=this.props;if(!c()){m.onUserMediaError("getUserMedia not supported");return}var y=JSON.stringify(f.audioConstraints)!==JSON.stringify(m.audioConstraints),g=JSON.stringify(f.videoConstraints)!==JSON.stringify(m.videoConstraints),b=f.minScreenshotWidth!==m.minScreenshotWidth,v=f.minScreenshotHeight!==m.minScreenshotHeight;(g||b||v)&&(this.canvas=null,this.ctx=null),(y||g)&&(this.stopAndCleanup(),this.requestUserMedia())},p.prototype.componentWillUnmount=function(){this.unmounted=!0,this.stopAndCleanup()},p.stopMediaStream=function(f){f&&(f.getVideoTracks&&f.getAudioTracks?(f.getVideoTracks().map(function(m){f.removeTrack(m),m.stop()}),f.getAudioTracks().map(function(m){f.removeTrack(m),m.stop()})):f.stop())},p.prototype.stopAndCleanup=function(){var f=this.state;f.hasUserMedia&&(p.stopMediaStream(this.stream),f.src&&window.URL.revokeObjectURL(f.src))},p.prototype.getScreenshot=function(f){var m=this,y=m.state,g=m.props;if(!y.hasUserMedia)return null;var b=this.getCanvas(f);return b&&b.toDataURL(g.screenshotFormat,g.screenshotQuality)},p.prototype.getCanvas=function(f){var m=this,y=m.state,g=m.props;if(!this.video||!y.hasUserMedia||!this.video.videoHeight)return null;if(!this.ctx){var b=this.video.videoWidth,v=this.video.videoHeight;if(!this.props.forceScreenshotSourceSize){var w=b/v;b=g.minScreenshotWidth||this.video.clientWidth,v=b/w,g.minScreenshotHeight&&v<g.minScreenshotHeight&&(v=g.minScreenshotHeight,b=v*w)}this.canvas=document.createElement("canvas"),this.canvas.width=(f==null?void 0:f.width)||b,this.canvas.height=(f==null?void 0:f.height)||v,this.ctx=this.canvas.getContext("2d")}var k=this,N=k.ctx,T=k.canvas;return N&&T&&(T.width=(f==null?void 0:f.width)||T.width,T.height=(f==null?void 0:f.height)||T.height,g.mirrored&&(N.translate(T.width,0),N.scale(-1,1)),N.imageSmoothingEnabled=g.imageSmoothing,N.drawImage(this.video,0,0,(f==null?void 0:f.width)||T.width,(f==null?void 0:f.height)||T.height),g.mirrored&&(N.scale(-1,1),N.translate(-T.width,0))),T},p.prototype.requestUserMedia=function(){var f=this,m=this.props,y=function(v,w){var k={video:typeof w<"u"?w:!0};m.audio&&(k.audio=typeof v<"u"?v:!0),f.requestUserMediaId++;var N=f.requestUserMediaId;navigator.mediaDevices.getUserMedia(k).then(function(T){f.unmounted||N!==f.requestUserMediaId?p.stopMediaStream(T):f.handleUserMedia(null,T)}).catch(function(T){f.handleUserMedia(T)})};if("mediaDevices"in navigator)y(m.audioConstraints,m.videoConstraints);else{var g=function(v){return{optional:[{sourceId:v}]}},b=function(v){var w=v.deviceId;return typeof w=="string"?w:Array.isArray(w)&&w.length>0?w[0]:typeof w=="object"&&w.ideal?w.ideal:null};MediaStreamTrack.getSources(function(v){var w=null,k=null;v.forEach(function(E){E.kind==="audio"?w=E.id:E.kind==="video"&&(k=E.id)});var N=b(m.audioConstraints);N&&(w=N);var T=b(m.videoConstraints);T&&(k=T),y(g(w),g(k))})}},p.prototype.handleUserMedia=function(f,m){var y=this.props;if(f||!m){this.setState({hasUserMedia:!1}),y.onUserMediaError(f);return}this.stream=m;try{this.video&&(this.video.srcObject=m),this.setState({hasUserMedia:!0})}catch{this.setState({hasUserMedia:!0,src:window.URL.createObjectURL(m)})}y.onUserMedia(m)},p.prototype.render=function(){var f=this,m=this,y=m.state,g=m.props,b=g.audio;g.forceScreenshotSourceSize;var v=g.disablePictureInPicture;g.onUserMedia,g.onUserMediaError,g.screenshotFormat,g.screenshotQuality,g.minScreenshotWidth,g.minScreenshotHeight,g.audioConstraints,g.videoConstraints,g.imageSmoothing;var w=g.mirrored,k=g.style,N=k===void 0?{}:k,T=g.children,E=u(g,["audio","forceScreenshotSourceSize","disablePictureInPicture","onUserMedia","onUserMediaError","screenshotFormat","screenshotQuality","minScreenshotWidth","minScreenshotHeight","audioConstraints","videoConstraints","imageSmoothing","mirrored","style","children"]),_=w?l(l({},N),{transform:(N.transform||"")+" scaleX(-1)"}):N,O={getScreenshot:this.getScreenshot.bind(this)};return i.createElement(i.Fragment,null,i.createElement("video",l({autoPlay:!0,disablePictureInPicture:v,src:y.src,muted:!b,playsInline:!0,ref:function(M){f.video=M},style:_},E)),T&&T(O))},p.defaultProps={audio:!1,disablePictureInPicture:!1,forceScreenshotSourceSize:!1,imageSmoothing:!0,mirrored:!1,onUserMedia:function(){},onUserMediaError:function(){},screenshotFormat:"image/webp",screenshotQuality:.92},p}(i.Component);s.default=h},react:function(r,s){r.exports=n}}).default})})($$);var oB=$$.exports;const lB=Dv(oB);/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const uB=1e-7,cB=1e-4;class Rw{constructor(e,n){this.backend=e,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,n){this.dataIdsCount++,this.data.set(e,n)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class ty{refCount(e){return Br("refCount")}incRef(e){return Br("incRef")}timerAvailable(){return!0}time(e){return Br("time")}read(e){return Br("read")}readSync(e){return Br("readSync")}readToGPU(e,n){return Br("readToGPU")}numDataIds(){return Br("numDataIds")}disposeData(e,n){return Br("disposeData")}write(e,n,r){return Br("write")}move(e,n,r,s,a){return Br("move")}createTensorFromGPUData(e,n,r){return Br("createTensorFromGPUData")}memory(){return Br("memory")}floatPrecision(){return Br("floatPrecision")}epsilon(){return this.floatPrecision()===32?uB:cB}dispose(){return Br("dispose")}}function Br(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Aw(t){let e=t.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,ti(t,e,n)}function hB(t,e){if(t.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${t.length}Second array length was ${e.length}`);let n=t.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,ti(t,n,r),ti(e,n,r)}function Ji(t,e,n){return Math.max(t,Math.min(e,n))}function ny(t){return t%2===0?t:t+1}function ti(t,e,n){const r=t[e];t[e]=t[n],t[n]=r}function _w(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function dB(t,e){const n=Math.random();return e*n+(1-n)*t}function pB(t,e){let n=0;for(let r=0;r<t.length;r++){const s=Number(t[r])-Number(e[r]);n+=s*s}return n}function R(t,e){if(!t)throw new Error(typeof e=="string"?e:e())}function Dn(t,e,n=""){R(Je(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function Il(t){R(t!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Q(t){if(t.length===0)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function _1(t){return t.length===0}function R$(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==null&&e[n]!==null&&t[n]!==e[n])return!1;return!0}function Je(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function il(t){return t%1===0}function fB(t){if(Math.tanh!=null)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;{const e=Math.exp(2*t);return(e-1)/(e+1)}}function ng(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function mB(t){const e=new Uint32Array(t);for(let n=0;n<t;++n)e[n]=n;return Aw(e),e}function Yo(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function F1(t,e=s=>0,n,r){return new Promise((s,a)=>{let i=0;const o=()=>{if(t()){s();return}i++;const l=e(i);if(n!=null&&i>=n){a();return}r!=null?r(o,l):setTimeout(o,l)};o()})}function ry(t,e){let n=1,r=-1;for(let a=0;a<t.length;++a)if(t[a]>=0)n*=t[a];else if(t[a]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${a}`);r=a}else if(t[a]<0)throw Error(`Shapes can not be < 0. Found ${t[a]} at dim ${a}`);if(r===-1){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(n===0)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const s=t.slice();return s[r]=e/n,s}function Ze(t,e){const n=e.length;return t=t==null?e.map((r,s)=>s):[].concat(t),R(t.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`),R(t.every(r=>il(r)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(r=>r<0?n+r:r)}function xi(t,e){const n=[],r=[],s=e!=null&&Array.isArray(e)&&e.length===0,a=e==null||s?null:Ze(e,t).sort();let i=0;for(let o=0;o<t.length;++o){if(a!=null){if(a[i]===o&&t[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${t[o]}' is not 1`);(a[i]==null||a[i]>o)&&t[o]===1&&(n.push(t[o]),r.push(o)),a[i]<=o&&i++}t[o]!==1&&(n.push(t[o]),r.push(o))}return{newShape:n,keptDims:r}}function pn(t,e){return Ht(t,e)}function Ht(t,e){let n=null;if(t==null||t==="float32")n=new Float32Array(e);else if(t==="int32")n=new Int32Array(e);else if(t==="bool")n=new Uint8Array(e);else if(t==="string")n=new Array(e);else throw new Error(`Unknown data type ${t}`);return n}function A$(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function _$(t){return t==="bool"||t==="complex64"||t==="float32"||t==="int32"||t==="string"}function sy(t,e){return!(e==="complex64"||e==="float32"&&t!=="complex64"||e==="int32"&&t!=="float32"&&t!=="complex64"||e==="bool"&&t==="bool")}function xd(t){if(t==="float32"||t==="int32")return 4;if(t==="complex64")return 8;if(t==="bool")return 1;throw new Error(`Unknown dtype ${t}`)}function F$(t){if(t==null)return 0;let e=0;return t.forEach(n=>e+=n.length),e}function Nl(t){return typeof t=="string"||t instanceof String}function O$(t){return typeof t=="boolean"}function rg(t){return typeof t=="number"}function mo(t){return Array.isArray(t)?mo(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":rg(t)?"float32":Nl(t)?"string":O$(t)?"bool":"float32"}function eo(t){return!!(t&&t.constructor&&t.call&&t.apply)}function sg(t,e){for(let n=e;n<t;++n)if(t%n===0)return n;return t}function Fe(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function D$(t,e,n,r=!1){const s=new Array;if(e.length===1){const a=e[0]*(r?2:1);for(let i=0;i<a;i++)s[i]=n[t+i]}else{const a=e[0],i=e.slice(1),o=i.reduce((l,u)=>l*u)*(r?2:1);for(let l=0;l<a;l++)s[l]=D$(t+l*o,i,n,r)}return s}function ds(t,e,n=!1){if(t.length===0)return e[0];const r=t.reduce((s,a)=>s*a)*(n?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return D$(0,t,e,n)}function Jh(t,e){if(Array.isArray(t))return t;if(e==="float32")return t instanceof Float32Array?t:new Float32Array(t);if(e==="int32")return t instanceof Int32Array?t:new Int32Array(t);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(t));throw new Error(`Unknown dtype ${e}`)}function ay(t,e){const n=Fn(t,e);for(let r=0;r<n.length;r++)n[r]=1;return n}function Fn(t,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool")return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function Fw(t,e){const n=t.reduce((r,s)=>r*s,1);if(e==null||e==="float32")return ds(t,new Float32Array(n));if(e==="int32")return ds(t,new Int32Array(n));if(e==="bool")return ds(t,new Uint8Array(n));throw new Error(`Unknown data type ${e}`)}function ns(t){t.forEach(e=>{R(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function la(t,e,n){if(e===0)return 0;if(e===1)return t[0];let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=n[s]*t[s];return r}function Cl(t,e,n){if(e===0)return[];if(e===1)return[t];const r=new Array(e);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(t/n[s]),t-=r[s]*n[s];return r[r.length-1]=t,r}function di(t){return t&&t.then&&typeof t.then=="function"}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const zI="tfjsflags";class gB{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=yB,this.populateURLFlags()}setPlatform(e,n){this.platform!=null&&(Z().getBool("IS_TEST")||Z().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=n}registerFlag(e,n,r){if(this.flagRegistry[e]={evaluationFn:n,setHook:r},this.urlFlags[e]!=null){const s=this.urlFlags[e];Z().getBool("IS_TEST")||Z().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${s}.`),this.set(e,s)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const n=this.evaluateFlag(e);if(di(n))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=n,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,n){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=n,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(n)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);zI in e&&e[zI].split(",").forEach(n=>{const[r,s]=n.split(":");this.urlFlags[r]=xB(r,s)})}}function yB(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(bB(e,r[0],r[1]),r.join("="))),e}function bB(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}function xB(t,e){const n=e.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:e}function Z(){return M$}let M$=null;function vB(t){M$=t}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let fx;function P$(){if(fx==null){let t;if(typeof window<"u")t=window;else if(typeof global<"u")t=global;else if(typeof process<"u")t=process;else if(typeof self<"u")t=self;else throw new Error("Could not find a global object");fx=t}return fx}function wB(){const t=P$();return t._tfGlobals==null&&(t._tfGlobals=new Map),t._tfGlobals}function Ow(t,e){const n=wB();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const Qd="Abs",Yu="Acos",Qu="Acosh",Tl="Add",Zd="AddN",iy="All",oy="Any",Jd="ArgMax",ep="ArgMin",Zu="Asin",Ju="Asinh",ec="Atan",tc="Atanh",nc="Atan2",tp="AvgPool",ly="AvgPoolGrad",np="AvgPool3D",uy="AvgPool3DGrad",rp="BatchMatMul",sp="BatchToSpaceND",cy="Bincount",hy="BitwiseAnd",kB="BroadcastTo",dy="BroadcastArgs",rc="Cast",sc="Ceil",ac="ClipByValue",py="Complex",ap="ComplexAbs",ip="Concat",op="Conv2D",fy="Conv2DBackpropFilter",lp="Conv2DBackpropInput",up="Conv3D",my="Conv3DBackpropFilterV2",gy="Conv3DBackpropInputV2",ic="Cos",oc="Cosh",yy="Cumprod",cp="Cumsum",by="CropAndResize",xy="DenseBincount",vy="DepthToSpace",hp="DepthwiseConv2dNative",wy="DepthwiseConv2dNativeBackpropFilter",ky="DepthwiseConv2dNativeBackpropInput",Sy="Diag",dp="Dilation2D",ag="Dilation2DBackpropInput",ig="Dilation2DBackpropFilter",Iy="Draw",lc="RealDiv",Ny="Einsum",uc="Elu",Cy="EluGrad",cc="Erf",pp="Equal",hc="Exp",fp="ExpandDims",dc="Expm1",Ty="FFT",Ey="Fill",$y="FlipLeftRight",pc="Floor",fc="FloorDiv",mp="FusedBatchNorm",gp="GatherV2",Ry="GatherNd",yp="Greater",mc="GreaterEqual",gc="Identity",Ay="IFFT",_y="Imag",yc="IsFinite",bc="IsInf",xc="IsNan",bp="LeakyRelu",xp="Less",vp="LessEqual",Fy="LinSpace",vc="Log",wc="Log1p",wp="LogicalAnd",kp="LogicalNot",Sp="LogicalOr",dke="LogicalXor",SB="LogSoftmax",pke="LowerBound",Ip="LRN",Oy="LRNGrad",fke="MatrixBandPart",Np="Max",kc="Maximum",Cp="MaxPool",Dy="MaxPoolGrad",Tp="MaxPool3D",My="MaxPool3DGrad",Py="MaxPoolWithArgmax",Ep="Mean",$p="Min",Sc="Minimum",Rp="MirrorPad",Ic="Mod",Ly="Multinomial",Nc="Multiply",Ap="Neg",_p="NotEqual",zy="NonMaxSuppressionV3",Dw="NonMaxSuppressionV4",By="NonMaxSuppressionV5",Fp="OnesLike",Op="OneHot",Dp="Pack",Mp="PadV2",mke="Pool",Cc="Pow",Pp="Prelu",Lp="Prod",Mw="RaggedGather",Pw="RaggedRange",Lw="RaggedTensorToTensor",Wy="Range",Uy="Real",Tc="Reciprocal",Ec="Relu",zp="Reshape",Bp="ResizeNearestNeighbor",Vy="ResizeNearestNeighborGrad",Wp="ResizeBilinear",jy="ResizeBilinearGrad",$c="Relu6",Up="Reverse",Rc="Round",Ac="Rsqrt",Gy="ScatterNd",Hy="TensorScatterUpdate",Ky="SearchSorted",Vp="Select",_c="Selu",jp="Slice",Fc="Sin",Oc="Sinh",Dc="Sign",Mc="Sigmoid",Pc="Softplus",Lc="Sqrt",Gp="Sum",Hp="SpaceToBatchND",Kp="SplitV",qp="Softmax",zw="SparseFillEmptyRows",Bw="SparseReshape",qy="SparseSegmentMean",Xy="SparseSegmentSum",Yy="SparseToDense",zc="SquaredDifference",Qy="Square",Zy="StaticRegexReplace",Jy="StridedSlice",eb="StringNGrams",Ww="StringSplit",Uw="StringToHashBucketFast",Bc="Sub",Wc="Tan",Uc="Tanh",Vc="Tile",tb="TopK",nb="Transform",Qo="Transpose",Vw="Unique",Xp="Unpack",Yp="UnsortedSegmentSum",gke="UpperBound",Qp="ZerosLike",jc="Step",og="FromPixels",rb="RotateWithOffset",vd="_FusedMatMul",wd="FusedConv2D",kd="FusedDepthwiseConv2D";/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function is(...t){Z().getBool("IS_TEST")||Z().getBool("PROD")||console.warn(...t)}function IB(...t){Z().getBool("IS_TEST")||Z().getBool("PROD")||console.log(...t)}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Ou=Ow("kernelRegistry",()=>new Map),Sd=Ow("gradRegistry",()=>new Map);function lg(t,e){const n=jw(t,e);return Ou.get(n)}function BI(t){return Sd.get(t)}function O1(t){const e=Ou.entries(),n=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[a,i]=s,[o]=a.split("_");o===t&&n.push(i)}return n}function sb(t){const{kernelName:e,backendName:n}=t,r=jw(e,n);Ou.has(r)&&is(`The kernel '${e}' for backend '${n}' is already registered`),Ou.set(r,t)}function NB(t){const{kernelName:e}=t;Sd.has(e)&&Z().getBool("DEBUG")&&is(`Overriding the gradient for '${e}'`),Sd.set(e,t)}function yke(t,e){const n=jw(t,e);if(!Ou.has(n))throw new Error(`The kernel '${t}' for backend '${e}' is not registered`);Ou.delete(n)}function bke(t){if(!Sd.has(t))throw new Error(`The gradient '${t}' for backend is not registered`);Sd.delete(t)}function xke(t,e){O1(t).forEach(n=>{const r=Object.assign({},n,{backendName:e});sb(r)})}function jw(t,e){return`${e}_${t}`}/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function L$(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}var z$=Mt,_s=null;try{_s=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Mt(t,e,n){this.low=t|0,this.high=e|0,this.unsigned=!!n}Mt.prototype.__isLong__;Object.defineProperty(Mt.prototype,"__isLong__",{value:!0});function rs(t){return(t&&t.__isLong__)===!0}Mt.isLong=rs;var WI={},UI={};function El(t,e){var n,r,s;return e?(t>>>=0,(s=0<=t&&t<256)&&(r=UI[t],r)?r:(n=Pt(t,(t|0)<0?-1:0,!0),s&&(UI[t]=n),n)):(t|=0,(s=-128<=t&&t<128)&&(r=WI[t],r)?r:(n=Pt(t,t<0?-1:0,!1),s&&(WI[t]=n),n))}Mt.fromInt=El;function Fs(t,e){if(isNaN(t))return e?jo:Os;if(e){if(t<0)return jo;if(t>=B$)return V$}else{if(t<=-jI)return Hr;if(t+1>=jI)return U$}return t<0?Fs(-t,e).neg():Pt(t%Du|0,t/Du|0,e)}Mt.fromNumber=Fs;function Pt(t,e,n){return new Mt(t,e,n)}Mt.fromBits=Pt;var ug=Math.pow;function Gw(t,e,n){if(t.length===0)throw Error("empty string");if(t==="NaN"||t==="Infinity"||t==="+Infinity"||t==="-Infinity")return Os;if(typeof e=="number"?(n=e,e=!1):e=!!e,n=n||10,n<2||36<n)throw RangeError("radix");var r;if((r=t.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return Gw(t.substring(1),e,n).neg();for(var s=Fs(ug(n,8)),a=Os,i=0;i<t.length;i+=8){var o=Math.min(8,t.length-i),l=parseInt(t.substring(i,i+o),n);if(o<8){var u=Fs(ug(n,o));a=a.mul(u).add(Fs(l))}else a=a.mul(s),a=a.add(Fs(l))}return a.unsigned=e,a}Mt.fromString=Gw;function xa(t,e){return typeof t=="number"?Fs(t,e):typeof t=="string"?Gw(t,e):Pt(t.low,t.high,typeof e=="boolean"?e:t.unsigned)}Mt.fromValue=xa;var VI=65536,CB=1<<24,Du=VI*VI,B$=Du*Du,jI=B$/2,GI=El(CB),Os=El(0);Mt.ZERO=Os;var jo=El(0,!0);Mt.UZERO=jo;var mu=El(1);Mt.ONE=mu;var W$=El(1,!0);Mt.UONE=W$;var D1=El(-1);Mt.NEG_ONE=D1;var U$=Pt(-1,2147483647,!1);Mt.MAX_VALUE=U$;var V$=Pt(-1,-1,!0);Mt.MAX_UNSIGNED_VALUE=V$;var Hr=Pt(0,-2147483648,!1);Mt.MIN_VALUE=Hr;var ke=Mt.prototype;ke.toInt=function(){return this.unsigned?this.low>>>0:this.low};ke.toNumber=function(){return this.unsigned?(this.high>>>0)*Du+(this.low>>>0):this.high*Du+(this.low>>>0)};ke.toString=function(t){if(t=t||10,t<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Hr)){var e=Fs(t),n=this.div(e),r=n.mul(e).sub(this);return n.toString(t)+r.toInt().toString(t)}else return"-"+this.neg().toString(t);for(var s=Fs(ug(t,6),this.unsigned),a=this,i="";;){var o=a.div(s),l=a.sub(o.mul(s)).toInt()>>>0,u=l.toString(t);if(a=o,a.isZero())return u+i;for(;u.length<6;)u="0"+u;i=""+u+i}};ke.getHighBits=function(){return this.high};ke.getHighBitsUnsigned=function(){return this.high>>>0};ke.getLowBits=function(){return this.low};ke.getLowBitsUnsigned=function(){return this.low>>>0};ke.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Hr)?64:this.neg().getNumBitsAbs();for(var t=this.high!=0?this.high:this.low,e=31;e>0&&!(t&1<<e);e--);return this.high!=0?e+33:e+1};ke.isZero=function(){return this.high===0&&this.low===0};ke.eqz=ke.isZero;ke.isNegative=function(){return!this.unsigned&&this.high<0};ke.isPositive=function(){return this.unsigned||this.high>=0};ke.isOdd=function(){return(this.low&1)===1};ke.isEven=function(){return(this.low&1)===0};ke.equals=function(t){return rs(t)||(t=xa(t)),this.unsigned!==t.unsigned&&this.high>>>31===1&&t.high>>>31===1?!1:this.high===t.high&&this.low===t.low};ke.eq=ke.equals;ke.notEquals=function(t){return!this.eq(t)};ke.neq=ke.notEquals;ke.ne=ke.notEquals;ke.lessThan=function(t){return this.comp(t)<0};ke.lt=ke.lessThan;ke.lessThanOrEqual=function(t){return this.comp(t)<=0};ke.lte=ke.lessThanOrEqual;ke.le=ke.lessThanOrEqual;ke.greaterThan=function(t){return this.comp(t)>0};ke.gt=ke.greaterThan;ke.greaterThanOrEqual=function(t){return this.comp(t)>=0};ke.gte=ke.greaterThanOrEqual;ke.ge=ke.greaterThanOrEqual;ke.compare=function(t){if(rs(t)||(t=xa(t)),this.eq(t))return 0;var e=this.isNegative(),n=t.isNegative();return e&&!n?-1:!e&&n?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1};ke.comp=ke.compare;ke.negate=function(){return!this.unsigned&&this.eq(Hr)?Hr:this.not().add(mu)};ke.neg=ke.negate;ke.add=function(t){rs(t)||(t=xa(t));var e=this.high>>>16,n=this.high&65535,r=this.low>>>16,s=this.low&65535,a=t.high>>>16,i=t.high&65535,o=t.low>>>16,l=t.low&65535,u=0,c=0,h=0,d=0;return d+=s+l,h+=d>>>16,d&=65535,h+=r+o,c+=h>>>16,h&=65535,c+=n+i,u+=c>>>16,c&=65535,u+=e+a,u&=65535,Pt(h<<16|d,u<<16|c,this.unsigned)};ke.subtract=function(t){return rs(t)||(t=xa(t)),this.add(t.neg())};ke.sub=ke.subtract;ke.multiply=function(t){if(this.isZero())return Os;if(rs(t)||(t=xa(t)),_s){var e=_s.mul(this.low,this.high,t.low,t.high);return Pt(e,_s.get_high(),this.unsigned)}if(t.isZero())return Os;if(this.eq(Hr))return t.isOdd()?Hr:Os;if(t.eq(Hr))return this.isOdd()?Hr:Os;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(GI)&&t.lt(GI))return Fs(this.toNumber()*t.toNumber(),this.unsigned);var n=this.high>>>16,r=this.high&65535,s=this.low>>>16,a=this.low&65535,i=t.high>>>16,o=t.high&65535,l=t.low>>>16,u=t.low&65535,c=0,h=0,d=0,p=0;return p+=a*u,d+=p>>>16,p&=65535,d+=s*u,h+=d>>>16,d&=65535,d+=a*l,h+=d>>>16,d&=65535,h+=r*u,c+=h>>>16,h&=65535,h+=s*l,c+=h>>>16,h&=65535,h+=a*o,c+=h>>>16,h&=65535,c+=n*u+r*l+s*o+a*i,c&=65535,Pt(d<<16|p,c<<16|h,this.unsigned)};ke.mul=ke.multiply;ke.divide=function(t){if(rs(t)||(t=xa(t)),t.isZero())throw Error("division by zero");if(_s){if(!this.unsigned&&this.high===-2147483648&&t.low===-1&&t.high===-1)return this;var e=(this.unsigned?_s.div_u:_s.div_s)(this.low,this.high,t.low,t.high);return Pt(e,_s.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?jo:Os;var n,r,s;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return jo;if(t.gt(this.shru(1)))return W$;s=jo}else{if(this.eq(Hr)){if(t.eq(mu)||t.eq(D1))return Hr;if(t.eq(Hr))return mu;var a=this.shr(1);return n=a.div(t).shl(1),n.eq(Os)?t.isNegative()?mu:D1:(r=this.sub(t.mul(n)),s=n.add(r.div(t)),s)}else if(t.eq(Hr))return this.unsigned?jo:Os;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();s=Os}for(r=this;r.gte(t);){n=Math.max(1,Math.floor(r.toNumber()/t.toNumber()));for(var i=Math.ceil(Math.log(n)/Math.LN2),o=i<=48?1:ug(2,i-48),l=Fs(n),u=l.mul(t);u.isNegative()||u.gt(r);)n-=o,l=Fs(n,this.unsigned),u=l.mul(t);l.isZero()&&(l=mu),s=s.add(l),r=r.sub(u)}return s};ke.div=ke.divide;ke.modulo=function(t){if(rs(t)||(t=xa(t)),_s){var e=(this.unsigned?_s.rem_u:_s.rem_s)(this.low,this.high,t.low,t.high);return Pt(e,_s.get_high(),this.unsigned)}return this.sub(this.div(t).mul(t))};ke.mod=ke.modulo;ke.rem=ke.modulo;ke.not=function(){return Pt(~this.low,~this.high,this.unsigned)};ke.and=function(t){return rs(t)||(t=xa(t)),Pt(this.low&t.low,this.high&t.high,this.unsigned)};ke.or=function(t){return rs(t)||(t=xa(t)),Pt(this.low|t.low,this.high|t.high,this.unsigned)};ke.xor=function(t){return rs(t)||(t=xa(t)),Pt(this.low^t.low,this.high^t.high,this.unsigned)};ke.shiftLeft=function(t){return rs(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?Pt(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):Pt(0,this.low<<t-32,this.unsigned)};ke.shl=ke.shiftLeft;ke.shiftRight=function(t){return rs(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?Pt(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):Pt(this.high>>t-32,this.high>=0?0:-1,this.unsigned)};ke.shr=ke.shiftRight;ke.shiftRightUnsigned=function(t){if(rs(t)&&(t=t.toInt()),t&=63,t===0)return this;var e=this.high;if(t<32){var n=this.low;return Pt(n>>>t|e<<32-t,e>>>t,this.unsigned)}else return t===32?Pt(e,0,this.unsigned):Pt(e>>>t-32,0,this.unsigned)};ke.shru=ke.shiftRightUnsigned;ke.shr_u=ke.shiftRightUnsigned;ke.toSigned=function(){return this.unsigned?Pt(this.low,this.high,!1):this};ke.toUnsigned=function(){return this.unsigned?this:Pt(this.low,this.high,!0)};ke.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()};ke.toBytesLE=function(){var t=this.high,e=this.low;return[e&255,e>>>8&255,e>>>16&255,e>>>24,t&255,t>>>8&255,t>>>16&255,t>>>24]};ke.toBytesBE=function(){var t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,t&255,e>>>24,e>>>16&255,e>>>8&255,e&255]};Mt.fromBytes=function(t,e,n){return n?Mt.fromBytesLE(t,e):Mt.fromBytesBE(t,e)};Mt.fromBytesLE=function(t,e){return new Mt(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)};Mt.fromBytesBE=function(t,e){return new Mt(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)};const j$=Dv(z$),TB=CL({__proto__:null,default:j$},[z$]);/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Mo=j$||TB;function Zp(t){return Mo.fromString(t,!0,16)}const G$=Zp("c3a5c85c97cb3127"),Oo=Zp("b492b66fbe98f273"),ur=Zp("9ae16a3b2f90404f");function M1(t){return t.xor(t.shru(47))}function H$(t,e,n){const r=t.slice(e,e+n);return Mo.fromBytes(Array.from(r),!0,!0)}function Rt(t,e){return H$(t,e,8)}function HI(t,e){return H$(t,e,4)}function $n(t,e){return e===0?t:t.shru(e).or(t.shl(64-e))}function Ki(t,e,n=Zp("9ddfea08eb382d69")){let r=t.xor(e).mul(n);r=r.xor(r.shru(47));let s=e.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function EB(t,e,n,r,s,a){s=s.add(t),a=$n(a.add(s).add(r),21);const i=s;return s=s.add(e),s=s.add(n),a=a.add($n(s,44)),[s.add(r),a.add(i)]}function em(t,e,n,r){return EB(Rt(t,e),Rt(t,e+8),Rt(t,e+16),Rt(t,e+24),n,r)}function $B(t,e=t.length){if(e>=8){const n=ur.add(e*2),r=Rt(t,0).add(ur),s=Rt(t,e-8),a=$n(s,37).mul(n).add(r),i=$n(r,25).add(s).mul(n);return Ki(a,i,n)}if(e>=4){const n=ur.add(e*2),r=HI(t,0);return Ki(r.shl(3).add(e),HI(t,e-4),n)}if(e>0){const n=t[0],r=t[e>>1],s=t[e-1],a=n+(r<<8),i=e+(s<<2);return M1(ur.mul(a).xor(G$.mul(i))).mul(ur)}return ur}function RB(t,e=t.length){const n=ur.add(e*2),r=Rt(t,0).mul(Oo),s=Rt(t,8),a=Rt(t,e-8).mul(n),i=Rt(t,e-16).mul(ur);return Ki($n(r.add(s),43).add($n(a,30)).add(i),r.add($n(s.add(ur),18)).add(a),n)}function AB(t,e=t.length){const n=ur.add(e*2),r=Rt(t,0).mul(ur),s=Rt(t,8),a=Rt(t,e-8).mul(n),i=Rt(t,e-16).mul(ur),o=$n(r.add(s),43).add($n(a,30)).add(i),l=Ki(o,r.add($n(s.add(ur),18)).add(a),n),u=Rt(t,16).mul(n),c=Rt(t,24),h=o.add(Rt(t,e-32)).mul(n),d=l.add(Rt(t,e-24)).mul(n);return Ki($n(u.add(c),43).add($n(h,30)).add(d),u.add($n(c.add(r),18)).add(h),n)}function K$(t,e=t.length){const n=Mo.fromNumber(81,!0);if(e<=32)return e<=16?$B(t,e):RB(t,e);if(e<=64)return AB(t,e);let r=n,s=n.mul(Oo).add(113),a=M1(s.mul(ur).add(113)).mul(ur),i=[Mo.UZERO,Mo.UZERO],o=[Mo.UZERO,Mo.UZERO];r=r.mul(ur).add(Rt(t,0));let l=0;const u=(e-1>>6)*64,c=u+(e-1&63)-63;do r=$n(r.add(s).add(i[0]).add(Rt(t,l+8)),37).mul(Oo),s=$n(s.add(i[1]).add(Rt(t,l+48)),42).mul(Oo),r=r.xor(o[1]),s=s.add(i[0]).add(Rt(t,l+40)),a=$n(a.add(o[0]),33).mul(Oo),i=em(t,l,i[1].mul(Oo),r.add(o[0])),o=em(t,l+32,a.add(o[1]),s.add(Rt(t,l+16))),[a,r]=[r,a],l+=64;while(l!==u);const h=Oo.add(a.and(255).shl(1));return l=c,o[0]=o[0].add(e-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=$n(r.add(s).add(i[0]).add(Rt(t,l+8)),37).mul(h),s=$n(s.add(i[1]).add(Rt(t,l+48)),42).mul(h),r=r.xor(o[1].mul(9)),s=s.add(i[0].mul(9).add(Rt(t,l+40))),a=$n(a.add(o[0]),33).mul(h),i=em(t,l,i[1].mul(h),r.add(o[0])),o=em(t,l+32,a.add(o[1]),s.add(Rt(t,l+16))),[a,r]=[r,a],Ki(Ki(i[0],o[0],h).add(M1(s).mul(G$)).add(a),Ki(i[1],o[1],h).add(r),h)}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function vi(t,e){return e==="string"?za(t):go([t],e)}function _B(t,e){return t instanceof Float32Array&&e==="float32"||t instanceof Int32Array&&e==="int32"||t instanceof Uint8Array&&e==="bool"}function go(t,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=Wa(t)),Z().getBool("DEBUG")&&A$(t,e),_B(t,e))return t;if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool"){const n=new Uint8Array(t.length);for(let r=0;r<n.length;++r)Math.round(t[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${e}`)}function Ln(){return Z().platform.now()}function FB(t,e){return Z().platform.fetch(t,e)}function za(t,e="utf-8"){return e=e||"utf-8",Z().platform.encode(t,e)}function Vs(t,e="utf-8"){return e=e||"utf-8",Z().platform.decode(t,e)}function Zr(t){return Z().platform.isTypedArray!=null?Z().platform.isTypedArray(t):L$(t)}function Wa(t,e=[],n=!1){if(e==null&&(e=[]),typeof t=="boolean"||typeof t=="number"||typeof t=="string"||di(t)||t==null||Zr(t)&&n)e.push(t);else if(Array.isArray(t)||Zr(t))for(let r=0;r<t.length;++r)Wa(t[r],e,n);else{let r=-1;for(const s of Object.keys(t))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)Wa(t[s],e,n)}return e}const vke=Object.freeze(Object.defineProperty({__proto__:null,arraysEqual:Je,arraysEqualWithNull:R$,assert:R,assertNonNegativeIntegerDimensions:ns,assertNonNull:Il,assertShapesMatch:Dn,bytesFromStringArray:F$,bytesPerElement:xd,checkConversionForErrors:A$,clamp:Ji,computeStrides:Fe,convertBackendValuesAndArrayBuffer:Jh,createScalarValue:vi,createShuffledIndices:mB,decodeString:Vs,distSquared:pB,encodeString:za,fetch:FB,fingerPrint64:K$,flatten:Wa,getArrayFromDType:Ht,getTypedArrayFromDType:pn,hasEncodingLoss:sy,hexToLong:Zp,indexToLoc:Cl,inferDtype:mo,inferFromImplicitShape:ry,isBoolean:O$,isFunction:eo,isInt:il,isNumber:rg,isPromise:di,isScalarShape:_1,isString:Nl,isTypedArray:Zr,isValidDtype:_$,locToIndex:la,makeOnesTypedArray:ay,makeZerosNestedTypedArray:Fw,makeZerosTypedArray:Fn,nearestDivisor:sg,nearestLargerEven:ny,now:Ln,parseAxisParam:Ze,randUniform:dB,repeatedTry:F1,rightPad:Yo,shuffle:Aw,shuffleCombo:hB,sizeFromShape:Q,sizeToSquarishShape:ng,squeezeShape:xi,sum:_w,swap:ti,tanh:fB,toNestedArray:ds,toTypedArray:go},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class OB{constructor(e,n){this.backendTimer=e,this.logger=n,n==null&&(this.logger=new MB)}profileKernel(e,n,r){let s;const a=()=>{s=r()};let i;const o=Ln();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(a);else{a();for(const l of s)l.dataSync();i=Promise.resolve({kernelMs:Ln()-o})}if(Z().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<s.length;l++){const u=s[l];u.data().then(c=>{DB(c,u.dtype,e)})}return{kernelName:e,outputs:s,inputs:n,timeMs:i.then(l=>l.kernelMs),extraInfo:i.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:n,outputs:r,timeMs:s,inputs:a,extraInfo:i}=e;r.forEach(o=>{Promise.all([o.data(),s,i]).then(l=>{this.logger.logKernelProfile(n,o,l[0],l[1],a,l[2])})})}}function DB(t,e,n){if(e!=="float32")return!1;for(let r=0;r<t.length;r++){const s=t[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${n}'`),!0}return!1}class MB{logKernelProfile(e,n,r,s,a,i){const o=typeof s=="number"?Yo(`${s}ms`,9):s.error,l=Yo(e,25),u=n.rank,c=n.size,h=Yo(n.shape.toString(),14);let d="";for(const p in a){const f=a[p];if(f!=null){const m=f.shape||n.shape,y=m.length;d+=`${p}: ${y}D ${y>0?m:""} `}}console.log(`%c${l}	%c${o}	%c${u}D ${h}	%c${c}	%c${d}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function PB(t,e,n){const r={},s={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<t.length;l++){const u=t[l],c=u.inputs;for(const h in c){const d=c[h];let p=!1;for(let f=0;f<e.length;f++)if(r[d.id]){u.outputs.forEach(m=>r[m.id]=!0),p=!0,s[u.id]=!0;break}if(p)break}}const a={};a[n.id]=!0;const i={};for(let l=t.length-1;l>=0;l--){const u=t[l],c=u.inputs;for(let h=0;h<u.outputs.length;h++)if(a[u.outputs[h].id]){for(const d in c)a[c[d].id]=!0,i[u.id]=!0;break}}const o=[];for(let l=0;l<t.length;l++){const u=t[l];if(s[u.id]&&i[u.id]){const c={};for(const d in u.inputs){const p=u.inputs[d];r[p.id]&&(c[d]=p)}const h=Object.assign({},u);h.inputs=c,h.outputs=u.outputs,o.push(h)}}return o}function LB(t,e,n,r){for(let s=e.length-1;s>=0;s--){const a=e[s],i=[];if(a.outputs.forEach(l=>{const u=t[l.id];u!=null?i.push(u):i.push(null)}),a.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const o=a.gradient(i);for(const l in a.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);const u=n(()=>o[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=a.inputs[l];if(!Je(u.shape,c.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(t[c.id]==null)t[c.id]=u;else{const h=t[c.id];t[c.id]=r(h,u),h.dispose()}}}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const KI=20,Nh=3,mx=7;function zB(t,e,n,r){const s=Fe(e),a=BB(t,e,n,s),i=e.length,o=Sm(t,e,n,s,a),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(o.map(u=>"    "+u).join(`
`)),l.join(`
`)}function BB(t,e,n,r){const s=Q(e),a=r[r.length-1],i=new Array(a).fill(0),o=e.length,l=n==="complex64"?Dh(t):t;if(o>1)for(let u=0;u<s/a;u++){const c=u*a;for(let h=0;h<a;h++)i[h]=Math.max(i[h],Oh(l[c+h],0,n).length)}return i}function Oh(t,e,n){let r;return Array.isArray(t)?r=`${parseFloat(t[0].toFixed(mx))} + ${parseFloat(t[1].toFixed(mx))}j`:Nl(t)?r=`'${t}'`:n==="bool"?r=q$(t):r=parseFloat(t.toFixed(mx)).toString(),Yo(r,e)}function q$(t){return t===0?"false":"true"}function Sm(t,e,n,r,s,a=!0){const i=n==="complex64"?2:1,o=e[0],l=e.length;if(l===0){if(n==="complex64"){const m=Dh(t);return[Oh(m[0],0,n)]}return n==="bool"?[q$(t[0])]:[t[0].toString()]}if(l===1){if(o>KI){const m=Nh*i;let y=Array.from(t.slice(0,m)),g=Array.from(t.slice((o-Nh)*i,o*i));return n==="complex64"&&(y=Dh(y),g=Dh(g)),["["+y.map((b,v)=>Oh(b,s[v],n)).join(", ")+", ..., "+g.map((b,v)=>Oh(b,s[o-Nh+v],n)).join(", ")+"]"]}return["["+(n==="complex64"?Dh(t):Array.from(t)).map((m,y)=>Oh(m,s[y],n)).join(", ")+"]"]}const u=e.slice(1),c=r.slice(1),h=r[0]*i,d=[];if(o>KI){for(let m=0;m<Nh;m++){const y=m*h,g=y+h;d.push(...Sm(t.slice(y,g),u,n,c,s,!1))}d.push("...");for(let m=o-Nh;m<o;m++){const y=m*h,g=y+h;d.push(...Sm(t.slice(y,g),u,n,c,s,m===o-1))}}else for(let m=0;m<o;m++){const y=m*h,g=y+h;d.push(...Sm(t.slice(y,g),u,n,c,s,m===o-1))}const p=l===2?",":"";d[0]="["+(o>0?d[0]+p:"");for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=`,
`;for(let m=2;m<l;m++)f+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(a?"":f),d}function Dh(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class wn{constructor(e,n,r){if(this.dtype=n,this.shape=e.slice(),this.size=Q(e),r!=null){const s=r.length;R(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Ht(n,this.size),this.strides=Fe(e)}set(e,...n){n.length===0&&(n=[0]),R(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const r=this.locToIndex(n);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let n=0;for(const s of e){if(s<0||s>=this.shape[n]){const a=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(a)}n++}let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=this.strides[s]*e[s];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return n}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const n=new Array(this.shape.length);for(let r=0;r<n.length-1;++r)n[r]=Math.floor(e/this.strides[r]),e-=n[r]*this.strides[r];return n[n.length-1]=e,n}get rank(){return this.shape.length}toTensor(){return ra().makeTensor(this.values,this.shape,this.dtype)}}let ra=null,eu=null;function WB(t){ra=t}function UB(t){eu=t}class st{constructor(e,n,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=n||"float32",this.size=Q(e),this.strides=Fe(e),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return eu.buffer(this.shape,this.dtype,e)}bufferSync(){return eu.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return ds(this.shape,e,this.dtype==="complex64")}arraySync(){return ds(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=ra().read(this.dataId);if(this.dtype==="string"){const n=await e;try{return n.map(r=>Vs(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),ra().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=ra().readSync(this.dataId);if(this.dtype==="string")try{return e.map(n=>Vs(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await ra().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),ra().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return eu.print(this,e)}clone(){return this.throwIfDisposed(),eu.clone(this)}toString(e=!1){const n=this.dataSync();return zB(n,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),eu.cast(this,e)}variable(e=!0,n,r){return this.throwIfDisposed(),ra().makeVariable(this,e,n,r)}}Object.defineProperty(st,Symbol.hasInstance,{value:t=>!!t&&t.data!=null&&t.dataSync!=null&&t.throwIfDisposed!=null});function se(){return Ow("Tensor",()=>st)}se();class cg extends st{constructor(e,n,r,s){super(e.shape,e.dtype,e.dataId,s),this.trainable=n,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Je(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);ra().disposeTensor(this),this.dataId=e.dataId,ra().incRef(this,null)}dispose(){ra().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(cg,Symbol.hasInstance,{value:t=>t instanceof st&&t.assign!=null&&t.assign instanceof Function});/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/var qI;(function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"})(qI||(qI={}));var P1;(function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"})(P1||(P1={}));var L1;(function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"})(L1||(L1={}));var z1;(function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"})(z1||(z1={}));var B1;(function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"})(B1||(B1={}));const VB={float32:z1,int32:P1,bool:L1,complex64:B1};function On(t,e){if(t==="string"||e==="string"){if(t==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return VB[t][e]}function ab(t){return On(t,"int32")}function X$(t){return t!=null&&typeof t=="object"&&"texture"in t&&t.texture instanceof WebGLTexture}function Y$(t){return typeof GPUBuffer<"u"&&t!=null&&typeof t=="object"&&"buffer"in t&&t.buffer instanceof GPUBuffer}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Xt(t,e){if(t.dtype===e.dtype)return[t,e];const n=On(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function Q$(t,e){R(t.dtype===e.dtype,()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`)}function ib(t,e){return e.some(n=>n.id===t.id)}function pi(t){const e=[];return Z$(t,e,new Set),e}function Z$(t,e,n){if(t==null)return;if(t instanceof st){e.push(t);return}if(!jB(t))return;const r=t;for(const s in r){const a=r[s];n.has(a)||(n.add(a),Z$(a,e,n))}}function jB(t){return Array.isArray(t)||typeof t=="object"}const wke=Object.freeze(Object.defineProperty({__proto__:null,assertTypesMatch:Q$,getTensorsInContainer:pi,isTensorInList:ib,makeTypesMatch:Xt},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function gx(t){return t.kernelName!=null}class XI{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Mu{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new XI}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const r=e[n];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:n}=this.initializeBackend(e);if(n)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,n,r=1){return e in this.registryFactory?(is(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:n,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:n,asyncInit:r}=this.initializeBackend(e);if(!(r?await n:n))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new OB(this.backendInstance),!0}setupRegisteredKernels(){O1(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){O1(e).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[e])})}initializeBackend(e){const n=this.registryFactory[e];if(n==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=n.factory();if(r&&!(r instanceof ty)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,a=r.then(i=>s<this.pendingBackendInitId?!1:(this.registry[e]=i,this.pendingBackendInit=null,!0)).catch(i=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,is(`Initialization of backend ${e} failed`),is(i.stack||i.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return is(`Initialization of backend ${e} failed`),is(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,n)=>this.registryFactory[n].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const r=e[n],{success:s,asyncInit:a}=this.initializeBackend(r);if(a||s)return{name:r,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,n){const r=this.state.tensorInfo.get(n),s=r.backend,a=this.readSync(n),i=s.refCount(n);s.disposeData(n,!0),r.backend=e,e.move(n,a,r.shape,r.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,n){let r=null;if(n==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");n=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=n(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,n,r){e();try{const s=r();return n(),s}catch(s){throw n(),s}}nextTensorId(){return Mu.nextTensorId++}nextVariableId(){return Mu.nextVariableId++}clone(e){const n=B.runKernel(gc,{x:e}),r={x:e},s=i=>({x:()=>{const o="float32",l={x:i},u={dtype:o};return B.runKernel(rc,l,u)}}),a=[];return this.addTapeNode(this.state.activeScope.name,r,[n],s,a,{}),n}runKernel(e,n,r){if(this.backendName==null&&this.backend,lg(e,this.backendName)==null)throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:n,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,n,r){const s=this.backend.numDataIds();let a=0;r.forEach(l=>{a+=l.dtype==="complex64"?3:1});const i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=s-n-a-i;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`)}runKernelFunc(e){let n,r=[];const s=this.isTapeOn(),a=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let l;const u=gx(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(gx(e)){const{kernelName:f,inputs:m,attrs:y}=e;this.backendName==null&&this.backend;const g=lg(f,this.backendName);R(g!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),o=()=>{const b=this.backend.numDataIds();l=g.kernelFunc({inputs:m,attrs:y,backend:this.backend});const v=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,b,v);const w=v.map(k=>k.rank!=null?k:this.makeTensorFromTensorInfo(k));if(s){const k=this.getTensorsForGradient(f,m,w);r=this.saveTensorsForBackwardMode(k)}return w}}else{const{forwardFunc:f}=e,m=y=>{s&&(r=y.map(g=>this.keep(this.clone(g))))};o=()=>{const y=this.backend.numDataIds();l=this.tidy(()=>f(this.backend,m));const g=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,y,g),g}}const{inputs:c,attrs:h}=e,d=gx(e)?null:e.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=o():(p=this.profiler.profileKernel(u,c,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),n=p.outputs)}),s&&this.addTapeNode(u,c,n,d,r,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(f=>c[f]!=null?c[f].shape:null),outputShapes:n.map(f=>f.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(e){return e.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(e,n,r){const s=BI(e);if(s!=null){const a=s.inputsToSave||[],i=s.outputsToSave||[];let o;s.saveAllInputs?(R(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(n).map(u=>n[u])):o=a.map(u=>n[u]);const l=r.filter((u,c)=>i[c]);return o.concat(l)}return[]}makeTensor(e,n,r,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let a=e;r==="string"&&Nl(e[0])&&(a=e.map(l=>za(l)));const i=s.write(a,n,r),o=new st(n,r,i,this.nextTensorId());if(this.trackTensor(o,s),r==="string"){const l=this.state.tensorInfo.get(i),u=F$(a);this.state.numBytes+=u-l.bytes,l.bytes=u}return o}makeTensorFromDataId(e,n,r,s){r=r||"float32";const a={dataId:e,shape:n,dtype:r};return this.makeTensorFromTensorInfo(a,s)}makeTensorFromTensorInfo(e,n){const{dataId:r,shape:s,dtype:a}=e,i=new st(s,a,r,this.nextTensorId());return this.trackTensor(i,n),i}makeVariable(e,n=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));const a=new cg(e,n,r,this.nextTensorId());if(this.state.registeredVariables[a.name]!=null)throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,n){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*xd(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:n||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof cg||this.track(e)}incRef(e,n){this.trackTensor(e,n),this.backend.incRef(e.dataId)}removeDataId(e,n){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===n&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const n=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*xd(e.dtype);this.state.numBytes-=r}n.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,n.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const n=this.state.registeredVariables[e];this.disposeVariable(n)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const n=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,n,r,s,a,i){const o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:n,outputs:r,saved:a},l=BI(e);l!=null&&(s=l.gradFunc),s!=null&&(o.gradient=u=>(u=u.map((c,h)=>{if(c==null){const d=r[h],p=Fn(d.size,d.dtype);return this.makeTensor(p,d.shape,d.dtype)}return c}),s(u.length>1?u:u[0],a,i))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(n.name=e),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(e){const n=pi(e),r=new Set(n.map(a=>a.id));for(let a=0;a<this.state.activeScope.track.length;a++){const i=this.state.activeScope.track[a];!i.kept&&!r.has(i.id)&&i.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(a=>{!a.kept&&a.scopeId===s.id&&this.track(a)})}gradients(e,n,r,s=!1){if(R(n.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));R(a instanceof st,()=>"The result y returned by f() must be a tensor.");const i=PB(this.state.activeTape,n,a);if(!s&&i.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const o={};o[a.id]=r??GB(a.shape),LB(o,i,u=>this.tidy(u),HB);const l=n.map(u=>o[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(const c of u.saved)c.dispose()}),this.state.activeTape=null),{value:a,grads:l}})}customGrad(e){return R(eo(e),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{R(n.every(o=>o instanceof st),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};n.forEach((o,l)=>{s[l]=o});const a=(o,l)=>(r=e(...n,l),R(r.value instanceof st,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),R(eo(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),i=(o,l)=>{const u=r.gradFunc(o,l),c=Array.isArray(u)?u:[u];R(c.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),R(c.every(d=>d instanceof st),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return c.forEach((d,p)=>{h[p]=()=>d}),h};return this.runKernelFunc({forwardFunc:a,backwardsFunc:i,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,n){return this.state.tensorInfo.get(e).backend.readToGPU(e,n)}async time(e){const n=Ln(),r=await this.backend.time(e);return r.wallMs=Ln()-n,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new XI;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Mu.nextTensorId=0;Mu.nextVariableId=0;function GB(t){const e=ay(Q(t),"float32");return B.makeTensor(e,t,"float32")}function J$(){const t=P$();if(t._tfengine==null){const e=new gB(t);t._tfengine=new Mu(e)}return vB(t._tfengine.ENV),WB(()=>t._tfengine),t._tfengine}const B=J$();function HB(t,e){const n={a:t,b:e};return B.runKernel(Tl,n)}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function KB(){return typeof navigator<"u"&&navigator!=null}let W1;function qB(t){W1=t}function Hw(t){if(W1!==void 0)return W1;if(t||KB()){if(t||(t=navigator),t.product==="ReactNative")return!0;const e=t.userAgent||t.vendor||(typeof window<"u"?window.opera:"");if(!e){const n=t;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function Kw(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const kke=Object.freeze(Object.defineProperty({__proto__:null,isBrowser:Kw,isMobile:Hw,mockIsMobile:qB},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Nr=Z();Nr.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Nr.registerFlag("IS_BROWSER",()=>Kw());Nr.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Nr.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Nr.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Nr.registerFlag("PROD",()=>!1);Nr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Nr.getBool("DEBUG"));Nr.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Nr.registerFlag("IS_TEST",()=>!1);Nr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Nr.getBool("DEBUG"));Nr.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Nr.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Nr.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function yo(t,e){let n=t;if(Zr(t))return e==="string"?[]:[t.length];if(X$(t)){const s=t.channels||"RGBA";return[t.height,t.width*s.length]}else if(Y$(t))return[t.buffer.size/(e==null?4:xd(e))];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||Zr(n)&&e!=="string";)r.push(n.length),n=n[0];return Array.isArray(t)&&Z().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&eR(t,r,[]),r}function eR(t,e,n){if(n=n||[],!Array.isArray(t)&&!Zr(t)){R(e.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}R(e.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`),R(t.length===e[0],()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);const r=e.slice(1);for(let s=0;s<t.length;++s)eR(t[s],r,n.concat(s))}function YI(t,e,n,r){if(t!=="string_or_numeric"){if(t==null)throw new Error("Expected dtype cannot be null.");if(t!=="numeric"&&t!==e||t==="numeric"&&e==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}}function F(t,e,n,r="numeric"){if(t instanceof se())return YI(r,t.dtype,e,n),t;let s=mo(t);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),YI(r,s,e,n),t==null||!Zr(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string"){const o=t==null?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${o}'`)}const a=yo(t,s);!Zr(t)&&!Array.isArray(t)&&(t=[t]);const i=s!=="string"?go(t,s):Wa(t,[],!0);return B.makeTensor(i,a,s)}function Id(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((s,a)=>F(s,`${e}[${a}]`,n,r))}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const tR="__op";function U(t){const e=Object.keys(t);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+tR;const s=(...a)=>{B.startScope(n);try{const i=r(...a);return di(i)&&console.error("Cannot return a Promise inside of tidy."),B.endScope(i),i}catch(i){throw B.endScope(null),i}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function XB(t,e){const n=F(t,"real","complex"),r=F(e,"imag","complex");Dn(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:n,imag:r};return B.runKernel(py,s)}const to=U({complex_:XB});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function bo(t,e,n,r){if(r==null)r=mo(t);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Y$(t)||X$(t)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return B.backend.createTensorFromGPUData(t,e||n,r)}if(!Zr(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){ns(e);const s=Q(e),a=Q(n);R(s===a,()=>`Based on the provided shape, [${e}], the tensor should have ${s} values but has ${a}`);for(let i=0;i<n.length;++i){const o=n[i],l=i===n.length-1?o!==Q(e.slice(i)):!0;R(n[i]===e[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return!Zr(t)&&!Array.isArray(t)&&(t=[t]),e=e||n,t=r!=="string"?go(t,r):Wa(t,[],!0),B.makeTensor(t,e,r)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ls(t,e,n){const r=yo(t,n);return bo(t,e,r,n)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ol={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class va{static join(e){return new va(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(r=>Zr(r)?r.buffer:r),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let n=0;for(let r=0;r<e.length;r++){const s=e[r];r!==e.length-1&&s.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const a=n+s.byteLength;this.shards.push({buffer:s,start:n,end:a}),n=a}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,n=isNaN(Number(n))?0:n,e=Math.max(0,e),n=Math.min(this.byteLength,n),n<=e)return new ArrayBuffer(0);const r=this.findShardForByte(e);if(r===-1)throw new Error(`Could not find start shard for byte ${e}`);const s=n-e,a=new ArrayBuffer(s),i=new Uint8Array(a);let o=0;for(let l=r;l<this.shards.length;l++){const u=this.shards[l],c=e+o-u.start,h=o,d=Math.min(n,u.end)-u.start,p=new Uint8Array(u.buffer,c,d-c);if(i.set(p,h),o+=p.length,n<u.end)break}return a}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function n(s){return e<s.start?-1:e>=s.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const r=YB(this.shards,n);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}}function YB(t,e){let n=0,r=t.length;for(;n<=r;){const s=Math.floor((r-n)/2)+n,a=e(t[s]);if(a===0)return s;a<0?r=s:n=s+1}return-1}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ske(){Z().set("PROD",!0)}function Ike(){Z().set("DEBUG",!0)}function Nke(){Z().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function Cke(t){Z().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function Tke(){B.disposeVariables()}function ir(){return B}function QI(){return B.memory()}function Eke(t){return B.profile(t)}function Y(t,e){return B.tidy(t,e)}function Pe(t){pi(t).forEach(e=>e.dispose())}function An(t){return B.keep(t)}function $ke(t){return B.time(t)}function Rke(t){return B.setBackend(t)}function QB(){return B.ready()}function Nd(){return B.backendName}function Ake(t){B.removeBackend(t)}function _ke(t){return B.findBackend(t)}function Fke(t){return B.findBackendFactory(t)}function qw(t,e,n=1){return B.registerBackend(t,e,n)}function ll(){return B.backend}function Oke(t,e){Z().setPlatform(t,e)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const no=4;async function U1(t,e){const n=[],r=[],s=Array.isArray(t)?t.map(i=>i.name):Object.keys(t);for(let i=0;i<s.length;++i){const o=s[i],l=Array.isArray(t)?t[i].tensor:t[o];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);const u={name:o,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const c=new Promise(async h=>{const d=await l.bytes(),p=d.reduce((y,g)=>y+g.length,0)+no*d.length,f=new Uint8Array(p);let m=0;for(let y=0;y<d.length;y++){const g=d[y],b=new Uint8Array(new Uint32Array([g.length]).buffer);f.set(b,m),m+=no,f.set(g,m),m+=g.length}h(f)});r.push(c)}else r.push(l.data());e!=null&&(u.group=e),n.push(u)}const a=await Promise.all(r);return{data:eW(a),specs:n}}function Xw(t,e){const n=new va(t),r={};let s=0;for(const a of e){const i=ZB(a,(o,l)=>n.slice(s+o,s+l));r[a.name]=nR(a,n.slice(s,s+i)),s+=i}return r}function ZB(t,e){const n=Q(t.shape);let r;if("quantization"in t){const s=t.quantization;r=ol[s.dtype]}else if(t.dtype==="string"){let s=0;for(let a=0;a<n;a++)s+=no+new Uint32Array(e(s,s+no))[0];return s}else r=ol[t.dtype];return n*r}async function JB(t,e){const n=Q(t.shape);let r;if("quantization"in t){const s=t.quantization;r=ol[s.dtype]}else if(t.dtype==="string"){let s=0;for(let a=0;a<n;a++)s+=no+new Uint32Array(await e(s,s+no))[0];return s}else r=ol[t.dtype];return n*r}function nR(t,e){const n=t.name,r=t.dtype,s=t.shape,a=Q(s);let i,o=0;if("quantization"in t){const l=t.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${t.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(r!=="float32")throw new Error(`Weight ${t.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${r}.`)}else throw new Error(`Weight ${t.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const u=ol[l.dtype],c=l.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(r==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){i=new Float32Array(c.length);for(let h=0;h<c.length;h++){const d=c[h];i[h]=d*l.scale+l.min}}else if(l.dtype==="float16")i=iW()(c);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(r==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);i=new Int32Array(c.length);for(let h=0;h<c.length;h++){const d=c[h];i[h]=Math.round(d*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);o+=a*u}else if(r==="string"){const l=Q(t.shape);i=[];for(let u=0;u<l;u++){const c=new Uint32Array(e.slice(o,o+no))[0];o+=no;const h=new Uint8Array(e.slice(o,o+c));i.push(h),o+=c}}else{const l=ol[r];if(r==="float32")i=new Float32Array(e);else if(r==="int32")i=new Int32Array(e);else if(r==="bool")i=new Uint8Array(e);else if(r==="complex64"){i=new Float32Array(e);const u=new Float32Array(i.length/2),c=new Float32Array(i.length/2);for(let f=0;f<u.length;f++)u[f]=i[f*2],c[f]=i[f*2+1];const h=Ls(u,s,"float32"),d=Ls(c,s,"float32"),p=to(h,d);return h.dispose(),d.dispose(),p}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);o+=a*l}return Ls(i,s,r)}async function ZI(t,e,n){let r=new Uint8Array(e);for(;r.byteLength<n;){const{done:s,value:a}=await t.read();if(s&&a==null){const o=n-r.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}const i=new Uint8Array(r.length+a.byteLength);i.set(r,0),i.set(new Uint8Array(a),r.length),r=i}return r.buffer}async function rR(t,e){const n={},r=t.getReader();let s=new ArrayBuffer(0);for(const a of e){const i=await JB(a,async(u,c)=>(s=await ZI(r,s,c),s.slice(u,c)));s=await ZI(r,s,i);const o=s.slice(0,i);s=s.slice(i);const l=nR(a,o);if(n[a.name]=l,Nd()==="webgpu"){const u=ll();"uploadToGPU"in u&&Q(l.shape)>=Z().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&u.uploadToGPU(l.dataId)}}return n}function eW(t){if(t===null)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach(a=>{if(e+=a.byteLength,n.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});const r=new Uint8Array(e);let s=0;return n.forEach(a=>{r.set(new Uint8Array(a.buffer),s),s+=a.byteLength}),r.buffer}const Yw=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function JI(t){return Yw?Buffer.byteLength(t,"utf8"):new Blob([t]).size}function tW(t){if(Yw)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let r=0,s=e.length;r<s;r++)n+=String.fromCharCode(e[r]);return btoa(n)}function nW(t){if(Yw){const r=Buffer.from(t,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)n.set([e.charCodeAt(r)],r);return n.buffer}function sR(t){return va.join(t)}function eN(t){const e="/";for(t=t.trim();t.endsWith(e);)t=t.slice(0,t.length-1);const n=t.split(e);return n[n.length-1]}function aR(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return t.signature!=null&&(n.signature=t.signature),t.userDefinedMetadata!=null&&(n.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(n.modelInitializer=t.modelInitializer),t.initializerSignature!=null&&(n.initializerSignature=t.initializerSignature),t.trainingConfig!=null&&(n.trainingConfig=t.trainingConfig),n}function Qw(t,e,n){const r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(t.trainingConfig!=null&&(r.trainingConfig=t.trainingConfig),t.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=n}return t.signature!=null&&(r.signature=t.signature),t.userDefinedMetadata!=null&&(r.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(r.modelInitializer=t.modelInitializer),t.initializerSignature!=null&&(r.initializerSignature=t.initializerSignature),r}async function Zw(t,e){let n,r;return t.weightsManifest!=null&&([n,r]=await e(t.weightsManifest)),Qw(t,n,r)}function Jp(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:t.modelTopology==null?0:JI(JSON.stringify(t.modelTopology)),weightSpecsBytes:t.weightSpecs==null?0:JI(JSON.stringify(t.weightSpecs)),weightDataBytes:t.weightData==null?0:new va(t.weightData).byteLength}}function hg(t){const e=[];for(const n of t)e.push(...n.weights);return e}function rW(){const t=n=>{let r=n<<13,s=0;for(;!(r&8388608);)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}function sW(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}function aW(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}function iW(){const t=rW(),e=sW(),n=aW();return r=>{const s=new ArrayBuffer(4*r.length),a=new Uint32Array(s);for(let i=0;i<r.length;i++){const o=r[i],l=t[n[o>>10]+(o&1023)]+e[o>>10];a[i]=l}return new Float32Array(s)}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class jt{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return jt.instance==null&&(jt.instance=new jt),jt.instance}static registerSaveRouter(e){jt.getInstance().saveRouters.push(e)}static registerLoadRouter(e){jt.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return jt.getHandlers(e,"save")}static getLoadHandlers(e,n){return jt.getHandlers(e,"load",n)}static getHandlers(e,n,r){const s=[];return(n==="load"?jt.getInstance().loadRouters:jt.getInstance().saveRouters).forEach(a=>{const i=a(e,r);i!==null&&s.push(i)}),s}}const oW=t=>jt.registerSaveRouter(t),lW=t=>jt.registerLoadRouter(t),iR=t=>jt.getSaveHandlers(t),oR=(t,e)=>jt.getLoadHandlers(t,e);/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const V1="tensorflowjs",j1=1,Go="models_store",Oi="model_info_store";function lR(){if(!Z().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t=typeof window>"u"?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function G1(t){const e=t.result;e.createObjectStore(Go,{keyPath:"modelPath"}),e.createObjectStore(Oi,{keyPath:"modelPath"})}class ul{constructor(e){if(this.indexedDB=lR(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,n){return new Promise((r,s)=>{const a=this.indexedDB.open(V1,j1);a.onupgradeneeded=()=>G1(a),a.onsuccess=()=>{const i=a.result;if(n==null){const o=i.transaction(Go,"readonly"),l=o.objectStore(Go).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return i.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(l.result.modelArtifacts)},l.onerror=u=>(i.close(),s(l.error)),o.oncomplete=()=>i.close()}else{n.weightData=va.join(n.weightData);const o=Jp(n),l=i.transaction(Oi,"readwrite");let u=l.objectStore(Oi),c;try{c=u.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(d){return s(d)}let h;c.onsuccess=()=>{h=i.transaction(Go,"readwrite");const d=h.objectStore(Go);let p;try{p=d.put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:o})}catch(f){return s(f)}p.onsuccess=()=>r({modelArtifactsInfo:o}),p.onerror=f=>{u=l.objectStore(Oi);const m=u.delete(this.modelPath);m.onsuccess=()=>(i.close(),s(p.error)),m.onerror=y=>(i.close(),s(p.error))}},c.onerror=d=>(i.close(),s(c.error)),l.oncomplete=()=>{h==null?i.close():h.oncomplete=()=>i.close()}}},a.onerror=i=>s(a.error)})}}ul.URL_SCHEME="indexeddb://";const uR=t=>Z().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(ul.URL_SCHEME)?uW(t.slice(ul.URL_SCHEME.length)):null;jt.registerSaveRouter(uR);jt.registerLoadRouter(uR);function uW(t){return new ul(t)}function cW(t){return t.startsWith(ul.URL_SCHEME)?t.slice(ul.URL_SCHEME.length):t}class hW{constructor(){this.indexedDB=lR()}async listModels(){return new Promise((e,n)=>{const r=this.indexedDB.open(V1,j1);r.onupgradeneeded=()=>G1(r),r.onsuccess=()=>{const s=r.result,a=s.transaction(Oi,"readonly"),i=a.objectStore(Oi).getAll();i.onsuccess=()=>{const o={};for(const l of i.result)o[l.modelPath]=l.modelArtifactsInfo;e(o)},i.onerror=o=>(s.close(),n(i.error)),a.oncomplete=()=>s.close()},r.onerror=s=>n(r.error)})}async removeModel(e){return e=cW(e),new Promise((n,r)=>{const s=this.indexedDB.open(V1,j1);s.onupgradeneeded=()=>G1(s),s.onsuccess=()=>{const a=s.result,i=a.transaction(Oi,"readwrite"),o=i.objectStore(Oi),l=o.get(e);let u;l.onsuccess=()=>{if(l.result==null)return a.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const c=o.delete(e),h=()=>{u=a.transaction(Go,"readwrite");const d=u.objectStore(Go).delete(e);d.onsuccess=()=>n(l.result.modelArtifactsInfo),d.onerror=p=>r(l.error)};c.onsuccess=h,c.onerror=d=>(h(),a.close(),r(l.error))}},l.onerror=c=>(a.close(),r(l.error)),i.oncomplete=()=>{u==null?a.close():u.oncomplete=()=>a.close()}},s.onerror=a=>r(s.error)})}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ni="/",tu="tensorflowjs_models",cR="info",dW="model_topology",pW="weight_specs",fW="weight_data",mW="model_metadata";function hR(t){return{info:[tu,t,cR].join(ni),topology:[tu,t,dW].join(ni),weightSpecs:[tu,t,pW].join(ni),weightData:[tu,t,fW].join(ni),modelMetadata:[tu,t,mW].join(ni)}}function dR(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function gW(t){const e=t.split(ni);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(ni)}function yW(t){return t.startsWith(cl.URL_SCHEME)?t.slice(cl.URL_SCHEME.length):t}class cl{constructor(e){if(!Z().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=hR(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=Jp(e),a=va.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,tW(a));const i={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(i)),{modelArtifactsInfo:s}}catch{throw dR(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=r;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=s;const a=this.LS.getItem(this.keys.modelMetadata);if(a!=null){const o=JSON.parse(a);n.format=o.format,n.generatedBy=o.generatedBy,n.convertedBy=o.convertedBy,o.signature!=null&&(n.signature=o.signature),o.userDefinedMetadata!=null&&(n.userDefinedMetadata=o.userDefinedMetadata),o.modelInitializer!=null&&(n.modelInitializer=o.modelInitializer),o.initializerSignature!=null&&(n.initializerSignature=o.initializerSignature),o.trainingConfig!=null&&(n.trainingConfig=o.trainingConfig)}const i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=nW(i),n}}cl.URL_SCHEME="localstorage://";const pR=t=>Z().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(cl.URL_SCHEME)?bW(t.slice(cl.URL_SCHEME.length)):null;jt.registerSaveRouter(pR);jt.registerLoadRouter(pR);function bW(t){return new cl(t)}class xW{constructor(){R(Z().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),R(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},n=tu+ni,r=ni+cR;for(let s=0;s<this.LS.length;++s){const a=this.LS.key(s);if(a.startsWith(n)&&a.endsWith(r)){const i=gW(a);e[i]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){e=yW(e);const n=hR(e);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return dR(n),r}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ku="://";class or{constructor(){this.managers={}}static getInstance(){return or.instance==null&&(or.instance=new or),or.instance}static registerManager(e,n){R(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(ku)&&(e=e.slice(0,e.indexOf(ku))),R(e.length>0,()=>"scheme must not be an empty string.");const r=or.getInstance();R(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=n}static getManager(e){const n=or.getInstance().managers[e];if(n==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return n}static getSchemes(){return Object.keys(or.getInstance().managers)}}function Im(t){if(t.indexOf(ku)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${or.getSchemes().join(",")}`);return{scheme:t.split(ku)[0],path:t.split(ku)[1]}}async function fR(t,e,n=!1){R(t!==e,()=>`Old path and new path are the same: '${t}'`);const r=jt.getLoadHandlers(t);R(r.length>0,()=>`Copying failed because no load handler is found for source URL ${t}.`),R(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${t}.`);const s=r[0],a=jt.getSaveHandlers(e);R(a.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),R(a.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);const i=a[0],o=Im(t).scheme,l=Im(t).path,u=o===Im(t).scheme,c=await s.load();n&&u&&await or.getManager(o).removeModel(l);const h=await i.save(c);return n&&!u&&await or.getManager(o).removeModel(l),h.modelArtifactsInfo}async function vW(){const t=or.getSchemes(),e={};for(const n of t){const r=await or.getManager(n).listModels();for(const s in r){const a=n+ku+s;e[a]=r[s]}}return e}async function wW(t){const e=Im(t);return or.getManager(e.scheme).removeModel(e.path)}async function kW(t,e){return fR(t,e,!1)}async function SW(t,e){return fR(t,e,!0)}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class IW{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,n){return fetch(e,n)}now(){return performance.now()}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,n){return new TextDecoder(n).decode(e)}setTimeoutCustom(e,n){if(typeof window>"u"||!Z().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,n);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},n),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();const s=this.functionRefs[r.data.index];s(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return L$(e)}}if(Z().get("IS_BROWSER")){Z().setPlatform("browser",new IW);try{or.registerManager(cl.URL_SCHEME,new xW)}catch{}try{or.registerManager(ul.URL_SCHEME,new hW)}catch{}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const NW={importFetch:()=>require("node-fetch")};let yx;class CW{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,n){return Z().global.fetch!=null?Z().global.fetch(e,n):(yx==null&&(yx=NW.importFetch()),yx(e,n))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(e)}decode(e,n){return e.length===0?"":new this.util.TextDecoder(n).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}Z().get("IS_NODE")&&!Z().get("IS_BROWSER")&&Z().setPlatform("node",new CW);/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Qe(t,e="float32",n){return e=e||"float32",ns(t),new wn(t,e,n)}/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function TW(t,e){const n=F(t,"x","cast");if(!_$(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&n.dtype!=="string"||e!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:e};return B.runKernel(rc,r,s)}const me=U({cast_:TW});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function EW(t){const e={x:F(t,"x","clone","string_or_numeric")};return B.runKernel(gc,e)}const ii=U({clone_:EW});/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function mR(t,e=!1){console.log(t.toString(e))}/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/J$();const $W={buffer:Qe,cast:me,clone:ii,print:mR};UB($W);/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function RW(t,e){let n=F(t,"a","add"),r=F(e,"b","add");[n,r]=Xt(n,r);const s={a:n,b:r};return B.runKernel(Tl,s)}const ie=U({add_:RW});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function AW(t,e){let n=F(t,"a","floorDiv"),r=F(e,"b","floorDiv");[n,r]=Xt(n,r);const s={a:n,b:r};return B.runKernel(fc,s)}const Jw=U({floorDiv_:AW});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _W(t,e){let n=F(t,"a","div"),r=F(e,"b","div");if([n,r]=Xt(n,r),n.dtype==="int32"&&r.dtype==="int32")return Jw(n,r);const s={a:n,b:r},a={};return B.runKernel(lc,s,a)}const Se=U({div_:_W});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function FW(t,e){let n=F(t,"a","mul"),r=F(e,"b","mul");[n,r]=Xt(n,r);const s={a:n,b:r};return B.runKernel(Nc,s)}const z=U({mul_:FW});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function OW(t){const e=F(t,"x","abs");if(e.dtype==="complex64"){const n={x:e};return B.runKernel(ap,n)}else{const n={x:e};return B.runKernel(Qd,n)}}const yn=U({abs_:OW});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function DW(t){const e={x:F(t,"x","acos")};return B.runKernel(Yu,e)}const gR=U({acos_:DW});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function MW(t){const e={x:F(t,"x","acosh")};return B.runKernel(Qu,e)}const yR=U({acosh_:MW});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function PW(t){R(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),R(t.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`);const e=t.map((s,a)=>F(s,`tensors${a}`,"addN")),n=e[0];e.forEach(s=>{if(s.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(s=>{if(!Je(s.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=e;return B.runKernel(Zd,r)}const LW=U({addN_:PW});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zW(t,e=null,n=!1){const r={x:F(t,"x","all","bool")},s={axis:e,keepDims:n};return B.runKernel(iy,r,s)}const ek=U({all_:zW});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function BW(t,e=null,n=!1){const r={x:F(t,"x","any","bool")},s={axis:e,keepDims:n};return B.runKernel(oy,r,s)}const dg=U({any_:BW});/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function WW(t,e=0){const n={x:F(t,"x","argMax")},r={axis:e};return B.runKernel(Jd,n,r)}const hl=U({argMax_:WW});/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function UW(t,e=0){const n={x:F(t,"x","argMin")},r={axis:e};return B.runKernel(ep,n,r)}const bR=U({argMin_:UW});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function VW(t){const e={x:F(t,"x","asin")};return B.runKernel(Zu,e)}const xR=U({asin_:VW});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function jW(t){const e={x:F(t,"x","asinh")};return B.runKernel(Ju,e)}const vR=U({asinh_:jW});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function GW(t){const e={x:F(t,"x","atan")};return B.runKernel(ec,e)}const wR=U({atan_:GW});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function HW(t,e){let n=F(t,"a","atan2"),r=F(e,"b","atan2");[n,r]=Xt(n,r);const s={a:n,b:r};return B.runKernel(nc,s)}const kR=U({atan2_:HW});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function KW(t){const e={x:F(t,"x","atanh")};return B.runKernel(tc,e)}const SR=U({atanh_:KW});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function xo(t,e,n,r,s="NHWC",a){const i=t[3],o=[...e,i],l=ss(s);return _t(t,o,n,a,r,null,null,l)}function er(t,e,n,r,s,a,i="channelsLast"){const[o,l]=Cd(e);let u;if(i==="channelsLast")u=[o,l,t[3],t[3]];else if(i==="channelsFirst")u=[o,l,t[1],t[1]];else throw new Error(`Unknown dataFormat ${i}`);return _t(t,u,n,r,s,a,!1,i)}function vs(t,e,n,r,s,a,i="NDHWC"){const[o,l,u]=H1(e);let c,h;if(i==="NDHWC")h="channelsLast",c=[o,l,u,t[4],t[4]];else if(i==="NCDHW")h="channelsFirst",c=[o,l,u,t[1],t[1]];else throw new Error(`Unknown dataFormat ${i}`);return wa(t,c,n,r,s,!1,h,a)}function _t(t,e,n,r,s,a,i=!1,o="channelsLast"){let[l,u,c,h]=[-1,-1,-1,-1];if(o==="channelsLast")[l,u,c,h]=t;else if(o==="channelsFirst")[l,h,u,c]=t;else throw new Error(`Unknown dataFormat ${o}`);const[d,p,,f]=e,[m,y]=Cd(n),[g,b]=Cd(r),v=Su(d,g),w=Su(p,b),{padInfo:k,outHeight:N,outWidth:T}=YW(s,u,c,m,y,v,w,a,o),E=i?f*h:f;let _;return o==="channelsFirst"?_=[l,E,N,T]:o==="channelsLast"&&(_=[l,N,T,E]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:h,outHeight:N,outWidth:T,outChannels:E,padInfo:k,strideHeight:m,strideWidth:y,filterHeight:d,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:w,dilationHeight:g,dilationWidth:b,inShape:t,outShape:_,filterShape:e}}function wa(t,e,n,r,s,a=!1,i="channelsLast",o){let[l,u,c,h,d]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[l,u,c,h,d]=t;else if(i==="channelsFirst")[l,d,u,c,h]=t;else throw new Error(`Unknown dataFormat ${i}`);const[p,f,m,,y]=e,[g,b,v]=H1(n),[w,k,N]=H1(r),T=Su(p,w),E=Su(f,k),_=Su(m,N),{padInfo:O,outDepth:M,outHeight:V,outWidth:W}=QW(s,u,c,h,g,b,v,T,E,_,o),K=a?y*d:y;let q;return i==="channelsFirst"?q=[l,K,M,V,W]:i==="channelsLast"&&(q=[l,M,V,W,K]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:h,inChannels:d,outDepth:M,outHeight:V,outWidth:W,outChannels:K,padInfo:O,strideDepth:g,strideHeight:b,strideWidth:v,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:T,effectiveFilterHeight:E,effectiveFilterWidth:_,dilationDepth:w,dilationHeight:k,dilationWidth:N,inShape:t,outShape:q,filterShape:e}}function qW(t,e,n,r,s){r==null&&(r=tk(t,e,n));const a=t[0],i=t[1],o=Td((a-e+2*r)/n+1,s),l=Td((i-e+2*r)/n+1,s);return[o,l]}function XW(t,e,n,r,s,a){s==null&&(s=tk(t,e[0],r[0]));const i=[0,0,0,n];for(let o=0;o<3;o++)t[o]+2*s>=e[o]&&(i[o]=Td((t[o]-e[o]+2*s)/r[o]+1,a));return i}function tk(t,e,n,r=1){const s=Su(e,r);return Math.floor((t[0]*(n-1)-n+s)/2)}function Cd(t){return typeof t=="number"?[t,t,t]:t.length===2?[t[0],t[1],1]:t}function H1(t){return typeof t=="number"?[t,t,t]:t}function Su(t,e){return e<=1?t:t+(t-1)*(e-1)}function YW(t,e,n,r,s,a,i,o,l){let u,c,h;if(typeof t=="number"){u={top:t,bottom:t,left:t,right:t,type:t===0?"VALID":"NUMBER"};const d=qW([e,n],a,r,t,o);c=d[0],h=d[1]}else if(t==="same"){c=Math.ceil(e/r),h=Math.ceil(n/s);const d=Math.max(0,(c-1)*r+a-e),p=Math.max(0,(h-1)*s+i-n),f=Math.floor(d/2),m=d-f,y=Math.floor(p/2),g=p-y;u={top:f,bottom:m,left:y,right:g,type:"SAME"}}else if(t==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-a+1)/r),h=Math.ceil((n-i+1)/s);else if(typeof t=="object"){const d=l==="channelsLast"?t[1][0]:t[2][0],p=l==="channelsLast"?t[1][1]:t[2][1],f=l==="channelsLast"?t[2][0]:t[3][0],m=l==="channelsLast"?t[2][1]:t[3][1];u={top:d,bottom:p,left:f,right:m,type:d===0&&p===0&&f===0&&m===0?"VALID":"EXPLICIT"},c=Td((e-a+d+p)/r+1,o),h=Td((n-i+f+m)/s+1,o)}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:u,outHeight:c,outWidth:h}}function QW(t,e,n,r,s,a,i,o,l,u,c){let h,d,p,f;if(t==="valid"&&(t=0),typeof t=="number"){h={top:t,bottom:t,left:t,right:t,front:t,back:t,type:t===0?"VALID":"NUMBER"};const m=XW([e,n,r,1],[o,l,u],1,[s,a,i],t,c);d=m[0],p=m[1],f=m[2]}else if(t==="same"){d=Math.ceil(e/s),p=Math.ceil(n/a),f=Math.ceil(r/i);const m=(d-1)*s+o-e,y=(p-1)*a+l-n,g=(f-1)*i+u-r,b=Math.floor(m/2),v=m-b,w=Math.floor(y/2),k=y-w,N=Math.floor(g/2),T=g-N;h={top:w,bottom:k,left:N,right:T,front:b,back:v,type:"SAME"}}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}function Td(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function ro(t){const[e,n,r]=Cd(t);return e===1&&n===1&&r===1}function In(t,e){return ro(t)||ro(e)}function dl(t){return Cd(t).every(e=>e>0)}function ss(t){if(t==="NHWC")return"channelsLast";if(t==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function mr(t,e,n){if(n!=null){if(typeof e=="string")throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);if(typeof e=="number")R(il(e),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(s=>{R(il(s),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${s}.`)})});else throw Error(`Error in ${t}: Unknown padding parameter: ${e}`)}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ZW(t,e){const n={x:F(t,"x","reshape","string_or_numeric")},r={shape:e};return B.runKernel(zp,n,r)}const j=U({reshape_:ZW});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function JW(t,e,n,r,s){const a=F(t,"x","avgPool","float32"),i=1;R(In(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let o=a,l=!1;a.rank===3&&(l=!0,o=j(a,[1,a.shape[0],a.shape[1],a.shape[2]])),R(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),mr("avgPool",r,s);const u={x:o},c={filterSize:e,strides:n,pad:r,dimRoundingMode:s};let h=B.runKernel(tp,u,c);return h=me(h,a.dtype),l?j(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const ob=U({avgPool_:JW});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function eU(t,e,n,r,s,a="NDHWC"){const i=F(t,"x","avgPool3d","float32");let o=i,l=!1;i.rank===4&&(l=!0,o=j(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),R(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),R(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),R(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),mr("avgPool3d",r,s);const u={x:o},c={filterSize:e,strides:n,pad:r,dimRoundingMode:s,dataFormat:a};let h=B.runKernel(np,u,c);return h=me(h,o.dtype),l?j(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const IR=U({avgPool3d_:eU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function tU(t,e=0){R(t.length>=1,()=>"Pass at least one tensor to concat");const n=Id(t,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),n.length===1)return ii(n[0]);const r=n,s={axis:e};return B.runKernel(ip,r,s)}const qt=U({concat_:tU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function nU(t,e,n=!1,r=!1){let s=F(t,"a","matMul"),a=F(e,"b","matMul");[s,a]=Xt(s,a);const i={a:s,b:a},o={transposeA:n,transposeB:r};return B.runKernel(rp,i,o)}const ot=U({matMul_:nU});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function rU(t){const e={x:F(t,"x","sigmoid","float32")};return B.runKernel(Mc,e)}const ps=U({sigmoid_:rU});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function sU(t,e,n){const r=F(t,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const s={x:r},a={begin:e,size:n};return B.runKernel(jp,s,a)}const je=U({slice_:sU});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function aU(t){const e={x:F(t,"x","tanh","float32")};return B.runKernel(Uc,e)}const pl=U({tanh_:aU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function iU(t,e,n,r,s,a){const i=F(t,"forgetBias","basicLSTMCell"),o=F(e,"lstmKernel","basicLSTMCell"),l=F(n,"lstmBias","basicLSTMCell"),u=F(r,"data","basicLSTMCell"),c=F(s,"c","basicLSTMCell"),h=F(a,"h","basicLSTMCell"),d=qt([u,h],1),p=ot(d,o),f=ie(p,l),m=f.shape[0],y=f.shape[1]/4,g=[m,y],b=je(f,[0,0],g),v=je(f,[0,y],g),w=je(f,[0,y*2],g),k=je(f,[0,y*3],g),N=ie(z(ps(b),pl(v)),z(c,ps(ie(i,w)))),T=z(pl(N),ps(k));return[N,T]}const oU=U({basicLSTMCell_:iU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function lU(t,e,n){const r=F(t,"x","batchToSpaceND"),s=e.reduce((o,l)=>o*l);R(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),R(n.length===e.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`),R(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${s}`);const a={x:r},i={blockShape:e,crops:n};return B.runKernel(sp,a,i)}const lb=U({batchToSpaceND_:lU});function uU(t){let e;return t.rank===0||t.rank===1?e=j(t,[1,1,1,t.size]):t.rank===2?e=j(t,[1,1,t.shape[0],t.shape[1]]):t.rank===3?e=j(t,[1,t.shape[0],t.shape[1],t.shape[2]]):e=t,e}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function cU(t,e,n,r,s,a){a==null&&(a=.001);const i=F(t,"x","batchNorm"),o=F(e,"mean","batchNorm"),l=F(n,"variance","batchNorm");let u;s!=null&&(u=F(s,"scale","batchNorm"));let c;r!=null&&(c=F(r,"offset","batchNorm")),R(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),R(c==null||o.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),R(u==null||o.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h={x:uU(i),scale:u,offset:c,mean:o,variance:l},d={varianceEpsilon:a},p=B.runKernel(mp,h,d);return j(p,i.shape)}const ef=U({batchNorm_:cU});function hU(t,e,n,r,s,a){const i=F(t,"x","batchNorm"),o=F(e,"mean","batchNorm"),l=F(n,"variance","batchNorm");let u;s!=null&&(u=F(s,"scale","batchNorm"));let c;return r!=null&&(c=F(r,"offset","batchNorm")),R(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),R(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),R(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&R(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&R(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),ef(i,o,l,c,u,a)}const NR=U({batchNorm2d_:hU});function dU(t,e,n,r,s,a){const i=F(t,"x","batchNorm"),o=F(e,"mean","batchNorm"),l=F(n,"variance","batchNorm");let u;s!=null&&(u=F(s,"scale","batchNorm"));let c;return r!=null&&(c=F(r,"offset","batchNorm")),R(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),R(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),R(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&R(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&R(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),ef(i,o,l,c,u,a)}const CR=U({batchNorm3d_:dU});function pU(t,e,n,r,s,a){const i=F(t,"x","batchNorm"),o=F(e,"mean","batchNorm"),l=F(n,"variance","batchNorm");let u;s!=null&&(u=F(s,"scale","batchNorm"));let c;return r!=null&&(c=F(r,"offset","batchNorm")),R(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),R(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),R(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&R(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&R(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),ef(i,o,l,c,u,a)}const TR=U({batchNorm4d_:pU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function fU(t,e,n){const r=F(t,"x","bincount"),s=F(e,"weights","bincount");R(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),R(n>=0,()=>`size must be non-negative, but got ${n}.`),R(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const a={x:r,weights:s},i={size:n};return B.runKernel(cy,a,i)}const ER=U({bincount_:fU});/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function mU(t,e){const n=F(t,"x","bitwiseAnd"),r=F(e,"y","bitwiseAnd");if(!Je(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if(n.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);const s={a:n,b:r};return B.runKernel(hy,s)}const gU=U({bitwiseAnd_:mU});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function yU(t,e){const n=F(t,"s0","broadcastArgs","int32"),r=F(e,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:n,s1:r};return B.runKernel(dy,s)}const bU=U({broadcastArgs_:yU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function xU(t,e){let n=F(t,"broadcastTo","x");const r=n.shape;if(ns(e),e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const l=n.shape.slice();for(;l.length<e.length;)l.unshift(1);n=j(n,l)}const s=n.shape,a=Array.from(e);for(let l=e.length-1;l>=0;l--)if(s[l]===e[l])a[l]=1;else if(n.shape[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(a.map((l,u)=>l>1?u:-1).filter(l=>l>=0).length===0)return ii(n);const i={x:n},o={reps:a};return B.runKernel(Vc,i,o)}const Iu=U({broadcastTo_:xU});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function vU(t){const e={x:F(t,"x","ceil","float32")};return B.runKernel(sc,e)}const $R=U({ceil_:vU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Gc(t,e,n){ns(t),n=n||mo(e);const r={shape:t,value:e,dtype:n};return B.runKernel(Ey,{},r)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function wU(t,e,n){const r=F(t,"x","clipByValue");if(R(e<=n,()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`),e===n)return Gc(r.shape,e,r.dtype);const s={x:r},a={clipValueMin:e,clipValueMax:n};return B.runKernel(ac,s,a)}const Cr=U({clipByValue_:wU});function kU(t){return qt(t,0)}const RR=U({concat1d_:kU});function SU(t,e){return qt(t,e)}const AR=U({concat2d_:SU});function IU(t,e){return qt(t,e)}const _R=U({concat3d_:IU});function NU(t,e){return qt(t,e)}const FR=U({concat4d_:NU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function CU(t,e,n,r,s="NHWC",a=[1,1],i){const o=F(t,"x","conv2d","float32"),l=F(e,"filter","conv2d","float32");let u=o,c=!1;o.rank===3&&(c=!0,u=j(o,[1,o.shape[0],o.shape[1],o.shape[2]])),R(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),R(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),mr("conv2d",r,i);const h=s==="NHWC"?u.shape[3]:u.shape[1];R(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),R(In(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),R(dl(a),()=>"Error in conv2D: Dilated rates should be larger than 0."),R(dl(n),()=>"Error in conv2D: Strides should be larger than 0.");const d={x:u,filter:l},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=B.runKernel(op,d,p);return c?j(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const so=U({conv2d_:CU});function TU(t,e,n,r,s="NWC",a=1,i){const o=F(t,"x","conv1d"),l=F(e,"filter","conv1d");let u=o,c=!1;o.rank===2&&(c=!0,u=j(o,[1,o.shape[0],o.shape[1]])),R(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),R(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),mr("conv1d",r,i),R(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),R(In(n,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`),R(dl(a),()=>"Error in conv1D: Dilated rates should be larger than 0."),R(dl(n),()=>"Error in conv1D: Stride should be larger than 0."),R(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const h=j(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=j(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=so(d,h,[1,n],r,"NHWC",[1,a],i);return c?j(p,[p.shape[2],p.shape[3]]):j(p,[p.shape[0],p.shape[2],p.shape[3]])}const nk=U({conv1d_:TU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function EU(t,e,n,r,s,a="NHWC",i){R(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let o=t,l=e,u=!1;e.rank===3&&(u=!0,l=j(e,[1,e.shape[0],e.shape[1],e.shape[2]]),o=[1,t[0],t[1],t[2]]),R(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),R(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),R(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const c=a==="NHWC"?o[3]:o[1],h=a==="NHWC"?l.shape[3]:l.shape[1];R(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),R(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),mr("conv2dDerInput",s,i);const d={dy:l,filter:n},p={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,inputShape:o},f=B.runKernel(lp,d,p);return u?j(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const rk=U({conv2DBackpropInput_:EU});function $U(t,e,n,r,s,a){const i=F(t,"x","conv2dTranspose"),o=F(e,"filter","conv2dTranspose");return rk(n,i,o,r,s,"NHWC",a)}const sk=U({conv2dTranspose_:$U});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function RU(t,e,n,r,s="NDHWC",a=[1,1,1]){const i=F(t,"x","conv3d"),o=F(e,"filter","conv3d");let l=i,u=!1;i.rank===4&&(u=!0,l=j(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),R(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),R(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),R(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),R(In(n,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),R(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),R(dl(a),()=>"Error in conv3D: Dilated rates should be larger than 0."),R(dl(n),()=>"Error in conv3D: Strides should be larger than 0.");const c={x:l,filter:o},h={strides:n,pad:r,dataFormat:s,dilations:a},d=B.runKernel(up,c,h);return u?j(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const OR=U({conv3d_:RU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function AU(t,e,n,r,s){R(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let a=t,i=e,o=!1;e.rank===4&&(o=!0,i=j(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),a=[1,t[0],t[1],t[2],t[3]]);const l=a[4],u=i.shape[4];R(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),R(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),R(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),R(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),R(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);const c={dy:i,filter:n},h={pad:s,strides:r,inputShape:a},d=B.runKernel(gy,c,h);return o?j(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const DR=U({conv3DBackpropInput_:AU});function _U(t,e,n,r,s){const a=F(t,"x","conv3dTranspose"),i=F(e,"filter","conv3dTranspose");return DR(n,a,i,r,s)}const MR=U({conv3dTranspose_:_U});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function FU(t){const e={x:F(t,"x","cos","float32")};return B.runKernel(ic,e)}const ub=U({cos_:FU});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function OU(t){const e={x:F(t,"x","cosh","float32")};return B.runKernel(oc,e)}const ak=U({cosh_:OU});/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the 'License');
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an 'AS IS' BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function DU(t,e=0,n=!1,r=!1){const s={x:F(t,"x","cumprod")},a={axis:e,exclusive:n,reverse:r};return B.runKernel(yy,s,a)}const pg=U({cumprod_:DU});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function MU(t,e=0,n=!1,r=!1){const s={x:F(t,"x","cumsum")},a={axis:e,exclusive:n,reverse:r};return B.runKernel(cp,s,a)}const ik=U({cumsum_:MU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function PU(t,e,n,r=!1){const s=F(t,"x","denseBincount"),a=F(e,"weights","denseBincount");R(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),R(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),R(n>=0,()=>`size must be non-negative, but got ${n}.`),R(a.size===s.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`);const i={x:s,weights:a},o={size:n,binaryOutput:r};return B.runKernel(xy,i,o)}const K1=U({denseBincount_:PU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function LU(t,e,n="NHWC"){const r=F(t,"x","depthToSpace","float32"),s=n==="NHWC"?r.shape[1]:r.shape[2],a=n==="NHWC"?r.shape[2]:r.shape[3],i=n==="NHWC"?r.shape[3]:r.shape[1];R(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),R(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e}  for depthToSpace with input shape
    ${r.shape}`),R(a*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${e} for depthToSpace with input shape
        ${r.shape}`),R(i%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${i} for depthToSpace with input shape ${r.shape}`);const o={x:r},l={blockSize:e,dataFormat:n};return B.runKernel(vy,o,l)}const PR=U({depthToSpace_:LU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zU(t,e,n,r,s="NHWC",a=[1,1],i){const o=F(t,"x","depthwiseConv2d","float32"),l=F(e,"filter","depthwiseConv2d","float32");let u=o,c=!1;o.rank===3&&(c=!0,u=j(o,[1,o.shape[0],o.shape[1],o.shape[2]])),R(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),R(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const h=s==="NHWC"?u.shape[3]:u.shape[1];R(h===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`),mr("depthwiseConv2d",r,i);const d={x:u,filter:l},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=B.runKernel(hp,d,p);return c?j(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const tf=U({depthwiseConv2d_:zU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function BU(t){const e={x:F(t,"x","diag")};return B.runKernel(Sy,e)}const WU=U({diag_:BU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function UU(t,e,n,r,s=[1,1],a="NHWC"){const i=F(t,"x","dilation2d"),o=F(e,"filter","dilation2d");R(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),R(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),R(a==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let l=i,u=!1;i.rank===3&&(l=j(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),R(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);const c={x:l,filter:o},h={strides:n,pad:r,dilations:s},d=B.runKernel(dp,c,h);return u?j(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const LR=U({dilation2d_:UU});/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function fi(t,e){const n=t.length,r=[];for(let s=0;s<n;s++){const a=n-1-s,i=t[a]||1;(e[e.length-1-s]||1)>1&&i===1&&r.unshift(a)}return r}function fn(t,e){const n=[];for(let r=0;r<e.length;r++){const s=t[t.length-r-1],a=e.length-r-1,i=e[a];(s==null||s===1&&i>1)&&n.unshift(a)}return n}function Ue(t,e){const n=Math.max(t.length,e.length),r=new Array(n);for(let s=0;s<n;s++){let a=t[t.length-s-1];a==null&&(a=1);let i=e[e.length-s-1];if(i==null&&(i=1),a===1)r[n-s-1]=i;else if(i===1)r[n-s-1]=a;else if(a!==i){const o=`Operands could not be broadcast together with shapes ${t} and ${e}.`;throw Error(o)}else r[n-s-1]=a}return r}const Dke=Object.freeze(Object.defineProperty({__proto__:null,assertAndGetBroadcastShape:Ue,getBroadcastDims:fi,getReductionAxes:fn},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function VU(t,e){let n=F(t,"a","equal","string_or_numeric"),r=F(e,"b","equal","string_or_numeric");[n,r]=Xt(n,r),Ue(n.shape,r.shape);const s={a:n,b:r};return B.runKernel(pp,s)}const ms=U({equal_:VU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function jU(t,e,n){const r=F(e,"a","where"),s=F(n,"b","where"),a=F(t,"condition","where","bool"),i=Ue(Ue(a.shape,r.shape),s.shape),o=Iu(a,i),l=Iu(r,i),u=Iu(s,i),c={condition:o,t:l,e:u};return B.runKernel(Vp,c)}const Un=U({where_:jU});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function GU(t){const e={x:F(t,"x","zerosLike")};return B.runKernel(Qp,e)}const dt=U({zerosLike_:GU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function HU(t,e){let n=F(t,"a","div"),r=F(e,"b","div");[n,r]=Xt(n,r);const s=Se(n,r),a=dt(s),i=ms(r,a);return Un(i,a,s)}const zR=U({divNoNan_:HU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function KU(t,e){const n=F(t,"t1","dot"),r=F(e,"t2","dot");R((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);const s=n.rank===1?n.size:n.shape[1],a=r.rank===1?r.size:r.shape[0];if(R(s===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`),n.rank===1&&r.rank===1){const i=j(n,[1,-1]),o=j(r,[-1,1]),l=ot(i,o);return j(l,[])}else if(n.rank===1&&r.rank===2){const i=j(n,[1,-1]),o=j(r,[r.shape[0],r.shape[1]]),l=ot(i,o);return j(l,[l.size])}else if(n.rank===2&&r.rank===1){const i=j(r,[-1,1]),o=ot(n,i);return j(o,[o.size])}else{const i=j(r,[r.shape[0],r.shape[1]]);return ot(n,i)}}const BR=U({dot_:KU});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function qU(t,...e){const n=e.map((s,a)=>F(s,`tensors${a}`,"einsum")),r={equation:t};return B.runKernel(Ny,n,r)}const nu=U({einsum_:qU});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function XU(t){const e={x:F(t,"x","elu","float32")};return B.runKernel(uc,e)}const nf=U({elu_:XU});/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function YU(t,e){const n=F(t,"x","ensureShape","string_or_numeric");if(!R$(n.shape,e))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${e}`);return t}const QU=U({ensureShape_:YU});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ZU(t){let e=F(t,"x","erf");R(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=me(e,"float32"));const n={x:e};return B.runKernel(cc,n)}const ok=U({erf_:ZU});/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function lk(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function WR(t,e,n){const r=t.length+e.length,s=[];let a=0,i=0;for(let o=0;o<r;o++)n.indexOf(o)===-1?s.push(t[a++]):s.push(e[i++]);return s}function an(t,e){const n=[],r=t.length;for(let a=0;a<r;a++)e.indexOf(a)===-1&&n.push(t[a]);const s=e.map(a=>t[a]);return[n,s]}function en(t,e){const n=e.map(r=>1);return WR(t,n,e)}function mn(t,e,n){R(lk(e,n),()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`)}function Tt(t,e){if(lk(t,e))return null;const n=[];for(let r=0;r<e;++r)t.indexOf(r)===-1&&n.push(r);return t.forEach(r=>n.push(r)),n}function Ha(t){return t.map((e,n)=>[n,e]).sort((e,n)=>e[1]-n[1]).map(e=>e[0])}function Ft(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function JU(t,e=null,n=!1){const r={x:F(t,"x","max")},s={reductionIndices:e,keepDims:n};return B.runKernel(Np,r,s)}const zs=U({max_:JU});/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function eV(t,e=null,n=!1){const r={x:F(t,"x","min")},s={axis:e,keepDims:n};return B.runKernel($p,r,s)}const Ed=U({min_:eV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function tV(t,e){let n=F(t,"base","pow"),r=F(e,"exp","pow");[n,r]=Xt(n,r);const s={a:n,b:r};return B.runKernel(Cc,s)}const mi=U({pow_:tV});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Me(t,e){if((Zr(t)&&e!=="string"||Array.isArray(t))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Zr(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return bo(t,[],[],e)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function nV(t){const e={x:F(t,"x","sqrt","float32")};return B.runKernel(Lc,e)}const Vn=U({sqrt_:nV});/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function rV(t){const e=F(t,"x","square"),n={};return B.runKernel("Square",{x:e},n)}const It=U({square_:rV});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function sV(t,e=null,n=!1){let r=F(t,"x","sum");r.dtype==="bool"&&(r=me(r,"int32"));const s={x:r},a={axis:e,keepDims:n};return B.runKernel(Gp,s,a)}const Re=U({sum_:sV});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function aV(t,e="euclidean",n=null,r=!1){t=F(t,"x","norm");const s=UR(t,e,n);let a=s.shape;if(r){const i=Ze(n,t.shape);a=en(s.shape,i)}return j(s,a)}function UR(t,e,n=null){if(t.rank===0)return yn(t);if(t.rank!==1&&n===null)return UR(j(t,[-1]),e,n);if(t.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(e===1)return Re(yn(t),n);if(e===1/0)return zs(yn(t),n);if(e===-1/0)return Ed(yn(t),n);if(e==="euclidean"||e===2)return Vn(Re(mi(yn(t),Me(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&n.length===2){if(e===1)return zs(Re(yn(t),n[0]),n[1]-1);if(e===1/0)return zs(Re(yn(t),n[1]),n[0]);if(e===-1/0)return Ed(Re(yn(t),n[1]),n[0]);if(e==="fro"||e==="euclidean")return Vn(Re(It(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const rf=U({norm_:aV});/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function iV(t,e=null,n=!1){return rf(t,"euclidean",e,n)}const VR=U({euclideanNorm_:iV});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function oV(t){const e={x:F(t,"x","exp")};return B.runKernel(hc,e)}const pr=U({exp_:oV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function lV(t,e=0){const n=F(t,"x","expandDims","string_or_numeric");R(e<=n.rank,()=>"Axis must be <= rank of the tensor");const r={input:n},s={dim:e};return B.runKernel(fp,r,s)}const hn=U({expandDims_:lV});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function uV(t){const e={x:F(t,"x","expm1")};return B.runKernel(dc,e)}const jR=U({expm1_:uV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function cV(t,e){const n=F(t,"x","tile","string_or_numeric");R(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`);const r={x:n},s={reps:e};return B.runKernel(Vc,r,s)}const Ds=U({tile_:cV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function hV(t,e,n,r="float32"){e==null&&(e=t);const s=Qe([t,e],r),a=t<=e?t:e;for(let o=0;o<a;++o)s.set(1,o,o);const i=j(s.toTensor(),[t,e]);if(n==null)return i;if(n.length===1)return Ds(hn(i,0),[n[0],1,1]);if(n.length===2)return Ds(hn(hn(i,0),0),[n[0],n[1],1,1]);if(n.length===3)return Ds(hn(hn(hn(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const uk=U({eye_:hV});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function dV(t){const e={x:F(t,"x","floor","float32")};return B.runKernel(pc,e)}const sf=U({floor_:dV});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function pV(t,e,n=0,r=0){const s=F(t,"x","gather"),a=F(e,"indices","gather","int32"),i={x:s,indices:a},o={axis:n,batchDims:r};return B.runKernel(gp,i,o)}const af=U({gather_:pV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function fV(t,e){let n=F(t,"a","greater","string_or_numeric"),r=F(e,"b","greater","string_or_numeric");[n,r]=Xt(n,r),Ue(n.shape,r.shape);const s={a:n,b:r};return B.runKernel(yp,s)}const _r=U({greater_:fV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function mV(t,e){let n=F(t,"a","greaterEqual","string_or_numeric"),r=F(e,"b","greaterEqual","string_or_numeric");[n,r]=Xt(n,r),Ue(n.shape,r.shape);const s={a:n,b:r};return B.runKernel(mc,s)}const vo=U({greaterEqual_:mV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function gV(t){const e={input:F(t,"input","imag")};return B.runKernel(_y,e)}const cb=U({imag_:gV});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function yV(t){const e={x:F(t,"x","isFinite")};return B.runKernel(yc,e)}const GR=U({isFinite_:yV});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function bV(t){const e={x:F(t,"x","isInf")};return B.runKernel(bc,e)}const HR=U({isInf_:bV});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function xV(t){const e={x:F(t,"x","isNaN")};return B.runKernel(xc,e)}const KR=U({isNaN_:xV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function vV(t,e=.2){const n={x:F(t,"x","leakyRelu")},r={alpha:e};return B.runKernel(bp,n,r)}const hb=U({leakyRelu_:vV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function wV(t,e){let n=F(t,"a","less","string_or_numeric"),r=F(e,"b","less","string_or_numeric");[n,r]=Xt(n,r),Ue(n.shape,r.shape);const s={a:n,b:r};return B.runKernel(xp,s)}const $d=U({less_:wV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function kV(t,e){let n=F(t,"a","lessEqual","string_or_numeric"),r=F(e,"b","lessEqual","string_or_numeric");[n,r]=Xt(n,r),Ue(n.shape,r.shape);const s={a:n,b:r};return B.runKernel(vp,s)}const $l=U({lessEqual_:kV});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function SV(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:t,stop:e,num:n};return B.runKernel(Fy,{},r)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function IV(t,e=5,n=1,r=1,s=.5){const a=F(t,"x","localResponseNormalization");R(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),R(il(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let i=a,o=!1;a.rank===3&&(o=!0,i=j(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const l={x:i},u={depthRadius:e,bias:n,alpha:r,beta:s},c=B.runKernel(Ip,l,u);return o?j(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const qR=U({localResponseNormalization_:IV});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function NV(t){const e={x:F(t,"x","log","float32")};return B.runKernel(vc,e)}const gs=U({log_:NV});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function CV(t){const e={x:F(t,"x","log1p")};return B.runKernel(wc,e)}const db=U({log1p_:CV});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Mke(t){return R(eo(t),()=>"The f passed in grad(f) must be a function"),(e,n)=>{const r=F(e,"x","tf.grad","string_or_numeric"),s=n!=null?F(n,"dy","tf.grad"):null;return B.tidy(()=>{const{value:a,grads:i}=B.gradients(()=>t(r),[r],s);return s!=null&&Dn(a.shape,s.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),pb(i),i[0]})}}function Pke(t){return R(eo(t),()=>"The f passed in grads(f) must be a function"),(e,n)=>{R(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const r=Id(e,"args","tf.grads","string_or_numeric"),s=n!=null?F(n,"dy","tf.grads"):null;return B.tidy(()=>{const{value:a,grads:i}=B.gradients(()=>t(...r),r,s);return s!=null&&Dn(a.shape,s.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),pb(i),i})}}function Lke(t){return R(eo(t),()=>"The f passed in valueAndGrad(f) must be a function"),(e,n)=>{R(e instanceof st,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),R(n==null||n instanceof st,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:r,value:s}=B.gradients(()=>t(e),[e],n);return pb(r),{grad:r[0],value:s}}}function zke(t){return R(eo(t),()=>"The f passed in valueAndGrads(f) must be a function"),(e,n)=>{R(Array.isArray(e)&&e.every(s=>s instanceof st),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),R(n==null||n instanceof st,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const r=B.gradients(()=>t(...e),e,n);return n!=null&&Dn(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),pb(r.grads),r}}function TV(t,e){R(eo(t),()=>"The f passed in variableGrads(f) must be a function"),R(e==null||Array.isArray(e)&&e.every(u=>u instanceof cg),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=e!=null;if(!n){e=[];for(const u in B.registeredVariables)e.push(B.registeredVariables[u])}const r=n?e.filter(u=>!u.trainable):null,s=e.length;e=e.filter(u=>u.trainable),R(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const a=!0,{value:i,grads:o}=B.gradients(t,e,null,a);R(o.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),R(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const l={};return e.forEach((u,c)=>{o[c]!=null&&(l[u.name]=o[c])}),r!=null&&r.forEach(u=>l[u.name]=null),{value:i,grads:l}}function gi(t){return B.customGrad(t)}function pb(t){if(t.filter(e=>e==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function EV(t){const e={x:F(t,"x","neg")};return B.runKernel(Ap,e)}const Lt=U({neg_:EV});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function $V(t){const e={x:F(t,"x","softplus")};return B.runKernel(Pc,e)}const Hc=U({softplus_:$V});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function RV(t){const e=F(t,"x","logSigmoid");return gi(n=>({value:Lt(Hc(Lt(n))),gradFunc:r=>z(r,ps(Lt(n)))}))(e)}const XR=U({logSigmoid_:RV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function AV(t,e){let n=F(t,"a","sub"),r=F(e,"b","sub");[n,r]=Xt(n,r);const s={a:n,b:r};return B.runKernel(Bc,s)}const Ie=U({sub_:AV});/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _V(t,e=-1){const n=F(t,"logits","logSoftmax");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return gi((r,s)=>{const a=zs(r,e,!0),i=Ie(r,a),o=Ie(me(i,"float32"),gs(Re(pr(i),e,!0)));return s([o]),{value:o,gradFunc:(l,u)=>{const[c]=u,h=!0,d=pr(c);return Ie(l,z(Re(l,e,h),d))}}})(n)}const ck=U({logSoftmax_:_V});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function FV(t,e=null,n=!1){const r=F(t,"x","logSumExp"),s=Ze(e,r.shape),a=zs(r,s,!0),i=Ie(r,a),o=pr(i),l=Re(o,s),u=gs(l),c=ie(j(a,u.shape),u);if(n){const h=en(c.shape,s);return j(c,h)}return c}const fb=U({logSumExp_:FV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function OV(t,e){const n=F(t,"a","logicalAnd","bool"),r=F(e,"b","logicalAnd","bool");Ue(n.shape,r.shape);const s={a:n,b:r};return B.runKernel(wp,s)}const da=U({logicalAnd_:OV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function DV(t){const e={x:F(t,"x","logicalNot","bool")};return B.runKernel(kp,e)}const mb=U({logicalNot_:DV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function MV(t,e){const n=F(t,"a","logicalOr","bool"),r=F(e,"b","logicalOr","bool");Ue(n.shape,r.shape);const s={a:n,b:r};return B.runKernel(Sp,s)}const hk=U({logicalOr_:MV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function PV(t,e){const n=F(t,"a","logicalXor","bool"),r=F(e,"b","logicalXor","bool");return Ue(n.shape,r.shape),da(hk(t,e),mb(da(t,e)))}const YR=U({logicalXor_:PV});/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const tm=2147483648;function LV(t,e,n="left"){const r=F(t,"sortedSequence","searchSorted"),s=F(e,"values","searchSorted"),a=r.shape[r.shape.length-1],i=s.shape[s.shape.length-1],o=j(r,[-1,a]),l=j(s,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Q(l.shape)>=tm)throw new Error(`values tensor size must less than ${tm}`);if(o.shape[1]>=tm)throw new Error(`trailing dim_size must less than ${tm} for int32 output type, was ${o.shape[1]}`);const u={sortedSequence:o,values:l},c={side:n};return B.runKernel(Ky,u,c)}const dk=U({searchSorted_:LV});/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zV(t,e){return dk(t,e,"left")}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function BV(t,e,n,r,s){const a=F(t,"x","maxPool"),i=1;let o=a,l=!1;a.rank===3&&(l=!0,o=j(a,[1,a.shape[0],a.shape[1],a.shape[2]])),R(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),R(In(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),mr("maxPool",r,s);const u={x:o},c={filterSize:e,strides:n,pad:r,dimRoundingMode:s},h=B.runKernel(Cp,u,c);return l?j(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const gb=U({maxPool_:BV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function WV(t,e=[1,1,1],n,r,s,a="NDHWC"){const i=F(t,"x","maxPool3d");let o=i,l=!1;i.rank===4&&(l=!0,o=j(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),R(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),R(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),mr("maxPool3d",r,s);const u={x:o},c={filterSize:e,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},h=B.runKernel(Tp,u,c);return l?j(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const QR=U({maxPool3d_:WV});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function UV(t,e,n,r,s=!1){const a={x:F(t,"x","maxPoolWithArgmax")},i={filterSize:e,strides:n,pad:r,includeBatchInIndex:s},o=B.runKernel(Py,a,i);return{result:o[0],indexes:o[1]}}const VV=U({maxPoolWithArgmax_:UV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function jV(t,e){let n=F(t,"a","maximum"),r=F(e,"b","maximum");[n,r]=Xt(n,r),n.dtype==="bool"&&(n=me(n,"int32"),r=me(r,"int32")),Ue(n.shape,r.shape);const s={a:n,b:r};return B.runKernel(kc,s)}const wi=U({maximum_:jV});/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function GV(t,e=null,n=!1){const r={x:F(t,"x","mean")},s={axis:e,keepDims:n};return B.runKernel(Ep,r,s)}const Qt=U({mean_:GV});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function rn(t,e="float32"){if(ns(t),e==="complex64"){const r=rn(t,"float32"),s=rn(t,"float32");return to(r,s)}const n=Fn(Q(t),e);return B.makeTensor(n,t,e)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Kr(t,e="float32"){if(ns(t),e==="complex64"){const r=Kr(t,"float32"),s=rn(t,"float32");return to(r,s)}const n=ay(Q(t),e);return B.makeTensor(n,t,e)}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function HV(t,e,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(t===void 0)return[];let r=F(t,"x","meshgrid",t instanceof st?t.dtype:"float32");if(e===void 0)return[r];let s=F(e,"y","meshgrid",e instanceof st?e.dtype:"float32");const a=Q(r.shape),i=Q(s.shape);return n==="xy"?(r=j(r,[1,-1]),s=j(s,[-1,1]),[ot(Kr([i,1],r.dtype),r),ot(s,Kr([1,a],s.dtype))]):(r=j(r,[-1,1]),s=j(s,[1,-1]),[ot(r,Kr([1,i],r.dtype)),ot(Kr([a,1],s.dtype),s)])}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function KV(t,e){let n=F(t,"a","minimum"),r=F(e,"b","minimum");[n,r]=Xt(n,r),n.dtype==="bool"&&(n=me(n,"int32"),r=me(r,"int32")),Ue(n.shape,r.shape);const s={a:n,b:r};return B.runKernel(Sc,s)}const ao=U({minimum_:KV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function qV(t,e,n){R(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const r=F(t,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");R(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);const s=n==="reflect"?1:0;for(let o=0;o<r.rank;o++)R(e[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),R(e[o][0]>=0&&e[o][0]<=r.shape[o]-s&&e[o][1]>=0&&e[o][1]<=r.shape[o]-s,()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-s} or less than 0 for input of shape ${r.shape}`);const a={paddings:e,mode:n},i={x:r};return B.runKernel(Rp,i,a)}const pk=U({mirrorPad_:qV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function XV(t,e){let n=F(t,"a","mod"),r=F(e,"b","mod");[n,r]=Xt(n,r);const s={a:n,b:r};return B.runKernel(Ic,s)}const ZR=U({mod_:XV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function YV(t,e=null,n=!1){t=F(t,"x","moments");const r=Ze(e,t.shape),s=Qt(t,r,n);let a=s.shape;n||(a=en(s.shape,r));const i=It(Ie(me(t,"float32"),j(s,a))),o=Qt(i,r,n);return{mean:s,variance:o}}const yb=U({moments_:YV});function QV(t,e,n,r){const s=F(e,"data","multiRNNCell"),a=Id(n,"c","multiRNNCell"),i=Id(r,"h","multiRNNCell");let o=s;const l=[];for(let h=0;h<t.length;h++){const d=t[h](o,a[h],i[h]);l.push(d[0]),l.push(d[1]),o=d[1]}const u=[],c=[];for(let h=0;h<l.length;h+=2)u.push(l[h]),c.push(l[h+1]);return[u,c]}const ZV=U({multiRNNCell_:QV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function JV(t,e,n,r=!1){const s=F(t,"logits","multinomial"),a=s.size,i=s.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();const o={logits:i===1?j(s,[1,-1]):s},l={numSamples:e,seed:n,normalized:r},u=B.runKernel(Ly,o,l);return i===1?j(u,[u.size]):u}const ej=U({multinomial_:JV});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function tj(t,e){let n=F(t,"a","notEqual","string_or_numeric"),r=F(e,"b","notEqual","string_or_numeric");[n,r]=Xt(n,r),Ue(n.shape,r.shape);const s={a:n,b:r};return B.runKernel(_p,s)}const Pu=U({notEqual_:tj});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function nj(t,e,n=1,r=0,s="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const a={indices:F(t,"indices","oneHot","int32")},i={dtype:s,depth:e,onValue:n,offValue:r};return B.runKernel(Op,a,i)}const fk=U({oneHot_:nj});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function rj(t){const e={x:F(t,"x","onesLike")};return B.runKernel(Fp,e)}const ys=U({onesLike_:rj});function sj(t,e){const n=F(t,"v1","outerProduct"),r=F(e,"v2","outerProduct");R(n.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);const s=j(n,[-1,1]),a=j(r,[1,-1]);return ot(s,a)}const aj=U({outerProduct_:sj});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ij(t,e,n=0){const r=F(t,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:e,constantValue:n},a={x:r};return B.runKernel(Mp,a,s)}const pa=U({pad_:ij});function oj(t,e,n=0){return R(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),pa(t,[e],n)}const lj=U({pad1d_:oj});function uj(t,e,n=0){return R(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),pa(t,e,n)}const cj=U({pad2d_:uj});function hj(t,e,n=0){return R(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),pa(t,e,n)}const dj=U({pad3d_:hj});function pj(t,e,n=0){return R(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),pa(t,e,n)}const fj=U({pad4d_:pj});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function mj(t,e,n){const r=F(t,"x","spaceToBatchND");R(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),R(n.length===e.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`),R(r.shape.reduce((i,o,l)=>l>0&&l<=e.length?i&&(o+n[l-1][0]+n[l-1][1])%e[l-1]===0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`);const s={x:r},a={blockShape:e,paddings:n};return B.runKernel(Hp,s,a)}const bb=U({spaceToBatchND_:mj});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function gj(t,e,n,r,s,a,i){s==null&&(s=[1,1]),a==null&&(a=1),r===0&&(r="valid");const o=F(t,"x","maxPool");let l=o,u=!1;o.rank===3&&(u=!0,l=j(o,[1,o.shape[0],o.shape[1],o.shape[2]])),R(In(a,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`);const c=er(l.shape,e,a,s,r),h=[c.dilationHeight,c.dilationWidth];let d;r==="same"?d=bj([c.filterHeight,c.filterWidth],h):d=[[0,0],[0,0]];const p=h[0]===1&&h[1]===1,[f,m]=yj([c.inHeight,c.inWidth],h,d),y=p?r:"valid",g=p?l:bb(l,h,f),b=(n==="avg"?()=>ob(g,e,a,y,i):()=>gb(g,e,a,y,i))(),v=p?b:lb(b,h,m);return u?j(v,[v.shape[1],v.shape[2],v.shape[3]]):v}function yj(t,e,n){const r=n.map(c=>c[0]),s=n.map(c=>c[1]),a=t.concat(r,s),i=e.map((c,h)=>(c-a[h]%c)%c),o=s.map((c,h)=>c+i[h]),l=e.map((c,h)=>[r[h],o[h]]),u=e.map((c,h)=>[0,i[h]]);return[l,u]}function bj(t,e){const n=t.map((a,i)=>a+(a-1)*(e[i]-1)).map(a=>a-1),r=n.map(a=>Math.floor(a/2)),s=n.map((a,i)=>a-r[i]);return n.map((a,i)=>[r[i],s[i]])}const JR=U({pool_:gj});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function xj(t,e){const n=F(t,"x","prelu"),r=F(e,"alpha","prelu"),s={x:n,alpha:r};return B.runKernel(Pp,s)}const xb=U({prelu_:xj});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function vj(t,e=null,n=!1){let r=F(t,"x","prod");r.dtype==="bool"&&(r=me(r,"int32"));const s={x:r},a={axis:e,keepDims:n};return B.runKernel(Lp,s,a)}const e3=U({prod_:vj});/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function wj(t,e,n,r){const s=t.map((c,h)=>F(c,`tensors${h}`,"raggedGather","int32")),a=F(e,"paramsDenseValues","raggedGather"),i=F(n,"indices","raggedGather","int32"),o={paramsNestedSplits:s,paramsDenseValues:a,indices:i},l={outputRaggedRank:r},u=B.runKernel(Mw,o,l);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}const kj=U({raggedGather_:wj});/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Sj(t,e,n){const r=F(t,"starts","raggedRange"),s=F(e,"limits","raggedRange",r.dtype),a=F(n,"deltas","raggedRange",r.dtype),i={starts:r,limits:s,deltas:a},o=B.runKernel(Pw,i);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}const Ij=U({raggedRange_:Sj});/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Nj(t,e,n,r,s){const a=F(t,"shape","raggedTensorToTensor","int32"),i=F(e,"values","raggedTensorToTensor"),o=F(n,"defaultValue","raggedTensorToTensor",i.dtype),l=r.map((h,d)=>F(h,`tensors${d}`,"raggedTensorToTensor","int32")),u={shape:a,values:i,defaultValue:o,rowPartitionTensors:l},c={rowPartitionTypes:s};return B.runKernel(Lw,u,c)}const Cj=U({raggedTensorToTensor_:Nj});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Tj(t,e,n){ns(t);const r=Q(t);let s=null;if(n==null||n==="float32")s=new Float32Array(r);else if(n==="int32")s=new Int32Array(r);else if(n==="bool")s=new Uint8Array(r);else throw new Error(`Unknown data type ${n}`);for(let a=0;a<r;a++)s[a]=e();return B.makeTensor(s,t,n)}const Ej=U({rand_:Tj});var t3={exports:{}};(function(t){(function(e,n,r){function s(l){var u=this,c=o();u.next=function(){var h=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=h-(u.c=h|0)},u.c=1,u.s0=c(" "),u.s1=c(" "),u.s2=c(" "),u.s0-=c(l),u.s0<0&&(u.s0+=1),u.s1-=c(l),u.s1<0&&(u.s1+=1),u.s2-=c(l),u.s2<0&&(u.s2+=1),c=null}function a(l,u){return u.c=l.c,u.s0=l.s0,u.s1=l.s1,u.s2=l.s2,u}function i(l,u){var c=new s(l),h=u&&u.state,d=c.next;return d.int32=function(){return c.next()*4294967296|0},d.double=function(){return d()+(d()*2097152|0)*11102230246251565e-32},d.quick=d,h&&(typeof h=="object"&&a(h,c),d.state=function(){return a(c,{})}),d}function o(){var l=4022871197,u=function(c){c=String(c);for(var h=0;h<c.length;h++){l+=c.charCodeAt(h);var d=.02519603282416938*l;l=d>>>0,d-=l,d*=l,l=d>>>0,d-=l,l+=d*4294967296}return(l>>>0)*23283064365386963e-26};return u}n&&n.exports?n.exports=i:this.alea=i})(aa,t)})(t3);var $j=t3.exports,n3={exports:{}};(function(t){(function(e,n,r){function s(o){var l=this,u="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var h=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^h^h>>>8},o===(o|0)?l.x=o:u+=o;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,l.next()}function a(o,l){return l.x=o.x,l.y=o.y,l.z=o.z,l.w=o.w,l}function i(o,l){var u=new s(o),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&a(c,u),h.state=function(){return a(u,{})}),h}n&&n.exports?n.exports=i:this.xor128=i})(aa,t)})(n3);var Rj=n3.exports,r3={exports:{}};(function(t){(function(e,n,r){function s(o){var l=this,u="";l.next=function(){var h=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(h^h<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,o===(o|0)?l.x=o:u+=o;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,c==u.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function a(o,l){return l.x=o.x,l.y=o.y,l.z=o.z,l.w=o.w,l.v=o.v,l.d=o.d,l}function i(o,l){var u=new s(o),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&a(c,u),h.state=function(){return a(u,{})}),h}n&&n.exports?n.exports=i:this.xorwow=i})(aa,t)})(r3);var Aj=r3.exports,s3={exports:{}};(function(t){(function(e,n,r){function s(o){var l=this;l.next=function(){var c=l.x,h=l.i,d,p;return d=c[h],d^=d>>>7,p=d^d<<24,d=c[h+1&7],p^=d^d>>>10,d=c[h+3&7],p^=d^d>>>3,d=c[h+4&7],p^=d^d<<7,d=c[h+7&7],d=d^d<<13,p^=d^d<<9,c[h]=p,l.i=h+1&7,p};function u(c,h){var d,p=[];if(h===(h|0))p[0]=h;else for(h=""+h,d=0;d<h.length;++d)p[d&7]=p[d&7]<<15^h.charCodeAt(d)+p[d+1&7]<<13;for(;p.length<8;)p.push(0);for(d=0;d<8&&p[d]===0;++d);for(d==8?p[7]=-1:p[d],c.x=p,c.i=0,d=256;d>0;--d)c.next()}u(l,o)}function a(o,l){return l.x=o.x.slice(),l.i=o.i,l}function i(o,l){o==null&&(o=+new Date);var u=new s(o),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(c.x&&a(c,u),h.state=function(){return a(u,{})}),h}n&&n.exports?n.exports=i:this.xorshift7=i})(aa,t)})(s3);var _j=s3.exports,a3={exports:{}};(function(t){(function(e,n,r){function s(o){var l=this;l.next=function(){var c=l.w,h=l.X,d=l.i,p,f;return l.w=c=c+1640531527|0,f=h[d+34&127],p=h[d=d+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,f=h[d]=f^p,l.i=d,f+(c^c>>>16)|0};function u(c,h){var d,p,f,m,y,g=[],b=128;for(h===(h|0)?(p=h,h=null):(h=h+"\0",p=0,b=Math.max(b,h.length)),f=0,m=-32;m<b;++m)h&&(p^=h.charCodeAt((m+32)%h.length)),m===0&&(y=p),p^=p<<10,p^=p>>>15,p^=p<<4,p^=p>>>13,m>=0&&(y=y+1640531527|0,d=g[m&127]^=p+y,f=d==0?f+1:0);for(f>=128&&(g[(h&&h.length||0)&127]=-1),f=127,m=4*128;m>0;--m)p=g[f+34&127],d=g[f=f+1&127],p^=p<<13,d^=d<<17,p^=p>>>15,d^=d>>>12,g[f]=p^d;c.w=y,c.X=g,c.i=f}u(l,o)}function a(o,l){return l.i=o.i,l.w=o.w,l.X=o.X.slice(),l}function i(o,l){o==null&&(o=+new Date);var u=new s(o),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(c.X&&a(c,u),h.state=function(){return a(u,{})}),h}n&&n.exports?n.exports=i:this.xor4096=i})(aa,t)})(a3);var Fj=a3.exports,i3={exports:{}};(function(t){(function(e,n,r){function s(o){var l=this,u="";l.next=function(){var h=l.b,d=l.c,p=l.d,f=l.a;return h=h<<25^h>>>7^d,d=d-p|0,p=p<<24^p>>>8^f,f=f-h|0,l.b=h=h<<20^h>>>12^d,l.c=d=d-p|0,l.d=p<<16^d>>>16^f,l.a=f-h|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,o===Math.floor(o)?(l.a=o/4294967296|0,l.b=o|0):u+=o;for(var c=0;c<u.length+20;c++)l.b^=u.charCodeAt(c)|0,l.next()}function a(o,l){return l.a=o.a,l.b=o.b,l.c=o.c,l.d=o.d,l}function i(o,l){var u=new s(o),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&a(c,u),h.state=function(){return a(u,{})}),h}n&&n.exports?n.exports=i:this.tychei=i})(aa,t)})(i3);var Oj=i3.exports,o3={exports:{}};const Dj={},Mj=Object.freeze(Object.defineProperty({__proto__:null,default:Dj},Symbol.toStringTag,{value:"Module"})),Pj=TL(Mj);(function(t){(function(e,n,r){var s=256,a=6,i=52,o="random",l=r.pow(s,a),u=r.pow(2,i),c=u*2,h=s-1,d;function p(w,k,N){var T=[];k=k==!0?{entropy:!0}:k||{};var E=g(y(k.entropy?[w,v(n)]:w??b(),3),T),_=new f(T),O=function(){for(var M=_.g(a),V=l,W=0;M<u;)M=(M+W)*s,V*=s,W=_.g(1);for(;M>=c;)M/=2,V/=2,W>>>=1;return(M+W)/V};return O.int32=function(){return _.g(4)|0},O.quick=function(){return _.g(4)/4294967296},O.double=O,g(v(_.S),n),(k.pass||N||function(M,V,W,K){return K&&(K.S&&m(K,_),M.state=function(){return m(_,{})}),W?(r[o]=M,V):M})(O,E,"global"in k?k.global:this==r,k.state)}function f(w){var k,N=w.length,T=this,E=0,_=T.i=T.j=0,O=T.S=[];for(N||(w=[N++]);E<s;)O[E]=E++;for(E=0;E<s;E++)O[E]=O[_=h&_+w[E%N]+(k=O[E])],O[_]=k;(T.g=function(M){for(var V,W=0,K=T.i,q=T.j,ee=T.S;M--;)V=ee[K=h&K+1],W=W*s+ee[h&(ee[K]=ee[q=h&q+V])+(ee[q]=V)];return T.i=K,T.j=q,W})(s)}function m(w,k){return k.i=w.i,k.j=w.j,k.S=w.S.slice(),k}function y(w,k){var N=[],T=typeof w,E;if(k&&T=="object")for(E in w)try{N.push(y(w[E],k-1))}catch{}return N.length?N:T=="string"?w:w+"\0"}function g(w,k){for(var N=w+"",T,E=0;E<N.length;)k[h&E]=h&(T^=k[h&E]*19)+N.charCodeAt(E++);return v(k)}function b(){try{var w;return d&&(w=d.randomBytes)?w=w(s):(w=new Uint8Array(s),(e.crypto||e.msCrypto).getRandomValues(w)),v(w)}catch{var k=e.navigator,N=k&&k.plugins;return[+new Date,e,N,e.screen,v(n)]}}function v(w){return String.fromCharCode.apply(0,w)}if(g(r.random(),n),t.exports){t.exports=p;try{d=Pj}catch{}}else r["seed"+o]=p})(typeof self<"u"?self:aa,[],Math)})(o3);var Lj=o3.exports,zj=$j,Bj=Rj,Wj=Aj,Uj=_j,Vj=Fj,jj=Oj,Rl=Lj;Rl.alea=zj;Rl.xor128=Bj;Rl.xorwow=Wj;Rl.xorshift7=Uj;Rl.xor4096=Vj;Rl.tychei=jj;var Kc=Rl;/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class mk{constructor(e,n,r,s,a){this.mean=e,this.stdDev=n,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const i=a||Math.random();this.random=Kc.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let e,n,r=!1;for(;!r;){let s,a,i;do s=2*this.random()-1,a=2*this.random()-1,i=s*s+a*a;while(i>=1||i===0);const o=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*s*o,n=this.mean+this.stdDev*a*o,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class Gj{constructor(e,n,r,s){this.alpha=e,this.beta=1/n,this.dtype=r;const a=s||Math.random();this.randu=Kc.alea(a.toString()),this.randn=new mk(0,1,r,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,n,r,s,a,i;for(;;){do s=this.randn.nextValue(),i=1+this.c*s;while(i<=0);if(i*=i*i,e=s*s,n=1-.331*e*e,r=.5*e+this.d*(1-i+Math.log(i)),a=this.randu(),a<n||Math.log(a)<r)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class Hj{constructor(e=0,n=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=n-e,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${n} <= 1 and dtype is not float`);this.random=Kc.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Kj(t,e,n=1,r="float32",s){if(ns(t),n==null&&(n=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);const a=new Gj(e,n,r,s),i=Qe(t,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const qj=U({randomGamma_:Kj});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Xj(t,e=0,n=1,r,s){if(ns(t),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const a=new mk(e,n,r,!1,s),i=Qe(t,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const gk=U({randomNormal_:Xj});/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Yj(t,e,n){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return gk(t,0,1,e,n)}const Qj=U({randomStandardNormal_:Yj});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Zj(t,e=0,n=1,r="float32",s){ns(t);const a=Qe(t,r),i=new Hj(e,n,null,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}const Al=U({randomUniform_:Zj});/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Jj(t,e,n,r){return Al(t,e,n,"int32",r)}const eG=U({randomUniformInt_:Jj});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Lu(t,e,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");const s={start:t,stop:e,step:n,dtype:r};return B.runKernel(Wy,{},s)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function tG(t){const e={input:F(t,"input","real")};return B.runKernel(Uy,e)}const Rd=U({real_:tG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function nG(t){const e={x:F(t,"x","reciprocal")};return B.runKernel(Tc,e)}const l3=U({reciprocal_:nG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function rG(t){const e={x:F(t,"x","relu")};return B.runKernel(Ec,e)}const Ka=U({relu_:rG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function sG(t){const e={x:F(t,"x","relu6")};return B.runKernel($c,e)}const yk=U({relu6_:sG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function aG(t,e){const n={x:F(t,"x","reverse")},r={dims:e};return B.runKernel(Up,n,r)}const js=U({reverse_:aG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function iG(t){const e=F(t,"x","reverse");return R(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),js(e,0)}const oG=U({reverse1d_:iG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function lG(t,e){const n=F(t,"x","reverse");return R(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),js(n,e)}const uG=U({reverse2d_:lG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function cG(t,e){const n=F(t,"x","reverse");return R(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),js(n,e)}const hG=U({reverse3d_:cG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function dG(t,e){const n=F(t,"x","reverse");return R(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),js(n,e)}const pG=U({reverse4d_:dG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function fG(t){const e={x:F(t,"x","round")};return B.runKernel(Rc,e)}const bk=U({round_:fG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function mG(t){const e={x:F(t,"x","rsqrt","float32")};return B.runKernel(Ac,e)}const xk=U({rsqrt_:mG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function gG(t){const e={x:F(t,"x","selu")};return B.runKernel(_c,e)}const vk=U({selu_:gG});function yG(t,e,n,r,s,a=[1,1],i="NHWC"){const o=F(t,"x","separableConv2d"),l=F(e,"depthwiseFilter","separableConv2d"),u=F(n,"pointwiseFilter","separableConv2d");let c=o,h=!1;if(o.rank===3&&(h=!0,c=j(o,[1,o.shape[0],o.shape[1],o.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");R(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),R(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),R(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),R(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),R(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const d=l.shape[2],p=l.shape[3];R(u.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${u.shape[2]}.`);const f=tf(c,l,r,s,i,a),m=so(f,u,1,"valid",i);return h?j(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const wk=U({separableConv2d_:yG});/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/async function bG(t,e){const n=F(t,"x","setdiff1d"),r=F(e,"y","setdiff1d");R(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),R(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),R(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=await n.data(),a=await r.data(),i=new Set(a);let o=0;for(let c=0;c<s.length;c++)i.has(s[c])||o++;const l=new wn([o],n.dtype),u=new wn([o],"int32");for(let c=0,h=0;c<s.length;c++)i.has(s[c])||(l.values[h]=s[c],u.values[h]=c,h++);return[l.toTensor(),u.toTensor()]}const xG=bG;/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function vG(t){const e={x:F(t,"x","sign")};return B.runKernel(Dc,e)}const u3=U({sign_:vG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function wG(t){const e={x:F(t,"x","sin","float32")};return B.runKernel(Fc,e)}const kk=U({sin_:wG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function kG(t){const e={x:F(t,"x","sinh")};return B.runKernel(Oc,e)}const Sk=U({sinh_:kG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function SG(t,e,n){const r=F(t,"x","slice1d");return R(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),je(r,[e],[n])}const vb=U({slice1d_:SG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function IG(t,e,n){const r=F(t,"x","slice2d");return R(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),je(r,e,n)}const Ik=U({slice2d_:IG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function NG(t,e,n){const r=F(t,"x","slice3d");return R(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),je(r,e,n)}const wb=U({slice3d_:NG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function CG(t,e,n){const r=F(t,"x","slice4d");return R(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),je(r,e,n)}const Ad=U({slice4d_:CG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function TG(t,e=-1){const n=F(t,"logits","softmax","float32");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);const r={logits:n},s={dim:e};return B.runKernel(qp,r,s)}const kb=U({softmax_:TG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function EG(t){R(t.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`);const e={input:t};return B.runKernel(Ty,e)}const Sb=U({fft_:EG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function $G(t){R(t.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`);const e={input:t};return B.runKernel(Ay,e)}const _d=U({ifft_:$G});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function RG(t){const e=t.shape[t.shape.length-1],n=t.size/e;let r;if(e<=2){const s=j(t,[n,e]);r=_d(s)}else{const s=[n,2*(e-1)],a=j(Rd(t),[n,e]),i=j(cb(t),[n,e]),o=js(je(a,[0,1],[n,e-2]),1),l=z(js(je(i,[0,1],[n,e-2]),1),Me(-1)),u=qt([a,o],1),c=qt([i,l],1),h=j(to(u,c),[s[0],s[1]]);r=_d(h)}if(r=Rd(r),t.rank===3&&t.shape[0]!==0){const s=r,a=t.shape[0];r=j(r,[a,r.shape[0]/a,r.shape[1]]),s.dispose()}return r}const Nk=U({irfft_:RG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function AG(t,e,n=0){const r={x:F(t,"x","split")},s={numOrSizeSplits:e,axis:n};return B.runKernel(Kp,r,s)}const Qr=U({split_:AG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _G(t,e){R(t.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let n=t.shape[t.shape.length-1];const r=t.size/n;let s;if(e!=null&&e<n){const f=t.shape.map(y=>0),m=t.shape.map(y=>y);m[t.shape.length-1]=e,s=je(t,f,m),n=e}else if(e!=null&&e>n){const f=t.shape.map(m=>m);f[t.shape.length-1]=e-n,s=qt([t,rn(f)],t.shape.length-1),n=e}else s=t;const a=dt(s),i=j(to(s,a),[r,n]),o=Sb(i),l=Math.floor(n/2)+1,u=Rd(o),c=cb(o),h=Qr(u,[l,n-l],u.shape.length-1),d=Qr(c,[l,n-l],c.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=l,j(to(h[0],d[0]),p)}const Ib=U({rfft_:_G});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function FG(t,e){let n=F(t,"a","squaredDifference"),r=F(e,"b","squaredDifference");[n,r]=Xt(n,r),Ue(n.shape,r.shape);const s={a:n,b:r},a={};return B.runKernel(zc,s,a)}const Ck=U({squaredDifference_:FG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function OG(t,e){const n=F(t,"x","squeeze","string_or_numeric");return j(n,xi(n.shape,e).newShape)}const yt=U({squeeze_:OG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function DG(t,e=0){const n=Id(t,"tensors","stack","string_or_numeric");R(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&R(e<=n[0].rank,()=>"Axis must be <= rank of the tensor");const r=n,s={axis:e};return B.runKernel(Dp,r,s)}const Tr=U({stack_:DG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function MG(t,e=0){const n={x:F(t,"x","step")},r={alpha:e};return B.runKernel(jc,n,r)}const qc=U({step_:MG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function PG(t,e,n,r,s=0,a=0,i=0,o=0,l=0){const u={x:F(t,"x","stridedSlice","string_or_numeric")},c={begin:e,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return B.runKernel(Jy,u,c)}const c3=U({stridedSlice_:PG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function LG(t){const e={x:F(t,"x","tan","float32")};return B.runKernel(Wc,e)}const h3=U({tan_:LG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function dn(t,e){Il(t);const n=yo(t,e);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return bo(t,null,n,e)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Bs(t,e,n){if(Il(t),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=yo(t,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return bo(t,e,r,n)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function d3(t,e,n){if(Il(t),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const r=yo(t,n);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return bo(t,e,r,n)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zG(t,e,n){if(Il(t),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const r=yo(t,n);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return bo(t,e,r,n)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function BG(t,e,n){if(Il(t),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const r=yo(t,n);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return bo(t,e,r,n)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function WG(t,e,n){if(Il(t),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const r=yo(t,n);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||r,bo(t,e,r,n)}function Tk(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(t.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+t.length-r)throw new Error(a+` update.rank != ${s+t.length-r}`);for(let i=0;i<s;++i)if(n.shape[i]!==e.shape[i])throw new Error(a+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${e.shape[i]}).`);for(let i=0;i<n.rank-s;++i)if(n.shape[i+s]!==t[i+r])throw new Error(a+` updates.shape[${i+s}] (${n.shape[i+s]}) != shape[${i+s}] (${t[i+s]})`)}function Nb(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(t.size===0)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}Tk(n,e,t)}function ka(t,e,n){const r=e.shape.length,s=r>1?e.shape[r-1]:1,a=n.length;let i=1;for(let h=s;h<a;++h)i*=n[h];const o=s<1?1:s,l=Q(e.shape)/o,u=[...Fe(n.slice(0,s)),1],c=Q(n);return{sliceRank:s,numUpdates:l,sliceSize:i,strides:u,outputSize:c}}const Bke=Object.freeze(Object.defineProperty({__proto__:null,calculateShapes:ka,validateInput:Nb,validateUpdateShape:Tk},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function UG(t,e,n){const r=F(t,"tensor","tensorScatterupdate"),s=F(e,"indices","tensorScatterupdate","int32"),a=F(n,"updates","tensorScatterupdate");if(Nb(a,s,r.shape),r.dtype!==a.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${a.dtype}.`);const i={tensor:r,indices:s,updates:a},o={};return B.runKernel(Hy,i,o)}const VG=U({tensorScatterUpdate_:UG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function jG(t,e=1,n=!0){const r=F(t,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${e}`);const a={x:r},i={k:e,sorted:n},[o,l]=B.runKernel(tb,a,i);return{values:o,indices:l}}const p3=U({topk_:jG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function GG(t,e=0,n=1,r,s){if(ns(t),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const a=new mk(e,n,r,!0,s),i=Qe(t,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const Ek=U({truncatedNormal_:GG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function HG(t,e=0){const n=F(t,"x","unique","string_or_numeric");R(n.rank>0,()=>"The input tensor must be at least 1D");const r={x:n},s={axis:e},[a,i]=B.runKernel(Vw,r,s);return{values:a,indices:i}}const f3=U({unique_:HG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function KG(t,e,n){const r=F(t,"x","unsortedSegmentSum"),s=F(e,"segmentIds","unsortedSegmentSum","int32");R(il(n),()=>"numSegments must be of dtype int");const a={x:r,segmentIds:s},i={numSegments:n};return B.runKernel(Yp,a,i)}const $k=U({unsortedSegmentSum_:KG});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function qG(t,e=0){const n=F(t,"x","unstack","string_or_numeric");R(e>=-n.shape.length&&e<n.shape.length,()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`);const r={value:n},s={axis:e};return B.runKernel(Xp,r,s)}const Gs=U({unstack_:qG});/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function XG(t,e){return dk(t,e,"right")}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function m3(t,e=!0,n,r){return B.makeVariable(t,e,n,r)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Rk(t,e){const n=[];for(let a=0;a<e.length;a++)e[a]&&n.push(a);const r=Qe(t,"int32"),s=Qe([n.length,t.length],"int32");for(let a=0;a<n.length;a++){const i=r.indexToLoc(n[a]),o=a*t.length;s.values.set(i,o)}return s.toTensor()}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/async function YG(t){const e=F(t,"condition","whereAsync","bool"),n=await e.data(),r=Rk(e.shape,n);return t!==e&&e.dispose(),r}const g3=YG;/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/async function QG(t,e,n){const r=F(t,"tensor","boolMask"),s=F(e,"mask","boolMask","bool"),a=n??0,i=s.rank,o=r.shape;R(i>0,()=>"mask cannot be scalar"),Dn(o.slice(a,a+i),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=a;m<a+i;m++)l*=o[m];const u=o.slice(0,a).concat([l],o.slice(a+i)),c=j(r,u),h=j(s,[-1]),d=await g3(h),p=yt(d,[1]),f=af(c,p,a);return t!==r&&r.dispose(),e!==s&&s.dispose(),p.dispose(),c.dispose(),h.dispose(),d.dispose(),f}const ZG=QG;/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function JG(t,e,n){const r=F(t,"x","transpose");if(e==null&&(e=r.shape.map((i,o)=>o).reverse()),R(r.rank===e.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`),e.forEach(i=>{R(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${e}`)}),r.rank<=1)return r.clone();const s={x:r},a={perm:e};return r.dtype==="complex64"?Y(()=>{let i=Rd(r),o=cb(r);return i=B.runKernel(Qo,{x:i},a),o=B.runKernel(Qo,{x:o},a),n&&(o=Lt(o)),to(i,o)}):B.runKernel(Qo,s,a)}const ht=U({transpose_:JG});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function e6(t,e,n,r,s=!0){const a=F(t,"v","movingAverage"),i=F(e,"x","movingAverage"),o=F(n,"decay","movingAverage");Q$(a,i),R(Je(a.shape,i.shape),()=>"Shape mismatch in v and x");const l=Me(1),u=Ie(l,o);let c=z(Ie(i,a),u);if(s){R(r!=null,()=>"When using zeroDebias: true, step is required.");const h=F(r,"step","movingAverage");c=Se(c,Ie(l,mi(o,h)))}return ie(a,c)}const t6=U({movingAverage_:e6});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function n6(t,e,n){ns(n);const r=F(t,"indices","scatterND","int32"),s=F(e,"updates","scatterND");Nb(s,r,n);const a={indices:r,updates:s},i={shape:n};return B.runKernel(Gy,a,i)}const r6=U({scatterND_:n6});function s6(t,e,n,r){if(t.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const s=t.rank>0?t.shape[0]:1,a=t.rank>1?t.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);const i=e.size;if(!(e.rank===0||e.rank===1&&i===s))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${s}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function a6(t,e,n,r=0){ns(n);const s=F(t,"sparseIndices","sparseToDense","int32"),a=F(e,"sparseValues","sparseToDense","string_or_numeric"),i=F(r,"defaultValue","sparseToDense",a.dtype);s6(s,a,n,i);const o={sparseIndices:s,sparseValues:a,defaultValue:i},l={outputShape:n};return B.runKernel(Yy,o,l)}const i6=U({sparseToDense_:a6});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function o6(t,e){const n=F(e,"indices","gatherND","int32"),r={params:F(t,"x","gatherND","string_or_numeric"),indices:n};return B.runKernel(Ry,r)}const l6=U({gatherND_:o6});/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function u6(t,e){if(e==null)return t.shape.slice();if(Je(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let r=0;r<t.shape.length;r++)e[r]==null&&t.shape[r]!=null?n.push(t.shape[r]):n.push(e[r]);return n}return e}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function c6(t,e,n,r){const s=F(t,"x","dropout");if(R(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),R(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return t instanceof st?s.clone():s;const a=u6(s,n),i=1-e,o=Se(sf(ie(Al(a,0,1,"float32",r),i)),i);return z(s,o)}const y3=U({dropout_:c6});/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function b3(t){return Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2))))}function Ak(t,e,n){const r=1-t%2,s=new Float32Array(t);for(let a=0;a<t;++a){const i=2*Math.PI*a/(t+r-1);s[a]=e-n*Math.cos(i)}return dn(s,"float32")}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/async function h6(t,e,n=1){const r=F(t,"predictions","inTopK"),s=F(e,"targets","inTopK");R(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),R(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),Dn(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const a=r.shape[r.shape.length-1];R(n>0&&n<=a,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`);const i=await r.data(),o=await s.data(),[l,u]=[i.length/a,a],c=pn("bool",l);for(let h=0;h<l;h++){const d=h*u,p=i.subarray(d,d+u),f=[];for(let m=0;m<p.length;m++)f.push({value:p[m],index:m});f.sort((m,y)=>y.value-m.value),c[h]=0;for(let m=0;m<n;m++)if(f[m].index===o[h]){c[h]=1;break}}return t!==r&&r.dispose(),e!==s&&s.dispose(),Ls(c,s.shape,"bool")}const d6=h6;/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function p6(t,e,n,r,s,a="NHWC",i){let o=t;t.rank===3&&(o=j(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;l.rank===3&&(l=j(e,[1,e.shape[0],e.shape[1],e.shape[2]])),R(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),R(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),R(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const u=a==="NHWC"?o.shape[3]:o.shape[1],c=a==="NHWC"?l.shape[3]:l.shape[1];R(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),R(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),mr("conv2dDerFilter",s,i);const h={x:o,dy:l},d={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,filterShape:n};return B.runKernel(fy,h,d)}const _k=U({conv2DBackpropFilter_:p6});/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Cb(t,e,n){if(n==null||n==="linear")return t;if(n==="relu")return z(t,qc(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Tb(t,e){let n=e;const r=fn(t.shape,e.shape);return r.length>0&&(n=Re(n,r)),j(n,t.shape)}function Eb(t,e,n,r){if(e==="linear")return t;if(e==="relu")return Ka(t);if(e==="elu")return nf(t);if(e==="relu6")return yk(t);if(e==="prelu")return xb(t,n);if(e==="leakyrelu")return hb(t,r);if(e==="sigmoid")return ps(t);throw new Error(`Unknown fused activation ${e}.`)}const $b=(t,e)=>!(t>0)||e==="linear";/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function f6({x:t,filter:e,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",$b(B.state.gradientDepth,l)===!1){R(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let N=so(t,e,n,r,s,a,i);return o!=null&&(N=ie(N,o)),Eb(N,l,u,c)}const h=F(t,"x","conv2d","float32"),d=F(e,"filter","conv2d","float32");let p=h,f=!1;h.rank===3&&(f=!0,p=j(h,[1,h.shape[0],h.shape[1],h.shape[2]])),R(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),R(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),mr("fused conv2d",r,i);const m=s==="NHWC"?p.shape[3]:p.shape[1];R(d.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${d.shape[2]}.`),R(In(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);const y=_t(p.shape,d.shape,n,a,r,i);let g;o!=null&&(g=F(o,"bias","fused conv2d"),[g]=Xt(g,h),s==="NHWC"?Ue(y.outShape,g.shape):(R(g.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${g.shape.length}.`),R(g.shape.length===0||g.shape[0]===y.outChannels||g.shape[0]===1,()=>`Error in fused conv2d: bias shape (${g.shape}) is not compatible with the number of output channels (${y.outChannels})`)));let b;if(u!=null){const N=u.shape;if(R(N.length<=1||N.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${N.length}.`),N.length===1)R(N[0]===1||N[0]===y.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${N}) is not compatible with the number of output channels (${y.outChannels}).`);else if(N.length===3)try{Ue(N,y.outShape)}catch{const T=`Error in fused conv2d: PReLU activation weights (${N}) is not compatible with the output shape of the conv2d (${y.outShape}).`;throw Error(T)}b=F(u,"prelu weights","fused conv2d")}const v=(N,T)=>{R(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[E,_,O,M]=T,V=Cb(N,O,l);R(ro(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const W=rk(_.shape,V,E,n,r),K=_k(_,V,E.shape,n,r),q=[W,K];if(M!=null){const ee=Tb(M,V);q.push(ee)}return q},w={x:p,filter:d,bias:g,preluActivationWeights:b},k={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return o==null?gi((N,T,E)=>{let _=B.runKernel(wd,w,k);return E([T,N,_]),f&&(_=j(_,[_.shape[1],_.shape[2],_.shape[3]])),{value:_,gradFunc:v}})(p,d):gi((N,T,E,_)=>{let O=B.runKernel(wd,w,k);return _([T,N,O,E]),f&&(O=j(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:v}})(p,d,g)}const x3=U({fusedConv2d_:f6});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function m6(t,e,n,r,s,a=[1,1],i){let o=t;t.rank===3&&(o=j(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;l.rank===3&&(l=j(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={x:o,dy:l},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,filterShape:n};return B.runKernel(wy,u,c)}const v3=U({depthwiseConv2dNativeBackpropFilter_:m6});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function g6(t,e,n,r,s,a=[1,1],i){let o=e,l=!1;e.rank===3&&(l=!0,o=j(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={dy:o,filter:n},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,inputShape:t},h=B.runKernel(ky,u,c);return l?j(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const w3=U({depthwiseConv2dNativeBackpropInput_:g6});/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function y6({x:t,filter:e,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if($b(B.state.gradientDepth,l)===!1){let k=tf(t,e,n,r,s,a,i);return o!=null&&(k=ie(k,o)),Eb(k,l,u,c)}const h=F(t,"x","depthwiseConv2d","float32"),d=F(e,"filter","depthwiseConv2d","float32");let p=h,f=!1;h.rank===3&&(f=!0,p=j(h,[1,h.shape[0],h.shape[1],h.shape[2]])),R(p.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),R(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),R(p.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),a==null&&(a=[1,1]),R(In(n,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),mr("fused depthwiseConv2d",r,i);const m=_t(p.shape,d.shape,n,a,r,i,!0);let y;o!=null&&(y=F(o,"bias","fused conv2d"),[y]=Xt(y,h),Ue(m.outShape,y.shape));let g;u!=null&&(g=F(u,"prelu weights","fused depthwiseConv2d"));const b=(k,N)=>{R(ro(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[T,E,_,O]=N,M=Cb(k,_,l),V=w3(E.shape,M,T,n,r,a,i),W=v3(E,M,T.shape,n,r,a,i);if(O!=null){const K=Tb(y,M);return[V,W,K]}return[V,W]},v={x:p,filter:d,bias:y,preluActivationWeights:g},w={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return o==null?gi((k,N,T)=>{let E=B.runKernel(kd,v,w);return T([N,k,E]),f&&(E=j(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:b}})(p,d):gi((k,N,T,E)=>{let _=B.runKernel(kd,v,w);return E([N,k,_,T]),f&&(_=j(_,[_.shape[1],_.shape[2],_.shape[3]])),{value:_,gradFunc:b}})(p,d,y)}const b6=U({fusedDepthwiseConv2d_:y6});/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function x6({a:t,b:e,transposeA:n=!1,transposeB:r=!1,bias:s,activation:a="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if($b(B.state.gradientDepth,a)===!1){let O=ot(t,e,n,r);return s!=null&&(O=ie(O,s)),Eb(O,a,i,o)}let l=F(t,"a","fused matMul"),u=F(e,"b","fused matMul");[l,u]=Xt(l,u);const c=n?l.shape[l.rank-2]:l.shape[l.rank-1],h=r?u.shape[u.rank-1]:u.shape[u.rank-2],d=n?l.shape[l.rank-1]:l.shape[l.rank-2],p=r?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),m=u.shape.slice(0,-2),y=Q(f),g=Q(m);R(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${r} must match.`);const b=Ue(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([d,p]),v=n?j(l,[y,c,d]):j(l,[y,d,c]),w=r?j(u,[g,p,h]):j(u,[g,h,p]);let k;s!=null&&(k=F(s,"bias","fused matMul"),[k]=Xt(k,l),Ue(b,k.shape));let N;i!=null&&(N=F(i,"prelu weights","fused matMul"));const T=(O,M)=>{const[V,W,K,q]=M,ee=Cb(j(O,K.shape),K,a);let te,G;if(!n&&!r?(te=ot(ee,W,!1,!0),G=ot(V,ee,!0,!1)):!n&&r?(te=ot(ee,W,!1,!1),G=ot(ee,V,!0,!1)):n&&!r?(te=ot(W,ee,!1,!0),G=ot(V,ee,!1,!1)):(te=ot(W,ee,!0,!0),G=ot(ee,V,!0,!0)),s!=null){const J=Tb(q,ee);return[te,G,J]}else return[te,G]},E={a:v,b:w,bias:k,preluActivationWeights:N},_={transposeA:n,transposeB:r,activation:a,leakyreluAlpha:o};return s==null?gi((O,M,V)=>{const W=B.runKernel(vd,E,_);return V([O,M,W]),{value:j(W,b),gradFunc:T}})(v,w):gi((O,M,V,W)=>{const K=B.runKernel(vd,E,_);return W([O,M,K,V]),{value:j(K,b),gradFunc:T}})(v,w,k)}const q1=U({fusedMatMul_:x6});/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const v6=Object.freeze(Object.defineProperty({__proto__:null,conv2d:x3,depthwiseConv2d:b6,matMul:q1},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function w6(t){return Ak(t,.54,.46)}const k6=U({hammingWindow_:w6});/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function S6(t){return Ak(t,.5,.5)}const k3=U({hannWindow_:S6});/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function I6(t,e,n,r=!1,s=0){let a=0;const i=[];for(;a+e<=t.size;)i.push(je(t,a,e)),a+=n;if(r)for(;a<t.size;){const o=a+e-t.size,l=qt([je(t,a,e-o),Gc([o],s)]);i.push(l),a+=n}return i.length===0?Bs([],[0,e]):j(qt(i),[i.length,e])}const S3=U({frame_:I6});/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function N6(t,e,n,r,s=k3){r==null&&(r=b3(e));const a=S3(t,e,n),i=z(a,s(e));return Ib(i,r)}const C6=U({stft_:N6});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function T6(t,e,n,r,s="bilinear",a=0){const i=F(t,"image","cropAndResize"),o=F(e,"boxes","cropAndResize","float32"),l=F(n,"boxInd","cropAndResize","int32"),u=o.shape[0];R(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),R(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`),R(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`),R(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),R(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),R(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const c={image:i,boxes:o,boxInd:l},h={method:s,extrapolationValue:a,cropSize:r};return B.runKernel(by,c,h)}const E6=U({cropAndResize_:T6});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function $6(t){const e=F(t,"image","flipLeftRight","float32");R(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const n={image:e};return B.runKernel($y,n,{})}const R6=U({flipLeftRight_:$6});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function A6(t){const e=F(t,"image","grayscaleToRGB"),n=e.rank-1,r=e.shape[n];R(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),R(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(e.rank);return s.fill(1,0,n),s[n]=3,Ds(e,s)}const _6=U({grayscaleToRGB_:A6});/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function F6(t){const e=F(t,"image","RGBToGrayscale"),n=e.rank-1,r=e.shape[n];R(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),R(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);const s=e.dtype,a=me(e,"float32"),i=dn([.2989,.587,.114]);let o;switch(e.rank){case 2:o=nu("ij,j->i",a,i);break;case 3:o=nu("ijk,k->ij",a,i);break;case 4:o=nu("ijkl,l->ijk",a,i);break;case 5:o=nu("ijklm,m->ijkl",a,i);break;case 6:o=nu("ijklmn,n->ijklm",a,i);break;default:throw new Error("Not a valid tensor rank.")}return o=hn(o,-1),me(o,s)}const O6=U({rgbToGrayscale_:F6});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function D6(t,e,n=0,r=.5){const s=F(t,"image","rotateWithOffset","float32");R(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const a={image:s},i={radians:e,fillValue:n,center:r};return B.runKernel(rb,a,i)}const M6=U({rotateWithOffset_:D6});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Xc(t,e,n,r,s,a){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),a==null&&(a=0);const i=t.shape[0];return n=Math.min(n,i),R(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),R(t.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),R(t.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),R(e.rank===1,()=>"scores must be a 1D tensor"),R(e.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${e.shape[0]}`),R(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function P6(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=F(t,"boxes","nonMaxSuppression","float32"),i=F(e,"scores","nonMaxSuppression","float32"),o=Xc(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const l={maxOutputSize:n,iouThreshold:r,scoreThreshold:s};return B.runKernel(zy,{boxes:a,scores:i},l)}const L6=U({nonMaxSuppression_:P6});/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function z6(t,e,n){const r=B6(t,e,n),s=r<0?-(r+1):r;t.splice(s,0,e)}function B6(t,e,n){return U6(t,e,n||W6)}function W6(t,e){return t>e?1:t<e?-1:0}function U6(t,e,n){let r=0,s=t.length,a=0,i=!1;for(;r<s;){a=r+(s-r>>>1);const o=n(e,t[a]);o>0?r=a+1:(s=a,i=!o)}return i?r:-r-1}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Rb(t,e,n,r,s){return Ok(t,e,n,r,s,0)}function Fk(t,e,n,r,s,a){return Ok(t,e,n,r,s,0,!1,a,!0)}function Ab(t,e,n,r,s,a){return Ok(t,e,n,r,s,a,!0)}function Ok(t,e,n,r,s,a,i=!1,o=!1,l=!1){const u=[];for(let y=0;y<e.length;y++)e[y]>s&&u.push({score:e[y],boxIndex:y,suppressBeginIndex:0});u.sort(tN);const c=a>0?-.5/a:0,h=[],d=[];for(;h.length<n&&u.length>0;){const y=u.pop(),{score:g,boxIndex:b,suppressBeginIndex:v}=y;if(g<s)break;let w=!1;for(let k=h.length-1;k>=v;--k){const N=V6(t,b,h[k]);if(N>=r){w=!0;break}if(y.score=y.score*j6(r,c,N),y.score<=s)break}y.suppressBeginIndex=h.length,w||(y.score===g?(h.push(b),d.push(y.score)):y.score>s&&z6(u,y,tN))}const p=h.length,f=n-p;o&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return i&&(m.selectedScores=d),l&&(m.validOutputs=p),m}function V6(t,e,n){const r=t.subarray(e*4,e*4+4),s=t.subarray(n*4,n*4+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),p=(o-a)*(l-i),f=(h-u)*(d-c);if(p<=0||f<=0)return 0;const m=Math.max(a,u),y=Math.max(i,c),g=Math.min(o,h),b=Math.min(l,d),v=Math.max(g-m,0)*Math.max(b-y,0);return v/(p+f-v)}function j6(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function tN(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/async function G6(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=F(t,"boxes","nonMaxSuppressionAsync"),i=F(e,"scores","nonMaxSuppressionAsync"),o=Xc(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const l=await Promise.all([a.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:h}=Rb(u,c,n,r,s);return a!==t&&a.dispose(),i!==e&&i.dispose(),dn(h,"int32")}const H6=G6;/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function K6(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=F(t,"boxes","nonMaxSuppression"),o=F(e,"scores","nonMaxSuppression"),l=Xc(i,o,n,r,s,a);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,a=l.softNmsSigma;const u={boxes:i,scores:o},c={maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a},h=B.runKernel(By,u,c);return{selectedIndices:h[0],selectedScores:h[1]}}const q6=U({nonMaxSuppressionWithScore_:K6});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/async function X6(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=F(t,"boxes","nonMaxSuppressionAsync"),o=F(e,"scores","nonMaxSuppressionAsync"),l=Xc(i,o,n,r,s,a);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,a=l.softNmsSigma;const u=await Promise.all([i.data(),o.data()]),c=u[0],h=u[1],{selectedIndices:d,selectedScores:p}=Ab(c,h,n,r,s,a);return i!==t&&i.dispose(),o!==e&&o.dispose(),{selectedIndices:dn(d,"int32"),selectedScores:dn(p)}}const Y6=X6;/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Q6(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=F(t,"boxes","nonMaxSuppression"),o=F(e,"scores","nonMaxSuppression"),l=Xc(i,o,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,d={boxes:i,scores:o},p={maxOutputSize:u,iouThreshold:c,scoreThreshold:h,padToMaxOutputSize:a},f=B.runKernel(Dw,d,p);return{selectedIndices:f[0],validOutputs:f[1]}}const Z6=U({nonMaxSuppressionPadded_:Q6});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/async function J6(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=F(t,"boxes","nonMaxSuppressionAsync"),o=F(e,"scores","nonMaxSuppressionAsync"),l=Xc(i,o,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=Fk(d,p,u,c,h,a);return i!==t&&i.dispose(),o!==e&&o.dispose(),{selectedIndices:dn(f,"int32"),validOutputs:Me(m,"int32")}}const eH=J6;/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function tH(t,e,n=!1,r=!1){const s=F(t,"images","resizeBilinear");R(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),R(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),R(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=s,i=!1;s.rank===3&&(i=!0,a=j(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const o={images:a},l={alignCorners:n,halfPixelCenters:r,size:e},u=B.runKernel(Wp,o,l);return i?j(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const I3=U({resizeBilinear_:tH});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function nH(t,e,n=!1,r=!1){const s=F(t,"images","resizeNearestNeighbor");R(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),R(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),R(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),R(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=s,i=!1;s.rank===3&&(i=!0,a=j(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const o={images:a},l={alignCorners:n,halfPixelCenters:r,size:e},u=B.runKernel(Bp,o,l);return i?j(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const N3=U({resizeNearestNeighbor_:nH});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* https://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function rH(t,e="binary",n=!1,r=.5){const s=F(t,"image","threshold"),a=.2989,i=.587,o=.114,l=s.shape[0]*s.shape[1];let u=z(dn([r]),255),c,h,d,p;if(R(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),R(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),R(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),R(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),s.shape[2]===3){[c,h,d]=Qr(s,[1,1,1],-1);const m=z(c,a),y=z(h,i),g=z(d,o);p=ie(ie(m,y),g)}else p=t;if(e==="otsu"){const m=ER(me(bk(p),"int32"),Ls([]),256);u=sH(m,l)}const f=n?$l(p,u):_r(p,u);return me(z(f,255),"int32")}function sH(t,e){let n=dn([-1]),r=dn([0]),s=dn([0]),a,i,o,l,u,c;for(let h=0;h<t.size-1;h++){a=je(t,0,h+1),i=je(t,h+1),u=Se(Re(a),e),c=Se(Re(i),e);const d=Re(z(a,Lu(0,a.size)));o=Se(d,Re(a));const p=Gc(i.shape,a.size),f=ie(Lu(0,i.size),p),m=z(i,f);l=Se(Re(m),Re(i));const y=Ie(o,l),g=Ie(o,l),b=z(u,c);s=z(z(b,y),g);const v=_r(s,r);r=Un(v,s,r),n=Un(v,dn([h]),n)}return n}const aH=U({threshold_:rH});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function iH(t,e,n="nearest",r="constant",s=0,a){const i=F(t,"image","transform","float32"),o=F(e,"transforms","transform","float32");R(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),R(o.rank===2&&(o.shape[0]===i.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),R(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);const l={image:i,transforms:o},u={interpolation:n,fillMode:r,fillValue:s,outputShape:a};return B.runKernel(nb,l,u)}const oH=U({transform_:iH});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function lH(t,e,n){const r=F(t,"a","bandPart");R(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[a,i]=r.shape.slice(-2);let o,l;typeof e=="number"?(R(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),R(e<=a,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${a}).`),o=F(e<0?a:e,"numLower","bandPart")):(R(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=Un($d(e,0),a,ao(e,a))),typeof n=="number"?(R(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),R(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),l=F(n<0?i:n,"numUpper","bandPart")):(R(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=Un($d(n,0),i,ao(n,i)));const u=j(Lu(0,a,1,"int32"),[-1,1]),c=Lu(0,i,1,"int32"),h=Ie(u,c),d=da($l(h,o),vo(h,Lt(l))),p=rn([a,i],r.dtype);return j(Tr(Gs(j(r,[-1,a,i])).map(f=>Un(d,f,p))),s)}const uH=U({bandPart_:lH});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function cH(t){let e;if(Array.isArray(t)){e=!1,R(t!=null&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=t[0].shape[0];for(let a=1;a<t.length;++a)R(t[a].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[a].shape[0]} vs. ${s})`)}else e=!0,t=Qr(t,t.shape[0],0).map(s=>yt(s,[0]));R(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const n=[],r=t;for(let s=0;s<t.length;++s)n.push(B.tidy(()=>{let a=r[s];if(s>0)for(let i=0;i<s;++i){const o=z(Re(z(n[i],a)),n[i]);a=Ie(a,o)}return Se(a,rf(a,"euclidean"))}));return e?Tr(n,0):n}const hH=U({gramSchmidt_:cH});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function dH(t,e=!1){if(R(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),t.rank===2)return nN(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce((l,u)=>l*u),r=Gs(j(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),s=[],a=[];r.forEach(l=>{const[u,c]=nN(l,e);s.push(u),a.push(c)});const i=j(Tr(s,0),t.shape),o=j(Tr(a,0),t.shape);return[i,o]}}function nN(t,e=!1){return B.tidy(()=>{R(t.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const n=t.shape[0],r=t.shape[1];let s=uk(n),a=ii(t);const i=Bs([[1]],[1,1]);let o=ii(i);const l=n>=r?r:n;for(let u=0;u<l;++u){const c=a,h=o,d=s;[o,a,s]=B.tidy(()=>{const p=je(a,[u,u],[n-u,1]),f=rf(p),m=je(a,[u,u],[1,1]),y=Un(_r(m,0),Bs([[-1]]),Bs([[1]])),g=Ie(m,z(y,f)),b=Se(p,g);b.shape[0]===1?o=ii(i):o=qt([i,je(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);const v=Lt(Se(ot(y,g),f)),w=je(a,[u,0],[n-u,r]),k=z(v,o),N=ht(o);if(u===0)a=Ie(w,ot(k,ot(N,w)));else{const _=Ie(w,ot(k,ot(N,w)));a=qt([je(a,[0,0],[u,r]),_],0)}const T=ht(k),E=je(s,[0,u],[n,s.shape[1]-u]);if(u===0)s=Ie(E,ot(ot(E,o),T));else{const _=Ie(E,ot(ot(E,o),T));s=qt([je(s,[0,0],[n,u]),_],1)}return[o,a,s]}),Pe([c,h,d])}return!e&&n>r&&(s=je(s,[0,0],[n,r]),a=je(a,[0,0],[r,r])),[s,a]})}const pH=U({qr_:dH});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/var wr;(function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(wr||(wr={}));function fH(t,e,n=wr.SUM_BY_NONZERO_WEIGHTS){const r=F(t,"losses","computeWeightedLoss");let s=null;e!=null&&(s=F(e,"weights","computeWeightedLoss"));const a=s==null?r:z(r,s);if(n===wr.NONE)return a;if(n===wr.SUM)return Re(a);if(n===wr.MEAN){if(s==null)return Qt(a);{const i=r.size/s.size,o=Se(Re(a),Re(s));return i>1?Se(o,Me(i)):o}}if(n===wr.SUM_BY_NONZERO_WEIGHTS){if(s==null)return Se(Re(a),Me(r.size));{const i=z(s,Kr(r.shape)),o=me(Re(Pu(i,Me(0))),"float32");return Se(Re(a),o)}}throw Error(`Unknown reduction: ${n}`)}const ki=U({computeWeightedLoss_:fH});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function mH(t,e,n,r=wr.SUM_BY_NONZERO_WEIGHTS){const s=F(t,"labels","absoluteDifference"),a=F(e,"predictions","absoluteDifference");let i=null;n!=null&&(i=F(n,"weights","absoluteDifference")),Dn(s.shape,a.shape,"Error in absoluteDifference: ");const o=yn(Ie(s,a));return ki(o,i,r)}const gH=U({absoluteDifference_:mH});function yH(t,e,n,r,s=wr.SUM_BY_NONZERO_WEIGHTS){const a=F(t,"labels","cosineDistance"),i=F(e,"predictions","cosineDistance");let o=null;r!=null&&(o=F(r,"weights","cosineDistance")),Dn(a.shape,i.shape,"Error in cosineDistance: ");const l=Me(1),u=Ie(l,Re(z(a,i),n,!0));return ki(u,o,s)}const bH=U({cosineDistance_:yH});function xH(t,e,n,r=wr.SUM_BY_NONZERO_WEIGHTS){let s=F(t,"labels","hingeLoss");const a=F(e,"predictions","hingeLoss");let i=null;n!=null&&(i=F(n,"weights","hingeLoss")),Dn(s.shape,a.shape,"Error in hingeLoss: ");const o=Me(1);s=Ie(z(Me(2),s),o);const l=Ka(Ie(o,z(s,a)));return ki(l,i,r)}const vH=U({hingeLoss_:xH});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function wH(t,e,n,r=1,s=wr.SUM_BY_NONZERO_WEIGHTS){const a=F(t,"labels","huberLoss"),i=F(e,"predictions","huberLoss");let o=null;n!=null&&(o=F(n,"weights","huberLoss")),Dn(a.shape,i.shape,"Error in huberLoss: ");const l=Me(r),u=yn(Ie(i,a)),c=ao(u,l),h=Ie(u,c),d=ie(z(Me(.5),It(c)),z(l,h));return ki(d,o,s)}const kH=U({huberLoss_:wH});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function SH(t,e,n,r=1e-7,s=wr.SUM_BY_NONZERO_WEIGHTS){const a=F(t,"labels","logLoss"),i=F(e,"predictions","logLoss");let o=null;n!=null&&(o=F(n,"weights","logLoss")),Dn(a.shape,i.shape,"Error in logLoss: ");const l=Me(1),u=Me(r),c=Lt(z(a,gs(ie(i,u)))),h=z(Ie(l,a),gs(ie(Ie(l,i),u))),d=Ie(c,h);return ki(d,o,s)}const IH=U({logLoss_:SH});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function NH(t,e,n,r=wr.SUM_BY_NONZERO_WEIGHTS){const s=F(t,"labels","meanSquaredError"),a=F(e,"predictions","meanSquaredError");let i=null;n!=null&&(i=F(n,"weights","meanSquaredError")),Dn(s.shape,a.shape,"Error in meanSquaredError: ");const o=Ck(s,a);return ki(o,i,r)}const CH=U({meanSquaredError_:NH});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function TH(t,e){const n=F(t,"labels","sigmoidCrossEntropyWithLogits"),r=F(e,"logits","sigmoidCrossEntropyWithLogits");Dn(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=Ka(r),a=z(r,n),i=db(pr(Lt(yn(r))));return ie(Ie(s,a),i)}function EH(t,e,n,r=0,s=wr.SUM_BY_NONZERO_WEIGHTS){let a=F(t,"multiClassLabels","sigmoidCrossEntropy");const i=F(e,"logits","sigmoidCrossEntropy");let o=null;if(n!=null&&(o=F(n,"weights","sigmoidCrossEntropy")),Dn(a.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const u=Me(r),c=Me(1),h=Me(.5);a=ie(z(a,Ie(c,u)),z(h,u))}const l=TH(a,i);return ki(l,o,s)}const $H=U({sigmoidCrossEntropy_:EH});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function RH(t,e,n=-1){if(n===-1&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);return gi((r,s,a)=>{const i=fb(s,[n],!0),o=Ie(me(s,"float32"),i);a([r,o]);const l=Lt(z(o,r));return{value:Re(l,[n]),gradFunc:(u,c)=>{const[h,d]=c,p=en(u.shape,[n]);return[z(j(u,p),Ie(me(h,"float32"),pr(d))),z(j(u,p),Ie(pr(d),me(h,"float32")))]}}})(t,e)}function AH(t,e,n,r=0,s=wr.SUM_BY_NONZERO_WEIGHTS){let a=F(t,"onehotLabels","softmaxCrossEntropy");const i=F(e,"logits","softmaxCrossEntropy");let o=null;if(n!=null&&(o=F(n,"weights","softmaxCrossEntropy")),Dn(a.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const u=Me(r),c=Me(1),h=Me(a.shape[1]);a=ie(z(a,Ie(c,u)),Se(u,h))}const l=RH(a,i);return ki(l,o,s)}const _H=U({softmaxCrossEntropy_:AH});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function FH(t,e,n,r){const s=F(t,"indices","sparseFillEmptyRows","int32"),a=F(e,"values","sparseFillEmptyRows"),i=F(n,"denseShape","sparseFillEmptyRows","int32"),o=F(r,"defaultValue","sparseFillEmptyRows",a.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(a.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const l={indices:s,values:a,denseShape:i,defaultValue:o},u=B.runKernel(zw,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}const OH=U({sparseFillEmptyRows_:FH});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function DH(t,e,n){const r=F(t,"inputIndices","sparseReshape","int32"),s=F(e,"inputShape","sparseReshape","int32"),a=F(n,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(a.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const i={inputIndices:r,inputShape:s,newShape:a},o=B.runKernel(Bw,i);return{outputIndices:o[0],outputShape:o[1]}}const MH=U({sparseReshape_:DH});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function PH(t,e,n){const r=F(t,"data","sparseSegmentMean"),s=F(e,"indices","sparseSegmentMean","int32"),a=F(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${a.shape}`);const i={data:r,indices:s,segmentIds:a};return B.runKernel(qy,i)}const LH=U({sparseSegmentMean_:PH});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zH(t,e,n){const r=F(t,"data","sparseSegmentSum"),s=F(e,"indices","sparseSegmentSum","int32"),a=F(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${a.shape}`);const i={data:r,indices:s,segmentIds:a};return B.runKernel(Xy,i)}const BH=U({sparseSegmentSum_:zH});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function WH(t,e,n,r,s,a,i,o){const l=F(t,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=F(e,"dataSplits","stringNGrams");if(u.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:r,leftPad:s,rightPad:a,padWidth:i,preserveShortSequences:o},h={data:l,dataSplits:u},d=B.runKernel(eb,h,c);return{nGrams:d[0],nGramsSplits:d[1]}}const UH=U({stringNGrams_:WH});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function VH(t,e,n=!0){const r=F(t,"input","stringSplit","string"),s=F(e,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const a={skipEmpty:n},i={input:r,delimiter:s},o=B.runKernel(Ww,i,a);return{indices:o[0],values:o[1],shape:o[2]}}const jH=U({stringSplit_:VH});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function GH(t,e){const n=F(t,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const s={input:n};return B.runKernel(Uw,s,r)}const HH=U({stringToHashBucketFast_:GH});/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function KH(t,e,n,r=!0){const s=F(t,"input","staticRegexReplace","string"),a={pattern:e,rewrite:n,replaceGlobal:r};return B.runKernel(Zy,{x:s},a)}const qH=U({staticRegexReplace_:KH});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const XH={fft:Sb,ifft:_d,rfft:Ib,irfft:Nk},YH={hammingWindow:k6,hannWindow:k3,frame:S3,stft:C6},hr={flipLeftRight:R6,grayscaleToRGB:_6,resizeNearestNeighbor:N3,resizeBilinear:I3,rgbToGrayscale:O6,rotateWithOffset:M6,cropAndResize:E6,nonMaxSuppression:L6,nonMaxSuppressionAsync:H6,nonMaxSuppressionWithScore:q6,nonMaxSuppressionWithScoreAsync:Y6,nonMaxSuppressionPadded:Z6,nonMaxSuppressionPaddedAsync:eH,threshold:aH,transform:oH},C3={bandPart:uH,gramSchmidt:hH,qr:pH},QH={absoluteDifference:gH,computeWeightedLoss:ki,cosineDistance:bH,hingeLoss:vH,huberLoss:kH,logLoss:IH,meanSquaredError:CH,sigmoidCrossEntropy:$H,softmaxCrossEntropy:_H},ZH={sparseFillEmptyRows:OH,sparseReshape:MH,sparseSegmentMean:LH,sparseSegmentSum:BH},JH={stringNGrams:UH,stringSplit:jH,stringToHashBucketFast:HH,staticRegexReplace:qH};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const e5=new Map,X1=new Map;class _l{getClassName(){return this.constructor.className}static fromConfig(e,n){return new e(n)}}class os{constructor(){this.classNameMap={}}static getMap(){return os.instance==null&&(os.instance=new os),os.instance}static register(e){os.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function le(t,e,n){R(t.className!=null,()=>"Class being registered does not have the static className property defined."),R(typeof t.className=="string",()=>"className is required to be a string, but got type "+typeof t.className),R(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof n>"u"&&(n=t.className);const r=n,s=e+">"+r;return os.register(t),e5.set(s,t),X1.set(t,s),t}function t5(t){return X1.has(t)?X1.get(t):t.className}const Wke=Object.freeze(Object.defineProperty({__proto__:null,Serializable:_l,SerializationMap:os,getRegisteredName:t5,registerClass:le},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class wo extends _l{minimize(e,n=!1,r){const{value:s,grads:a}=this.computeGradients(e,r);if(r!=null){const i=r.map(o=>({name:o.name,tensor:a[o.name]}));this.applyGradients(i)}else this.applyGradients(a);return Pe(a),n?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,n){return TV(e,n)}dispose(){this.iterations_!=null&&Pe(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Me(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(wo,Symbol.hasInstance,{value:t=>t.minimize!=null&&t.computeGradients!=null&&t.applyGradients!=null});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class T3 extends wo{static get className(){return"Adadelta"}constructor(e,n,r=null){super(),this.learningRate=e,this.rho=n,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=B.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,r)=>{const s=B.registeredVariables[n],a=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${n}/accum_grad`,variable:Y(()=>dt(s).variable(a))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${n}/accum_var`,variable:Y(()=>dt(s).variable(a))});const i=Array.isArray(e)?e[r].tensor:e[n];if(i==null)return;const o=this.accumulatedGrads[r].variable,l=this.accumulatedUpdates[r].variable;Y(()=>{const u=ie(z(o,this.rho),z(It(i),1-this.rho)),c=z(Se(Vn(ie(l,this.epsilon)),Vn(ie(o,this.epsilon))),i),h=ie(z(l,this.rho),z(It(c),1-this.rho));o.assign(u),l.assign(h);const d=ie(z(c,-this.learningRate),s);s.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Pe(this.accumulatedGrads.map(e=>e.variable)),Pe(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=e.length/2,r=!1;this.accumulatedGrads=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedUpdates=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.rho,n.epsilon)}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class E3 extends wo{static get className(){return"Adagrad"}constructor(e,n=.1){super(),this.learningRate=e,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,r)=>{const s=B.registeredVariables[n];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${n}/accumulator`,variable:Y(()=>Gc(s.shape,this.initialAccumulatorValue).variable(!1))});const a=Array.isArray(e)?e[r].tensor:e[n];if(a==null)return;const i=this.accumulatedGrads[r].variable;Y(()=>{const o=ie(i,It(a));i.assign(o);const l=ie(z(Se(a,Vn(ie(o,B.backend.epsilon()))),-this.learningRate),s);s.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Pe(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulatedGrads=e.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,n){return new e(n.learningRate,n.initialAccumulatorValue)}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class $3 extends wo{static get className(){return"Adam"}constructor(e,n,r,s=null){super(),this.learningRate=e,this.beta1=n,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Y(()=>{this.accBeta1=Me(n).variable(),this.accBeta2=Me(r).variable()}),s==null&&(this.epsilon=B.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);Y(()=>{const r=Ie(1,this.accBeta1),s=Ie(1,this.accBeta2);n.forEach((a,i)=>{const o=B.registeredVariables[a],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${a}/m`,variable:Y(()=>dt(o).variable(l))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${a}/v`,variable:Y(()=>dt(o).variable(l))});const u=Array.isArray(e)?e[i].tensor:e[a];if(u==null)return;const c=this.accumulatedFirstMoment[i].variable,h=this.accumulatedSecondMoment[i].variable,d=ie(z(c,this.beta1),z(u,1-this.beta1)),p=ie(z(h,this.beta2),z(It(u),1-this.beta2)),f=Se(d,r),m=Se(p,s);c.assign(d),h.assign(p);const y=ie(z(Se(f,ie(Vn(m),this.epsilon)),-this.learningRate),o);o.assign(y)}),this.accBeta1.assign(z(this.accBeta1,this.beta1)),this.accBeta2.assign(z(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Pe(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Pe(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e),Y(()=>{this.accBeta1.assign(mi(this.beta1,this.iterations_+1)),this.accBeta2.assign(mi(this.beta2,this.iterations_+1))});const n=e.length/2,r=!1;this.accumulatedFirstMoment=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedSecondMoment=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon)}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class R3 extends wo{static get className(){return"Adamax"}constructor(e,n,r,s=null,a=0){super(),this.learningRate=e,this.beta1=n,this.beta2=r,this.epsilon=s,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Y(()=>{this.iteration=Me(0).variable(),this.accBeta1=Me(n).variable()}),s==null&&(this.epsilon=B.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);Y(()=>{const r=Ie(1,this.accBeta1),s=Se(-this.learningRate,ie(z(this.iteration,this.decay),1));n.forEach((a,i)=>{const o=B.registeredVariables[a],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${a}/m`,variable:dt(o).variable(l)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${a}/v`,variable:dt(o).variable(l)});const u=Array.isArray(e)?e[i].tensor:e[a];if(u==null)return;const c=this.accumulatedFirstMoment[i].variable,h=this.accumulatedWeightedInfNorm[i].variable,d=ie(z(c,this.beta1),z(u,1-this.beta1)),p=z(h,this.beta2),f=yn(u),m=wi(p,f);c.assign(d),h.assign(m);const y=ie(z(Se(s,r),Se(d,ie(m,this.epsilon))),o);o.assign(y)}),this.iteration.assign(ie(this.iteration,1)),this.accBeta1.assign(z(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Pe(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Pe(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Dk extends wo{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,r)=>{const s=Array.isArray(e)?e[r].tensor:e[n];if(s==null)return;const a=B.registeredVariables[n];Y(()=>{const i=ie(z(this.c,s),a);a.assign(i)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=An(Me(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,n){return new e(n.learningRate)}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class A3 extends Dk{static get className(){return"Momentum"}constructor(e,n,r=!1){super(e),this.learningRate=e,this.momentum=n,this.useNesterov=r,this.accumulations=[],this.m=Me(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,r)=>{const s=B.registeredVariables[n];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${n}/momentum`,variable:Y(()=>dt(s).variable(!1))});const a=this.accumulations[r].variable,i=Array.isArray(e)?e[r].tensor:e[n];i!=null&&Y(()=>{let o;const l=ie(z(this.m,a),i);this.useNesterov?o=ie(z(this.c,ie(i,z(l,this.m))),s):o=ie(z(this.c,l),s),a.assign(l),s.assign(o)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Pe(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulations=e.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,n){return new e(n.learningRate,n.momentum,n.useNesterov)}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class _3 extends wo{static get className(){return"RMSProp"}constructor(e,n=.9,r=0,s=null,a=!1){if(super(),this.learningRate=e,this.decay=n,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,s==null&&(this.epsilon=B.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,r)=>{const s=B.registeredVariables[n],a=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${n}/rms`,variable:Y(()=>dt(s).variable(a))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${n}/momentum`,variable:Y(()=>dt(s).variable(a))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${n}/mg`,variable:Y(()=>dt(s).variable(a))});const i=Array.isArray(e)?e[r].tensor:e[n];if(i==null)return;const o=this.accumulatedMeanSquares[r].variable,l=this.accumulatedMoments[r].variable;Y(()=>{const u=ie(z(o,this.decay),z(It(i),1-this.decay));if(this.centered){const c=this.accumulatedMeanGrads[r].variable,h=ie(z(c,this.decay),z(i,1-this.decay)),d=Se(z(i,this.learningRate),Vn(Ie(u,ie(It(h),this.epsilon)))),p=ie(z(l,this.momentum),d);o.assign(u),c.assign(h),l.assign(p);const f=Ie(s,p);s.assign(f)}else{const c=ie(z(o,this.decay),z(It(i),1-this.decay)),h=ie(z(l,this.momentum),Se(z(i,this.learningRate),Vn(ie(c,this.epsilon))));o.assign(c),l.assign(h);const d=Ie(s,h);s.assign(d)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Pe(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Pe(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Pe(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=this.centered?e.length/3:e.length/2,r=!1;this.accumulatedMeanSquares=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedMoments=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=e.slice(n*2,n*3).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,n){return new e(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const n5=[T3,E3,$3,R3,A3,_3,Dk];function r5(){for(const t of n5)le(t)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const s5="model",a5=".json",i5=".weights.bin";function rN(t){return new Promise(e=>setTimeout(e)).then(t)}class fl{constructor(e){if(!Z().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(fl.URL_SCHEME)&&(e=e.slice(fl.URL_SCHEME.length)),(e==null||e.length===0)&&(e=s5),this.modelJsonFileName=e+a5,this.weightDataFileName=e+i5}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=va.join(e.weightData),r=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const s=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],a=aR(e,s),i=window.URL.createObjectURL(new Blob([JSON.stringify(a)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=i,await rN(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=r,await rN(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Jp(e)}}}}fl.URL_SCHEME="downloads://";class o5{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,n)=>{const r=new FileReader;r.onload=s=>{const a=JSON.parse(s.target.result),i=a.modelTopology;if(i==null){n(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(a.weightsManifest==null){n(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:i});return}const o=Zw(a,l=>this.loadWeights(l));e(o)},r.onerror=s=>n(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})}loadWeights(e){const n=[],r=[];for(const i of e)n.push(...i.weights),r.push(...i.paths);const s=this.checkManifestAndWeightFiles(e),a=r.map(i=>this.loadWeightsFile(i,s[i]));return Promise.all(a).then(i=>[n,i])}loadWeightsFile(e,n){return new Promise((r,s)=>{const a=new FileReader;a.onload=i=>{const o=i.target.result;r(o)},a.onerror=i=>s(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(n)})}checkManifestAndWeightFiles(e){const n=[],r=this.weightsFiles.map(a=>eN(a.name)),s={};for(const a of e)a.paths.forEach(i=>{const o=eN(i);if(n.indexOf(o)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${o}'`);if(n.push(o),r.indexOf(o)===-1)throw new Error(`Weight file with basename '${o}' is not provided.`);s[i]=this.weightsFiles[r.indexOf(o)]});if(n.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}}const l5=t=>Z().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(fl.URL_SCHEME)?u5(t.slice(fl.URL_SCHEME.length)):null;jt.registerSaveRouter(l5);function u5(t="model"){return new fl(t)}function c5(t){return new o5(t)}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function sN(t,e,n,r){i(t),n=n??0,r=r??1,o(n,r);let s=0;const a=l=>(l.then(u=>{const c=n+ ++s/t.length*(r-n);return e(c),u}),l);function i(l){R(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function o(l,u){R(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),R(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),R(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(t.map(a))}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/async function F3(t,e){e==null&&(e={});const n=e.fetchFunc==null?Z().platform.fetch:e.fetchFunc,r=t.map(a=>n(a,e.requestInit,{isBinary:!0})),s=(e.onProgress==null?await Promise.all(r):await sN(r,e.onProgress,0,.5)).map(a=>a.arrayBuffer());return e.onProgress==null?await Promise.all(s):await sN(s,e.onProgress,.5,1)}function h5(t,e){var n;const r=e.fetchFunc==null?Z().platform.fetch:e.fetchFunc;let s=0,a;return(n=e.onProgress)===null||n===void 0||n.call(e,0),new ReadableStream({pull:async i=>{for(var o;s<t.length;){a||(a=(await r(t[s],e.requestInit,{isBinary:!0})).body.getReader());const{done:l,value:u}=await a.read();if(l){s++,a=void 0,(o=e.onProgress)===null||o===void 0||o.call(e,s/t.length);continue}i.enqueue(u);return}i.close()}})}async function O3(t,e="",n,r){return D3(s=>F3(s,{requestInit:r}))(t,e,n)}function D3(t){return async(e,n="",r)=>{const s=e.map(()=>!1),a={},i=r!=null?r.map(()=>!1):[],o=[];if(e.forEach((p,f)=>{let m=0;p.weights.forEach(y=>{const g="quantization"in y?y.quantization.dtype:y.dtype,b=ol[g]*Q(y.shape),v=()=>{s[f]=!0,a[f]==null&&(a[f]=[]),a[f].push({manifestEntry:y,groupOffset:m,sizeBytes:b})};r!=null?r.forEach((w,k)=>{w===y.name&&(v(),i[k]=!0)}):v(),o.push(y.name),m+=b})}),!i.every(p=>p)){const p=r.filter((f,m)=>!i[m]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}const l=s.reduce((p,f,m)=>(f&&p.push(m),p),[]),u=[];l.forEach(p=>{e[p].paths.forEach(f=>{const m=n+(n.endsWith("/")?"":"/")+f;u.push(m)})});const c=await t(u),h={};let d=0;return l.forEach(p=>{const f=e[p].paths.length,m=new va(c.slice(d,d+f));a[p].forEach(y=>{const g=m.slice(y.groupOffset,y.groupOffset+y.sizeBytes),b=Xw(g,[y.manifestEntry]);for(const v in b)h[v]=b[v]}),d+=f}),h}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const d5="application/octet-stream",p5="application/json";class Mk{constructor(e,n){if(this.DEFAULT_METHOD="POST",n==null&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.weightUrlConverter=n.weightUrlConverter,n.fetchFunc!=null?(R(typeof n.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=Z().platform.fetch,R(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&R(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,n.requestInit!=null&&n.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{},this.loadOptions=n}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const r=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],s=aR(e,r);if(n.body.append("model.json",new Blob([JSON.stringify(s)],{type:p5}),"model.json"),e.weightData!=null){const i=va.join(e.weightData);n.body.append("model.weights.bin",new Blob([i],{type:d5}),"model.weights.bin")}const a=await this.fetch(this.path,n);if(a.ok)return{modelArtifactsInfo:Jp(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=await e.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}const r=n.modelTopology,s=n.weightsManifest;if(r==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return n}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return Zw(e,n=>this.loadWeights(n))}async loadStream(){const e=await this.loadModelJSON(),n=await this.getWeightUrls(e.weightsManifest),r=hg(e.weightsManifest),s=()=>h5(n,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:r,getWeightStream:s})}async getWeightUrls(e){const n=Array.isArray(this.path)?this.path[1]:this.path,[r,s]=f5(n),a=this.weightPathPrefix||r,i=[],o=[];for(const l of e)for(const u of l.paths)this.weightUrlConverter!=null?o.push(this.weightUrlConverter(u)):i.push(a+u+s);return this.weightUrlConverter&&i.push(...await Promise.all(o)),i}async loadWeights(e){const n=await this.getWeightUrls(e),r=hg(e),s=await F3(n,this.loadOptions);return[r,s]}}Mk.URL_SCHEME_REGEX=/^https?:\/\//;function f5(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),r=t.substring(0,e),s=n>e?t.substring(n):"";return[r+"/",s]}function Y1(t){return t.match(Mk.URL_SCHEME_REGEX)!=null}const M3=(t,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let n=!0;if(Array.isArray(t)?n=t.every(r=>Y1(r)):n=Y1(t),n)return Pk(t,e)}return null};jt.registerSaveRouter(M3);jt.registerLoadRouter(M3);function Pk(t,e){return new Mk(t,e)}function P3(t,e){return Pk(t,e)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class bx{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class L3{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class m5{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=n=>Promise.resolve(e.save(n)))}}function g5(t,e,n,r){const s=arguments;return new m5(fg(...s))}function fg(t,e,n,r){return arguments.length===1?t.modelTopology!=null||t.weightSpecs!=null?new bx(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new bx({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new bx({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:r}))}function y5(t){return new L3(t)}function b5(t){return new L3(t)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const z3=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:va,browserFiles:c5,browserHTTPRequest:P3,concatenateArrayBuffers:sR,copyModel:kW,decodeWeights:Xw,decodeWeightsStream:rR,encodeWeights:U1,fromMemory:g5,fromMemorySync:fg,getLoadHandlers:oR,getModelArtifactsForJSON:Zw,getModelArtifactsForJSONSync:Qw,getModelArtifactsInfoForJSON:Jp,getSaveHandlers:iR,getWeightSpecs:hg,http:Pk,isHTTPScheme:Y1,listModels:vW,loadWeights:O3,moveModel:SW,registerLoadRouter:lW,registerSaveRouter:oW,removeModel:wW,weightsLoaderFactory:D3,withSaveHandler:y5,withSaveHandlerSync:b5},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let $o,aN=!1;function B3(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(t==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,a=!1,i=!1,o=!1;if(t.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&t instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement)a=!0;else if(t.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&t instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);if(lg(og,B.backendName)!=null){const d={pixels:t},p={numChannels:e};return B.runKernel(og,d,p)}const[l,u]=s?[t.videoWidth,t.videoHeight]:[t.width,t.height];let c;if(i)c=t.getContext("2d").getImageData(0,0,l,u).data;else if(r||n)c=t.data;else if(a||s||o){if($o==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")$o=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else $o=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});$o.canvas.width=l,$o.canvas.height=u,$o.drawImage(t,0,0,l,u),c=$o.getImageData(0,0,l,u).data}let h;if(e===4)h=new Int32Array(c);else{const d=l*u;h=new Int32Array(d*e);for(let p=0;p<d;p++)for(let f=0;f<e;++f)h[p*e+f]=c[p*4+f]}return d3(h,[u,l,e],"int32")}function x5(t){return t!=null&&t.data instanceof Uint8Array}function v5(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function w5(t){return t!=null&&t.width!==0&&t.height!==0}function k5(t){return v5()&&!(t instanceof ImageBitmap)&&w5(t)&&!x5(t)}async function S5(t,e=3){let n=null;if(Z().getBool("WRAP_TO_IMAGEBITMAP")&&k5(t)){let r;try{r=await createImageBitmap(t,{premultiplyAlpha:"none"})}catch{r=null}r!=null&&r.width===t.width&&r.height===t.height?n=r:n=t}else n=t;return B3(n,e)}function W3(t){if(t.rank!==2&&t.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);const e=t.rank===2?1:t.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(t.dtype!=="float32"&&t.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`)}function I5(t){const e=(t==null?void 0:t.alpha)||1;if(e>1||e<0)throw new Error(`Alpha value ${e} is suppoed to be in range [0 - 1].`)}async function _b(t,e){let n=F(t,"img","toPixels");if(!(t instanceof st)){const u=n;n=me(u,"int32"),u.dispose()}W3(n);const[r,s]=n.shape.slice(0,2),a=n.rank===2?1:n.shape[2],i=await n.data(),o=n.dtype==="float32"?255:1,l=new Uint8ClampedArray(s*r*4);for(let u=0;u<r*s;++u){const c=[0,0,0,255];for(let d=0;d<a;d++){const p=i[u*a+d];if(n.dtype==="float32"){if(p<0||p>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${p}.`)}else if(n.dtype==="int32"&&(p<0||p>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${p}.`);a===1?(c[0]=p*o,c[1]=p*o,c[2]=p*o):c[d]=p*o}const h=u*4;l[h+0]=Math.round(c[0]),l[h+1]=Math.round(c[1]),l[h+2]=Math.round(c[2]),l[h+3]=Math.round(c[3])}if(e!=null){aN||lg(Iy,B.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),aN=!0),e.width=s,e.height=r;const u=e.getContext("2d"),c=new ImageData(l,s,r);u.putImageData(c,0,0)}return n!==t&&n.dispose(),l}function N5(t,e,n){let r=F(t,"img","draw");if(!(t instanceof st)){const i=r;r=me(i,"int32"),i.dispose()}W3(r),I5(n==null?void 0:n.imageOptions);const s={image:r},a={canvas:e,options:n};B.runKernel(Iy,s,a)}const Lk=U({fromPixels_:B3}),Uke=Object.freeze(Object.defineProperty({__proto__:null,draw:N5,fromPixels:Lk,fromPixelsAsync:S5,toPixels:_b},Symbol.toStringTag,{value:"Module"}));function of(t,e){const n=t.shape.length,r=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${n}`);if(Q(t.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const s=e.shape,a=s[s.length-1];let i=1;for(let h=0;h<s.length-1;++h)i*=s[h];const o=t.shape,l=s.slice();l.pop();let u=1;for(let h=a;h<n;++h)u*=o[h],l.push(o[h]);const c=[...Fe(t.shape).map(h=>h/u),1].slice(0,a);return[l,i,u,c]}const Vke=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:of},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Q1=-2,C5=-1;function Fb(t,e,n){const r=t.shape.length;R(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),R(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)R(e[s]+n[s]<=t.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${e[s]+n[s]}) would overflow input.shape[${s}] (${t.shape[s]})`)}function T5(t){const e=[];let n=0;for(;t>0;)t&1&&e.push(n),t/=2,n++;return e}function Ob(t,e,n){const r=[];for(let s=0;s<t.length;s++)r[s]=Math.ceil((e[s]-t[s])/n[s]);return r}function U3(t,e,n,r){const s=[...t];for(let a=s.length;a<r.length;a++)s.push(1);for(let a=0;a<n;a++)a===0?s[e]=1:(s.splice(e,0,1),s.pop());return s}function V3(t,e,n){return n<=t?n:n-(e-1)}function j3(t,e){const n=[];for(let r=0;r<t;r++)n.push(e+r);return n}function E5(t,e,n,r,s,a,i,o,l){const u=t.length;let c=new Array(u),h=new Array(u),d=new Array(u);if(e.length&&n>0){const p=e[0],f=n+1;c=G3(i,p,f,r,t),h=H3(o,p,f,s,t),d=U3(a,p,f,t)}else for(let p=0;p<u;p++)c[p]=q3(i,r,a,t,p,l),h[p]=X3(o,s,a,t,p,l),d[p]=K3(a,p,l);return{begin:c,end:h,strides:d}}function G3(t,e,n,r,s){const a=[...s],i=j3(n,e);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=0;else{const l=V3(e,n,o);let u=r[l];t&1<<l&&(u=0),a[o]=u}return a}function H3(t,e,n,r,s){const a=[...s],i=j3(n,e);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=Number.MAX_SAFE_INTEGER;else{const l=V3(e,n,o);let u=r[l];t&1<<l&&(u=Number.MAX_SAFE_INTEGER),a[o]=u}for(let o=0;o<a.length;o++){const l=s[o];a[o]<0&&(a[o]+=l),a[o]=Ji(0,a[o],s[o])}return a}function K3(t,e,n){let r=t[e];return(n&1<<e||r==null)&&(r=1),r}function q3(t,e,n,r,s,a){let i=e[s];const o=n[s]||1;(t&1<<s||a&1<<s||i==null)&&(o>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=Ji(0,i,l-1),i}function X3(t,e,n,r,s,a){let i=e[s];const o=n[s]||1;(t&1<<s||a&1<<s||i==null)&&(o>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),o>0?i=Ji(0,i,l):i=Ji(-1,i,l-1),i}function zk(t,e,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(e[s]>0||n[s]!==t[s])return!1;return!0}function Bk(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function lf(t,e,n){let r;const s=t.shape.length;typeof e=="number"?r=[e,...new Array(s-1).fill(0)]:e.length<s?r=e.concat(new Array(s-e.length).fill(0)):r=e.slice(),r.forEach(i=>{R(i!==-1,()=>"slice() does not support negative begin indexing.")});let a;return n==null?a=new Array(s).fill(-1):typeof n=="number"?a=[n,...new Array(s-1).fill(-1)]:n.length<s?a=n.concat(new Array(s-n.length).fill(-1)):a=n,a=a.map((i,o)=>i>=0?i:(R(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${o}.`),t.shape[o]-r[o])),[r,a]}function Db(t,e,n,r,s,a,i,o,l){let u;if(r==null?(u=new Array(e.length),u.fill(1)):u=r,i!=null&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const h={dims:u.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:n.slice(),strides:u.slice(),beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let b=0;b<h.dims;b++)c&&1<<b&o&&h.numAddAxisAfterEllipsis++,1<<b&i&&(c=!0);c||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};$5(h,d);let p=!0,f=!0,m=!0;const y=[],g=[];for(let b=0;b<t.length;++b){if(d.strides[b]===0)throw Error(`strides[${b}] must be non-zero`);const v=!!(d.shrinkAxisMask&1<<b),w=t[b];if(w===-1){y.push(v?1:-1);continue}const k=[d.beginMask&1<<b,d.endMask&1<<b],N=[d.strides[b]>0?0:-1,d.strides[b]>0?w:w-1];if(v&&d.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&d.strides[b]===1;const T=!!(d.beginMask&1<<b&&d.endMask&1<<b);if(d.beginValid&&d.endValid){if(v){const M=d.begin[b]<0?w+d.begin[b]:d.begin[b];if(d.begin[b]=M,d.end[b]=d.begin[b]+1,M<0||M>=w)throw Error(`slice index ${d.begin[b]} of dimension ${b} out of bounds.`)}else d.begin[b]=iN(d.begin[b],0,d.strides[b],w,k,N),d.end[b]=iN(d.end[b],1,d.strides[b],w,k,N);const O=d.strides[b]===1&&d.begin[b]===0&&d.end[b]===w;p=p&&O,f=f&&(b===0&&d.strides[b]===1||O)}else p=p&&d.strides[b]===1&&T,f=f&&(b===0&&d.strides[b]===1||T);let E,_=!1;if(d.beginValid&&d.endValid?(E=d.end[b]-d.begin[b],_=!0):v?(E=1,_=!0):T&&w>=0&&(d.strides[b]<0?E=-w:E=w,_=!0),_){let O;E===0||E<0!=d.strides[b]<0?O=0:O=Math.trunc(E/d.strides[b])+(E%d.strides[b]!==0?1:0),y.push(O)}else y.push(-1)}for(let b=0;b<d.finalShapeGatherIndices.length;++b){const v=d.finalShapeGatherIndices[b];v>=0?g.push(y[v]):v===Q1&&g.push(1)}return{finalShapeSparse:g.filter((b,v)=>d.finalShapeGatherIndices[v]!==Q1),finalShape:g,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function $5(t,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let n=0;e.beginValid=t.begin!=null,e.endValid=t.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<t.dims;r++)if(1<<r&t.ellipsisMask){const s=Math.min(e.dims-(t.dims-r)+1+t.numAddAxisAfterEllipsis,e.dims);for(;n<s;n++)e.begin[n]=0,e.end[n]=0,e.strides[n]=1,e.beginMask|=1<<n,e.endMask|=1<<n,e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&t.newAxisMask)e.finalShapeGatherIndices.push(Q1),e.finalShapeGatherIndicesSparse.push(-1);else{if(n===e.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${e.dims} dims, ${e.begin.length}.`);t.begin!=null&&(e.begin[n]=t.begin[r]),t.end!=null&&(e.end[n]=t.end[r]),e.strides[n]=t.strides[r],t.beginMask&1<<r&&(e.beginMask|=1<<n),t.endMask&1<<r&&(e.endMask|=1<<n),t.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(C5),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<n):(e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[n]=r,n++}}function iN(t,e,n,r,s,a){if(s[e])return n>0?a[e]:a[e+1&1];{const i=t<0?r+t:t;return i<a[0]?a[0]:i>a[1]?a[1]:i}}const R5=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:Fb,computeFlatOffset:Bk,computeOutShape:Ob,getNormalizedAxes:E5,isSliceContinous:zk,maskToAxes:T5,parseSliceParams:lf,sliceInfo:Db,startForAxis:q3,startIndicesWithElidedDims:G3,stopForAxis:X3,stopIndicesWithElidedDims:H3,stridesForAxis:K3,stridesWithElidedDims:U3},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class A5{static sgd(e){return new Dk(e)}static momentum(e,n,r=!1){return new A3(e,n,r)}static rmsprop(e,n=.9,r=0,s=null,a=!1){return new _3(e,n,r,s,a)}static adam(e=.001,n=.9,r=.999,s=null){return new $3(e,n,r,s)}static adadelta(e=.001,n=.95,r=null){return new T3(e,n,r)}static adamax(e=.002,n=.9,r=.999,s=null,a=0){return new R3(e,n,r,s,a)}static adagrad(e,n=.1){return new E3(e,n)}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ql=A5;/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const _5=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:t=>t();function Y3(){return new Promise(t=>_5(()=>t()))}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Mb(t,e){const n=t[0].length;t.forEach((s,a)=>{R(s.length===n,()=>`Error in concat${n}D: rank of tensors[${a}] must be the same as the rank of the rest (${n})`)}),R(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=t[0];t.forEach((s,a)=>{for(let i=0;i<n;i++)R(i===e||s[i]===r[i],()=>`Error in concat${n}D: Shape of tensors[${a}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`)})}function Sr(t,e){const n=t[0].slice();for(let r=1;r<t.length;r++)n[e]+=t[r][e];return n}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/var sa;(function(t){t[t.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",t[t.VALUE_ROWIDS=1]="VALUE_ROWIDS",t[t.ROW_LENGTHS=2]="ROW_LENGTHS",t[t.ROW_SPLITS=3]="ROW_SPLITS",t[t.ROW_LIMITS=4]="ROW_LIMITS",t[t.ROW_STARTS=5]="ROW_STARTS"})(sa||(sa={}));function Q3(t,e,n){let r=new Array;if(n==null&&e==null)return r;if(e==null)for(;r.length<t+n.length;)r.push(-1);else r=e.slice();if(n==null)return r;if(t+n.length!==r.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${t+n.length}, but shape.rank = ${r.length}`);for(let s=1;s<n.length;++s){const a=n[s],i=r[r.length-n.length+s],o=r[i];if(a>=0)if(o>=0){if(o!==a)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${s+t}] = ${a} but shape[${s+t}] = ${o}`)}else r[i]=a}return r}function Z3(t){const e={FIRST_DIM_SIZE:sa.FIRST_DIM_SIZE,VALUE_ROWIDS:sa.VALUE_ROWIDS,ROW_LENGTHS:sa.ROW_LENGTHS,ROW_SPLITS:sa.ROW_SPLITS,ROW_LIMITS:sa.ROW_LIMITS,ROW_STARTS:sa.ROW_STARTS},n=[];for(const r of t)if(r in e)n.push(e[r]);else break;return n}function J3(t){return t.length===0?0:t[0]===sa.FIRST_DIM_SIZE?t.length-1:t.length}function eA(t,e){if(t==null||e==null)return;const n=t.length,r=e.length;if(n>=r)throw new Error(`defaultValue.shape=${t} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(n,r-1);++s){const a=t[s],i=e[s+1];if(a>=0&&i>=0&&a!==1&&a!==i)throw new Error(`defaultValue.shape=${t}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${s-t.length}] = ${a} but ragged tensor input.flatValues.shape[${s-t.length}] = ${i}`)}}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Wk=30;function Pb(t){return t<=Wk?t:sg(t,Math.floor(Math.sqrt(t)))}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Lb(t,e,n){const r=n*(typeof t=="number"?t:t[0]),s=e*(typeof t=="number"?t:t[1]);return[r,s]}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Fl(t,e,n,r=!0){let s=[];if(r)s=s.concat(e.slice(0)),s.push(t[0]/n),s=s.concat(t.slice(1));else{s=s.concat(t[0]);const a=e.length;for(let i=0;i<a;++i)s=s.concat([t[i+1]/e[i],e[i]]);s=s.concat(t.slice(a+1))}return s}function Ol(t,e,n=!0){const r=[];if(n){r.push(e);for(let s=e+1;s<t;++s)s<=2*e?(r.push(s),r.push(s-(e+1))):r.push(s)}else{const s=[],a=[];for(let i=1;i<t;++i)i>=e*2+1||i%2===1?a.push(i):s.push(i);r.push(...s),r.push(0),r.push(...a)}return r}function Dl(t,e,n,r=!0){const s=[];r?s.push(t[0]/n):s.push(t[0]*n);for(let a=1;a<t.length;++a)a<=e.length?r?s.push(e[a-1]*t[a]):s.push(t[a]/e[a-1]):s.push(t[a]);return s}function zb(t,e){const n=[0];for(let r=0;r<e;++r)n.push(t[r][0]);return n}function Bb(t,e,n){const r=t.slice(0,1);for(let s=0;s<n;++s)r.push(t[s+1]-e[s][0]-e[s][1]);return r}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const uf=1.7580993408473768,cf=1.0507009873554805;/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Wb=.3275911,Ub=.254829592,Vb=-.284496736,jb=1.421413741,Gb=-1.453152027,Hb=1.061405429;/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function fa(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(t.length*2);for(let r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function tA(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}function nA(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let s=0;s<t.length;s+=4)n[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:n,imag:r}}function rA(t){const e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let s=2;s<t.length;s+=4)n[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:n,imag:r}}function Uk(t,e){const n=t[e*2],r=t[e*2+1];return{real:n,imag:r}}function sA(t,e,n,r){t[r*2]=e,t[r*2+1]=n}function aA(t,e){const n=new Float32Array(t/2),r=new Float32Array(t/2);for(let s=0;s<Math.ceil(t/2);s++){const a=(e?2:-2)*Math.PI*(s/t);n[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:n,imag:r}}function iA(t,e,n){const r=(n?2:-2)*Math.PI*(t/e),s=Math.cos(r),a=Math.sin(r);return{real:s,imag:a}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const xx="->",F5=/->/g,oN=",",lN="...";function Kb(t,e){t=t.replace(/\s/g,"");const n=(t.length-t.replace(F5,"").length)/xx.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${xx}").`);const[r,s]=t.split(xx);R(r.indexOf(lN)===-1,()=>`The ellipsis notation ("${lN}") is not supported yet.`);const a=r.split(oN),i=a.length;if(e!==i)throw new Error(`Expected ${i} input tensors, received ${e}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let d=0;d<s.length;++d){const p=s[d];if(!a.some(f=>f.indexOf(p)!==-1))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);o.indexOf(p)===-1&&o.push(p)}for(let d=0;d<r.length;++d){const p=r[d];o.indexOf(p)===-1&&p!==oN&&o.push(p)}const l=new Array(a.length);for(let d=0;d<i;++d){if(new Set(a[d].split("")).size!==a[d].length)throw new Error(`Found duplicate axes in input component ${a[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let p=0;p<a[d].length;++p)l[d].push(o.indexOf(a[d][p]))}const u=o.length,c=s.length,h=[];for(let d=c;d<u;++d)h.push(d);return{allDims:o,summedDims:h,idDims:l}}function qb(t,e){let n=new Array(t);n.fill(-1);for(let s=0;s<e.length;++s)n[e[s]]=s;const r=[];for(let s=0;s<t;++s)n[s]===-1&&r.push(s);return n=n.filter(s=>s!==-1),{permutationIndices:n,expandDims:r}}function Xb(t,e,n){const r=new Array(t);for(let s=0;s<n.length;++s){const a=n[s].shape;for(let i=0;i<e[s].length;++i)r[e[s][i]]===void 0?r[e[s][i]]=a[i]:R(r[e[s][i]]===a[i],()=>`Expected dimension ${r[e[s][i]]} at axis ${i} of input shaped ${JSON.stringify(a)}, but got dimension ${a[i]}`)}}function Yb(t,e){const n=t,r=[];let s=0;t.length===0&&n.push(-1),s=t.length+1;for(let i=0;i<s;++i)r.push([]);const a=[];for(let i=0;i<n.length;++i){const o=n[i],l=O5(e,o);for(const u of l)a.indexOf(u)===-1&&(r[i].push(u),a.push(u))}return{path:n,steps:r}}function Qb(t){return t.every((e,n)=>e===n)}function O5(t,e){const n=[];for(let r=0;r<t.length;++r)(t[r].length===0||t[r].indexOf(e)!==-1||e===-1)&&n.push(r);return n}function Zb(t,e,n=0){let r=[];if(typeof e=="number")R(t.shape[n]%e===0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(t.shape[n]/e);else{const s=e.reduce((i,o)=>(o===-1&&(i+=1),i),0);R(s<=1,()=>"There should be only one negative value in split array.");const a=e.indexOf(-1);if(a!==-1){const i=e.reduce((o,l)=>l>0?o+l:o);e[a]=t.shape[n]-i}R(t.shape[n]===e.reduce((i,o)=>i+o),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function oA(t){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${t}`}function lA(t,e){return`indices(${t}, 0) is invalid: ${e} < 0`}function uA(t,e,n){return`indices(${t}, 0) is invalid: ${e} >= ${n}`}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function cA(t,e){return`only one output dimension may be -1, not both ${t} and ${e}`}function hA(t,e){return`size ${t} must be non-negative, not ${e}`}function dA(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function pA(t,e){const n=Q(t),r=Q(e);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${t} outputShape= ${e}`}function fA(t,e){const n=Q(t),r=Q(e);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${t} outputShape=${e}`}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Z1(){return"segment ids must be >= 0"}function mA(){return"segment ids are not increasing"}function gA(t,e){return`Segment id ${t} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function yA(t,e,n){return`Bad: indices[${t}] == ${e} out of range [0, ${n})`}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function bA(t,e){let n=!1,r;for(t<=Wk?(r=t,n=!0):r=sg(t,Math.floor(Math.sqrt(t)));!n;)r>e||r===t?n=!0:r=sg(t,r+1);return r}function Vk(t,e,n){const r=[],s=t.length;for(let a=0;a<s;a++)a!==e?r.push(t[a]):r.push(n);return r}function Jb(t,e,n,r){const s=e.shape.length,a=t.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let h=0;h<r;++h)if(t.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${t.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const i=t.shape[n],o=[];let l=1,u=1,c=1;for(let h=0;h<r;++h)o.push(t.shape[h]),l*=t.shape[h];for(let h=r;h<n;h++)o.push(t.shape[h]),u*=t.shape[h];for(let h=r;h<s;h++)o.push(e.shape[h]);for(let h=n+1;h<a;h++)o.push(t.shape[h]),c*=t.shape[h];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:o}}const D5=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:Jb,computeOutShape:Vk,segOpComputeOptimalWindowSize:bA},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ma(t){try{return t.map(e=>Vs(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function xA(t){return t.map(e=>za(e))}const M5=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:Ub,ERF_A2:Vb,ERF_A3:jb,ERF_A4:Gb,ERF_A5:Hb,ERF_P:Wb,PARALLELIZE_THRESHOLD:Wk,get RowPartitionType(){return sa},SELU_SCALE:cf,SELU_SCALEALPHA:uf,applyActivation:Eb,assertAndGetBroadcastShape:Ue,assertAxesAreInnerMostDims:mn,assertParamsConsistent:Mb,assignToTypedArray:sA,axesAreInnerMostDims:lk,calculateShapes:ka,checkEinsumDimSizes:Xb,checkPadOnDimRoundingMode:mr,combineLocations:WR,combineRaggedTensorToTensorShapes:Q3,complexWithEvenIndex:nA,complexWithOddIndex:rA,computeConv2DInfo:_t,computeConv3DInfo:wa,computeDefaultPad:tk,computeDilation2DInfo:xo,computeOptimalWindowSize:Pb,computeOutAndReduceShapes:an,computeOutShape:Sr,computePool2DInfo:er,computePool3DInfo:vs,convertConv2DDataFormat:ss,decodeEinsumEquation:Kb,eitherStridesOrDilationsAreOne:In,expandShapeToKeepDim:en,exponent:iA,exponents:aA,fromStringArrayToUint8:xA,fromUint8ToStringArray:ma,getAxesPermutation:Tt,getBroadcastDims:fi,getComplexWithIndex:Uk,getEinsumComputePath:Yb,getEinsumPermutation:qb,getFusedBiasGradient:Tb,getFusedDyActivation:Cb,getImageCenter:Lb,getInnerMostAxes:Ft,getPermuted:Ol,getRaggedRank:J3,getReductionAxes:fn,getReshaped:Fl,getReshapedPermuted:Dl,getRowPartitionTypesHelper:Z3,getSliceBeginCoords:zb,getSliceSize:Bb,getSparseFillEmptyRowsIndicesDenseShapeMismatch:oA,getSparseFillEmptyRowsNegativeIndexErrorMessage:lA,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:uA,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:dA,getSparseReshapeInputOutputMismatchErrorMessage:fA,getSparseReshapeInputOutputMultipleErrorMessage:pA,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:cA,getSparseReshapeNegativeOutputDimErrorMessage:hA,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:yA,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:Z1,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:mA,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:gA,getUndoAxesPermutation:Ha,isIdentityPermutation:Qb,log:IB,mergeRealAndImagArrays:fa,prepareAndValidate:of,prepareSplitSize:Zb,segment_util:D5,shouldFuse:$b,slice_util:R5,splitRealAndImagArrays:tA,stridesOrDilationsArePositive:dl,tupleValuesAreOne:ro,upcastType:On,validateDefaultValueShape:eA,validateInput:Nb,validateUpdateShape:Tk,warn:is},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/r5();/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const vA={kernelName:Qd,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>z(t,qc(me(n,"float32"),-1))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const P5={kernelName:Yu,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const r=It(me(n,"float32")),s=Vn(Ie(Me(1),r));return Lt(Se(t,s))}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const L5={kernelName:Qu,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const r=Vn(Ie(It(me(n,"float32")),1));return Se(t,r)}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const z5={kernelName:Tl,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=Ue(n.shape,r.shape);return{a:()=>{let a=t;const i=fn(n.shape,s);return i.length>0&&(a=Re(a,i)),j(a,n.shape)},b:()=>{let a=t;const i=fn(r.shape,s);return i.length>0&&(a=Re(a,i)),j(a,r.shape)}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const B5={kernelName:Zd,saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach((r,s)=>{n[s]=()=>t.clone()}),n}};/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const W5={kernelName:Jd,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>dt(n)}}};/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const U5={kernelName:ep,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>dt(n)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const V5={kernelName:Zu,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Se(t,Vn(Ie(Me(1),It(me(n,"float32")))))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const j5={kernelName:Ju,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const r=Vn(ie(Me(1),It(me(n,"float32"))));return Se(t,r)}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const G5={kernelName:nc,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=Ue(n.shape,r.shape);return{a:()=>{const a=ie(It(n),It(r));let i=z(t,Se(r,a));const o=fn(n.shape,s);return o.length>0&&(i=Re(i,o)),j(i,n.shape)},b:()=>{const a=ie(It(n),It(r));let i=Lt(z(t,Se(n,a)));const o=fn(r.shape,s);return o.length>0&&(i=Re(i,o)),j(i,r.shape)}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const H5={kernelName:ec,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Se(t,ie(It(me(n,"float32")),1))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const K5={kernelName:tc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Se(t,Ie(Me(1),It(me(n,"float32"))))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function q5(t,e,n,r,s,a){const i=F(t,"dy","avgPool3dGrad"),o=F(e,"input","avgPool3dGrad");let l=i,u=o,c=!1;o.rank===4&&(c=!0,l=j(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=j(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),R(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),R(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),mr("avgPool3dGrad",s,a);const h={dy:l,input:u},d={filterSize:n,strides:r,pad:s,dimRoundingMode:a},p=B.runKernel(uy,h,d);return c?j(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const X5=U({avgPool3dGrad_:q5});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Y5={kernelName:np,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:o}=n;return{x:()=>X5(t,r,s,a,i,o)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Q5(t,e,n,r,s){const a=F(t,"dy","avgPoolGrad"),i=F(e,"input","avgPoolGrad");R(i.rank===a.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${a.rank})`);let o=i,l=a,u=!1;i.rank===3&&(u=!0,o=j(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=j(a,[1,a.shape[0],a.shape[1],a.shape[2]])),R(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),R(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const c={dy:l,input:o},h={filterSize:n,strides:r,pad:s},d=B.runKernel(ly,c,h);return u?j(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const Z5=U({avgPoolGrad_:Q5});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const J5={kernelName:tp,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:s,strides:a,pad:i}=n;return{x:()=>Z5(t,r,s,a,i)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const e8={kernelName:rp,inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[r,s]=e,{transposeA:a,transposeB:i}=n;return!a&&!i?{a:()=>ot(t,s,!1,!0),b:()=>ot(r,t,!0,!1)}:!a&&i?{a:()=>ot(t,s,!1,!1),b:()=>ot(t,r,!0,!1)}:a&&!i?{a:()=>ot(s,t,!1,!0),b:()=>ot(r,t,!1,!1)}:{a:()=>ot(s,t,!0,!0),b:()=>ot(t,r,!0,!0)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const t8={kernelName:sp,gradFunc:(t,e,n)=>{const{blockShape:r,crops:s}=n;return{x:()=>bb(t,r,s)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const n8={kernelName:kB,gradFunc:(t,e,n)=>{const r=n,s=r.inputShape,a=r.shape,i=Array.from(a);for(let l=s.length-1;l>=0;l--)if(s[l]===a[l])i[l]=1;else if(s[l]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${a}].`);const o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>Re(t,o,!0)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const r8={kernelName:rc,gradFunc:t=>({x:()=>t.clone()})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const s8={kernelName:sc,gradFunc:t=>({x:()=>dt(t)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const a8={kernelName:ac,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{clipValueMin:s,clipValueMax:a}=n;return{x:()=>Un(da(vo(r,s),$l(r,a)),t,dt(t))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const i8={kernelName:ap,inputsToSave:["x"],gradFunc:vA.gradFunc};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const o8={kernelName:ip,saveAllInputs:!0,gradFunc:(t,e,n)=>{const r=e.map(o=>o.shape),{axis:s}=n,a=Ze(s,e[0].shape)[0],i=r.map(o=>o[a]);return Qr(t,i,a).map(o=>()=>o)}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const l8={kernelName:op,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,s]=e,{dilations:a,strides:i,pad:o,dataFormat:l}=n;return R(ro(a),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`),{x:()=>rk(r.shape,t,s,i,o,l),filter:()=>_k(r,t,s.shape,i,o,l)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const u8={kernelName:lp,inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[r,s]=e,{strides:a,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>so(t,s,a,i,o,1,l),filter:()=>_k(t,r,s.shape,a,i,o,l)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function c8(t,e,n,r,s){let a=t;t.rank===4&&(a=j(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let i=e;i.rank===4&&(i=j(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),R(a.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`),R(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),R(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),R(a.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`),R(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`);const o={x:a,dy:i},l={strides:r,pad:s,filterShape:n};return B.runKernel(my,o,l)}const h8=U({conv3DBackpropFilter_:c8});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const d8={kernelName:up,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:s,pad:a}=n;R(ro(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[i,o]=e;return{x:()=>DR(i.shape,t,o,s,a),filter:()=>h8(i,t,o.shape,s,a)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const p8={kernelName:ic,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>z(Lt(kk(me(n,"float32"))),t)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const f8={kernelName:oc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>z(Sk(me(n,"float32")),t)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const m8={kernelName:cp,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:s,exclusive:a,reverse:i}=n;return{x:()=>{const o=Tt([s],r.rank);let l=ik(t,s,a,!i);return o!=null&&(l=ht(l,o)),l}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const g8={kernelName:hp,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:s,pad:a,dimRoundingMode:i}=n,o=r??[1,1];R(ro(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[l,u]=e;return R(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),R(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),R(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),R(In(s,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${o}'.`),mr("depthwiseConv2d",a,i),{x:()=>w3(l.shape,t,u,s,a,o,i),filter:()=>v3(l,t,u.shape,s,a,o,i)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const y8={kernelName:dp,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,s]=e,a={x:r,filter:s,dy:t},i={x:r,filter:s,dy:t};return{x:()=>B.runKernel(ag,a,n),filter:()=>B.runKernel(ig,i,n)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const b8={kernelName:uc,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,r={dy:t,y:n};return{x:()=>B.runKernel(Cy,r)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const x8={kernelName:cc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=z(pr(Lt(It(n))),2/Math.sqrt(Math.PI));return{x:()=>z(t,r)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const v8={kernelName:hc,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>z(t,n)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const w8={kernelName:fp,inputsToSave:["input"],gradFunc:(t,e)=>{const[n]=e;return{input:()=>j(t,n.shape)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const k8={kernelName:dc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>z(t,pr(n))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const S8={kernelName:pc,gradFunc:t=>({x:()=>dt(t)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const I8={kernelName:fc,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=Ue(n.shape,r.shape);return{a:()=>{const a=Se(t,me(r,"float32")),i=fn(n.shape,s);return i.length>0?j(Re(a,i),n.shape):a},b:()=>{let a=z(t,me(n,"float32"));const i=fn(r.shape,s);i.length>0&&(a=j(Re(a,i),r.shape));const o=It(r);return Lt(Se(a,me(o,"float32")))}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const N8={kernelName:mp,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:r}=n,[s,a,i,o]=e,l=o??Me(1),u=fn(a.shape,s.shape),c=[];if(a.rank===1){for(let m=0;m<s.shape.length-1;++m)c.push(s.shape[m]);c.push(1)}const h=Ie(s,a),d=z(t,l),p=xk(ie(i,Me(r))),f=z(z(z(p,p),p),Me(-.5));return{x:()=>a.rank===1?j(z(z(t,Ds(j(p,[1,1,1,a.shape[0]]),c)),l),s.shape):j(z(z(t,p),l),s.shape),mean:()=>{let m=z(z(p,Me(-1)),d);return a.rank===1&&(m=Re(m,u)),j(m,a.shape)},variance:()=>{let m=z(z(f,h),d);return a.rank===1&&(m=Re(m,u)),j(m,a.shape)},scale:()=>{const m=z(h,p);let y=z(t,m);return a.rank===1&&(y=Re(y,u)),j(y,a.shape)},offset:()=>{let m=t;return a.rank===1&&(m=Re(m,u)),j(m,a.shape)}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const C8={kernelName:gp,inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[r,s]=e,{axis:a,batchDims:i}=n,o=Ze(a,r.shape)[0],l=(u,c,h)=>()=>{const d=u.shape,p=c.size,f=d.slice(0,o),m=f.length,y=d.slice(a,d.length).slice(1),g=y.length,b=uN(0,m),v=uN(m+1,m+1+g),w=cN([f,[p],y]),k=j(h,w),N=j(c,[p]),T=cN([[m],b,v]),E=ht(k,T);let _=$k(E,N,u.shape[o]);const O=Ha(T);return _=ht(_,O),_};if(i===1){const u=r.shape[0],c=r.split(u,0);return{x:()=>Tr(c.map((h,d)=>l(h,s.slice(d,1),t.slice(d,1))())).reshape(r.shape),indices:()=>s}}else return{x:l(r,s,t),indices:()=>s}}};function uN(t,e){const n=[];for(let r=t;r<e;++r)n.push(r);return n}function cN(t){const e=[];for(let n=0;n<t.length;++n)for(let r=0;r<t[n].length;++r)e.push(t[n][r]);return e}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const T8={kernelName:mc,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>dt(n),b:()=>dt(r)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const E8={kernelName:gc,gradFunc:t=>({x:()=>me(t,"float32")})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const $8={kernelName:yc,gradFunc:t=>({x:()=>dt(t)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const R8={kernelName:bc,gradFunc:t=>({x:()=>dt(t)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const A8={kernelName:xc,gradFunc:t=>({x:()=>dt(t)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const _8={kernelName:bp,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{alpha:s}=n,a=_r(r,0);return{x:()=>Un(a,t,z(t,s))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const F8={kernelName:wc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Se(t,ie(n,1))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const O8={kernelName:vc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Se(t,me(n,"float32"))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const D8={kernelName:SB,inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{axis:s}=n;return{logits:()=>{const a=pr(r);return Ie(t,z(Re(t,s,!0),a))}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function M8(t,e,n,r=5,s=1,a=1,i=.5){const o={x:t,y:e,dy:n},l={depthRadius:r,bias:s,alpha:a,beta:i};return B.runKernel(Oy,o,l)}const P8=U({localResponseNormalizationBackprop_:M8});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const L8={kernelName:Ip,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,s]=e,{depthRadius:a,bias:i,alpha:o,beta:l}=n;return{x:()=>P8(r,s,t,a,i,o,l)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function wA(t,e,n,r){return e.rank<n.rank&&(e=j(e,en(e.shape,r))),t.rank<n.rank&&(t=j(t,en(t.shape,r))),{x:()=>z(t,me(ms(n,e),t.dtype))}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const hN={kernelName:Np,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{reductionIndices:s}=r,a=e[0],i=e[1],o=Ze(s,a.shape),l=wA(t,i,a,o);return{x:()=>l.x()}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const z8={kernelName:kc,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>z(t,me(vo(n,r),"float32")),b:()=>z(t,me($d(n,r),"float32"))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function B8(t,e,n,r,s,a,i){const o=F(t,"dy","maxPool3dGrad"),l=F(e,"input","maxPool3dGrad"),u=F(n,"output","maxPool3dGrad");let c=o,h=l,d=u,p=!1;l.rank===4&&(p=!0,c=j(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=j(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=j(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),R(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),R(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),R(d.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),mr("maxPool3dGrad",a,i);const f={dy:c,input:h,output:d},m={filterSize:r,strides:s,pad:a,dimRoundingMode:i},y=B.runKernel(My,f,m);return p?j(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}const W8=U({maxPool3dGrad_:B8});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const U8={kernelName:Tp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,s]=e,{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>W8(t,r,s,a,i,o,l)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function V8(t,e,n,r,s,a,i){const o=F(t,"dy","maxPoolGrad"),l=F(e,"input","maxPoolGrad"),u=F(n,"output","maxPoolGrad");R(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),R(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),R(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),mr("maxPoolGrad",a,i);const c={dy:o,input:l,output:u},h={filterSize:r,strides:s,pad:a,dimRoundingMode:i};return B.runKernel(Dy,c,h)}const j8=U({maxPoolGrad_:V8});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const G8={kernelName:Cp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,s]=e,{filterSize:a,strides:i,pad:o}=n;return{x:()=>j8(t,r,s,a,i,o)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const H8={kernelName:Ep,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:s}=n,a=Ze(s,r.shape),i=an(r.shape,a)[1],o=Q(i);return{x:()=>{const l=r.shape.slice();a.forEach(c=>{l[c]=1});const u=j(t,l);return Se(z(u,Kr(r.shape,"float32")),o)}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const K8={kernelName:$p,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{axis:s}=r,[a,i]=e,o=Ze(s,a.shape),l=wA(t,i,a,o);return{x:()=>l.x()}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const q8={kernelName:Sc,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>z(t,me($l(n,r),"float32")),b:()=>z(t,me(_r(n,r),"float32"))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const X8={kernelName:Rp,inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:s}=n,a=s.map(i=>i[0]);return{x:()=>je(t,a,r.shape)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Y8={kernelName:Ic,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=Ue(n.shape,r.shape);return{a:()=>{const a=fn(n.shape,s);return a.length>0?j(Re(t,a),n.shape):t},b:()=>{const a=z(t,Lt(sf(Se(n,r)))),i=fn(r.shape,s);return i.length>0?j(Re(a,i),r.shape):a}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Q8={kernelName:Nc,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=Ue(n.shape,r.shape);return{a:()=>{const a=z(t,me(r,"float32")),i=fn(n.shape,s);return i.length>0?j(Re(a,i),n.shape):a},b:()=>{const a=z(t,me(n,"float32")),i=fn(r.shape,s);return i.length>0?j(Re(a,i),r.shape):a}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Z8={kernelName:Ap,gradFunc:t=>({x:()=>Lt(t)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const J8={kernelName:Op,inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>rn(n.shape,"float32")}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const eK={kernelName:Fp,gradFunc:t=>({x:()=>dt(t)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const tK={kernelName:Dp,saveAllInputs:!0,gradFunc:(t,e,n)=>{const{axis:r}=n;return Gs(t,r).map(s=>()=>s)}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const dN={kernelName:Mp,inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:s}=n,a=s.map(i=>i[0]);return{x:()=>je(t,a,r.shape)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const nK={kernelName:Cc,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,r,s]=e,a=n,i=r,o=Ue(a.shape,i.shape);return{a:()=>{const l=me(i,"float32");let u=z(t,z(l,mi(a,Ie(l,Me(1)))));const c=fn(a.shape,o);return c.length>0&&(u=Re(u,c)),j(u,a.shape)},b:()=>{const l=_r(a,0),u=Un(l,gs(a),dt(a));let c=z(t,z(s,u));const h=fn(i.shape,o);return h.length>0&&(c=Re(c,h)),j(c,i.shape)}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const rK={kernelName:Pp,inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,r]=e,s=_r(n,0);return{x:()=>Un(s,t,z(t,r)),alpha:()=>{let a=Un(s,dt(t),z(t,n));const i=fn(r.shape,t.shape);return i.length>0&&(a=Re(a,i)),j(a,r.shape)}}}};/**
* @license
* Copyright 2022 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function sK(t,e,n){const r=t.shape.slice();r[n]=1;const s=j(e,r),a=pg(t,n,!0,!1),i=pg(t,n,!0,!0),o=z(a,i);return z(s,o)}function aK(t,e,n){const r=t.shape.length,s=r-n.length,a=Tt(n,r);let i=t;a!=null&&(i=ht(t,a));const o=i.shape.slice(),l=o.splice(r-n.length,n.length).reduce((h,d)=>h*d,1);o.push(l);const u=i.reshape(o);let c=sK(u,e,s);if(c=c.reshape(i.shape),a!=null){const h=Ha(a);c=ht(c,h)}return c}const iK={kernelName:Lp,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:s}=n;let a=[];return s==null?a=r.shape.map((i,o)=>o):typeof s=="number"?a=[s]:a=s,{x:()=>aK(r,t,a)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const oK={kernelName:lc,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=Ue(n.shape,r.shape);return{a:()=>{const a=Se(t,me(r,"float32")),i=fn(n.shape,s);return i.length>0?j(Re(a,i),n.shape):a},b:()=>{let a=z(t,me(n,"float32"));const i=fn(r.shape,s);i.length>0&&(a=j(Re(a,i),r.shape));const o=It(r);return Lt(Se(a,me(o,"float32")))}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const lK={kernelName:Tc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Se(t,Lt(It(n)))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const uK={kernelName:$c,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=z($l(n,6),qc(n));return{x:()=>z(t,me(r,"float32"))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const cK={kernelName:Ec,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>z(t,me(qc(n),"float32"))}}};/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const hK={kernelName:zp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>j(t,n.shape)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const dK={kernelName:Wp,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,s={dy:t,images:r};return{images:()=>B.runKernel(jy,s,n)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const pK={kernelName:Bp,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,s={dy:t,images:r};return{images:()=>B.runKernel(Vy,s,n)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const fK={kernelName:Up,gradFunc:(t,e,n)=>{const{dims:r}=n,s=Ze(r,t.shape);return{x:()=>js(t,s)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const mK={kernelName:Rc,gradFunc:t=>({x:()=>dt(t)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const gK={kernelName:Ac,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Lt(Se(t,z(mi(n,1.5),2)))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const yK={kernelName:Vp,inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>me(dt(n),"float32"),t:()=>z(t,me(n,t.dtype)),e:()=>z(t,me(mb(n),t.dtype))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const bK={kernelName:_c,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const r=_r(n,Me(0)),s=Me(uf),a=Me(cf),i=z(t,a),o=z(z(t,s),pr(me(n,"float32")));return Un(r,i,o)}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const xK={kernelName:Mc,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>z(t,z(n,Ie(Me(1),n)))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const vK={kernelName:Dc,gradFunc:t=>({x:()=>dt(t)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const wK={kernelName:Fc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>z(ub(me(n,"float32")),t)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const kK={kernelName:Oc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>z(ak(me(n,"float32")),t)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const SK={kernelName:jp,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{begin:s,size:a}=n,i=r.shape,[o,l]=lf(r,s,a),u=[];for(let c=0;c<t.rank;c++)u.push([o[c],i[c]-o[c]-l[c]]);return{x:()=>pa(t,u)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const IK={kernelName:qp,outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{dim:s}=n,a=!0,i=z(t,r);return{logits:()=>Ie(i,z(Re(i,[s],a),r))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const NK={kernelName:Pc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>z(t,ps(n))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const pN={kernelName:Hp,gradFunc:(t,e,n)=>{const{blockShape:r,paddings:s}=n;return{x:()=>lb(t,r,s)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const fN={kernelName:Kp,gradFunc:(t,e,n)=>{const{axis:r}=n;return{x:()=>qt(t,r)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const CK={kernelName:Lc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Se(t,z(Vn(me(n,"float32")),2))}}};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const TK={kernelName:Qy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>z(t,z(me(n,"float32"),2))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const EK={kernelName:zc,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=Me(2);return{a:()=>z(t,z(s,Ie(n,r))),b:()=>z(t,z(s,Ie(r,n)))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const $K={kernelName:jc,gradFunc:t=>({x:()=>dt(t)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const RK={kernelName:Bc,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=Ue(n.shape,r.shape);return{a:()=>{let a=t;const i=fn(n.shape,s);return i.length>0&&(a=Re(a,i)),j(a,n.shape)},b:()=>{let a=t;const i=fn(r.shape,s);return i.length>0&&(a=Re(a,i)),j(Lt(a),r.shape)}}}};/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const AK={kernelName:Gp,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,s=r.shape.slice(),{axis:a}=n;Ze(a,r.shape).forEach(l=>{s[l]=1});const i=j(t,s),o=z(i,Kr(r.shape,"float32"));return{x:()=>o}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const _K={kernelName:Wc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Se(t,It(ub(n)))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const FK={kernelName:Uc,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>z(Ie(Me(1),It(n)),t)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const OK={kernelName:Vc,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{reps:s}=n;return{x:()=>{let a=dt(r);if(r.rank===1)for(let i=0;i<s[0];++i)a=ie(a,je(t,[i*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let i=0;i<s[0];++i)for(let o=0;o<s[1];++o)a=ie(a,je(t,[i*r.shape[0],o*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let i=0;i<s[0];++i)for(let o=0;o<s[1];++o)for(let l=0;l<s[2];++l)a=ie(a,je(t,[i*r.shape[0],o*r.shape[1],l*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let i=0;i<s[0];++i)for(let o=0;o<s[1];++o)for(let l=0;l<s[2];++l)for(let u=0;u<s[3];++u)a=ie(a,je(t,[i*r.shape[0],o*r.shape[1],l*r.shape[2],u*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return a}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const DK={kernelName:Qo,gradFunc:(t,e,n)=>{const r=n,{perm:s}=r,a=Ha(s);return{x:()=>ht(t,a)}}};/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const MK={kernelName:Xp,gradFunc:(t,e,n)=>{const r=n,{axis:s}=r;return{value:()=>Tr(t,s)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const PK={kernelName:Yp,inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>LK(t,n)}}};function LK(t,e){const n=wi(e,dt(e)),r=af(t,n);let s=vo(e,Me(0,"int32"));const a=r.rank-s.rank;for(let o=0;o<a;++o)s=hn(s,o+1);s=da(s,Kr(r.shape,"bool"));const i=dt(r);return Un(s,r,i)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const zK={kernelName:Qp,gradFunc:t=>({x:()=>dt(t)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const BK=[vA,P5,L5,z5,B5,W5,U5,V5,j5,G5,H5,K5,Y5,J5,e8,t8,n8,r8,s8,a8,i8,o8,u8,l8,d8,p8,f8,m8,g8,y8,oK,b8,x8,v8,w8,k8,I8,S8,N8,C8,T8,E8,$8,R8,A8,_8,F8,O8,D8,L8,hN,hN,z8,U8,G8,H8,K8,q8,X8,Y8,Q8,Z8,J8,eK,tK,dN,dN,nK,rK,iK,lK,uK,cK,hK,dK,pK,fK,mK,gK,yK,bK,xK,vK,wK,kK,SK,IK,NK,pN,pN,fN,fN,CK,EK,TK,$K,RK,AK,_K,FK,OK,DK,MK,PK,zK];for(const t of BK)NB(t);/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.abs=function(){return this.throwIfDisposed(),yn(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.acos=function(){return this.throwIfDisposed(),gR(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.acosh=function(){return this.throwIfDisposed(),yR(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.add=function(t){return this.throwIfDisposed(),ie(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.all=function(t,e){return this.throwIfDisposed(),ek(this,t,e)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.any=function(t,e){return this.throwIfDisposed(),dg(this,t,e)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.argMax=function(t){return this.throwIfDisposed(),hl(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.argMin=function(t){return this.throwIfDisposed(),bR(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.asScalar=function(){return this.throwIfDisposed(),R(this.size===1,()=>"The array must have only 1 element."),j(this,[])};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.asType=function(t){return this.throwIfDisposed(),me(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.as1D=function(){return this.throwIfDisposed(),j(this,[this.size])};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.as2D=function(t,e){return this.throwIfDisposed(),j(this,[t,e])};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.as3D=function(t,e,n){return this.throwIfDisposed(),j(this,[t,e,n])};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.as4D=function(t,e,n,r){return this.throwIfDisposed(),j(this,[t,e,n,r])};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.as5D=function(t,e,n,r,s){return this.throwIfDisposed(),j(this,[t,e,n,r,s])};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.asin=function(){return this.throwIfDisposed(),xR(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.asinh=function(){return this.throwIfDisposed(),vR(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.atan=function(){return this.throwIfDisposed(),wR(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.atan2=function(t){return this.throwIfDisposed(),kR(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.atanh=function(){return this.throwIfDisposed(),SR(this)};se().prototype.avgPool=function(t,e,n,r){return this.throwIfDisposed(),ob(this,t,e,n,r)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),lb(this,t,e)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.batchNorm=function(t,e,n,r,s){return this.throwIfDisposed(),ef(this,t,e,n,r,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.broadcastTo=function(t){return this.throwIfDisposed(),Iu(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.cast=function(t){return this.throwIfDisposed(),me(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.ceil=function(){return this.throwIfDisposed(),$R(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.clipByValue=function(t,e){return this.throwIfDisposed(),Cr(this,t,e)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.concat=function(t,e){return this.throwIfDisposed(),t instanceof st&&(t=[t]),qt([this,...t],e)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.conv1d=function(t,e,n,r,s,a){return this.throwIfDisposed(),nk(this,t,e,n,r,s,a)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.conv2dTranspose=function(t,e,n,r,s){return this.throwIfDisposed(),sk(this,t,e,n,r,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.conv2d=function(t,e,n,r,s,a){return this.throwIfDisposed(),so(this,t,e,n,r,s,a)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.cos=function(){return this.throwIfDisposed(),ub(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.cosh=function(){return this.throwIfDisposed(),ak(this)};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the 'License');
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an 'AS IS' BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.cumprod=function(t,e,n){return this.throwIfDisposed(),pg(this,t,e,n)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.cumsum=function(t,e,n){return this.throwIfDisposed(),ik(this,t,e,n)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),PR(this,t,e)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.depthwiseConv2d=function(t,e,n,r,s,a){return this.throwIfDisposed(),tf(this,t,e,n,r,s,a)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.dilation2d=function(t,e,n,r,s){return this.throwIfDisposed(),LR(this,t,e,n,r,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.divNoNan=function(t){return this.throwIfDisposed(),zR(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.div=function(t){return this.throwIfDisposed(),Se(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.dot=function(t){return this.throwIfDisposed(),BR(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.elu=function(){return this.throwIfDisposed(),nf(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.equal=function(t){return this.throwIfDisposed(),ms(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.erf=function(){return this.throwIfDisposed(),ok(this)};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.euclideanNorm=function(t,e){return this.throwIfDisposed(),VR(this,t,e)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.exp=function(){return this.throwIfDisposed(),pr(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.expandDims=function(t){return this.throwIfDisposed(),hn(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.expm1=function(){return this.throwIfDisposed(),jR(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.fft=function(){return this.throwIfDisposed(),Sb(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.flatten=function(){return this.throwIfDisposed(),j(this,[this.size])};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.floor=function(){return this.throwIfDisposed(),sf(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.floorDiv=function(t){return this.throwIfDisposed(),Jw(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.gather=function(t,e,n){return this.throwIfDisposed(),af(this,t,e,n)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.greaterEqual=function(t){return this.throwIfDisposed(),vo(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.greater=function(t){return this.throwIfDisposed(),_r(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.ifft=function(){return this.throwIfDisposed(),_d(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.irfft=function(){return this.throwIfDisposed(),Nk(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.isFinite=function(){return this.throwIfDisposed(),GR(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.isInf=function(){return this.throwIfDisposed(),HR(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.isNaN=function(){return this.throwIfDisposed(),KR(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.leakyRelu=function(t){return this.throwIfDisposed(),hb(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.lessEqual=function(t){return this.throwIfDisposed(),$l(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.less=function(t){return this.throwIfDisposed(),$d(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.localResponseNormalization=function(t,e,n,r){return this.throwIfDisposed(),qR(this,t,e,n,r)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.logSigmoid=function(){return this.throwIfDisposed(),XR(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.logSoftmax=function(t){return this.throwIfDisposed(),ck(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.logSumExp=function(t,e){return this.throwIfDisposed(),fb(this,t,e)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.log=function(){return this.throwIfDisposed(),gs(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.log1p=function(){return this.throwIfDisposed(),db(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.logicalAnd=function(t){return this.throwIfDisposed(),da(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.logicalNot=function(){return this.throwIfDisposed(),mb(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.logicalOr=function(t){return this.throwIfDisposed(),hk(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.logicalXor=function(t){return this.throwIfDisposed(),YR(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.matMul=function(t,e,n){return this.throwIfDisposed(),ot(this,t,e,n)};se().prototype.maxPool=function(t,e,n,r){return this.throwIfDisposed(),gb(this,t,e,n,r)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.max=function(t,e){return this.throwIfDisposed(),zs(this,t,e)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.maximum=function(t){return this.throwIfDisposed(),wi(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.mean=function(t,e){return this.throwIfDisposed(),Qt(this,t,e)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.min=function(t,e){return this.throwIfDisposed(),Ed(this,t,e)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.minimum=function(t){return this.throwIfDisposed(),ao(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.mirrorPad=function(t,e){return this.throwIfDisposed(),pk(this,t,e)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.mod=function(t){return this.throwIfDisposed(),ZR(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.mul=function(t){return this.throwIfDisposed(),z(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.neg=function(){return this.throwIfDisposed(),Lt(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.norm=function(t,e,n){return this.throwIfDisposed(),rf(this,t,e,n)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.notEqual=function(t){return this.throwIfDisposed(),Pu(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.oneHot=function(t,e=1,n=0){return this.throwIfDisposed(),fk(this,t,e,n)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.onesLike=function(){return this.throwIfDisposed(),ys(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.pad=function(t,e){return this.throwIfDisposed(),pa(this,t,e)};se().prototype.pool=function(t,e,n,r,s,a){return this.throwIfDisposed(),JR(this,t,e,n,r,s,a)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.pow=function(t){return this.throwIfDisposed(),mi(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.prelu=function(t){return this.throwIfDisposed(),xb(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.prod=function(t,e){return this.throwIfDisposed(),e3(this,t,e)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.reciprocal=function(){return this.throwIfDisposed(),l3(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.relu=function(){return this.throwIfDisposed(),Ka(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.relu6=function(){return this.throwIfDisposed(),yk(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.reshapeAs=function(t){return this.throwIfDisposed(),j(this,t.shape)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.reshape=function(t){return this.throwIfDisposed(),j(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.resizeBilinear=function(t,e,n){return this.throwIfDisposed(),I3(this,t,e,n)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.resizeNearestNeighbor=function(t,e,n){return this.throwIfDisposed(),N3(this,t,e,n)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.reverse=function(t){return this.throwIfDisposed(),js(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.rfft=function(){return this.throwIfDisposed(),Ib(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.round=function(){return this.throwIfDisposed(),bk(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.rsqrt=function(){return this.throwIfDisposed(),xk(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.selu=function(){return this.throwIfDisposed(),vk(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.separableConv2d=function(t,e,n,r,s,a){return this.throwIfDisposed(),wk(this,t,e,n,r,s,a)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.sigmoid=function(){return this.throwIfDisposed(),ps(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.sign=function(){return this.throwIfDisposed(),u3(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.sin=function(){return this.throwIfDisposed(),kk(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.sinh=function(){return this.throwIfDisposed(),Sk(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.slice=function(t,e){return this.throwIfDisposed(),je(this,t,e)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.softmax=function(t){return this.throwIfDisposed(),kb(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.softplus=function(){return this.throwIfDisposed(),Hc(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),bb(this,t,e)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.split=function(t,e){return this.throwIfDisposed(),Qr(this,t,e)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.sqrt=function(){return this.throwIfDisposed(),Vn(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.square=function(){return this.throwIfDisposed(),It(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.squaredDifference=function(t){return this.throwIfDisposed(),Ck(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.squeeze=function(t){return this.throwIfDisposed(),yt(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.stack=function(t,e){this.throwIfDisposed();const n=t instanceof st?[this,t]:[this,...t];return Tr(n,e)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.step=function(t){return this.throwIfDisposed(),qc(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.stridedSlice=function(t,e,n,r,s,a,i,o){return this.throwIfDisposed(),c3(this,t,e,n,r,s,a,i,o)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.sub=function(t){return this.throwIfDisposed(),Ie(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.sum=function(t,e){return this.throwIfDisposed(),Re(this,t,e)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.tan=function(){return this.throwIfDisposed(),h3(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.tanh=function(){return this.throwIfDisposed(),pl(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.tile=function(t){return this.throwIfDisposed(),Ds(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.toBool=function(){return this.throwIfDisposed(),me(this,"bool")};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.toFloat=function(){return this.throwIfDisposed(),me(this,"float32")};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.toInt=function(){return this.throwIfDisposed(),me(this,"int32")};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.topk=function(t,e){return this.throwIfDisposed(),p3(this,t,e)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.transpose=function(t){return this.throwIfDisposed(),ht(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.unique=function(t){return this.throwIfDisposed(),f3(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),$k(this,t,e)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.unstack=function(t){return this.throwIfDisposed(),Gs(this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.where=function(t,e){return this.throwIfDisposed(),Un(t,this,e)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/se().prototype.zerosLike=function(){return this.throwIfDisposed(),dt(this)};/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class _a extends Error{constructor(e){super(e),Object.setPrototypeOf(this,_a.prototype)}}class Ms extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Ms.prototype)}}class H extends Error{constructor(e){super(e),Object.setPrototypeOf(this,H.prototype)}}class et extends Error{constructor(e){super(e),Object.setPrototypeOf(this,et.prototype)}}class jk extends Error{constructor(e){super(e),Object.setPrototypeOf(this,jk.prototype)}}/**
* @license
* Copyright 2022 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class kA{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let n;return this.cache.has(e)&&(n=this.cache.get(e),this.cache.delete(e),this.cache.set(e,n)),n}put(e,n){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(e,n)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let n=0;n<this.maxEntries-e;n++){const r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=e}}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function ml(t,e){if(Array.isArray(t)){let n=[];for(let r=0;r<e;r++)n=n.concat(t);return n}else{const n=new Array(e);return n.fill(t),n}}function Fa(t,e){if(!t)throw new jk(e)}function mN(t,e){let n=0;for(const r of t)r===e&&n++;return n}function vr(t){return t.length===1?t[0]:t}function kt(t){return Array.isArray(t)?t:[t]}function Za(t){const e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function Po(t){return t.length<=1||t.indexOf("_")===-1?t:t.replace(/[_]+(\w|$)/g,(e,n)=>n.toUpperCase())}let Is={};function Gk(t){if(t==null)return null;const e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function J1(t){if(!(t==null||typeof t!="object"))if(Array.isArray(t))t.forEach(e=>J1(e));else{const e=Object.keys(t);for(const n of e){const r=t[n];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?t[n]=r.value:J1(r))}}}function hf(t,e={},n={},r="object",s=!1){if(typeof t=="string"){const a=t;let i;if(a in n)i=n[a];else if(a in Is)i=Is[a];else if(i=e[a],i==null)throw new H(`Unknown ${r}: ${t}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{const a=t;if(a.className==null||a.config==null)throw new H(`${r}: Improper config format: ${JSON.stringify(a)}.
'className' and 'config' must set.`);const i=a.className;let o,l;if(i in n?[o,l]=n[i]:i in Is?[o,l]=Is.className:i in e&&([o,l]=e[i]),o==null)throw new H(`Unknown ${r}: ${i}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const u={};for(const p of Object.keys(Is))u[p]=Is[p];for(const p of Object.keys(n))u[p]=n[p];const c=a.config;c.customObjects=u;const h=Object.assign({},Is);for(const p of Object.keys(n))Is[p]=n[p];J1(a.config);const d=l(o,a.config,n,s);return Is=Object.assign({},h),d}else{const u=Object.assign({},Is);for(const h of Object.keys(n))Is[h]=n[h];const c=new o(a.config);return Is=Object.assign({},u),c}}}function WK(t,e){return t<e?-1:t>e?1:0}function nm(t,e){return-1*WK(t,e)}function qi(t){if(t==null)return t;const e=[];for(const n of t)e.indexOf(n)===-1&&e.push(n);return e}function UK(t){if(t==null)throw new H(`Invalid value in obj: ${JSON.stringify(t)}`);for(const e in t)if(t.hasOwnProperty(e))return!1;return!0}function Ml(t,e,n){if(n!=null&&t.indexOf(n)<0)throw new H(`${n} is not a valid ${e}.  Valid values are ${t} or null/undefined.`)}function Hk(t,e,n=0,r=1/0){return Fa(n>=0),Fa(r>=n),Array.isArray(t)&&t.length>=n&&t.length<=r&&t.every(s=>typeof s===e)}function _n(t,e){Array.isArray(t)?(R(t.length>0,()=>`${e} is unexpectedly an empty array.`),t.forEach((n,r)=>_n(n,`element ${r+1} of ${e}`))):R(Number.isInteger(t)&&t>0,()=>`Expected ${e} to be a positive integer, but got ${SA(t)}.`)}function SA(t){return t===null?"null":Array.isArray(t)?"["+t.map(e=>SA(e)).join(",")+"]":typeof t=="string"?`"${t}"`:`${t}`}function VK(t,e,n){let r=n!=null?n():Ln(),s;return(...a)=>{const i=n!=null?n():Ln();return i-r<e||(r=i,s=t(...a)),s}}function IA(t){return t==="relu"?"relu":t==="linear"?"linear":t==="elu"?"elu":null}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/let jK=0;function NA(){return jK++}const rm={};function e0(t=""){return t in rm||(rm[t]=0),rm[t]+=1,t+rm[t].toString()}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/const GK=["channelsFirst","channelsLast"],HK=["nearest","bilinear"],KK=["valid","same","causal"],qK=["max","avg"],XK=["sum","mul","concat","ave"];/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/const Xl=new Map;function on(t){Ml(GK,"DataFormat",t)}function YK(t){Ml(HK,"InterpolationFormat",t)}function ws(t){Ml(KK,"PaddingMode",t)}function CA(t){Ml(qK,"PoolMode",t)}const ed=[],gN="/";function Zo(t,e){ed.push(t);try{const n=e();return ed.pop(),n}catch(n){throw ed.pop(),n}}function QK(){return ed.length===0?"":ed.join(gN)+gN}function TA(t){if(!$A(t))throw new Error("Not a valid tensor name: '"+t+"'");return QK()+t}function EA(t){if(!$A(t))throw new Error("Not a valid tensor name: '"+t+"'");Xl.has(t)||Xl.set(t,0);const e=Xl.get(t);if(Xl.set(t,Xl.get(t)+1),e>0){const n=`${t}_${e}`;return Xl.set(n,1),n}else return t}const ZK=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function $A(t){return!!t.match(ZK)}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function JK(t){return t===parseInt(t.toString(),10)}function Xi(t,e,n){e==null&&(e=0),n==null&&(n=t.length);let r=1;for(let s=e;s<n;++s)r*=t[s];return r}function zu(t){if(t.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let n=0;n<t.length;n++){const r=t[n];r<e&&(e=r)}return e}function io(t){if(t.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let n=0;n<t.length;n++){const r=t[n];r>e&&(e=r)}return e}function ga(t,e){if(e<t)throw new H(`end (${e}) < begin (${t}) is forbidden.`);const n=[];for(let r=t;r<e;++r)n.push(r);return n}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/let vx;function xn(){return vx==null&&(vx=ll().epsilon()),vx}function ya(){return"channelsLast"}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function yi(t,e){return me(t,e)}function df(t,e=-1){const n=t.shape.slice();return e<0&&(e=n.length+e+1),n.splice(e,0,1),j(t,n)}function eq(t,e){return Y(()=>{if(t.shape.length!==2)throw new H(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);const n=df(t,1);return ev(n,[1,e,1])})}function tq(t){const e=[Xi(t.shape)];return j(t,e)}function nq(t){if(t.rank<=1)throw new H(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);const e=[t.shape[0],Xi(t.shape,1)];return j(t,e)}function Jo(t,e,n){return Y(()=>{switch(t.rank){case 1:return vb(t,e,n);case 2:return Ik(t,[e,0],[n,t.shape[1]]);case 3:return wb(t,[e,0,0],[n,t.shape[1],t.shape[2]]);case 4:return Ad(t,[e,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3]]);case 5:return je(t,[e,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return je(t,[e,0,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new H(`sliceAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}})}function wx(t,e,n){return Y(()=>{switch(t.rank){case 1:return vb(t,e,n);case 2:return Ik(t,[0,e],[t.shape[0],n]);case 3:return wb(t,[0,0,e],[t.shape[0],t.shape[1],n]);case 4:return Ad(t,[0,0,0,e],[t.shape[0],t.shape[1],t.shape[2],n]);default:throw new H(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function sm(t,e,n,r){return Y(()=>{switch(t.rank){case 1:return vb(t,e,n);case 2:switch(r){case 1:return Jo(t,e,n);case 2:return wx(t,e,n);default:throw new H(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Jo(t,e,n);case 2:return wb(t,[0,e,0],[t.shape[0],n,t.shape[2]]);case 3:return wx(t,e,n);default:throw new H(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Jo(t,e,n);case 2:return Ad(t,[0,e,0,0],[t.shape[0],n,t.shape[2],t.shape[3]]);case 3:return Ad(t,[0,0,e,0],[t.shape[0],t.shape[1],n,t.shape[3]]);case 4:return wx(t,e,n);default:throw new H(`The axis is not within the rank of the tensor ${r}`)}default:throw new H(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function Kk(t,e=-1){let n;return e<0&&(n=t[0].rank,n!==0?e=n:e=0),e===t[0].rank&&(e=-1),qt(t,e)}function yN(t,e){switch(t.rank){case 1:return RR([t,e]);case 2:return AR([t,e],0);case 3:return _R([t,e],0);case 4:return FR([t,e],0);default:throw new H(`concatAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}function ev(t,e){if(Array.isArray(e)||(e=[e]),t.rank!==e.length)throw new H(`The length of input n (${e.length}) does not match the number of dimensions in input x (${t.rank})`);return Ds(t,e)}function t0(t,e=0,n=1,r,s){return gk(t,e,n,r,s)}function Ba(t,e,n,r){if(t.rank<2||e.rank<2)throw new et(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${e.shape}`);if(e.rank>=3){const s=t.shape.slice(-1)[0],a=e.shape.slice(-2)[0];if(s!==a)throw new et(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = ${e.shape}`)}if(t.rank===2&&e.rank===2)return q1({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?tv(t.rank,r,ya()):null,activation:n});{const s=t.shape.slice(),a=s.pop();t=j(t,[-1,a]);const i=e.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],c=Array.from({length:e.rank},(d,p)=>p===0?e.rank-2:p<=e.rank-2?p-1:p);e=j(ht(e,c),[l,-1]);const h=[...s,...u];return j(q1({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?tv(t.rank,r,ya()):null,activation:n}),h)}}function RA(t,e,n){return Y(()=>(Array.isArray(e)?e=dn(e,"int32"):e=me(e,"int32"),af(t,e,n)))}function pf(t){return z(t,t)}function tv(t,e,n){const r=e.shape;if(e.rank!==1&&e.rank!==t)throw new H(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${t}`);if(t===5){if(n==="channelsFirst")return r.length===1?j(e,[1,r[0],1,1,1]):j(e,[1,r[3],r[0],r[1],r[2]]);if(n==="channelsLast")return r.length===1?j(e,[1,1,1,1,r[0]]):j(e,[1].concat(r))}else if(t===4){if(n==="channelsFirst")return r.length===1?j(e,[1,r[0],1,1]):j(e,[1,r[2],r[0],r[1]]);if(n==="channelsLast")return r.length===1?j(e,[1,1,1,r[0]]):j(e,[1].concat(r))}else if(t===3){if(n==="channelsFirst")return r.length===1?j(e,[1,r[0],1]):j(e,[1,r[1],r[0]]);if(n==="channelsLast")return r.length===1?j(e,[1,1,r[0]]):j(e,[1].concat(r))}else if(t<3)return e;throw new H(`Unsupported input rank by biasAdd: ${e.rank}`)}function Sa(t,e,n){return Y(()=>(n==null&&(n=ya()),on(n),ie(t,tv(t.rank,e,n))))}function rq(t,e=1){if(e!==1)throw new et(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return nf(t)}function sq(t){return Y(()=>Se(t,ie(yn(t),1)))}function AA(t,e,n,r){return Y(()=>y3(t,e,n,r))}function aq(t){return Y(()=>{const e=ie(.5,z(.2,t));return Cr(e,0,1)})}function ff(t,e,n=!1){return n?t():e()}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/const iq=["fanIn","fanOut","fanAvg"],oq=["normal","uniform","truncatedNormal"];/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function lq(t){Ml(iq,"FanMode",t)}function uq(t){Ml(oq,"Distribution",t)}class Hs extends _l{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class _A extends Hs{apply(e,n){return rn(e,n)}}_A.className="Zeros";le(_A);class qk extends Hs{apply(e,n){return Kr(e,n)}}qk.className="Ones";le(qk);class FA extends Hs{constructor(e){if(super(),typeof e!="object")throw new H(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new H(`config must have value set but got ${e}`);this.value=e.value}apply(e,n){return Y(()=>z(Me(this.value),Kr(e,n)))}getConfig(){return{value:this.value}}}FA.className="Constant";le(FA);class OA extends Hs{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,n){return Al(e,this.minval,this.maxval,n,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}OA.className="RandomUniform";le(OA);class DA extends Hs{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new et(`randomNormal does not support dType ${n}.`);return t0(e,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}DA.className="RandomNormal";le(DA);class MA extends Hs{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new et(`truncatedNormal does not support dType ${n}.`);return Ek(e,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}MA.className="TruncatedNormal";le(MA);class PA extends Hs{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,n){return Y(()=>{if(e.length!==2||e[0]!==e[1])throw new H("Identity matrix initializer can only be used for 2D square matrices.");return z(this.gain,uk(e[0]))})}getConfig(){return{gain:this.gain}}}PA.className="Identity";le(PA);function cq(t,e="channelsLast"){let n,r;if(on(e),t.length===2)n=t[0],r=t[1];else if([3,4,5].indexOf(t.length)!==-1){if(e==="channelsFirst"){const s=Xi(t,2);n=t[1]*s,r=t[0]*s}else if(e==="channelsLast"){const s=Xi(t,0,t.length-2);n=t[t.length-2]*s,r=t[t.length-1]*s}}else{const s=Xi(t);n=Math.sqrt(s),r=Math.sqrt(s)}return[n,r]}class Jr extends Hs{constructor(e){if(super(),e.scale<0)throw new H(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,lq(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,uq(this.distribution),this.seed=e.seed}apply(e,n){const r=cq(e),s=r[0],a=r[1];let i=this.scale;if(this.mode==="fanIn"?i/=Math.max(1,s):this.mode==="fanOut"?i/=Math.max(1,a):i/=Math.max(1,(s+a)/2),this.distribution==="normal"){const o=Math.sqrt(i);if(n=n||"float32",n!=="float32"&&n!=="int32")throw new et(`${this.getClassName()} does not support dType ${n}.`);return Ek(e,0,o,n,this.seed)}else{const o=Math.sqrt(3*i);return Al(e,-o,o,n,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Jr.className="VarianceScaling";le(Jr);class Xk extends Jr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Jr.className}}Xk.className="GlorotUniform";le(Xk);class Yk extends Jr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Jr.className}}Yk.className="GlorotNormal";le(Yk);class Qk extends Jr{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Jr.className}}Qk.className="HeNormal";le(Qk);class Zk extends Jr{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Jr.className}}Zk.className="HeUniform";le(Zk);class Jk extends Jr{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Jr.className}}Jk.className="LeCunNormal";le(Jk);class e2 extends Jr{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Jr.className}}e2.className="LeCunUniform";le(e2);class LA extends Hs{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,n){return Y(()=>{if(e.length<2)throw new et("Shape must be at least 2D.");if(n!=="int32"&&n!=="float32"&&n!==void 0)throw new TypeError(`Unsupported data type ${n}.`);n=n;const r=Q(e.slice(0,-1)),s=e[e.length-1],a=r*s;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);const i=[Math.max(s,r),Math.min(s,r)],o=t0(i,0,1,n,this.seed),l=C3.qr(o,!1);let u=l[0];const c=l[1].flatten().stridedSlice([0],[Math.min(s,r)*Math.min(s,r)],[Math.min(s,r)+1]);return u=z(u,c.sign()),r<s&&(u=u.transpose()),z(Me(this.gain),u.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}LA.className="Orthogonal";le(LA);const bN={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function xN(t,e={}){return hf(t,os.getMap().classNameMap,e,"initializer")}function Kt(t){return Gk(t)}function Ut(t){if(typeof t=="string"){const e=t in bN?bN[t]:t;if(e==="GlorotNormal")return new Yk;if(e==="GlorotUniform")return new Xk;if(e==="HeNormal")return new Qk;if(e==="HeUniform")return new Zk;if(e==="LeCunNormal")return new Jk;if(e==="LeCunUniform")return new e2;{const n={};return n.className=e,n.config={},xN(n)}}else return t instanceof Hs?t:xN(t)}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function nv(t){return Array.isArray(t)&&Array.isArray(t[0])}function mg(t){return t.length===0?[]:Array.isArray(t[0])?t:[t]}function Ge(t){let e;if(Array.isArray(t)){if(t.length!==1)throw new H(`Expected Tensor length to be 1; got ${t.length}`);e=t[0]}else e=t;return e}function gt(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(t.length===1)return t=t,t[0];throw new H(`Expected exactly 1 Shape; got ${t.length}`)}else return t}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function gg(t){let e=0;for(const n of t)n.shape.length===0?e+=1:e+=n.shape.reduce((r,s)=>r*s);return e}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/const vN="Variable";class hq{constructor(e,n="float32",r=vN,s=!0,a=null){this.dtype=n??"float32",this.shape=e.shape,this.id=NA(),r=r??vN,this.originalName=TA(r),this.name=EA(this.originalName),this.trainable_=s,this.constraint=a,this.val=m3(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),dq(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function dq(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}function rv(t){return t.map(e=>e.read())}function t2(t){t.forEach(e=>{e[0].write(e[1])})}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class vn{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class Ua{constructor(e,n,r,s,a,i,o){this.dtype=e,this.shape=n,this.sourceLayer=r,this.inputs=s,this.callArgs=a,this.outputTensorIndex=o,this.id=NA(),i!=null&&(this.originalName=TA(i),this.name=EA(this.originalName)),this.rank=n.length}}let pq=0;class n0{constructor(e,n){this.callArgs=n,this.id=pq++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const r of e.inboundLayers)r!=null&&r.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const n of this.inboundLayers)n!=null?e.push(n.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let fq=0;class at extends _l{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=fq++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let n=e.name;if(!n){const r=this.getClassName();n=Za(r)+"_"+e0(r)}if(this.name=n,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let r;if(e.batchInputShape!=null)r=e.batchInputShape;else if(e.inputShape!=null){let a=null;e.batchSize!=null&&(a=e.batchSize),r=[a].concat(e.inputShape)}this.batchInputShape=r;let s=e.dtype;s==null&&(s=e.inputDType),s==null&&(s="float32"),this.dtype=s}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,n){return e.name+"_ib-"+n.toString()}getNodeAtIndex(e,n){if(this.inboundNodes.length===0)throw new Ms(`The layer has never been called and thus has no defined ${n}.`);if(this.inboundNodes.length<=e)throw new H(`Asked to get ${n} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return vr(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return vr(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new _a(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new _a(`Layer ${this.name} is not connected, no input to return.`);return vr(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new _a(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new _a(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return vr(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(n=>n.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const n=kt(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const r=kt(this.inputSpec);if(n.length!==r.length)throw new H(`Layer ${this.name} expects ${r.length} inputs, but it received ${n.length} input tensors. Input received: ${e}`);for(let s=0;s<n.length;s++){const a=n[s],i=r[s];if(i==null)continue;const o=a.rank;if(i.ndim!=null&&o!==i.ndim)throw new H(`Input ${s} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${o}`);if(i.maxNDim!=null&&o>i.maxNDim)throw new H(`Input ${s} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${o}`);if(i.minNDim!=null&&o<i.minNDim)throw new H(`Input ${s} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${o}.`);if(i.dtype!=null&&a.dtype!==i.dtype)throw new H(`Input ${s} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${a.dtype}.`);if(i.axes){const l=a.shape;for(const u in i.axes){const c=Number(u),h=i.axes[u],d=c>=0?l[c]:l[l.length+c];if(h!=null&&[h,null].indexOf(d)===-1)throw new H(`Input ${s} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${h} but got shape ${l}.`)}}if(i.shape!=null)for(let l=0;l<i.shape.length;++l){const u=i.shape[l],c=a.shape[l];if(u!=null&&c!=null&&u!==c)throw new H(`Input ${s} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${a.shape}.`)}}}call(e,n){return e}invokeCallHook(e,n){this._callHook!=null&&this._callHook(e,n)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,n){n=n||{},this.assertNotDisposed();const r=kt(e),s=yq(e),a=bq(e);if(s===a)throw new H("Arguments to apply() must be all SymbolicTensors or all Tensors");return Zo(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const i=[];for(const o of kt(e))i.push(o.shape);this.build(vr(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let i=this.call(e,n);this.supportsMasking&&this.setMaskMetadata(e,i);const o=kt(i),l=[];for(let u of o)r.indexOf(u)!==-1&&(u=u.clone()),l.push(u);if(i=vr(l),this.activityRegularizer!=null)throw new et("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}else{const i=mq(e),o=this.computeOutputShape(i);let l;const u=gq(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?i[0]:i),o!=null&&o.length>0&&Array.isArray(o[0])?l=o.map((c,h)=>new Ua(u,c,this,kt(e),n,this.name,h)):l=new Ua(u,o,this,kt(e),n,this.name),this.addInboundNode(e,l,null,null,i,o,n),this._refCount++,this.activityRegularizer!=null)throw new et("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let n=!1;this.batchInputShape.forEach((r,s)=>{r!=null&&e[s]!=null&&e[s]!==r&&(n=!0)}),n&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new _a(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const n of this.inboundNodes){const r=JSON.stringify(n.outputShapes);e.indexOf(r)===-1&&e.push(r)}if(e.length===1){const n=this.inboundNodes[0].outputShapes;return Array.isArray(n)&&Array.isArray(n[0])&&n.length===1?n[0]:n}else throw new _a(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Ms(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return gg(this.weights)}build(e){this.built=!0}getWeights(e=!1){return rv(e?this.trainableWeights:this.weights)}setWeights(e){Y(()=>{const n=this.weights;if(n.length!==e.length)throw new H(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${n.length} weights. Provided weights: ${e}...`);if(n.length===0)return;const r=[],s=rv(n);for(let a=0;a<s.length;++a){const i=s[a],o=n[a],l=e[a];if(!Je(i.shape,l.shape))throw new H(`Layer weight shape ${i.shape} not compatible with provided weight shape ${l.shape}`);r.push([o,l])}t2(r)})}addWeight(e,n,r,s,a,i,o,l){if(this._addedWeightNames.indexOf(e)!==-1)throw new H(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),r==null&&(r="float32"),this.fastWeightInitDuringBuild&&(s=l!=null?l():Ut("zeros"));const u=s.apply(n,r),c=new hq(u,r,e,i,o);return u.dispose(),a!=null&&this.addLoss(()=>a.apply(c.read())),i==null&&(i=!0),i?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=kt(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,n){if(!this.supportsMasking){if(n!=null)if(Array.isArray(n))n.forEach(r=>{if(r!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return n}setMaskMetadata(e,n,r){if(!this.supportsMasking)return;const s=this.computeMask(e,r),a=kt(n),i=kt(s);if(a.length!==i.length)throw new Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);for(let o=0;o<a.length;o++)a[o].kerasMask=i[o]}addInboundNode(e,n,r,s,a,i,o=null){const l=kt(e);n=kt(n),r=kt(r),s=kt(s),a=mg(a),i=mg(i);const u=[],c=[],h=[];for(const d of l)u.push(d.sourceLayer),c.push(d.nodeIndex),h.push(d.tensorIndex);new n0({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:h,inputTensors:l,outputTensors:n,inputMasks:r,outputMasks:s,inputShapes:a,outputShapes:i},o);for(let d=0;d<n.length;d++)n[d].sourceLayer=this,n[d].nodeIndex=this.inboundNodes.length-1,n[d].tensorIndex=d}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function mq(t){t=kt(t);const e=[];for(const n of t)e.push(n.shape);return vr(e)}function gq(t){return"float32"}function zA(t,e,n){if((e==null||n!=null&&n>0)&&(e=t.sourceLayer,n=t.nodeIndex),e.inboundNodes.length===0)return[t];{const r=e.inboundNodes[n];if(r.inboundLayers.length===0)return r.inputTensors;{const s=[];for(let a=0;a<r.inboundLayers.length;a++){const i=r.inputTensors[a],o=r.inboundLayers[a],l=r.nodeIndices[a],u=zA(i,o,l);for(const c of u)s.indexOf(c)===-1&&s.push(c)}return s}}}function yq(t){let e=!0;for(const n of kt(t))if(!(n instanceof Ua)){e=!1;break}return e}function bq(t){let e=!0;for(const n of kt(t))if(n instanceof Ua){e=!1;break}return e}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class mf extends at{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:e0("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new H("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let n=e.batchInputShape;if(n==null){if(e.inputShape==null)throw new H("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");n=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new H("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const r=e.dtype||"float32";this.batchInputShape=n,this.dtype=r,this.inputSpec=[{shape:n}];const s=new Ua(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new n0({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[n],outputShapes:[n]})}apply(e,n){throw new H(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}mf.className="InputLayer";le(mf);function xq(t){if(t.batchShape==null&&t.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(t.batchShape!=null&&t.shape!=null)throw new H("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=t.batchShape;t.shape!=null&&e==null&&(e=[null].concat(t.shape));let n=t.dtype;return n==null&&(n="float32"),new mf({batchInputShape:e,name:t.name,dtype:n,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function vq(t,e){if(t.dtype==null||t.dtype===e.dtype)return e;try{return me(e,t.dtype)}catch{throw new H(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}class Di{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Di)for(const n in e.id2Value)this.id2Value[n]=e.id2Value[n],n in e.id2Mask&&(this.id2Mask[n]=e.id2Mask[n]);else{if(e==null)return;for(const n of e)this.add(n.key,n.value)}}add(e,n,r){if(this.id2Value[e.id]==null)this.id2Value[e.id]=vq(e,n),this.name2Id[e.name]=e.id,r!=null&&(this.id2Mask[e.id]=r);else throw new H(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Ua){if(this.id2Value[e.id]==null)throw new H(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const n=this.name2Id[e];if(n==null)throw new H(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[n]}}getMask(e){if(e instanceof Ua){if(this.id2Value[e.id]==null)throw new H(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const n=this.name2Id[e];if(n==null)throw new H(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&Pe(this.id2Mask)}}const yg=new kA,bg=new kA;function wq(t){yg!=null&&yg.setMaxEntries(t),bg!=null&&bg.setMaxEntries(t)}function Mh(t,e,n,r){const s=n==null?!1:n.training,a=Array.isArray(t),i=a?t:[t],o=i.map(f=>f.name),l=[],u=e.names();for(const f of o)u.indexOf(f)!==-1?l.push(e.getValue(f)):l.push(null);const c=o.join(",")+"|"+e.names().sort().join(",");let h=yg.get(c),d;if(h==null){const f=kq(i,e);h=f.sorted,d=f.recipientCounts,yg.put(c,h),bg.put(c,d)}d={},s||Object.assign(d,bg.get(c));const p=new Di(e);for(let f=0;f<h.length;++f){const m=h[f],y=m.sourceLayer;if(y instanceof mf)continue;const g=[],b=[],v=[];let w=!1;for(const _ of m.inputs){const O=p.getValue(_),M=p.getMask(_);g.push(O),b.push(M),M!=null&&(w=!0),s||(d[_.name]--,d[_.name]===0&&!e.hasKey(_)&&o.indexOf(_.name)===-1&&!O.isDisposed&&_.sourceLayer.stateful!==!0&&v.push(O))}w&&(n=n||{},n.mask=b[0]);const k=kt(y.apply(g,n));let N=null;y.supportsMasking&&(N=y.computeMask(g,b));const T=Iq(m),E=Array.isArray(T)?T:[T];for(let _=0;_<E.length;++_){p.hasKey(E[_])||p.add(E[_],k[_],Array.isArray(N)?N[0]:N);const O=o.indexOf(E[_].name);O!==-1&&(l[O]=k[_])}s||Pe(v)}return p.disposeMasks(),a?l:l[0]}function kq(t,e){R(t!=null&&t.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(t.length===1){const s=wN(t[0],e);n=s.sorted,r=s.recipientMap}else{const s=new Set;for(const a of t){const{sorted:i,recipientMap:o}=wN(a,e);for(const l of i)s.has(l.name)||(n.push(l),s.add(l.name));for(const l in o)r[l]==null&&(r[l]=new Set),o[l].forEach(u=>r[l].add(u))}}return{sorted:n,recipientCounts:Sq(r)}}function Sq(t){const e={};for(const n in t)e[n]=t[n].size;return e}function wN(t,e){const n=new Set,r=[],s={};for(const o of e.names())n.add(o);const a=[],i=[];for(a.push(t);a.length>0;){const o=a[a.length-1];if(n.has(o.name)){a.pop();continue}const l=i[i.length-1]===a.length-1;if(o.inputs.length===0||l)a.pop(),r.push(o),n.add(o.name),l&&i.pop();else{i.push(a.length-1);for(const u of o.inputs)s[u.name]==null&&(s[u.name]=new Set),s[u.name].add(o.name),!n.has(u.name)&&a.push(u)}}return{sorted:r,recipientMap:s}}function Iq(t){let e;if(t.sourceLayer.inboundNodes.length===1)e=t.sourceLayer.output;else{let n=null;for(let r=0;r<t.sourceLayer.inboundNodes.length;++r)for(const s of t.sourceLayer.inboundNodes[r].outputTensors)if(s.id===t.id){n=r;break}e=t.sourceLayer.getOutputAt(n)}return e}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Nq=Z();Nq.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,wq);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function n2(t,e){return Y(()=>Vn(Re(z(t,t),e,!0)))}class gf extends _l{getConfig(){return{}}}class BA extends gf{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return Y(()=>{const n=n2(e,this.axis),r=Cr(n,0,this.maxValue);return z(e,Se(r,ie(xn(),n)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}BA.className="MaxNorm";le(BA);class WA extends gf{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return Y(()=>Se(e,ie(xn(),n2(e,this.axis))))}getConfig(){return{axis:this.axis}}}WA.className="UnitNorm";le(WA);class UA extends gf{apply(e){return Ka(e)}}UA.className="NonNeg";le(UA);class VA extends gf{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return Y(()=>{const n=n2(e,this.axis),r=ie(z(this.rate,Cr(n,this.minValue,this.maxValue)),z(1-this.rate,n));return z(e,Se(r,ie(xn(),n)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}VA.className="MinMaxNorm";le(VA);const kN={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function kn(t){return Gk(t)}function SN(t,e={}){return hf(t,os.getMap().classNameMap,e,"constraint")}function Sn(t){if(t==null)return null;if(typeof t=="string"){const e={className:t in kN?kN[t]:t,config:{}};return SN(e)}else return t instanceof gf?t:SN(t)}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/async function Ro(t){if(t==null)return;const e=[],n=[],r=[];for(const s in t){const a=t[s];if(typeof a!="number"){const i=a;e.push(i.data()),n.push(s),r.push(i)}}if(e.length>0){const s=await Promise.all(e);for(let a=0;a<s.length;++a)t[n[a]]=s[a][0];Pe(r)}}function jA(t){if(t!=null)for(const e in t){const n=t[e];typeof n!="number"&&n.dispose()}}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/var IN;(function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"})(IN||(IN={}));const Cq=125;class Fd{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,n){}async onEpochEnd(e,n){}async onBatchBegin(e,n){}async onBatchEnd(e,n){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class Tq{constructor(e,n=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=n}append(e){this.callbacks.push(e)}setParams(e){for(const n of this.callbacks)n.setParams(e)}setModel(e){for(const n of this.callbacks)n.setModel(e)}async onEpochBegin(e,n){n==null&&(n={});for(const r of this.callbacks)await r.onEpochBegin(e,n)}async onEpochEnd(e,n){n==null&&(n={});for(const r of this.callbacks)await r.onEpochEnd(e,n)}async onBatchBegin(e,n){n==null&&(n={});for(const r of this.callbacks)await r.onBatchBegin(e,n)}async onBatchEnd(e,n){n==null&&(n={});for(const r of this.callbacks)await r.onBatchEnd(e,n)}async onTrainBegin(e){e==null&&(e={});for(const n of this.callbacks)await n.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const n of this.callbacks)await n.onTrainEnd(e)}}class Eq extends Fd{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,n){n==null&&(n={});const r=n.size==null?0:n.size;this.seen+=r;for(const s in n){const a=n[s];if(typeof a=="number")this.totals.hasOwnProperty(s)||(this.totals[s]=0),this.totals[s]=this.totals[s]+a*r;else{let i;s in this.totals?i=this.totals[s]:this.totals[s]=0;const o=Y(()=>ie(this.totals[s],z(a,r)));this.totals[s]=o,i!=null&&i.dispose()}}}async onEpochEnd(e,n){if(n!=null)for(const r of this.params.metrics)this.totals[r]!=null&&(typeof this.totals[r]=="number"?n[r]=this.totals[r]/this.seen:Y(()=>{const s=z(Se(1,this.seen),this.totals[r]);n[r]=s,this.totals[r].dispose(),An(n[r])}))}}class $q extends Fd{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,n){n==null&&(n={}),this.epoch.push(e);for(const r in n)this.history[r]==null&&(this.history[r]=[]),this.history[r].push(n[r])}async syncData(){const e=[],n=[],r=[];for(const a in this.history){const i=this.history[a];for(let o=0;o<i.length;++o)if(typeof i[o]!="number"){const l=i[o];e.push(l.data()),n.push(a),r.push(o)}}const s=await Promise.all(e);for(let a=0;a<s.length;++a)this.history[n[a]][r[a]].dispose(),this.history[n[a]][r[a]]=s[a][0]}}class Rq extends Fd{constructor(e,n){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Y3,this.yieldEvery=n||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=Cq),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");rg(this.yieldEvery)&&(this.maybeWait=VK(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,n,r){const s=[];this.yield!=null&&(await Ro(r),s.push(this.yield(e,n,r))),s.push(this.nextFrameFunc()),await Promise.all(s)}async onEpochBegin(e,n){this.currentEpoch=e,this.epochBegin!=null&&(await Ro(n),await this.epochBegin(e,n))}async onEpochEnd(e,n){const r=[];this.epochEnd!=null&&(await Ro(n),r.push(this.epochEnd(e,n))),this.yieldEvery==="epoch"&&r.push(this.nextFrameFunc()),await Promise.all(r)}async onBatchBegin(e,n){this.batchBegin!=null&&(await Ro(n),await this.batchBegin(e,n))}async onBatchEnd(e,n){const r=[];this.batchEnd!=null&&(await Ro(n),r.push(this.batchEnd(e,n))),this.yieldEvery==="batch"?r.push(this.nextFrameFunc()):rg(this.yieldEvery)&&r.push(this.maybeWait(this.currentEpoch,e,n)),await Promise.all(r)}async onTrainBegin(e){this.trainBegin!=null&&(await Ro(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Ro(e),await this.trainEnd(e))}}function GA(t,e){return t==null&&(t={}),t instanceof Fd?[t]:Array.isArray(t)&&t[0]instanceof Fd?t:kt(t).map(n=>new Rq(n,e))}class Ts{constructor(){}static registerCallbackConstructor(e,n){R(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),Ts.checkForDuplicate(n),Ts.constructors[e]==null&&(Ts.constructors[e]=[]),Ts.constructors[e].push(n)}static checkForDuplicate(e){for(const n in Ts.constructors)Ts.constructors[+n].forEach(r=>{if(r===e)throw new H("Duplicate callback constructor.")})}static clear(){Ts.constructors={}}static createCallbacks(e){const n=[];for(const r in Ts.constructors){const s=+r;e>=s&&n.push(...Ts.constructors[s])}return n.map(r=>new r)}}Ts.constructors={};function HA(t,e,n,r,s,a,i,o,l){const u=new $q,c=[new Eq,...Ts.createCallbacks(e)];t!=null&&c.push(...t),c.push(u);const h=new Tq(c);return h.setParams({epochs:n,initialEpoch:r,samples:s,steps:a,batchSize:i,verbose:e,doValidation:o,metrics:l}),{callbackList:h,history:u}}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function ua(t,e={},n=!1){return hf(t,os.getMap().classNameMap,e,"layer",n)}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function xg(t,e){return Y(()=>{t.dtype!=="float32"&&(t=me(t,"float32"));const n=Re(pf(t),e,!0),r=Gc(n.shape,xn()),s=Vn(wi(n,r));return Se(t,s)})}function r0(t,e){return Y(()=>Qt(pf(Ie(e,t)),-1))}function r2(t,e){return Y(()=>Qt(yn(Ie(e,t)),-1))}function s2(t,e){return Y(()=>{const n=Ie(t,e),r=Cr(yn(t),xn(),Number.MAX_VALUE),s=yn(Se(n,r));return z(100,Qt(s,-1))})}function Aq(t,e){return Y(()=>{const n=Cr(e,xn(),Number.MAX_VALUE),r=gs(ie(1,n)),s=Cr(t,xn(),Number.MAX_VALUE),a=gs(ie(1,s));return Qt(pf(Ie(r,a)),-1)})}function _q(t,e){return Y(()=>{const n=wi(0,Ie(1,z(t,e)));return Qt(pf(n),-1)})}function Fq(t,e){return Y(()=>{const n=wi(0,Ie(1,z(t,e)));return Qt(n,-1)})}function Oq(t,e){return Y(()=>{const n=Re(z(t,e),-1),r=zs(z(Ie(1,t),e),-1);return wi(0,ie(1,Ie(r,n)))})}function Dq(t,e){return Y(()=>{const n=Math.log(2),r=Ie(e,t),s=Ie(ie(r,Hc(z(-2,r))),n);return Qt(s,-1)})}function Od(t,e,n=!1){return Y(()=>{if(n)e=kb(e);else{const r=Re(e,e.shape.length-1,!0);e=Se(e,r)}return e=Cr(e,xn(),1-xn()),Lt(Re(z(me(t,"float32"),gs(e)),e.shape.length-1))})}function vg(t,e,n=!1){return Y(()=>{const r=me(sf(tq(t)),"int32");e=Cr(e,xn(),1-xn());const s=e.shape,a=j(fk(r,s[s.length-1]),s);return Od(a,e,n)})}function Mq(t,e){if(!Je(t.shape,e.shape))throw new H(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(e.shape)}`);return Y(()=>{const n=Ka(e),r=Lt(yn(e));return ie(Ie(n,z(e,t)),db(pr(r)))})}function s0(t,e){return Y(()=>{let n;return n=Cr(e,xn(),1-xn()),n=gs(Se(n,Ie(1,n))),Qt(Mq(t,n),-1)})}function Pq(t,e){return Y(()=>{const n=Cr(t,xn(),1),r=Cr(e,xn(),1);return Re(z(t,gs(Se(n,r))),-1)})}function Lq(t,e){return Y(()=>{const n=gs(ie(xn(),e));return Qt(Ie(e,z(t,n)),-1)})}function KA(t,e){return Y(()=>{const n=xg(t,-1),r=xg(e,-1),s=z(n,r);return Lt(Re(s,-1))})}const wg={meanSquaredError:r0,meanAbsoluteError:r2,meanAbsolutePercentageError:s2,meanSquaredLogarithmicError:Aq,squaredHinge:_q,hinge:Fq,categoricalHinge:Oq,logcosh:Dq,categoricalCrossentropy:Od,sparseCategoricalCrossentropy:vg,binaryCrossentropy:s0,kullbackLeiblerDivergence:Pq,poisson:Lq,cosineProximity:KA};function kx(t){if(typeof t=="string"){if(t in wg)return wg[t];let e=`Unknown loss ${t}`;throw t.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new H(e)}else return t}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function qA(t,e){return Y(()=>{const n=z(.5,ys(e)),r=yi(_r(e,n),t.dtype);return Qt(ms(t,r),-1)})}function XA(t,e){return Y(()=>yi(ms(hl(t,-1),hl(e,-1)),"float32"))}function YA(t,e){return Y(()=>me(Re(da(ms(t,1),ms(e,1))),"float32"))}function zq(t,e){return Y(()=>me(Re(da(ms(t,1),ms(e,0))),"float32"))}function Bq(t,e){return Y(()=>me(Re(da(ms(t,0),ms(e,1))),"float32"))}function Wq(t,e){return Y(()=>{const n=YA(t,e),r=Bq(t,e),s=ie(n,r);return me(Un(_r(s,0),Se(n,s),0),"float32")})}function jke(t,e){return Y(()=>{const n=YA(t,e),r=zq(t,e),s=ie(n,r);return me(Un(_r(s,0),Se(n,s),0),"float32")})}function Uq(t,e){return s0(t,e)}function Vq(t,e){return t.rank===e.rank&&(t=yt(t,[t.rank-1])),e=hl(e,-1),e.dtype!==t.dtype&&(e=me(e,t.dtype)),me(ms(t,e),"float32")}function Gke(t,e){return Y(()=>{const n=t.sub(e).square().sum(),r=t.sub(t.mean()).square().sum();return Me(1).sub(n.div(r))})}const jq=r0,Gq=r0,Hq=r2,Kq=r2,qq=s2,Xq=s2,QA=Od,Yq=KA,ZA=vg,kg={binaryAccuracy:qA,categoricalAccuracy:XA,precision:Wq,categoricalCrossentropy:QA,sparseCategoricalCrossentropy:ZA,mse:jq,MSE:Gq,mae:Hq,MAE:Kq,mape:qq,MAPE:Xq,cosine:Yq};function Qq(t){if(typeof t=="string"&&t in kg)return kg[t];if(typeof t!="string"&&t!=null)return t;throw new H(`Unknown metric ${t}`)}function am(t){if(Fa(t!==null,`Unknown LossOrMetricFn ${t}`),typeof t=="string")return t;{let e;for(const n of Object.keys(wg))if(wg[n]===t){e=n;break}if(e!==void 0)return e;for(const n of Object.keys(kg))if(kg[n]===t){e=n;break}return e!==void 0?e:t.name}}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function Zq(t){const e={Adagrad:()=>ql.adagrad(.01),Adadelta:()=>ql.adadelta(1,.95,xn()),Adam:()=>ql.adam(.001,.9,.999,xn()),Adamax:()=>ql.adamax(.002,.9,.999,xn(),0),RMSProp:()=>ql.rmsprop(.001,.9,0,xn()),SGD:()=>ql.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,t in e)return e[t]();throw new H(`Unknown Optimizer ${t}`)}/**
* @license
* Copyright 2019 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/const NN=1*1024*1024;function CN(t,e,n=!1){if(t==null||typeof t!="object"||Object.getPrototypeOf(t)!==Object.prototype||!sv(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const r=JSON.stringify(t);r.length>NN&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${NN}.`)}}function sv(t){if(t===null)return!0;if(typeof t=="object")if(Object.getPrototypeOf(t)===Object.prototype){const e=Object.keys(t);for(const n of e)if(typeof n!="string"||!sv(t[n]))return!1;return!0}else if(Array.isArray(t)){for(const e of t)if(!sv(e))return!1;return!0}else return!1;else{const e=typeof t;return e==="string"||e==="number"||e==="boolean"}}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function Jq(t,e,n,r=console.log){const s=t7(t),a=["Layer (type)","Input Shape","Output shape","Param #"];s?(e=e||90,n=n||[.32,.61,.89,1]):(e=e||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(c=>Math.floor(e*c)));let i;if(!s){a.push("Receives inputs"),i=[];for(const c in t.nodesByDepth)i.push(...t.nodesByDepth[c])}r("_".repeat(e)),Sg(a,n,r),r("=".repeat(e));const o=t.layers;for(let c=0;c<o.length;++c)s?n7(o[c],n,r):r7(o[c],n,i,r),r((c===o.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();const l=e7(t),u=gg(t.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(e))}function e7(t){let e;return t.collectedTrainableWeights!=null?e=gg(t.collectedTrainableWeights):e=gg(t.trainableWeights),e}function t7(t){let e=!0;const n=[],r=[];for(const s in t.nodesByDepth)n.push(t.nodesByDepth[s]);for(const s of n){if(s.length>1||s.length===1&&s[0].inboundLayers.length>1){e=!1;break}r.push(...s)}if(e)for(const s of t.layers){let a=!1;for(const i of s.inboundNodes)if(r.indexOf(i)!==-1)if(a){e=!1;break}else a=!0;if(!e)break}return e}function Sg(t,e,n=console.log){let r="";for(let s=0;s<t.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=t[s],r=r.slice(0,e[s]),r+=" ".repeat(e[s]-r.length);n(r)}function n7(t,e,n){let r,s;try{s=t.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(t.outputShape)}catch{r="multiple"}const a=t.name,i=t.getClassName(),o=[`${a} (${i})`,s,r,t.countParams().toString()];Sg(o,e,n)}function r7(t,e,n,r){let s,a;try{a=t.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{a="multiple"}try{s=JSON.stringify(t.outputShape)}catch{s="multiple"}const i=[];for(const h of t.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(h)===-1))for(let d=0;d<h.inboundLayers.length;++d){const p=h.inboundLayers[d].name,f=h.nodeIndices[d],m=h.tensorIndices[d];i.push(`${p}[${f}][${m}]`)}const o=t.name,l=t.getClassName(),u=i.length===0?"":i[0],c=[`${o} (${l})`,a,s,t.countParams().toString(),u];Sg(c,e,r);for(let h=1;h<i.length;++h)Sg(["","","","",i[h]],e,r)}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function JA(t,e,n){return(t==="inboundNodes"||t==="outputLayers"||t==="inputLayers")&&e===0&&typeof n=="string"}function Dd(t,e){if(t===null)return null;if(typeof t=="string")return Po(t);if(typeof t=="number"||typeof t=="boolean")return t;if(t instanceof Array){const n=[],r=t.length;for(let s=0;s<r;++s){const a=t[s];JA(e,s,a)?n.push(a):n.push(Dd(a,e))}return n}else{const n={};for(const r of Object.keys(t)){const s=t[r];if(r==="name"&&typeof s=="string")n[r]=s;else{const a=Po(r);n[a]=Dd(s,a)}}return n}}function av(t,e){if(t==null)return null;if(typeof t=="string")return Za(t);if(typeof t=="number"||typeof t=="boolean")return t;if(t instanceof Array){const n=[],r=t.length;for(let s=0;s<r;++s){const a=t[s];JA(e,s,a)?n.push(a):n.push(av(a,e))}return n}else{const n={};for(const r of Object.keys(t)){const s=t[r],a=Za(r);(r==="name"||r==="className")&&typeof s=="string"?n[a]=s:n[a]=av(s,r)}return n}}/** @license See the LICENSE file. */const e_="4.22.0";/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/const s7=t=>{const e=Object.keys(t);if(e.length===0)return!1;const n=e[0].split("/");return!isNaN(parseInt(n[n.length-1],10))};class Js extends at{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const b=this.getClassName().toLowerCase();this.name=e0(b)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],qi(this.inputs).length!==this.inputs.length)throw new H(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);qi(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const v=b.sourceLayer,w=b.nodeIndex,k=b.tensorIndex;this.outputLayers.push(v),this.outputLayersNodeIndices.push(w),this.outputLayersTensorIndices.push(k)}for(const b of this.inputs){const v=b.sourceLayer,w=b.nodeIndex,k=b.tensorIndex;Fa(w===0,"input layer has >1 nodes"),Fa(k===0,"input layer has >1 tensors"),this.inputLayers.push(v),this.inputLayersNodeIndices.push(w),this.inputLayersTensorIndices.push(k)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const v=this.inputLayers[b];if(!(v instanceof mf))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${b} (0-based) originates from layer type ${v.getClassName()}.`);this.inputNames.push(v.name),this.feedInputShapes.push(v.batchInputShape),this.feedInputNames.push(v.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);const n={},r={},s={},a={},i={},o=[],l=(b,v,w,k,N,T)=>{(k==null||N==null||T==null)&&(k=b.sourceLayer,N=b.nodeIndex,T=b.tensorIndex);const E=k.inboundNodes[N];if(w.indexOf(E)!==-1)throw new Ms(`The tensor ${b.name} at layer "${k.name}" is part of a cycle.`);if(v.indexOf(E)!==-1)return;this.containerNodes.add(Js.nodeKey(k,N)),k.id in i||(i[k.id]=Object.keys(i).length),w.indexOf(E)===-1&&w.push(E);const _=E.inboundLayers.length;for(let O=0;O<_;O++){const M=E.inputTensors[O],V=E.inboundLayers[O],W=E.nodeIndices[O],K=E.tensorIndices[O];l(M,v,w,V,W,K)}for(v.push(E);w.indexOf(E)>=0;)w.splice(w.indexOf(E),1);o.push(E)},u=[],c=[];for(const b of this.outputs)l(b,u,c);const h=o.slice().reverse();for(const b of h){r[b.id]=b,b.id in n||(n[b.id]=0);let v=n[b.id];const w=s[b.outboundLayer.id]==null?0:s[b.outboundLayer.id];v=Math.max(v,w),s[b.outboundLayer.id]=v,a[b.outboundLayer.id]=b.outboundLayer,n[b.id]=v;for(let k=0;k<b.inboundLayers.length;k++){const N=b.inboundLayers[k],T=b.nodeIndices[k],E=N.inboundNodes[T],_=n[E.id]==null?0:n[E.id];n[E.id]=Math.max(v+1,_),r[E.id]=E}}const d={};for(const b in n){const v=n[b];v in d||(d[v]=[]),d[v].push(r[b])}const p={};for(const b in s){const v=s[b];v in p||(p[v]=[]),p[v].push(a[b])}let f=Object.keys(p).map(b=>parseInt(b,10)).sort(nm);this.layers=[];for(const b of f){const v=p[b];v.sort((w,k)=>{const N=i[w.id],T=i[k.id];return N<T?-1:N>T?1:0});for(const w of v)w instanceof Js&&this.internalContainerRefs.push(w),this.layers.push(w)}this.layersByDepth=p,f=Object.keys(d).map(b=>parseInt(b,10)).sort(nm);const m=this.inputs.slice(),y=[];for(const b of f)for(const v of d[b]){const w=v.outboundLayer;if(w!=null){for(const k of v.inputTensors)if(m.indexOf(k)===-1)throw new Ms(`Graph disconnected: cannot obtain value for tensor ${k} at layer "${w.name}". The following previous layers were accessed without issue: ${y}`);for(const k of v.outputTensors)m.push(k);y.push(w.name)}}this.nodesByDepth=d;const g=this.layers.map(b=>b.name);for(const b of g){const v=g.filter(w=>w===b).length;if(v!==1)throw new Ms(`The name "${b}" is used ${v} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new n0({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const n of this.layers)e.numDisposedVariables+=n.dispose().numDisposedVariables;for(const n of this.internalContainerRefs)e.numDisposedVariables+=n.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(n=>{n._trainableWeights.forEach(r=>r.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new H("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const n of this.layers)e=e.concat(n.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const n of this.layers)e.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const r of this.layers)n.push(...r.trainableWeights);return n.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,n=!0){const r={};let s=0;const a=s7(e);a&&this.parseWeights(e);for(const o of this.layers)for(const[l,u]of o.weights.entries()){const c=a?`${u.name.split("/").slice(0,-1).join("/")+"/"}${l}`:u.originalName;if(r[c]!=null)throw new H(`Duplicate weight name: ${c}`);r[c]=u,s++}const i=[];for(const o in e){let l=o;if(r[o]==null){const u=o.split("/");l=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(r[l]!=null)i.push([r[l],e[o]]);else if(n)throw new H(`Provided weight data has no target variable: ${o}`);delete r[l]}if(n){const o=[];for(const l in r)o.push(l);if(o.length>0)throw new H(`${o.length} of ${s} weights are not set: ${o}`)}t2(i)}parseWeights(e){for(const n in Object.keys(e)){const r=n.split("/"),s=["vars","layer_checkpoint_dependencies"],a=r.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!s.includes(i)).join("/");a!==n&&(e[a]=e[n],delete e[n])}}updatedConfig(){const e=this.getConfig(),n={};return n.className=this.getClassName(),n.config=e,n.kerasVersion=`tfjs-layers ${e_}`,n.backend="TensorFlow.js",n}toJSON(e,n=!0){const r=av(this.updatedConfig());return n?JSON.stringify(r):r}call(e,n){return Y(()=>{e=kt(e);const r=new Di;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],e[s]);return Mh(this.outputs,r,n)})}computeMask(e,n){return Y(()=>{e=kt(e);let r;return n==null?r=ml(null,e.length):r=kt(n),this.runInternalGraph(e,r)[1]})}computeOutputShape(e){const n=mg(e);if(n.length!==this.inputLayers.length)throw new H(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let o=0;o<n.length;o++){const l=this.inputLayers[o],u=n[o],c=l.name+"_0_0";r[c]=u}const s=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(nm);if(s.length>1)for(const o of s){const l=this.nodesByDepth[o];for(const u of l){const c=u.outboundLayer;if(this.inputLayers.map(m=>m.id).indexOf(c.id)!==-1)continue;const h=[];for(let m=0;m<u.inboundLayers.length;m++){const y=u.inboundLayers[m],g=u.nodeIndices[m],b=u.tensorIndices[m],v=`${y.name}_${g}_${b}`,w=r[v];h.push(w)}const d=c.computeOutputShape(vr(h)),p=mg(d),f=c.inboundNodes.indexOf(u);for(let m=0;m<p.length;m++){const y=`${c.name}_${f}_${m}`;r[y]=p[m]}}}const a=[],i=[];for(let o=0;o<this.outputLayers.length;o++){const l=this.outputLayers[o],u=this.outputLayersNodeIndices[o],c=this.outputLayersTensorIndices[o],h=`${l.name}_${u}_${c}`;i.push(h)}for(let o=0;o<i.length;o++){const l=i[o];Fa(l in r),a.push(r[l])}return vr(a)}runInternalGraph(e,n){n==null&&(n=ml(null,e.length));const r={};for(let l=0;l<this.inputs.length;++l){const u=this.inputs[l],c=e[l],h=n[l];r[u.id]=[c,h]}const s=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(nm);for(const l of s){const u=this.nodesByDepth[l];for(const c of u){const h=c.outboundLayer,d=c.inputTensors,p=c.outputTensors,f=new Array;for(const m of d)m.id in r&&f.push(r[m.id]);if(f.length===d.length){let m={},y,g,b,v;if(c.callArgs!=null&&(m=c.callArgs),f.length===1){const[w,k]=f[0];m.mask==null&&(m.mask=k),b=kt(h.call(w,m)),v=kt(h.computeMask(w,k)),y=[w],g=[k]}else y=f.map(w=>w[0]),g=f.map(w=>w[1]),m.mask==null&&(m.mask=g),b=kt(h.call(y,m)),v=kt(h.computeMask(y,g));if(h.activityRegularizer)throw new et("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let w=0;w<p.length;++w){const k=p[w],N=b[w],T=v[w];r[k.id]=[N,T]}}}}const a=[],i=[],o=[];for(const l of this.outputs){Fa(l.id in r,`Could not compute output ${l.name} : ${l.id}`);const[u,c]=r[l.id];o.push(u.shape),a.push(u),i.push(c)}return[a,i,o]}buildNodeConversionMap(e){const n={};let r;for(const s of this.layers){r=s instanceof Js?1:0;for(let a=0;a<s.inboundNodes.length;a++){const i=Js.nodeKey(s,a);this.containerNodes.has(i)&&(n[i]=r,r+=1)}}return n}getLayer(e,n){if(n!=null)return this.findLayer(n);if(e==null)throw new H("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const r of this.layers)if(r.name===e)return r;throw new H(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new H(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return Y(()=>{const e=[];for(const n of this.layers)for(let r=0;r<n.inboundNodes.length;++r){const s=Js.nodeKey(n,r);this.containerNodes.has(s)&&e.push(...n.calculateLosses())}return e})}getConfig(){const e={name:this.name},n=this.buildNodeConversionMap(this.layers),r=[];for(const i of this.layers){const o=i.getClassName(),l=i.getConfig(),u=[];for(let h=0;h<i.inboundNodes.length;h++){const d=i.inboundNodes[h],p=Js.nodeKey(i,h);let f={};if(this.containerNodes.has(p)){if(d.callArgs)try{JSON.stringify(d.callArgs),f=d.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(d.inboundLayers.length>0){const m=[];for(let y=0;y<d.inboundLayers.length;y++){const g=d.inboundLayers[y],b=d.nodeIndices[y],v=d.tensorIndices[y],w=Js.nodeKey(g,b);let k=n[w];k==null&&(k=0),m.push([g.name,k,v,f])}u.push(m)}}}const c={};c.name=i.name,c.className=o,c.config=l,c.inboundNodes=u,r.push(c)}e.layers=r;const s=[];for(let i=0;i<this.inputLayers.length;i++){const o=this.inputLayers[i],l=this.inputLayersNodeIndices[i],u=Js.nodeKey(o,l);if(!this.containerNodes.has(u))continue;let c=n[u];c==null&&(c=0);const h=this.inputLayersTensorIndices[i];s.push([o.name,c,h])}e.inputLayers=s;const a=[];for(let i=0;i<this.outputLayers.length;i++){const o=this.outputLayers[i],l=this.outputLayersNodeIndices[i],u=Js.nodeKey(o,l);if(!this.containerNodes.has(u))continue;let c=n[u];c==null&&(c=0);const h=this.outputLayersTensorIndices[i];a.push([o.name,c,h])}return e.outputLayers=a,e}static fromConfig(e,n,r={},s=!1){const a={},i={};function o(y,g){y.name in i?i[y.name].push(g):i[y.name]=[g]}function l(y,g){const b=[];let v;for(const w of g){const k=w[0],N=w[1],T=w[2];if(v=w[3]==null?{}:w[3],!(k in a)){o(y,g);return}const E=a[k];if(E.inboundNodes.length<=N){o(y,g);return}const _=E.inboundNodes[N];b.push(_.outputTensors[T])}b.length>0&&y.apply(vr(b),v)}function u(y){const g=y.name,b=ua(y,n.customObjects!=null?n.customObjects:{});b.setFastWeightInitDuringBuild(s),a[g]=b,y.inboundNodes.forEach(v=>{if(!(v instanceof Array))throw new H(`Corrupted configuration, expected array for nodeData: ${v}`);o(b,v)})}const c=n.name,h=n.layers;for(const y of h)u(y);for(;!UK(i);)for(const y of h){const g=a[y.name];if(g.name in i){const b=i[g.name];delete i[g.name];for(const v of b)l(g,v)}}const d=[],p=[],f=n.inputLayers;for(const y of f){const g=y[0],b=y[1],v=y[2];Fa(g in a);const w=a[g].inboundNodes[b].outputTensors;d.push(w[v])}const m=n.outputLayers;for(const y of m){const g=y[0],b=y[1],v=y[2];Fa(g in a);const w=a[g].inboundNodes[b].outputTensors;p.push(w[v])}return new e({inputs:d,outputs:p,name:c})}get stateful(){if(this._stateful)throw new H("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){Y(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function a7(t,e,n){const r=e.length;if(t==null||Array.isArray(t)&&t.length===0)return e.map(s=>null);if(r===1)return Array.isArray(t)&&t.length===1?t:typeof t=="object"&&e[0]in t?[t[e[0]]]:[t];if(Array.isArray(t)){if(t.length!==r)throw new Error(`Provided ${n} is an array of ${t.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return t}else if(typeof t=="object"&&Object.keys(t).length>0&&typeof t[Object.keys(t)[0]]=="object"){const s=[];return e.forEach(a=>{a in t?s.push(t[a]):s.push(null)}),s}else throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${e} keys. Provided ${n} not understood: ${JSON.stringify(t)}`)}function t_(t,e){return a7(t,e,"classWeight")}async function n_(t,e,n,r){if(n!=null){const s=Y(()=>{if(t.shape.length===1)return ii(t);if(t.shape.length===2){if(t.shape[1]>1)return hl(t,1);if(t.shape[1]===1)return j(t,[t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),a=Array.from(await s.data());Pe(s);const i=[];return a.forEach(o=>{if(n[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);i.push(n[o])}),dn(i,"float32")}else return null}function i7(t,e){return z(t,e)}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/const o7=32;function r_(t,e){let n,r;const s=e;n=s.xs,r=s.ys,R(n!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const a=TN("input",t.inputNames,n),i=TN("output",t.outputNames,r),o=a[0].shape[0];R(a.length===t.inputs.length,()=>`LayersModel has ${t.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(t.inputNames)})`),R(i.length===t.outputs.length,()=>`LayersModel has ${t.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(t.outputNames)})`);for(let l=0;l<a.length;l++)R(a[l].shape[0]===o,()=>`Batch size mismatch: input ${t.inputNames[l]} has ${a[l].shape[0]}; expected  ${o} based on input ${t.inputNames[0]}.`);for(let l=0;l<i.length;l++)R(i[l].shape[0]===o,()=>`Batch size mismatch: output ${t.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${t.inputNames[0]}.`);return{xs:a,ys:i}}function TN(t,e,n){if(n instanceof st)return[n];if(Array.isArray(n))return R(n.length===e.length,()=>`Received an array of ${n.length} Tensors, but expected ${e.length} to match the ${t} keys ${e}.`),n;{const r=[];for(const s of e){if(n[s]==null)throw new H(`The feature data generated by the dataset lacks the required ${t} key '${s}'.`);r.push(n[s])}return r}}function l7(t){if(t.length===3)throw new et("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}async function u7(t,e,n){const r=n.batchesPerEpoch!=null;if(R(t.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),R(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),R(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),R(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),R(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const s=n.validationData!=null;let a,i;if(s)if(EN(n.validationData))R(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{const y=l7(n.validationData);a=y.xs,i=y.ys}const o=t.makeTrainFunction(),l=t.getDedupedMetricsNames();let u;s?u=l.slice().concat(l.map(y=>"val_"+y)):u=l.slice();const c=GA(n.callbacks,n.yieldEvery),h=n.verbose==null?1:n.verbose,{callbackList:d,history:p}=HA(c,h,n.epochs,null,null,c7(e,n),null,s,u);d.setModel(t),t.history=p,await d.onTrainBegin(),t.stopTraining_=!1;let f=n.initialEpoch==null?0:n.initialEpoch,m=await e.iterator();for(;f<n.epochs;){const y={};await d.onEpochBegin(f);let g=0,b=0;for(r||(m=await e.iterator());!r||g<n.batchesPerEpoch;){const v=await m.next();if(r&&v.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${g} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(v.value!=null){const{xs:w,ys:k}=r_(t,v.value),N={};N.batch=b,N.size=w[0].shape[0],await d.onBatchBegin(b,N);const T=[];if(n.classWeight!=null){const O=t_(n.classWeight,t.outputNames);for(let M=0;M<O.length;++M)T.push(await n_(k[M],null,O[M]))}const E=w.concat(k).concat(T),_=o(E);Pe(E);for(let O=0;O<l.length;++O){const M=l[O],V=_[O];N[M]=V,An(V)}await d.onBatchEnd(b,N),jA(N),b++,g++}if(r?g>=n.batchesPerEpoch:v.done){if(s){let w;EN(n.validationData)?w=kt(await t.evaluateDataset(n.validationData,{batches:n.validationBatches})):w=kt(t.evaluate(a,i,{batchSize:n.validationBatchSize==null?o7:n.validationBatchSize,verbose:0}));for(let k=0;k<t.metricsNames.length;++k)y[`val_${t.metricsNames[k]}`]=w[k]}break}if(t.stopTraining_)break}if(await d.onEpochEnd(f,y),f++,t.stopTraining_)break}return await d.onTrainEnd(),await t.history.syncData(),t.history}finally{t.isTraining=!1}}function c7(t,e){let n=null;return e.batchesPerEpoch!=null?n=e.batchesPerEpoch:Number.isFinite(t.size)&&(n=t.size),n}function EN(t){return typeof t.iterator=="function"}function h7(t){return typeof t.next=="function"}async function d7(t,e,n){n=n||{};const r=n.batches!=null,s=t.testFunction;let a=[];if(n.verbose>0)throw new et("Verbose mode is not implemented yet.");R(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);const i=h7(e)?e:await e.iterator();let o=0,l=0;for(;!r||l<n.batches;){const u=await i.next();if(a=Y(()=>{if(u.value){const{xs:c,ys:h}=r_(t,u.value),d=c.concat(h),p=Y(()=>s(d));if(Pe(d),l===0)for(let m=0;m<p.length;++m)a.push(Me(0));const f=d[0].shape[0];for(let m=0;m<p.length;++m){const y=p[m],g=a[m];a[m]=Y(()=>ie(a[m],z(f,y))),l>0&&Pe(g)}Pe(p),o+=f,++l}return a}),u.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<a.length;++u){const c=a[u];a[u]=Se(a[u],o),Pe(c)}return vr(a)}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function Sx(t){R(t>0&&Number.isInteger(t),()=>`batchSize is required to be a positive integer, but got ${t}`)}function Ch(t,e,n){return t==null?[null]:Array.isArray(t)?t.map(r=>Jo(r,e,n-e)):Jo(t,e,n-e)}function iv(t,e){return Y(()=>t==null?null:Array.isArray(t)?t.map(n=>iv(n,e)):RA(t,e.dtype==="int32"?e:me(e,"int32")))}function Ix(t,e){const n=[];let r=0,s=null;for(;r<t;)s=r+e,s>=t&&(s=t),n.push([r,s]),r=s;return n}function s_(t){const e=[];t instanceof st&&(t=[t]);for(let n=0;n<t.length;++n){const r=t[n];if(r.rank===1)e.push(df(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(r)}}return e}function Zs(t,e){if(t==null)return;const n=[];if(e instanceof st)n.push(e.id);else if(Array.isArray(e))e.forEach(s=>n.push(s.id));else if(e!=null)for(const s in e){const a=e[s];n.push(a.id)}const r=[];if(t instanceof st)n.indexOf(t.id)===-1&&r.push(t);else if(Array.isArray(t))t.forEach(s=>{n.indexOf(s.id)===-1&&r.push(s)});else if(t!=null)for(const s in t){const a=t[s];n.indexOf(a.id)===-1&&r.push(a)}r.forEach(s=>{s.isDisposed||s.dispose()})}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function p7(t){return t instanceof st}function ov(t){return Array.isArray(t)}function $N(t){return!p7(t)&&!ov(t)}function RN(t,e,n,r=!0,s=""){if(e==null||e.length===0){if(t!=null){let i=!1;if(ov(t)&&t.length>0)i=!0;else if($N(t)){for(const o in t)if(t.hasOwnProperty(o)){i=!0;break}}else i=!0;if(i)throw new H(`Error when checking model ${s} expected no data, but got ${t}`)}return[]}if(t==null)return e.map(i=>null);let a;if($N(t)){t=t,a=[];for(const i of e){if(t[i]==null)throw new H(`No data provided for "${i}". Need data for each key in: ${e}`);a.push(t[i])}}else if(ov(t)){if(t=t,t.length!==e.length)throw new H(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${t}`);a=t}else{if(t=t,e.length>1)throw new H(`The model ${s} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${t.shape}`);a=[t]}if(a=s_(a),n!=null)for(let i=0;i<e.length;++i){if(n[i]==null)continue;const o=a[i];if(o.shape.length!==n[i].length)throw new H(`Error when checking ${s}: expected ${e[i]} to have ${n[i].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<n[i].length;++l){if(l===0&&!r)continue;const u=o.shape[l],c=n[i][l];if(c!=null&&c>=0&&u!==c)throw new H(`${s} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${s} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return a}function f7(t,e,n){const r=qi(t.map(a=>a.shape[0]));r.sort();const s=qi(e.map(a=>a.shape[0]));if(s.sort(),r.length>1)throw new H(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(a=>a.shape))}`);if(s.length>1)throw new H(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(a=>a.shape))}`);if(r.length>0&&s.length>0&&!Je(r,s))throw new H(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}function m7(t,e,n){const r=[r0,s0,Od];for(let s=0;s<t.length;++s){const a=t[s],i=e[s],o=n[s];if(i!=null){if(i===Od&&a.shape[a.shape.length-1]===1)throw new H(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(i)!==-1){const l=a.shape.slice(1),u=o.slice(1);for(let c=0;c<l.length;++c){const h=l[c],d=u[c];if(d!=null&&h!==d)throw new H(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function AN(t,e,n,r=!0,s=""){let a;if(Array.isArray(t)){if(t.length!==e.length)throw new H(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${t.length} Tensors(s).`);a=t}else{if(e.length>1)throw new H(`The model expects ${e.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(t.shape)}.`);a=[t]}if(n!=null)for(let i=0;i<e.length;++i){if(n[i]==null)continue;const o=a[i];if(o.shape.length!==n[i].length)throw new H(`Error when checking ${s}: expected ${e[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<n[i].length;++l){if(l===0&&!r)continue;const u=o.shape[l],c=n[i][l];if(c!=null&&c!==u)throw new H(`Error when checking ${s}: expected ${e[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function g7(t,e){if(t==null||Array.isArray(t)&&t.length===0)return e.map(r=>[]);let n;if(typeof t=="string"||typeof t=="function")n=[t];else if(Array.isArray(t)||typeof t=="object")n=t;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${t}`);if(Array.isArray(n))return e.map(r=>n);{const r=[];for(const s of e){let a=n.hasOwnProperty(s)?n[s]:[];Array.isArray(a)||(a=[a]),r.push(a)}return r}}const y7="layers-model";class Nu extends Js{constructor(e){super(e),this.isTraining=!1}summary(e,n,r=console.log){if(!this.built)throw new H("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");Jq(this,e,n,r)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=Zq(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof wo))throw new H("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let n=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const i in e.loss)if(this.outputNames.indexOf(i)===-1)throw new H(`Unknown entry in loss dictionary: "${i}". Only expected the following keys: ${this.outputNames}`);for(const i of this.outputNames)e.loss[i]==null&&console.warn(`Output "${i}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${i} during training`),n.push(kx(e.loss[i]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new H(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);n=e.loss.map(i=>kx(i))}else{const i=kx(e.loss);this.outputs.forEach(o=>{n.push(i)})}this.lossFunctions=n,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){const o=this.internalOutputShapes[i],l=this.outputNames[i];this.feedOutputNames.push(l),this.feedOutputShapes.push(o),this.feedLossFns.push(this.lossFunctions[i])}const r=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Zo("loss",()=>{for(let i=0;i<this.outputs.length;++i){if(r.indexOf(i)!==-1)continue;const o=this.lossFunctions[i];this.outputs.length>1&&(this.metricsTensors.push([o,i]),this.metricsNames.push(this.outputNames[i]+"_loss"))}});const s=g7(e.metrics,this.outputNames),a=(i,o,l)=>{this.outputNames.length>1&&(o=this.outputNames[i]+"_"+o),this.metricsNames.push(o),this.metricsTensors.push([l,i])};Zo("metric",()=>{for(let i=0;i<this.outputs.length;++i){if(r.indexOf(i)!==-1)continue;const o=s[i];(l=>{const u="";let c,h,d;for(const p of l){if(typeof p=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(p)!==-1){const m=this.internalOutputShapes[i];m[m.length-1]===1||this.lossFunctions[i]===s0?["accuracy","acc"].indexOf(p)!==-1?h=qA:["crossentropy","ce"].indexOf(p)!==-1&&(h=Uq):this.lossFunctions[i]===vg?["accuracy","acc"].indexOf(p)!==-1?h=Vq:["crossentropy","ce"].indexOf(p)!==-1&&(h=ZA):["accuracy","acc"].indexOf(p)!==-1?h=XA:["crossentropy","ce"].indexOf(p)!==-1&&(h=QA);let y;["accuracy","acc"].indexOf(p)!==-1?y="acc":["crossentropy","ce"].indexOf(p)!==-1&&(y="ce"),d=h,c=u+y}else d=Qq(p),c=u+am(p);let f;Zo(c,()=>{f=d}),a(i,c,f)}})(o)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,n,r={}){const s=r.batchSize==null?32:r.batchSize;Sx(s);const a=this.standardizeUserDataXY(e,n,!0,s);try{const i=a[0].concat(a[1]);this.makeTestFunction();const o=this.testFunction,l=this.testLoop(o,i,s,r.verbose,r.steps);return vr(l)}finally{Zs(a[0],e),Zs(a[1],n)}}async evaluateDataset(e,n){return this.makeTestFunction(),d7(this,e,n)}checkNumSamples(e,n,r,s="steps"){let a;if(r!=null){if(a=null,n!=null)throw new H(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${n}`)}else if(e!=null)Array.isArray(e)?a=e[0].shape[0]:a=e.shape[0];else throw new H(`Either the input data should have a defined shape, or ${s} shoud be specified.`);return a}execute(e,n){if(Array.isArray(n)&&n.length===0)throw new H("`outputs` is an empty Array, which is not allowed.");const r=Array.isArray(n),s=r?n:[n],a=this.retrieveSymbolicTensors(s),i=new Di;if(e instanceof st&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new H(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)i.add(this.inputs[l],e[l])}else for(const l of this.inputs){const u=e[l.name];if(u==null)throw new H(`No value is provided for the model's input ${l.name}`);i.add(l,u)}const o=Mh(a,i);return r?o:o[0]}retrieveSymbolicTensors(e){const n=ml(null,e.length);let r=e.length;for(const s of this.layers){const a=Array.isArray(s.output)?s.output:[s.output],i=a.map(o=>o.name);for(let o=0;o<e.length;++o){const l=i.indexOf(e[o]);if(l!==-1&&(n[o]=a[l],r--),r===0)break}if(r===0)break}if(r>0){const s=[];throw n.forEach((a,i)=>{a==null&&s.push(e[i])}),new H(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(s)}`)}return n}predictLoop(e,n=32,r=!1){return Y(()=>{const s=this.checkNumSamples(e);if(r)throw new et("Verbose predictLoop() is not implemented yet.");const a=Ix(s,n),i=this.outputs.map(o=>[]);for(let o=0;o<a.length;++o)Y(()=>{const l=a[o][0],u=a[o][1],c=Ch(e,l,u),h=[];if(Array.isArray(c))for(let p=0;p<c.length;++p)h.push({key:this.inputs[p],value:c[p]});else h.push({key:this.inputs[0],value:c});const d=new Di(h);return Mh(this.outputs,d)}).forEach((l,u)=>i[u].push(l));return vr(i.map(o=>qt(o,0)))})}predict(e,n={}){const r=s_(e);AN(r,this.inputNames,this.feedInputShapes,!1);try{const s=n.batchSize==null?32:n.batchSize;return Sx(s),this.predictLoop(r,s)}finally{Zs(r,e)}}predictOnBatch(e){AN(e,this.inputNames,this.feedInputShapes,!0);const n=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,n)}standardizeUserDataXY(e,n,r=!0,s){if(this.optimizer_==null)throw new Ms("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const a=[];for(let i=0;i<this.feedOutputShapes.length;++i){const o=this.feedOutputShapes[i];this.feedLossFns[i]===vg?a.push(o.slice(0,o.length-1).concat([1])):a.push(o)}if(e=RN(e,this.feedInputNames,this.feedInputShapes,!1,"input"),n=RN(n,this.feedOutputNames,a,!1,"target"),f7(e,n),m7(n,this.feedLossFns,this.feedOutputShapes),this.stateful&&s!=null&&s>0&&e[0].shape[0]%s!==0)throw new H(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${e[0].shape[0]} sample(s).`);return[e,n]}async standardizeUserData(e,n,r,s,a=!0,i){const[o,l]=this.standardizeUserDataXY(e,n,a,i);if(r!=null)throw new Error("sample weight is not supported yet.");let u=null;if(s!=null){const c=t_(s,this.outputNames);u=[];for(let h=0;h<c.length;++h)u.push(await n_(l[h],null,c[h]))}return[o,l,u]}testLoop(e,n,r,s=0,a){return Y(()=>{const i=this.checkNumSamples(n,r,a,"steps"),o=[];if(s>0)throw new et("Verbose mode is not implemented yet.");if(a!=null)throw new et("steps mode in testLoop() is not implemented yet");{const l=Ix(i,r),u=dn(ga(0,i));for(let c=0;c<l.length;++c){const h=l[c][0],d=l[c][1],p=Jo(u,h,d-h),f=iv(n,p),m=e(f);if(c===0)for(let y=0;y<m.length;++y)o.push(Me(0));for(let y=0;y<m.length;++y){const g=m[y];o[y]=ie(o[y],z(d-h,g))}}for(let c=0;c<o.length;++c)o[c]=Se(o[c],i)}return o})}getDedupedMetricsNames(){const e=this.metricsNames,n=[];for(let r=0;r<e.length;++r){const s=e[r];let a=s;if(mN(e,s)>1){const i=mN(e.slice(0,r),s);a+=`_${i}`}n.push(a)}return n}makeTrainFunction(){return e=>{const n=[],r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),i=[],o=()=>{const u=[];for(let p=0;p<this.inputs.length;++p)u.push({key:this.inputs[p],value:r[p]});const c=new Di(u),h=Mh(this.outputs,c,{training:!0});let d;for(let p=0;p<this.lossFunctions.length;++p){const f=this.lossFunctions[p];let m=f(s[p],h[p]);a[p]!=null&&(m=i7(m,a[p]));const y=Qt(m);n.push(y),p===0?d=m:d=ie(d,m)}for(let p=0;p<this.metricsTensors.length;++p){let f;if(this.outputs.length>1&&p<this.outputs.length)f=n[p];else{const m=this.metricsTensors[p][0],y=this.metricsTensors[p][1];f=Qt(m(s[y],h[y]))}An(f),i.push(f)}return d=Qt(d),this.calculateLosses().forEach(p=>{d=ie(d,p)}),d},l=this.collectedTrainableWeights.map(u=>u.read());return[this.optimizer_.minimize(o,!0,l)].concat(i)}}makeTestFunction(){this.testFunction=e=>Y(()=>{const n=[];let r;const s=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let u=0;u<this.inputs.length;++u)i.push({key:this.inputs[u],value:s[u]});const o=new Di(i),l=Mh(this.outputs,o);for(let u=0;u<this.lossFunctions.length;++u){const c=this.lossFunctions[u],h=Qt(c(a[u],l[u]));u===0?r=h:r=ie(r,h),n.push(r)}for(let u=0;u<this.metricsTensors.length;++u){const c=this.metricsTensors[u][0],h=this.metricsTensors[u][1],d=Qt(c(a[h],l[h]));n.push(d)}return n})}async fit(e,n,r={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let s,a,i,o,l,u,c,h,d;try{const p=r.batchSize==null?32:r.batchSize;Sx(p);const f=await this.standardizeUserData(e,n,r.sampleWeight,r.classWeight,!1,p);s=f[0],a=f[1],d=f[2];let m=!1,y;if(r.validationData!=null&&r.validationData.length>0){if(m=!0,r.validationData.length===2)l=r.validationData[0],u=r.validationData[1];else throw r.validationData.length===3?new et("validationData including sample weights is not supported yet."):new H(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);const T=await this.standardizeUserData(l,u,null,null,!0,p);c=T[0],h=T[1],y=c.concat(h)}else if(r.validationSplit!=null&&r.validationSplit>0&&r.validationSplit<1){m=!0;const T=Math.floor(s[0].shape[0]*(1-r.validationSplit)),E=s[0].shape[0];c=Ch(s,T,E),i=s,s=Ch(s,0,T),h=Ch(a,T,E),o=a,a=Ch(a,0,T),y=c.concat(h)}else r.validationSteps!=null&&(m=!0);const g=s.concat(a).concat(d);this.checkTrainableWeightsConsistency();const b=this.makeTrainFunction(),v=this.getDedupedMetricsNames();let w,k;m?(this.makeTestFunction(),w=this.testFunction,k=v.slice().concat(v.map(T=>"val_"+T))):(w=null,y=[],k=v.slice());const N=GA(r.callbacks,r.yieldEvery);return await this.fitLoop(b,g,v,p,r.epochs,r.verbose,N,w,y,r.shuffle,k,r.initialEpoch,null,null)}finally{this.isTraining=!1,Zs(s,e),Zs(a,n),Zs(i,e),Zs(o,n),Zs(c,l),Zs(h,u),d!=null&&Pe(d)}}async fitLoop(e,n,r,s,a,i,o,l,u,c,h,d,p,f){s==null&&(s=32),a==null&&(a=1),c==null&&(c=!0),d==null&&(d=0);let m=!1;if(l!=null&&u!=null&&(m=!0),f!=null&&(m=!0,p==null))throw new H("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const y=this.checkNumSamples(n,s,p,"steps_per_epoch");let g;y!=null&&(g=ga(0,y)),i==null&&(i=1);const{callbackList:b,history:v}=HA(o,i,a,d,y,p,s,m,h);b.setModel(this),this.history=v,await b.onTrainBegin(),this.stopTraining_=!1;for(let w=d;w<a;++w){await b.onEpochBegin(w);const k={};if(p!=null)throw new et("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new et("batch shuffling is not implemneted yet");c&&Aw(g);const N=dn(g),T=Ix(y,s);for(let E=0;E<T.length;++E){const _={};if(await b.onBatchBegin(E,_),Y(()=>{const O=T[E][0],M=T[E][1],V=Jo(N,O,M-O);_.batch=E,_.size=M-O;const W=iv(n,V),K=e(W);for(let q=0;q<r.length;++q){const ee=r[q],te=K[q];_[ee]=te,An(te)}if(E===T.length-1&&m){const q=this.testLoop(l,u,s);for(let ee=0;ee<r.length;++ee){const te=r[ee],G=q[ee];An(G),k["val_"+te]=G}}}),await b.onBatchEnd(E,_),jA(_),this.stopTraining_)break}N.dispose()}if(await b.onEpochEnd(w,k),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,n){return u7(this,e,n)}async trainOnBatch(e,n){const r=await this.standardizeUserData(e,n),s=r[0],a=r[1],i=this.makeTrainFunction()(s.concat(a)),o=[];for(const l of i){const u=await l.data();o.push(u[0])}return Pe(i),Zs(r[0],e),Zs(r[1],n),vr(o)}getNamedWeights(e){const n=[],r=e!=null&&e.trainableOnly,s=r?this.trainableWeights:this.weights,a=this.getWeights(r);for(let i=0;i<s.length;++i)r&&!s[i].trainable||n.push({name:s[i].originalName,tensor:a[i]});return n}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const n=QI().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=n-QI().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Za(this.loss);else if(Array.isArray(this.loss)){for(const n of this.loss)if(typeof n!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(n=>Za(n))}else{const n=Object.keys(this.loss);e={};const r=this.loss;for(const s of n)if(typeof r[s]=="string")e[s]=Za(r[s]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Za(am(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Za(am(e)));{const e={};for(const n in this.metrics)e[n]=Za(am(this.metrics[n]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const n=Dd(e.optimizer_config),r=ua(n);let s;if(typeof e.loss=="string")s=Po(e.loss);else if(Array.isArray(e.loss))s=e.loss.map(i=>Po(i));else if(e.loss!=null){s={};for(const i in e.loss)s[i]=Po(e.loss[i])}let a;if(Array.isArray(e.metrics))a=e.metrics.map(i=>Po(i));else if(e.metrics!=null){a={};for(const i in e.metrics)a[i]=Po(e.metrics[i])}this.compile({loss:s,metrics:a,optimizer:r})}async save(e,n){if(typeof e=="string"){const a=iR(e);if(a.length===0)throw new H(`Cannot find any save handlers for URL '${e}'`);if(a.length>1)throw new H(`Found more than one (${a.length}) save handlers for URL '${e}'`);e=a[0]}if(e.save==null)throw new H("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await U1(this.getNamedWeights(n)),s={modelTopology:this.toJSON(null,!1),format:y7,generatedBy:`TensorFlow.js tfjs-layers v${e_}`,convertedBy:null};if(n!=null&&n.includeOptimizer&&this.optimizer!=null){s.trainingConfig=this.getTrainingConfig();const a="optimizer",{data:i,specs:o}=await U1(await this.optimizer.getWeights(),a);r.specs.push(...o),r.data=sR([r.data,i])}return this.userDefinedMetadata!=null&&(CN(this.userDefinedMetadata,this.name,!0),s.userDefinedMetadata=this.userDefinedMetadata),s.weightData=r.data,s.weightSpecs=r.specs,e.save(s)}setUserDefinedMetadata(e){CN(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Nu.className="Model";le(Nu);class a_ extends Nu{}a_.className="Functional";le(a_);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/async function Hke(t,e){"modelTopology"in t||(t={modelTopology:t}),t=t;let n=t.modelTopology;n.model_config!=null&&(n=n.model_config);const r=Dd(n),s=ua(r,e);if(t.weightsManifest!=null){const a=await O3(t.weightsManifest,t.pathPrefix,s.weights.map(o=>o.originalName)),i={};for(const o of s.weights)i[o.originalName]=a[o.originalName];s.loadWeights(i),Pe(a)}return s}async function Kke(t,e){if(e==null&&(e={}),typeof t=="string"){const n=oR(t,e);if(n.length===0)n.push(P3(t,e));else if(n.length>1)throw new H(`Found more than one (${n.length}) load handlers for URL '${t}'`);t=n[0]}return b7(t,void 0,e)}async function b7(t,e,n){if(n==null&&(n={}),t.load==null)throw new H("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const r=await t.load();let s=r.modelTopology;s.model_config!=null&&(s=s.model_config);const a=n.strict==null?!0:n.strict,i=r.weightData!=null&&r.weightSpecs!=null&&a,o=ua(Dd(s),e,i),l=r.trainingConfig;if(l!=null&&o.loadTrainingConfig(l),r.userDefinedMetadata!=null&&o.setUserDefinedMetadata(r.userDefinedMetadata),r.weightData!=null){if(r.weightSpecs==null)throw new H("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:u,optimizerWeights:c}=x7(r.weightData,r.weightSpecs);o.loadWeights(u,a),o.optimizer!=null&&c.length>0&&await o.optimizer.setWeights(c),Pe(u),Pe(c.map(h=>h.tensor))}return o}function x7(t,e){const n=Xw(t,e),r={},s=[];return e.forEach(a=>{a.group==="optimizer"?s.push({name:a.name,tensor:n[a.name]}):r[a.name]=n[a.name]}),{modelWeights:r,optimizerWeights:s}}class Md extends Nu{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:e0("sequential_"),e.layers!=null)for(const n of e.layers)this.add(n)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new H(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const n=e instanceof Md||e instanceof Nu;let r;if(n){if(r=e,r.outputs.length!==1)throw new H("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(r.inputs.length!==1)throw new H("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new H("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const s=xq({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(s)}if(n)this.outputs=r.outputs,this.inputs=r.inputs;else{if(e.inboundNodes.length!==1)throw new H(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new H("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=zA(this.outputs[0])}this.inboundNodes=[],new n0({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:ml(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(s=>s.shape),outputShapes:this.outputs[0].shape})}else{const s=e.apply(this.outputs[0]);if(Array.isArray(s))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[s],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,n){return this.model==null&&this.build(),this.model.call(e,n)}build(e){if(gt(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Nu({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,n,r=console.log){this.built||this.build(),super.summary(e,n,r)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,n,r={}){if(!this.built)throw new Ms("The model needs to be compiled before being used.");return this.model.evaluate(e,n,r)}async evaluateDataset(e,n){if(!this.built)throw new Ms("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,n)}predict(e,n={}){return this.model==null&&this.build(),this.model.predict(e,n)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,n,r={}){if(!this.built)throw new Ms("The model needs to be compiled before being used.");return this.model.fit(e,n,r)}async fitDataset(e,n){if(!this.built)throw new Ms("The model needs to be compiled before being used.");return this.model.fitDataset(e,n)}async trainOnBatch(e,n){return this.model.trainOnBatch(e,n)}static fromConfig(e,n,r={},s=!1){let a,i={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new H("Legacy serialization format not supported yet.");a=n}else R(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),a=n.layers,delete n.layers,i=n;const o=new e(i);if(!(o instanceof Md))throw new et(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(const l of a){const u=ua(l,void 0,s);s&&u.setFastWeightInitDuringBuild(!0),o.add(u)}return o}set stopTraining(e){if(this.model==null)throw new H("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new H("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const n of this.layers){const r={};r.className=n.getClassName(),r.config=n.getConfig(),e.push(r)}return{name:this.name,layers:e}}}Md.className="Sequential";le(Md);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/let tr=class extends _l{getConfig(){return{}}};class i_ extends tr{apply(e,n=1){return rq(e,n)}}i_.className="elu";le(i_);class o_ extends tr{apply(e){return vk(e)}}o_.className="selu";le(o_);class l_ extends tr{apply(e){return Ka(e)}}l_.className="relu";le(l_);class u_ extends tr{apply(e){return Y(()=>ao(6,Ka(e)))}}u_.className="relu6";le(u_);class c_ extends tr{apply(e){return e}}c_.className="linear";le(c_);class h_ extends tr{apply(e){return ps(e)}}h_.className="sigmoid";le(h_);class d_ extends tr{apply(e){return aq(e)}}d_.className="hardSigmoid";le(d_);class p_ extends tr{apply(e){return Hc(e)}}p_.className="softplus";le(p_);class f_ extends tr{apply(e){return sq(e)}}f_.className="softsign";le(f_);class m_ extends tr{apply(e){return pl(e)}}m_.className="tanh";le(m_);let a2=class extends tr{apply(t,e=-1){return kb(t,e)}};a2.className="softmax";le(a2);class g_ extends tr{apply(e,n=-1){return ck(e,n)}}g_.className="logSoftmax";le(g_);class y_ extends tr{apply(e){return Y(()=>Y(()=>{const n=Math.sqrt(2),r=z(.5,ie(1,ok(Se(e,n))));return z(e,r)}))}}y_.className="gelu";le(y_);class b_ extends tr{apply(e){return Y(()=>z(.5,z(e,ie(1,pl(z(Vn(Se(2,Math.PI)),ie(e,z(.044715,mi(e,3)))))))))}}b_.className="gelu_new";le(b_);class x_ extends tr{apply(e){return Y(()=>z(e,pl(Hc(e))))}}x_.className="mish";le(x_);class v_ extends tr{apply(e,n=1){return Y(()=>z(ps(z(e,n)),e))}}v_.className="swish";le(v_);function oo(t){return t.getClassName()}function Nx(t,e={}){return hf(t,os.getMap().classNameMap,e,"activation")}function lo(t){if(t==null){const e={};return e.className="linear",e.config={},Nx(e)}if(typeof t=="string"){const e={};return e.className=t,e.config={},Nx(e)}else return t instanceof tr?t:Nx(t)}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function i2(t){if(t!=null&&typeof t!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`)}class w_ extends _l{}class a0 extends w_{constructor(e){super(),i2(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return Y(()=>{let n=rn([1]);return this.hasL1&&(n=ie(n,Re(z(this.l1,yn(e))))),this.hasL2&&(n=ie(n,Re(z(this.l2,pf(e))))),j(n,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,n){return new e({l1:n.l1,l2:n.l2})}}a0.className="L1L2";le(a0);function qke(t){return i2(t),new a0({l1:t!=null?t.l1:null,l2:0})}function Xke(t){return i2(t),new a0({l2:t!=null?t.l2:null,l1:0})}const _N={l1l2:"L1L2"};function Et(t){return Gk(t)}function FN(t,e={}){return hf(t,os.getMap().classNameMap,e,"regularizer")}function Vt(t){if(t==null)return null;if(typeof t=="string"){const e={className:t in _N?_N[t]:t,config:{}};return FN(e)}else return t instanceof w_?t:FN(t)}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class k_ extends at{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,n){e=Ge(e);let r=Ka(e);return this.maxValue!=null&&(r=Cr(r,0,this.maxValue)),r}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},n=super.getConfig();return Object.assign(e,n),e}}k_.className="ReLU";le(k_);class S_ extends at{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,n){const r=Ge(e);return hb(r,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},n=super.getConfig();return Object.assign(e,n),e}}S_.className="LeakyReLU";le(S_);class I_ extends at{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Ut(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Vt(e.alphaRegularizer),this.alphaConstraint=Sn(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new H(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=gt(e);const n=e.slice(1);if(this.sharedAxes!=null)for(const s of this.sharedAxes)n[s-1]=1;this.alpha=this.addWeight("alpha",n,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const r={};if(this.sharedAxes!=null)for(let s=1;s<e.length;++s)r[s]=e[s];this.inputSpec=[new vn({ndim:e.length,axes:r})],this.built=!0}call(e,n){return e=Ge(e),xb(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Kt(this.alphaInitializer),alphaRegularizer:Et(this.alphaRegularizer),alphaConstraint:kn(this.alphaConstraint),sharedAxes:this.sharedAxes},n=super.getConfig();return Object.assign(e,n),e}}I_.className="PReLU";le(I_);let N_=class extends at{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new et(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=Ge(t);return nf(n)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}};N_.className="ELU";le(N_);class C_ extends at{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,n){const r=Ge(e);return z(r,me(_r(r,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},n=super.getConfig();return Object.assign(e,n),e}}C_.className="ThresholdedReLU";le(C_);class T_ extends at{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new a2().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,n){return Y(()=>{let r=Ge(e);const s=n.mask;if(s!=null){const a=z(Ie(Kr(r.shape),me(s,r.dtype)),Me(-1e9));r=ie(r,a)}return this.axis instanceof Array?this.axis.length>1?pr(Ie(r,fb(r,this.axis,!0))):this.softmax(r,this.axis[0]):this.softmax(r,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},n=super.getConfig();return Object.assign(e,n),e}}T_.className="Softmax";le(T_);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function Cu(t,e,n){if(typeof t=="number")return ml(t,e);if(t.length!==e)throw new H(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${t.length} elements.`);for(let r=0;r<e;++r){const s=t[r];if(!JK(s))throw new H(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(t)} including a non-integer number ${s}`)}return t}function ca(t,e,n,r,s=1){if(t==null)return t;const a=e+(e-1)*(s-1);let i;return n==="same"?i=t:i=t-a+1,Math.floor((i+r-1)/r)}function Oa(t,e,n,r){if(t==null)return null;if(r==="valid")t=t*e+io([n-e,0]);else if(r==="same")t=t*e;else throw new H(`Unsupport padding mode: ${r}.`);return t}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function o2(t,e){return Y(()=>(on(e),e==="channelsFirst"?ht(t,[0,2,3,1]):t))}function E_(t,e){return Y(()=>(on(e),e==="channelsFirst"?ht(t,[0,2,3,4,1]):t))}function v7(t,e,n,r=1,s="valid",a,i=1){return Y(()=>{if(a==null&&(a=ya()),on(a),t.shape.length!==3)throw new H(`The input of a conv1dWithBias operation should be 3, but is ${t.shape.length} instead.`);if(e.shape.length!==3)throw new H(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new H(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if(a==="channelsFirst"&&(t=ht(t,[0,2,1])),s==="causal")throw new et("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=nk(t,e,r,s==="same"?"same":"valid","NWC",i);return n!=null&&(o=Sa(o,n)),o})}function ON(t,e,n,r=[1,1],s="valid",a,i,o=null){return Y(()=>{if(a==null&&(a=ya()),on(a),t.rank!==3&&t.rank!==4)throw new H(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(e.rank!==3&&e.rank!==4)throw new H(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let l=o2(t,a);if(s==="causal")throw new et("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=x3({x:l,filter:e,strides:r,pad:s==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),a==="channelsFirst"&&(l=ht(l,[0,3,1,2])),l})}function w7(t,e,n,r=[1,1,1],s="valid",a,i){return Y(()=>{if(a==null&&(a=ya()),on(a),t.rank!==4&&t.rank!==5)throw new H(`conv3dWithBias expects input to be of rank 4 or 5, but received ${t.rank}.`);if(e.rank!==4&&e.rank!==5)throw new H(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${t.rank}.`);let o=E_(t,a);if(s==="causal")throw new et("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=OR(o,e,r,s==="same"?"same":"valid","NDHWC",i),n!=null&&(o=Sa(o,n)),a==="channelsFirst"&&(o=ht(o,[0,4,1,2,3])),o})}class i0 extends at{constructor(e,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",i0.verifyArgs(n),this.rank=e,_n(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new et(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Cu(n.kernelSize,e,"kernelSize"),this.strides=Cu(n.strides==null?1:n.strides,e,"strides"),this.padding=n.padding==null?"valid":n.padding,ws(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,on(this.dataFormat),this.activation=lo(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=Ut(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Sn(n.biasConstraint),this.biasRegularizer=Vt(n.biasRegularizer),this.activityRegularizer=Vt(n.activityRegularizer),this.dilationRate=Cu(n.dilationRate==null?1:n.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new H(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new H(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new H(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(Fa("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!Hk(e.kernelSize,"number",1,3))throw new H(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:oo(this.activation),useBias:this.useBias,biasInitializer:Kt(this.biasInitializer),biasRegularizer:Et(this.biasRegularizer),activityRegularizer:Et(this.activityRegularizer),biasConstraint:kn(this.biasConstraint)},n=super.getConfig();return Object.assign(e,n),e}}class Yc extends i0{constructor(e,n){super(e,n),this.kernel=null,Yc.verifyArgs(n),this.filters=n.filters,_n(this.filters,"filters"),this.kernelInitializer=Ut(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Sn(n.kernelConstraint),this.kernelRegularizer=Vt(n.kernelRegularizer)}build(e){e=gt(e);const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new H(`The channel dimension of the input should be defined. Found ${e[n]}`);const r=e[n],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:r}}],this.built=!0}call(e,n){return Y(()=>{e=Ge(e);let r;const s=this.bias==null?null:this.bias.read(),a=IA(this.activation.getClassName());if(a!=null&&this.rank===2)r=ON(e,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(this.rank===1)r=v7(e,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=ON(e,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)r=w7(e,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new et("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(e){e=gt(e);const n=[],r=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let a=0;a<r.length;++a){const i=ca(r[a],this.kernelSize[a],this.padding,this.strides[a],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[a]);n.push(i)}let s=[e[0]];return this.dataFormat==="channelsLast"?(s=s.concat(n),s.push(this.filters)):(s.push(this.filters),s=s.concat(n)),s}getConfig(){const e={filters:this.filters,kernelInitializer:Kt(this.kernelInitializer),kernelRegularizer:Et(this.kernelRegularizer),kernelConstraint:kn(this.kernelConstraint)},n=super.getConfig();return Object.assign(e,n),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new H(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class yf extends Yc{constructor(e){super(2,e),yf.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Hk(e.kernelSize,"number",1,2))throw new H(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}yf.className="Conv2D";le(yf);class bf extends Yc{constructor(e){super(3,e),bf.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new H(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}bf.className="Conv3D";le(bf);class $_ extends yf{constructor(e){if(super(e),this.inputSpec=[new vn({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new H(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=gt(e),e.length!==4)throw new H("Input should have rank 4; Received input shape: "+JSON.stringify(e));const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new H("The channel dimension of the inputs should be defined. Found `None`.");const r=e[n],s=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new vn({ndim:4,axes:{[n]:r}})],this.built=!0}call(e,n){return Y(()=>{let r=Ge(e);if(r.shape.length!==4)throw new H(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const s=r.shape,a=s[0];let i,o;this.dataFormat==="channelsFirst"?(i=2,o=3):(i=1,o=2);const l=s[i],u=s[o],c=this.kernelSize[0],h=this.kernelSize[1],d=this.strides[0],p=this.strides[1],f=Oa(l,d,c,this.padding),m=Oa(u,p,h,this.padding),y=[a,f,m,this.filters];this.dataFormat!=="channelsLast"&&(r=ht(r,[0,2,3,1]));let g=sk(r,this.kernel.read(),y,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(g=ht(g,[0,3,1,2])),this.bias!=null&&(g=Sa(g,this.bias.read(),this.dataFormat)),this.activation!=null&&(g=this.activation.apply(g)),g})}computeOutputShape(e){e=gt(e);const n=e.slice();let r,s,a;this.dataFormat==="channelsFirst"?(r=1,s=2,a=3):(r=3,s=1,a=2);const i=this.kernelSize[0],o=this.kernelSize[1],l=this.strides[0],u=this.strides[1];return n[r]=this.filters,n[s]=Oa(n[s],l,i,this.padding),n[a]=Oa(n[a],u,o,this.padding),n}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}$_.className="Conv2DTranspose";le($_);class R_ extends bf{constructor(e){if(super(e),this.inputSpec=[new vn({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new H(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=gt(e),e.length!==5)throw new H("Input should have rank 5; Received input shape: "+JSON.stringify(e));const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new H("The channel dimension of the inputs should be defined. Found `None`.");const r=e[n],s=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new vn({ndim:5,axes:{[n]:r}})],this.built=!0}call(e,n){return Y(()=>{let r=Ge(e);if(r.shape.length!==5)throw new H(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const s=r.shape,a=s[0];let i,o,l;this.dataFormat==="channelsFirst"?(l=2,i=3,o=4):(l=1,i=2,o=3);const u=s[l],c=s[i],h=s[o],d=this.kernelSize[0],p=this.kernelSize[1],f=this.kernelSize[2],m=this.strides[0],y=this.strides[1],g=this.strides[2],b=Oa(u,m,d,this.padding),v=Oa(c,y,p,this.padding),w=Oa(h,g,f,this.padding),k=[a,b,v,w,this.filters];this.dataFormat!=="channelsLast"&&(r=ht(r,[0,2,3,4,1]));let N=MR(r,this.kernel.read(),k,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(N=ht(N,[0,4,1,2,3])),this.bias!==null&&(N=Sa(N,this.bias.read(),this.dataFormat)),this.activation!==null&&(N=this.activation.apply(N)),N})}computeOutputShape(e){e=gt(e);const n=e.slice();let r,s,a,i;this.dataFormat==="channelsFirst"?(r=1,s=2,a=3,i=4):(r=4,s=1,a=2,i=3);const o=this.kernelSize[0],l=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[0],h=this.strides[1],d=this.strides[2];return n[r]=this.filters,n[s]=Oa(n[s],c,o,this.padding),n[a]=Oa(n[a],h,l,this.padding),n[i]=Oa(n[i],d,u,this.padding),n}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}R_.className="Conv3DTranspose";le(R_);class A_ extends Yc{constructor(e,n){if(super(e,n),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,n.filters==null)throw new H("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(n.kernelInitializer!=null||n.kernelRegularizer!=null||n.kernelConstraint!=null)throw new H("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(n.padding!=null&&n.padding!=="same"&&n.padding!=="valid")throw new H(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(n.padding)}`);this.depthMultiplier=n.depthMultiplier==null?1:n.depthMultiplier,this.depthwiseInitializer=Ut(n.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Vt(n.depthwiseRegularizer),this.depthwiseConstraint=Sn(n.depthwiseConstraint),this.pointwiseInitializer=Ut(n.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Vt(n.pointwiseRegularizer),this.pointwiseConstraint=Sn(n.pointwiseConstraint)}build(e){if(e=gt(e),e.length<this.rank+2)throw new H(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null||e[n]<0)throw new H(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[n])}`);const r=e[n],s=this.kernelSize.concat([r,this.depthMultiplier]),a=[];for(let o=0;o<this.rank;++o)a.push(1);a.push(r*this.depthMultiplier,this.filters);const i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):this.bias=null,this.inputSpec=[new vn({ndim:this.rank+2,axes:{[n]:r}})],this.built=!0}call(e,n){return Y(()=>{e=Ge(e);let r;if(this.rank===1)throw new et("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=ht(e,[0,2,3,1])),r=wk(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(r=Sa(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),this.dataFormat==="channelsFirst"&&(r=ht(r,[0,3,1,2])),r})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Kt(this.depthwiseInitializer),e.pointwiseInitializer=Kt(this.pointwiseInitializer),e.depthwiseRegularizer=Et(this.depthwiseRegularizer),e.pointwiseRegularizer=Et(this.pointwiseRegularizer),e.depthwiseConstraint=kn(this.depthwiseConstraint),e.pointwiseConstraint=kn(this.pointwiseConstraint),e}}A_.className="SeparableConv";class __ extends A_{constructor(e){super(2,e)}}__.className="SeparableConv2D";le(__);class o0 extends Yc{constructor(e){super(1,e),o0.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Hk(e.kernelSize,"number",1,1))throw new H(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}o0.className="Conv1D";le(o0);class F_ extends at{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,n){return Y(()=>{if(e=Ge(e),this.dataFormat==="channelsLast"){const r=sm(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return sm(r,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const r=sm(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return sm(r,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}F_.className="Cropping2D";le(F_);class O_ extends at{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,on(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,YK(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const n=e[2]==null?null:this.size[0]*e[2],r=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],n,r]}else{const n=e[1]==null?null:this.size[0]*e[1],r=e[2]==null?null:this.size[1]*e[2];return[e[0],n,r,e[3]]}}call(e,n){return Y(()=>{let r=Ge(e);const s=r.shape;if(this.dataFormat==="channelsFirst"){r=ht(r,[0,2,3,1]);const a=this.size[0]*s[2],i=this.size[1]*s[3],o=this.interpolation==="nearest"?hr.resizeNearestNeighbor(r,[a,i]):hr.resizeBilinear(r,[a,i]);return ht(o,[0,3,1,2])}else{const a=this.size[0]*s[1],i=this.size[1]*s[2];return this.interpolation==="nearest"?hr.resizeNearestNeighbor(r,[a,i]):hr.resizeBilinear(r,[a,i])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},n=super.getConfig();return Object.assign(e,n),e}}O_.className="UpSampling2D";le(O_);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function k7(t,e,n=[1,1],r="valid",s,a){return Y(()=>{s==null&&(s=ya()),on(s);let i=o2(t,s);if(t.rank!==4)throw new H(`Input for depthwiseConv2d is required to be 4-D, but is instead ${t.rank}-D`);if(e.rank!==4)throw new H(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return i=tf(i,e,n,r==="same"?"same":"valid","NHWC",a),s==="channelsFirst"&&(i=ht(i,[0,3,1,2])),i})}class D_ extends i0{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=Ut(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Sn(e.depthwiseConstraint),this.depthwiseRegularizer=Vt(e.depthwiseRegularizer)}build(e){if(e=gt(e),e.length<4)throw new H(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const n=this.dataFormat==="channelsFirst"?1:3;if(e[n]==null||e[n]<0)throw new H(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[n]}).`);const r=e[n],s=[this.kernelSize[0],this.kernelSize[1],r,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",s,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[r*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,n){return Y(()=>{e=Ge(e);let r=k7(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(r=Sa(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),r})}computeOutputShape(e){e=gt(e);const n=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2],s=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=ca(n,this.kernelSize[0],this.padding,this.strides[0]),i=ca(r,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],s,a,i]:[e[0],a,i,s]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Kt(this.depthwiseInitializer),e.depthwiseRegularizer=Et(this.depthwiseRegularizer),e.depthwiseConstraint=kn(this.depthwiseRegularizer),e}}D_.className="DepthwiseConv2D";le(D_);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function M_(t,e,n,r){if(Array.isArray(t)){if(e!=null||n!=null)throw new H("When inputs is an array, neither initialState or constants should be provided");r!=null&&(n=t.slice(t.length-r,t.length),t=t.slice(0,t.length-r)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function s(a){return a==null||Array.isArray(a)?a:[a]}return e=s(e),n=s(n),{inputs:t,initialState:e,constants:n}}function P_(t,e,n,r=!1,s,a,i=!1,o=!1){return Y(()=>{const l=e.shape.length;if(l<3)throw new H(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(ga(2,l));e=ht(e,u),i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),s!=null&&(s=me(me(s,"bool"),"float32"),s.rank===l-1&&(s=hn(s,-1)),s=ht(s,u)),r&&(e=js(e,0),s!=null&&(s=js(s,0)));const c=[];let h,d=n;const p=e.shape[0],f=Gs(e);let m;s!=null&&(m=Gs(s));for(let g=0;g<p;++g){const b=f[g],v=Y(()=>t(b,d));if(s==null)h=v[0],d=v[1];else{const w=Y(()=>{const k=m[g],N=Ie(ys(k),k),T=ie(z(v[0],k),z(d[0],N)),E=d.map((_,O)=>ie(z(v[1][O],k),z(_,N)));return{output:T,newStates:E}});h=w.output,d=w.newStates}o&&c.push(h)}let y;return o&&(y=Tr(c,1)),[h,y,d]})}class ko extends at{constructor(e){super(e);let n;if(e.cell==null)throw new H("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?n=new c2({cells:e.cell}):n=e.cell,n.stateSize==null)throw new H("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new vn({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return ga(0,e).map(n=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){nv(e)&&(e=e[0]),e=e;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);const r=n[0];let s;if(this.returnSequences?s=[e[0],e[1],r]:s=[e[0],r],this.returnState){const a=[];for(const i of n)a.push([e[0],i]);return[s].concat(a)}else return s}computeMask(e,n){return Y(()=>{Array.isArray(n)&&(n=n[0]);const r=this.returnSequences?n:null;if(this.returnState){const s=this.states.map(a=>null);return[r].concat(s)}else return r})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let r=0;r<e;++r)n.push(null);return n}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new et("Constants support is not implemented in RNN yet.");nv(e)&&(e=e[0]),e=e;const n=this.stateful?e[0]:null,r=e.slice(2);this.inputSpec[0]=new vn({shape:[n,null,...r]});const s=[e[0]].concat(e.slice(2));this.cell.build(s);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!Je(this.stateSpec.map(i=>i.shape[i.shape.length-1]),a))throw new H(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(i=>new vn({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(e,n=!1){Y(()=>{if(!this.stateful)throw new _a("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape[0];if(r==null)throw new H("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>rn([r,s])):this.states_=[rn([r,this.cell.stateSize])];else if(e==null)Pe(this.states_),this.keptStates!=null&&(Pe(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>rn([r,s])):this.states_[0]=rn([r,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new H(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);n===!0?this.keptStates.push(this.states_.slice()):Pe(this.states_);for(let s=0;s<this.states_.length;++s){const a=e[s],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[s]:this.cell.stateSize,o=[r,i];if(!Je(a.shape,o))throw new H(`State ${s} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${a.shape}`);this.states_[s]=a}}this.states_=this.states_.map(s=>An(s.clone()))})}apply(e,n){let r=n==null?null:n.initialState,s=n==null?null:n.constants;n==null&&(n={});const a=M_(e,r,s,this.numConstants);e=a.inputs,r=a.initialState,s=a.constants;let i=[],o=[];if(r!=null){n.initialState=r,i=i.concat(r),this.stateSpec=[];for(const l of r)this.stateSpec.push(new vn({shape:l.shape}));o=o.concat(this.stateSpec)}if(s!=null&&(n.constants=s,i=i.concat(s),this.numConstants=s.length),i[0]instanceof Ua){const l=[e].concat(i),u=this.inputSpec.concat(o),c=this.inputSpec;this.inputSpec=u;const h=super.apply(l,n);return this.inputSpec=c,h}else return super.apply(e,n)}call(e,n){return Y(()=>{const r=n==null?null:n.mask,s=n==null?null:n.training;let a=n==null?null:n.initialState;e=Ge(e),a==null&&(this.stateful?a=this.states_:a=this.getInitialState(e));const i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==i)throw new H(`RNN Layer has ${i} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:s},l=P_((p,f)=>{const m=this.cell.call([p].concat(f),o);return[m[0],m.slice(1)]},e,a,this.goBackwards,r,null,this.unroll,this.returnSequences),u=l[0],c=l[1],h=l[2];this.stateful&&this.resetStates(h,s);const d=this.returnSequences?c:u;return this.returnState?[d].concat(h):d})}getInitialState(e){return Y(()=>{let n=rn(e.shape);return n=Re(n,[1,2]),n=df(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?ev(n,[1,r]):n):this.cell.stateSize>1?[ev(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);const r=this.cell.getConfig();return this.getClassName()===ko.className&&(n.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),e),n)}static fromConfig(e,n,r={}){const s=n.cell,a=ua(s,r);return new e(Object.assign(n,{cell:a}))}}ko.className="RNN";le(ko);class l0 extends at{}class l2 extends l0{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,_n(this.units,"units"),this.activation=lo(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Ut(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Ut(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Ut(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Vt(e.kernelRegularizer),this.recurrentRegularizer=Vt(e.recurrentRegularizer),this.biasRegularizer=Vt(e.biasRegularizer),this.kernelConstraint=Sn(e.kernelConstraint),this.recurrentConstraint=Sn(e.recurrentConstraint),this.biasConstraint=Sn(e.biasConstraint),this.dropout=zu([1,io([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=zu([1,io([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=gt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,n){return Y(()=>{if(e=e,e.length!==2)throw new H(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let r=e[1];e=e[0];const s=n.training==null?!1:n.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=uo({ones:()=>ys(e),rate:this.dropout,training:s,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=uo({ones:()=>ys(r),rate:this.recurrentDropout,training:s,dropoutFunc:this.dropoutFunc}));let a;const i=this.dropoutMask,o=this.recurrentDropoutMask;i!=null?a=Ba(z(e,i),this.kernel.read()):a=Ba(e,this.kernel.read()),this.bias!=null&&(a=Sa(a,this.bias.read())),o!=null&&(r=z(r,o));let l=ie(a,Ba(r,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const e=super.getConfig(),n={units:this.units,activation:oo(this.activation),useBias:this.useBias,kernelInitializer:Kt(this.kernelInitializer),recurrentInitializer:Kt(this.recurrentInitializer),biasInitializer:Kt(this.biasInitializer),kernelRegularizer:Et(this.kernelRegularizer),recurrentRegularizer:Et(this.recurrentRegularizer),biasRegularizer:Et(this.biasRegularizer),activityRegularizer:Et(this.activityRegularizer),kernelConstraint:kn(this.kernelConstraint),recurrentConstraint:kn(this.recurrentConstraint),biasConstraint:kn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),n)}}l2.className="SimpleRNNCell";le(l2);class L_ extends ko{constructor(e){e.cell=new l2(e),super(e)}call(e,n){return Y(()=>{this.cell.dropoutMask!=null&&(Pe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Pe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=n==null?null:n.mask,s=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(e,{mask:r,training:s,initialState:a})})}static fromConfig(e,n){return new e(n)}}L_.className="SimpleRNN";le(L_);class u2 extends l0{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new H("GRUCell does not support reset_after parameter set to true.");this.units=e.units,_n(this.units,"units"),this.activation=lo(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=lo(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Ut(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Ut(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Ut(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Vt(e.kernelRegularizer),this.recurrentRegularizer=Vt(e.recurrentRegularizer),this.biasRegularizer=Vt(e.biasRegularizer),this.kernelConstraint=Sn(e.kernelConstraint),this.recurrentConstraint=Sn(e.recurrentConstraint),this.biasConstraint=Sn(e.biasConstraint),this.dropout=zu([1,io([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=zu([1,io([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=gt(e);const n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,n){return Y(()=>{if(e=e,e.length!==2)throw new H(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const r=n.training==null?!1:n.training;let s=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=uo({ones:()=>ys(e),rate:this.dropout,training:r,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=uo({ones:()=>ys(s),rate:this.recurrentDropout,training:r,count:3,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;let o,l,u;0<this.dropout&&this.dropout<1&&(e=z(e,a[0]));let c=Ba(e,this.kernel.read());this.useBias&&(c=Sa(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=z(s,i[0]));const h=this.recurrentKernel.read(),[d,p]=Qr(h,[2*this.units,this.units],h.rank-1),f=Ba(s,d),[m,y,g]=Qr(c,3,c.rank-1),[b,v]=Qr(f,2,f.rank-1);o=this.recurrentActivation.apply(ie(m,b)),l=this.recurrentActivation.apply(ie(y,v));const w=Ba(z(l,s),p);u=this.activation.apply(ie(g,w));const k=ie(z(o,s),z(ie(1,Lt(o)),u));return[k,k]})}getConfig(){const e=super.getConfig(),n={units:this.units,activation:oo(this.activation),recurrentActivation:oo(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Kt(this.kernelInitializer),recurrentInitializer:Kt(this.recurrentInitializer),biasInitializer:Kt(this.biasInitializer),kernelRegularizer:Et(this.kernelRegularizer),recurrentRegularizer:Et(this.recurrentRegularizer),biasRegularizer:Et(this.biasRegularizer),activityRegularizer:Et(this.activityRegularizer),kernelConstraint:kn(this.kernelConstraint),recurrentConstraint:kn(this.recurrentConstraint),biasConstraint:kn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),n)}}u2.className="GRUCell";le(u2);class z_ extends ko{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new u2(e),super(e)}call(e,n){return Y(()=>{this.cell.dropoutMask!=null&&(Pe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Pe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=n==null?null:n.mask,s=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(e,{mask:r,training:s,initialState:a})})}static fromConfig(e,n){return n.implmentation===0&&(n.implementation=1),new e(n)}}z_.className="GRU";le(z_);class u0 extends l0{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,_n(this.units,"units"),this.activation=lo(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=lo(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Ut(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Ut(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Ut(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Vt(e.kernelRegularizer),this.recurrentRegularizer=Vt(e.recurrentRegularizer),this.biasRegularizer=Vt(e.biasRegularizer),this.kernelConstraint=Sn(e.kernelConstraint),this.recurrentConstraint=Sn(e.recurrentConstraint),this.biasConstraint=Sn(e.biasConstraint),this.dropout=zu([1,io([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=zu([1,io([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var n;e=gt(e);const r=e[e.length-1];this.kernel=this.addWeight("kernel",[r,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let s;if(this.useBias){if(this.unitForgetBias){const a=this.biasInitializer,i=this.units;s=new(n=class extends Hs{apply(o,l){const u=a.apply([i]),c=new qk().apply([i]),h=a.apply([i*2]);return yN(yN(u,c),h)}},n.className="CustomInit",n)}else s=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,s,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,n){return Y(()=>{const r=n.training==null?!1:n.training;if(e=e,e.length!==3)throw new H(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let s=e[1];const a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=uo({ones:()=>ys(e),rate:this.dropout,training:r,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=uo({ones:()=>ys(s),rate:this.recurrentDropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;let l,u,c,h;0<this.dropout&&this.dropout<1&&(e=z(e,i[0]));let d=Ba(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=z(s,o[0])),d=ie(d,Ba(s,this.recurrentKernel.read())),this.useBias&&(d=Sa(d,this.bias.read()));const[p,f,m,y]=Qr(d,4,d.rank-1);l=this.recurrentActivation.apply(p),u=this.recurrentActivation.apply(f),c=ie(z(u,a),z(l,this.activation.apply(m))),h=this.recurrentActivation.apply(y);const g=z(h,this.activation.apply(c));return[g,g,c]})}getConfig(){const e=super.getConfig(),n={units:this.units,activation:oo(this.activation),recurrentActivation:oo(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Kt(this.kernelInitializer),recurrentInitializer:Kt(this.recurrentInitializer),biasInitializer:Kt(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Et(this.kernelRegularizer),recurrentRegularizer:Et(this.recurrentRegularizer),biasRegularizer:Et(this.biasRegularizer),activityRegularizer:Et(this.activityRegularizer),kernelConstraint:kn(this.kernelConstraint),recurrentConstraint:kn(this.recurrentConstraint),biasConstraint:kn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),n)}}u0.className="LSTMCell";le(u0);class B_ extends ko{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new u0(e),super(e)}call(e,n){return Y(()=>{this.cell.dropoutMask!=null&&(Pe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Pe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=n==null?null:n.mask,s=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(e,{mask:r,training:s,initialState:a})})}static fromConfig(e,n){return n.implmentation===0&&(n.implementation=1),new e(n)}}B_.className="LSTM";le(B_);class c2 extends l0{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const n of this.cells.slice().reverse())Array.isArray(n.stateSize)?e.push(...n.stateSize):e.push(n.stateSize);return e}call(e,n){return Y(()=>{e=e;let r=e.slice(1);const s=[];for(const o of this.cells.slice().reverse())Array.isArray(o.stateSize)?s.push(r.splice(0,o.stateSize.length)):s.push(r.splice(0,1));s.reverse();const a=[];let i;for(let o=0;o<this.cells.length;++o){const l=this.cells[o];r=s[o],o===0?i=[e[0]].concat(r):i=[i[0]].concat(r),i=l.call(i,n),a.push(i.slice(1))}r=[];for(const o of a.slice().reverse())r.push(...o);return[i[0]].concat(r)})}build(e){nv(e)&&(e=e[0]),e=e;let n;this.cells.forEach((r,s)=>{Zo(`RNNCell_${s}`,()=>{r.build(e),Array.isArray(r.stateSize)?n=r.stateSize[0]:n=r.stateSize,e=[e[0],n]})}),this.built=!0}getConfig(){const e=super.getConfig(),n=s=>({className:s.getClassName(),config:s.getConfig()}),r={cells:this.cells.map(n)};return Object.assign(Object.assign({},e),r)}static fromConfig(e,n,r={}){const s=[];for(const a of n.cells)s.push(ua(a,r));return new e({cells:s})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const n of this.cells)e.push(...n.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const n of this.cells)e.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const r of this.cells)n.push(...r.trainableWeights);return n.concat(e)}return e}getWeights(){const e=[];for(const n of this.cells)e.push(...n.weights);return rv(e)}setWeights(e){const n=[];for(const r of this.cells){const s=r.weights.length,a=e.splice(s);for(let i=0;i<r.weights.length;++i)n.push([r.weights[i],a[i]])}t2(n)}}c2.className="StackedRNNCells";le(c2);function uo(t){const{ones:e,rate:n,training:r=!1,count:s=1,dropoutFunc:a}=t,i=()=>a!=null?a(e(),n):AA(e(),n),o=()=>ff(i,e,r);return!s||s<=1?An(o().clone()):Array(s).fill(void 0).map(o).map(l=>An(l.clone()))}/**
* @license
* Copyright 2020 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/var S7=function(t,e){var n={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&e.indexOf(r)<0&&(n[r]=t[r]);if(t!=null&&typeof Object.getOwnPropertySymbols=="function")for(var s=0,r=Object.getOwnPropertySymbols(t);s<r.length;s++)e.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(t,r[s])&&(n[r[s]]=t[r[s]]);return n};class W_ extends ko{constructor(e){if(e.unroll)throw new et("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new et("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new vn({ndim:5})]}call(e,n){return Y(()=>{if(this.cell.dropoutMask!=null&&(Pe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Pe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),n&&n.constants)throw new H("ConvRNN2D cell does not support constants");const r=n==null?null:n.mask,s=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(e,{mask:r,training:s,initialState:a})})}computeOutputShape(e){let n=this.computeSingleOutputShape(e);return this.returnSequences||(n=[n[0],...n.slice(2)]),this.returnState&&(n=[n,...Array(2).fill([e[0],...n.slice(-3)])]),n}getInitialState(e){return Y(()=>{const{stateSize:n}=this.cell,r=e.shape,s=this.computeSingleOutputShape(r),a=[s[0],...s.slice(2)],i=rn(a);return Array.isArray(n)?Array(n.length).fill(i):[i]})}resetStates(e,n=!1){Y(()=>{if(!this.stateful)throw new _a("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape,s=this.computeSingleOutputShape(r),a=[s[0],...s.slice(2)];if(r[0]==null)throw new H("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>rn(a)):this.states_=[rn(a)];else if(e==null)Pe(this.states_),this.keptStates!=null&&(Pe(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>rn(a)):this.states_[0]=rn(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new H(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);n?this.keptStates.push(this.states_.slice()):Pe(this.states_);for(let i=0;i<this.states_.length;++i){const o=e[i],l=a;if(!Je(o.shape,l))throw new H(`State ${i} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${o.shape}`);this.states_[i]=o}}this.states_=this.states_.map(i=>An(i.clone()))})}computeSingleOutputShape(e){const{dataFormat:n,filters:r,kernelSize:s,padding:a,strides:i,dilationRate:o}=this.cell,l=n==="channelsFirst",u=e[l?3:2],c=e[l?4:3],h=ca(u,s[0],a,i[0],o[0]),d=ca(c,s[1],a,i[1],o[1]);return[...e.slice(0,2),...l?[r,h,d]:[h,d,r]]}}W_.className="ConvRNN2D";class h2 extends u0{constructor(e){const{filters:n,kernelSize:r,strides:s,padding:a,dataFormat:i,dilationRate:o}=e;super(Object.assign(Object.assign({},e),{units:n})),this.filters=n,_n(this.filters,"filters"),this.kernelSize=Cu(r,2,"kernelSize"),this.kernelSize.forEach(l=>_n(l,"kernelSize")),this.strides=Cu(s||1,2,"strides"),this.strides.forEach(l=>_n(l,"strides")),this.padding=a||"valid",ws(this.padding),this.dataFormat=i||"channelsLast",on(this.dataFormat),this.dilationRate=Cu(o||1,2,"dilationRate"),this.dilationRate.forEach(l=>_n(l,"dilationRate"))}build(e){var n;e=gt(e);const r=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[r]==null)throw new H(`The channel dimension of the input should be defined. Found ${e[r]}`);const s=e[r],a=4,i=this.kernelSize.concat([s,this.filters*a]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const o=this.kernelSize.concat([this.filters,this.filters*a]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const u=this.biasInitializer,c=this.filters;l=new(n=class extends Hs{apply(h,d){const p=u.apply([c]),f=Kr([c]),m=u.apply([c*2]);return Kk([p,f,m])}},n.className="CustomInit",n)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*a],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,n){return Y(()=>{if(e.length!==3)throw new H(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const r=n.training||!1,s=e[0],a=e[1],i=e[2],o=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=uo({ones:()=>ys(s),rate:this.dropout,training:r,count:o,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,u=(ne,ae,oe)=>!ae||!ae[oe]?ne:z(ae[oe],ne);let c=u(s,l,0),h=u(s,l,1),d=u(s,l,2),p=u(s,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=uo({ones:()=>ys(a),rate:this.recurrentDropout,training:r,count:o,dropoutFunc:this.dropoutFunc}));const f=this.recurrentDropoutMask;let m=u(a,f,0),y=u(a,f,1),g=u(a,f,2),b=u(a,f,3);const v=3,[w,k,N,T]=Qr(this.kernel.read(),o,v),[E,_,O,M]=this.useBias?Qr(this.bias.read(),o):[null,null,null,null];c=this.inputConv(c,w,E,this.padding),h=this.inputConv(h,k,_,this.padding),d=this.inputConv(d,N,O,this.padding),p=this.inputConv(p,T,M,this.padding);const[V,W,K,q]=Qr(this.recurrentKernel.read(),o,v);m=this.recurrentConv(m,V),y=this.recurrentConv(y,W),g=this.recurrentConv(g,K),b=this.recurrentConv(b,q);const ee=this.recurrentActivation.apply(ie(c,m)),te=this.recurrentActivation.apply(ie(h,y)),G=ie(z(te,i),z(ee,this.activation.apply(ie(d,g)))),J=z(this.recurrentActivation.apply(ie(p,b)),this.activation.apply(G));return[J,J,G]})}getConfig(){const e=super.getConfig(),n=S7(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,n,r,s){const a=so(e,n,this.strides,s||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return r?Sa(a,r,this.dataFormat):a}recurrentConv(e,n){return so(e,n,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}h2.className="ConvLSTM2DCell";le(h2);class U_ extends W_{constructor(e){const n=new h2(e);super(Object.assign(Object.assign({},e),{cell:n}))}static fromConfig(e,n){return new e(n)}}U_.className="ConvLSTM2D";le(U_);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class d2 extends at{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const n=e.shape,r=[];for(let s=0;s<this.noiseShape.length;++s)r.push(this.noiseShape[s]==null?n[s]:this.noiseShape[s]);return r}call(e,n){return Y(()=>{this.invokeCallHook(e,n);const r=Ge(e);if(0<this.rate&&this.rate<1){const s=n.training==null?!1:n.training,a=this.getNoiseShape(r);return ff(()=>AA(r,this.rate,a,this.seed),()=>r,s)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},n=super.getConfig();return Object.assign(e,n),e}dispose(){return super.dispose()}}d2.className="Dropout";le(d2);class V_ extends d2{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const n=e.shape;return[n[0],1,n[2]]}}V_.className="SpatialDropout1D";le(V_);class j_ extends at{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let n=null;e.batchSize!=null&&(n=e.batchSize),this.batchInputShape=[n,e.inputDim]}this.units=e.units,_n(this.units,"units"),this.activation=lo(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=Ut(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Ut(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Sn(e.kernelConstraint),this.biasConstraint=Sn(e.biasConstraint),this.kernelRegularizer=Vt(e.kernelRegularizer),this.biasRegularizer=Vt(e.biasRegularizer),this.activityRegularizer=Vt(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=gt(e);const n=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[n,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:n}}],this.built=!0}computeOutputShape(e){e=gt(e);const n=e.slice();return n[n.length-1]=this.units,n}call(e,n){return Y(()=>{this.invokeCallHook(e,n);const r=Ge(e),s=IA(this.activation.getClassName());let a;return s!=null?a=Ba(r,this.kernel.read(),s,this.bias?this.bias.read():null):(a=Ba(r,this.kernel.read()),this.bias!=null&&(a=Sa(a,this.bias.read())),this.activation!=null&&(a=this.activation.apply(a))),a})}getConfig(){const e={units:this.units,activation:oo(this.activation),useBias:this.useBias,kernelInitializer:Kt(this.kernelInitializer),biasInitializer:Kt(this.biasInitializer),kernelRegularizer:Et(this.kernelRegularizer),biasRegularizer:Et(this.biasRegularizer),activityRegularizer:Et(this.activityRegularizer),kernelConstraint:kn(this.kernelConstraint),biasConstraint:kn(this.biasConstraint)},n=super.getConfig();return Object.assign(e,n),e}}j_.className="Dense";le(j_);class G_ extends at{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=gt(e);for(const n of e.slice(1))if(n==null)throw new H(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Xi(e,1)]}call(e,n){return Y(()=>{this.invokeCallHook(e,n);let r=Ge(e);if(this.dataFormat==="channelsFirst"&&r.rank>1){const s=[0];for(let a=2;a<r.rank;++a)s.push(a);s.push(1),r=ht(r,s)}return nq(r)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const n=super.getConfig();return Object.assign(e,n),e}}G_.className="Flatten";le(G_);class H_ extends at{constructor(e){super(e),this.supportsMasking=!0,this.activation=lo(e.activation)}call(e,n){return Y(()=>{this.invokeCallHook(e,n);const r=Ge(e);return this.activation.apply(r)})}getConfig(){const e={activation:oo(this.activation)},n=super.getConfig();return Object.assign(e,n),e}}H_.className="Activation";le(H_);class K_ extends at{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,n){return Y(()=>(e=Ge(e),eq(e,this.n)))}getConfig(){const e={n:this.n},n=super.getConfig();return Object.assign(e,n),e}}K_.className="RepeatVector";le(K_);class q_ extends at{constructor(e){super(e),this.targetShape=e.targetShape;for(let n=0;n<this.targetShape.length;++n)this.isUnknown(this.targetShape[n])&&(this.targetShape[n]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,n){const r="Total size of new array must be unchanged.",s=n.slice();let a=1,i=null;for(let l=0;l<s.length;++l){const u=s[l];if(this.isUnknown(u))if(i===null)i=l;else throw new H("Can only specifiy one unknown dimension.");else a*=u}const o=Xi(e);if(i!==null){if(a===0||o%a!==0)throw new H(r);s[i]=o/a}else if(o!==a)throw new H(r);return s}computeOutputShape(e){let n=!1;for(let r=0;r<e.length;++r)if(this.isUnknown(e[r])){n=!0;break}return n?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,n){return Y(()=>{this.invokeCallHook(e,n);const r=Ge(e),s=r.shape,a=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return j(r,a)})}getConfig(){const e={targetShape:this.targetShape},n=super.getConfig();return Object.assign(e,n),e}}q_.className="Reshape";le(q_);class X_ extends at{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const n=ga(1,e.dims.length+1);if(!Je(e.dims.slice().sort(),n))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new vn({ndim:this.dims.length+1})]}computeOutputShape(e){e=gt(e);const n=e.slice();return this.dims.forEach((r,s)=>{n[s+1]=e[r]}),n}call(e,n){return ht(Ge(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},n=super.getConfig();return Object.assign(e,n),e}}X_.className="Permute";le(X_);class Y_ extends at{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={maskValue:this.maskValue};return Object.assign(n,e),n}computeMask(e,n){const r=Ge(e);return dg(Pu(r,this.maskValue),-1)}call(e,n){return Y(()=>{this.invokeCallHook(e,n);const r=Ge(e),s=dg(Pu(r,this.maskValue),-1,!0);return z(r,me(s,r.dtype))})}}Y_.className="Masking";le(Y_);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class Q_ extends at{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let n=null;e.batchSize!=null&&(n=e.batchSize),e.inputLength==null?this.batchInputShape=[n,null]:this.batchInputShape=[n].concat(kt(e.inputLength))}this.inputDim=e.inputDim,_n(this.inputDim,"inputDim"),this.outputDim=e.outputDim,_n(this.outputDim,"outputDim"),this.embeddingsInitializer=Ut(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Vt(e.embeddingsRegularizer),this.activityRegularizer=Vt(e.activityRegularizer),this.embeddingsConstraint=Sn(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,n){return Y(()=>this.maskZero?(e=Ge(e),Pu(e,dt(e))):null)}computeOutputShape(e){if(e=gt(e),this.inputLength==null)return[...e,this.outputDim];const n=kt(this.inputLength);if(n.length!==e.length-1)throw new H(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let r=0;for(let s=0;s<n.length;++s){const a=n[s],i=e[s+1];if(a!=null&&i!=null&&a!==i)throw new H(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);a==null&&(n[r]=i),r++}}return[e[0],...n,this.outputDim]}call(e,n){return Y(()=>{this.invokeCallHook(e,n);let r=Ge(e);r.dtype!=="int32"&&(r=yi(r,"int32"));const s=RA(this.embeddings.read(),j(r,[r.size]));return j(s,gt(this.computeOutputShape(r.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Kt(this.embeddingsInitializer),embeddingsRegularizer:Et(this.embeddingsRegularizer),activityRegularizer:Et(this.activityRegularizer),embeddingsConstraint:kn(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},n=super.getConfig();return Object.assign(e,n),e}}Q_.className="Embedding";le(Q_);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class Pl extends at{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new et}computeElementwiseOpOutputShape(e,n){if(e==null||n==null)return null;if(e.length<n.length)return this.computeElementwiseOpOutputShape(n,e);if(n.length===0)return e;const r=e.slice(0,e.length-n.length);for(let s=0;s<n.length;++s){const a=e[e.length-n.length+s],i=n[s];if(a==null||i==null||a<0||i<0)r.push(null);else if(a===1)r.push(i);else if(i===1)r.push(a);else{if(a!==i)throw new H("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(n));r.push(a)}}return r}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[gt(e)]),e=e,e.length<2)throw new H(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let n=[];for(const a of e)a!=null&&a[0]!==null&&n.push(a[0]);if(n=qi(n),n.length>1)throw new H(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let r=e[0]==null?null:e[0].slice(1);for(let a=1;a<e.length;++a){const i=e[a]==null?null:e[a].slice(1);r=this.computeElementwiseOpOutputShape(r,i)}const s=e.map(a=>a.length);e.indexOf(null)===-1&&qi(s).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,n){return Y(()=>{if(e=e,this.reshapeRequired){const r=[],s=e.map(a=>a.rank);if(s.indexOf(null)===-1){const a=io(s);for(let i of e){const o=i.rank;for(let l=0;l<a-o;++l)i=df(i,1);r.push(i)}return this.mergeFunction(r)}else{let a=!1;for(const l of e){const u=l.rank;if(u==null){const c=l.shape,h=c[0],d=c.slice(1).concat([h]);let p=j(l,[h].concat(Xi(c.slice(1))));p=ht(p,[1,0]),p=j(p,d),r.push(p),a=!0}else if(u>1){const c=ga(1,u).concat([0]);r.push(ht(l,c)),a=!0}else r.push(l)}let i=this.mergeFunction(r);const o=i.rank;if(a){if(o==null){const l=i.shape,u=l.length,c=l[u-1],h=[c].concat(l.slice(0,l.length-1));i=j(ht(j(i,[-1,c]),[1,0]),h)}else if(o>1){const l=[o-1].concat(ga(0,o-1));i=ht(i,l)}}return i}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let n;e[0]==null?n=null:n=e[0].slice(1);for(let s=1;s<e.length;++s){const a=e[s]==null?null:e[s].slice(1);n=this.computeElementwiseOpOutputShape(n,a)}let r=[];for(const s of e)s!=null&&s[0]!==null&&r.push(s[0]);return r=qi(r),r.length===1?n=r.concat(n):n=[null].concat(n),n}computeMask(e,n){return Y(()=>{if(n==null)return null;if(!Array.isArray(n))throw new H("`mask` should be an Array");if(!Array.isArray(e))throw new H("`inputs` should be an Array");if(n.length!==e.length)throw new H(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${n.length})`);if(n.every(s=>s==null))return null;n=n.map(s=>s==null?s:hn(s,0));let r=n[0];for(let s=1;s<n.length-1;++s)r=da(r,n[s]);return r})}}class Z_ extends Pl{constructor(e){super(e)}mergeFunction(e){return Y(()=>{let n=e[0].clone();for(let r=1;r<e.length;++r)n=ie(n,e[r]);return n})}}Z_.className="Add";le(Z_);class J_ extends Pl{constructor(e){super(e)}mergeFunction(e){return Y(()=>{let n=e[0].clone();for(let r=1;r<e.length;++r)n=z(n,e[r]);return n})}}J_.className="Multiply";le(J_);class eF extends Pl{constructor(e){super(e)}mergeFunction(e){return Y(()=>{let n=e[0].clone();for(let r=1;r<e.length;++r)n=ie(n,e[r]);return z(1/e.length,n)})}}eF.className="Average";le(eF);class tF extends Pl{constructor(e){super(e)}mergeFunction(e){return Y(()=>{let n=e[0];for(let r=1;r<e.length;++r)n=wi(n,e[r]);return n})}}tF.className="Maximum";le(tF);class nF extends Pl{constructor(e){super(e)}mergeFunction(e){return Y(()=>{let n=e[0];for(let r=1;r<e.length;++r)n=ao(n,e[r]);return n})}}nF.className="Minimum";le(nF);class rF extends Pl{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new H("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let n=!0;for(const s of e)if(s!=null){n=!1;break}if(n)return;const r=[];for(let s=0;s<e.length;++s){const a=e[s].slice();a.splice(this.axis,1);let i=!1;for(const o of r)if(Je(o,a)){i=!0;break}i||r.push(a)}if(r.length>1)throw new H("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Y(()=>Kk(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new H("A `Concatenate` layer should be called on a list of inputs.");const n=e,r=n[0].slice(),s=this.axis<0?r.length+this.axis:this.axis;for(const a of n.slice(1)){if(r[s]==null||a[s]==null){r[s]=null;break}r[s]+=a[s]}return r}computeMask(e,n){if(n==null)return null;if(!Array.isArray(n))throw new H("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new H("`inputs` should be an array for Concatenate");if(n.length!==e.length)throw new H(`Mismatch in the length of mask (${n.length}) and the legnth of inputs (${e.length})`);return Y(()=>{let r=!0;if(n.forEach(i=>{if(i!=null){r=!1;return}}),r)return null;const s=[];for(let i=0;i<e.length;++i)n[i]==null?s.push(me(ys(e[i]),"bool")):n[i].rank<e[i].rank?s.push(hn(n[i],-1)):s.push(n[i]);const a=qt(s,this.axis);return ek(a,-1,!1)})}getConfig(){const e={axis:this.axis},n=super.getConfig();return Object.assign(e,n),e}}rF.className="Concatenate";le(rF);function Th(t,e){for(;t<0;)t+=e;return t}function I7(t,e,n){if(t.shape.length>3||e.shape.length>3)throw new et("batchDot is not implemented for tensors of 4D or higher rank yet");if(R(t.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`),R(t.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof n=="number"&&(n=[n,n]),t.dtype==="complex64"||e.dtype==="complex64")throw new et("batchDot is not implemented for complex64-type Tensors yet.");const r=t.shape.length,s=e.shape.length;n==null&&(n=[r-1,s-2]);const a=n;return Y(()=>{let i;if(r>s){i=r-s;const l=[];for(let u=0;u<i;++u)l.push(1);e=j(e,e.shape.concat(l))}else if(s>r){i=s-r;const l=[];for(let u=0;u<i;++u)l.push(1);t=j(t,t.shape.concat(l))}else i=0;let o;if(t.shape.length===2&&e.shape.length===2)a[0]===a[1]?o=Re(z(t,e),a[0]):o=Re(z(ht(t,[1,0]),e),a[1]);else{const l=a[0]!==t.shape.length-1,u=a[1]===e.shape.length-1;o=ot(t,e,l,u)}if(i>0){let l;r>s?l=r+s-3:l=r-1;const u=[];for(let c=l;c<l+i;++c)u.push(c);o=yt(o,u)}return o.shape.length===1&&(o=hn(o,1)),o})}class sF extends Pl{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){R(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=e[0],r=e[1];if(n.length>3||r.length>3)throw new et("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(n,r);if(n[s[0]]!==r[s[1]])throw new H(`Dimension incompatibility: ${n[s[0]]} !== ${r[s[1]]}`)}mergeFunction(e){if(e.length!==2)throw new H(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let n=e[0],r=e[1],s;return Array.isArray(this.axes)?s=this.axes.map((a,i)=>Th(a,e[i].shape.length)):s=[Th(this.axes,n.shape.length),Th(this.axes,r.shape.length)],this.normalize&&(n=xg(n,s[0]),r=xg(r,s[1])),I7(n,r,s)}interpretAxes(e,n){let r;return Array.isArray(this.axes)?r=this.axes:r=[Th(this.axes,e.length),Th(this.axes,n.length)],r}computeOutputShape(e){R(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=e[0].slice(),r=e[1].slice();if(n.length>3||r.length>3)throw new et("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(n,r);n.splice(s[0],1),r.splice(s[1],1),r.splice(0,1);const a=n.concat(r);return a.length===1&&a.push(1),a}computeMask(e,n){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},n=super.getConfig();return Object.assign(e,n),e}}sF.className="Dot";le(sF);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class aF extends at{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={stddev:this.stddev};return Object.assign(n,e),n}call(e,n){return Y(()=>{this.invokeCallHook(e,n);const r=Ge(e);return ff(()=>ie(t0(r.shape,0,this.stddev),r),()=>r,n.training||!1)})}}aF.className="GaussianNoise";le(aF);class iF extends at{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={rate:this.rate};return Object.assign(n,e),n}call(e,n){return Y(()=>{this.invokeCallHook(e,n);const r=Ge(e);return this.rate>0&&this.rate<1?ff(()=>{const s=Math.sqrt(this.rate/(1-this.rate));return z(r,t0(r.shape,1,s))},()=>r,n.training||!1):r})}}iF.className="GaussianDropout";le(iF);class oF extends at{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Ge(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={rate:this.rate};return Object.assign(n,e),n}call(e,n){return Y(()=>{if(this.rate<1&&this.rate>0){const r=this._getNoiseShape(e);return ff(()=>{const s=Ge(e),a=-1.6732632423543772*1.0507009873554805;let i=vo(Al(r),this.rate);i=yi(i,"float32");const o=((1-this.rate)*(1+this.rate*a**2))**-.5,l=-o*a*this.rate,u=ie(z(s,i),z(ie(i,-1),a));return ie(z(u,o),l)},()=>Ge(e),n.training||!1)}return e})}}oF.className="AlphaDropout";le(oF);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function Pd(t,e,n,r,s,a=.001){let i;if(t.rank===2)i=NR(t,e,n,r,s,a);else if(t.rank===3)i=CR(t,e,n,r,s,a);else if(t.rank===4)i=TR(t,e,n,r,s,a);else throw new et(`batchNormalization is not implemented for array of rank ${t.rank} yet`);return i}function N7(t,e,n,r,s=.001){return Y(()=>{const a=yb(t,r),i=a.mean,o=a.variance;return[Pd(t,i,o,n,e,s),i,o]})}function C7(t,e,n,r,s=.001){return Y(()=>{const a=yb(t,r),i=a.mean,o=a.variance,l=[];for(const p of ga(0,t.rank))r.indexOf(p)!==-1?l.push(1):l.push(t.shape[p]);const u=j(i,l),c=j(o,l),h=e==null?null:j(e,l),d=n==null?null:j(n,l);return[Pd(t,u,c,d,h,s),i,o]})}function T7(t,e,n,r,s=.001){return Je(r.slice().sort(),ga(0,t.rank-1))?N7(t,e,n,r,s):C7(t,e,n,r,s)}class lF extends at{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=Ut(e.betaInitializer||"zeros"),this.gammaInitializer=Ut(e.gammaInitializer||"ones"),this.movingMeanInitializer=Ut(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Ut(e.movingVarianceInitializer||"ones"),this.betaConstraint=Sn(e.betaConstraint),this.gammaConstraint=Sn(e.gammaConstraint),this.betaRegularizer=Vt(e.betaRegularizer),this.gammaRegularizer=Vt(e.gammaRegularizer)}build(e){e=gt(e);const n=this.axis>=0?this.axis:this.axis+e.length,r=e[n];if(r==null)throw new H(`Axis ${n} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new vn({ndim:e.length,axes:{[n]:r}})];const s=[r];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,n){return Y(()=>{const r=n.training==null?!1:n.training,s=Ge(e),a=s.shape,i=a.length,o=ga(0,i),l=this.axis>=0?this.axis:this.axis+i;o.splice(l,1);const u=ml(1,i);u[l]=a[l];const c=o.slice();c.sort();const h=!Je(c,ga(0,i).slice(0,i-1)),d=()=>{if(h){const g=j(this.movingMean.read(),u),b=j(this.movingVariance.read(),u),v=this.center?j(this.beta.read(),u):null,w=this.scale?j(this.gamma.read(),u):null;return Pd(s,g,b,v,w,this.epsilon)}else return Pd(s,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!r)return d();const[p,f,m]=T7(s,this.gamma.read(),this.beta.read(),o,this.epsilon),y=(g,b,v)=>{Y(()=>{const w=1-v,k=g.read(),N=z(Ie(k,b),w);g.write(Ie(k,N))})};return y(this.movingMean,f,this.momentum),y(this.movingVariance,m,this.momentum),p})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Kt(this.betaInitializer),gammaInitializer:Kt(this.gammaInitializer),movingMeanInitializer:Kt(this.movingMeanInitializer),movingVarianceInitializer:Kt(this.movingVarianceInitializer),betaRegularizer:Et(this.betaRegularizer),gammaRegularizer:Et(this.gammaRegularizer),betaConstraint:kn(this.betaConstraint),gammaConstraint:kn(this.gammaConstraint)},n=super.getConfig();return Object.assign(e,n),e}}lF.className="BatchNormalization";le(lF);class uF extends at{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const n of this.axis)if(!Number.isInteger(n))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=Ut(e.betaInitializer||"zeros"),this.gammaInitializer=Ut(e.gammaInitializer||"ones"),this.betaRegularizer=Vt(e.betaRegularizer),this.gammaRegularizer=Vt(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=gt(e);const n=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=n);for(const a of this.axis)if(a<0||a>=n)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==qi(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const r=this.axis.map(a=>e[a]),s=!0;this.scale?this.gamma=this.addWeight("gamma",r,"float32",this.gammaInitializer,this.gammaRegularizer,s):this.gamma=null,this.center?this.beta=this.addWeight("beta",r,"float32",this.betaInitializer,this.betaRegularizer,s):this.beta=null,this.built=!0}call(e,n){const r=Ge(e),s=r.shape,a=s.length;return Y(()=>{let{mean:i,variance:o}=yb(r,this.axis,!0);const l=ml(1,a);for(const f of this.axis)l[f]=s[f];const u=f=>f!=null&&f.shape.length!==a?j(f,l):f;let c=this.scale?u(this.gamma.read()):null,h=this.center?u(this.beta.read()):null;const d=[],p=[];for(let f=0;f<a;++f)this.axis.indexOf(f)!==-1?(d.push(s[f]),p.push(1)):(d.push(1),p.push(s[f]));return i=Ds(i,d),o=Ds(o,d),c!=null&&(c=Ds(c,p)),h!=null&&(h=Ds(h,p)),Pd(r,i,o,h,c,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Kt(this.betaInitializer),gammaInitializer:Kt(this.gammaInitializer),betaRegularizer:Et(this.betaRegularizer),gammaRegularizer:Et(this.gammaRegularizer)},n=super.getConfig();return Object.assign(e,n),e}}uF.className="LayerNormalization";le(uF);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function E7(t,e,n){return Y(()=>{if(t.rank!==4)throw new H(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new H("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=ya()),n!=="channelsLast"&&n!=="channelsFirst")throw new H(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return n==="channelsFirst"?r=[[0,0],[0,0],e[0],e[1]]:r=[[0,0],e[0],e[1],[0,0]],pa(t,r)})}class cF extends at{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?ya():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new H(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let n,r;if(typeof e.padding[0]=="number")n=[e.padding[0],e.padding[0]],r=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new H(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(n=e.padding[0],e.padding[1].length!==2)throw new H(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);r=e.padding[1]}this.padding=[n,r]}this.inputSpec=[new vn({ndim:4})]}computeOutputShape(e){e=gt(e);let n,r;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?n=e[2]+this.padding[0][0]+this.padding[0][1]:n=null,e[3]!=null&&e[3]>=0?r=e[3]+this.padding[1][0]+this.padding[1][1]:r=null,[e[0],e[1],n,r]):(e[1]!=null&&e[1]>=0?n=e[1]+this.padding[0][0]+this.padding[0][1]:n=null,e[2]!=null&&e[2]>=0?r=e[2]+this.padding[1][0]+this.padding[1][1]:r=null,[e[0],n,r,e[3]])}call(e,n){return Y(()=>E7(Ge(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}cF.className="ZeroPadding2D";le(cF);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function c0(t,e,n,r,s,a){return Y(()=>{on(s),CA(a),ws(r),n==null&&(n=[1,1]),r==null&&(r="valid"),s==null&&(s=ya()),a==null&&(a="max"),t=o2(t,s);let i;const o=r==="same"?"same":"valid";return a==="max"?i=gb(t,e,n,o):i=ob(t,e,n,o),s==="channelsFirst"&&(i=ht(i,[0,3,1,2])),i})}function hF(t,e,n,r,s,a){return Y(()=>{on(s),CA(a),ws(r),n==null&&(n=[1,1,1]),r==null&&(r="valid"),s==null&&(s=ya()),a==null&&(a="max"),t=E_(t,s);let i;const o=r==="same"?"same":"valid";return a==="max"?i=QR(t,e,n,o):i=IR(t,e,n,o),s==="channelsFirst"&&(i=ht(i,[0,4,1,2,3])),i})}class dF extends at{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new H(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(_n(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new H(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);_n(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,ws(this.padding),this.inputSpec=[new vn({ndim:3})]}computeOutputShape(e){e=gt(e);const n=ca(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],n,e[2]]}call(e,n){return Y(()=>{this.invokeCallHook(e,n),e=df(Ge(e),2);const r=this.poolingFunction(Ge(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return yt(r,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},n=super.getConfig();return Object.assign(e,n),e}}class pF extends dF{constructor(e){super(e)}poolingFunction(e,n,r,s,a){return on(a),ws(s),c0(e,n,r,s,a,"max")}}pF.className="MaxPooling1D";le(pF);class fF extends dF{constructor(e){super(e)}poolingFunction(e,n,r,s,a){return on(a),ws(s),c0(e,n,r,s,a,"avg")}}fF.className="AveragePooling1D";le(fF);class mF extends at{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new H(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];_n(this.poolSize,"poolSize"),_n(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,on(this.dataFormat),ws(this.padding),this.inputSpec=[new vn({ndim:4})]}computeOutputShape(e){e=gt(e);let n=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2];return n=ca(n,this.poolSize[0],this.padding,this.strides[0]),r=ca(r,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],n,r]:[e[0],n,r,e[3]]}call(e,n){return Y(()=>(this.invokeCallHook(e,n),this.poolingFunction(Ge(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}class gF extends mF{constructor(e){super(e)}poolingFunction(e,n,r,s,a){return on(a),ws(s),c0(e,n,r,s,a,"max")}}gF.className="MaxPooling2D";le(gF);class yF extends mF{constructor(e){super(e)}poolingFunction(e,n,r,s,a){return on(a),ws(s),c0(e,n,r,s,a,"avg")}}yF.className="AveragePooling2D";le(yF);class bF extends at{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new H(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];_n(this.poolSize,"poolSize"),_n(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,on(this.dataFormat),ws(this.padding),this.inputSpec=[new vn({ndim:5})]}computeOutputShape(e){e=gt(e);let n=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2],s=this.dataFormat==="channelsFirst"?e[4]:e[3];return n=ca(n,this.poolSize[0],this.padding,this.strides[0]),r=ca(r,this.poolSize[1],this.padding,this.strides[1]),s=ca(s,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],n,r,s]:[e[0],n,r,s,e[4]]}call(e,n){return Y(()=>(this.invokeCallHook(e,n),this.poolingFunction(Ge(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}class xF extends bF{constructor(e){super(e)}poolingFunction(e,n,r,s,a){return on(a),ws(s),hF(e,n,r,s,a,"max")}}xF.className="MaxPooling3D";le(xF);class vF extends bF{constructor(e){super(e)}poolingFunction(e,n,r,s,a){return on(a),ws(s),hF(e,n,r,s,a,"avg")}}vF.className="AveragePooling3D";le(vF);class wF extends at{constructor(e){super(e),this.inputSpec=[new vn({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,n){throw new et}}class kF extends wF{constructor(e){super(e||{})}call(e,n){return Y(()=>{const r=Ge(e);return Qt(r,1)})}}kF.className="GlobalAveragePooling1D";le(kF);class SF extends wF{constructor(e){super(e||{})}call(e,n){return Y(()=>{const r=Ge(e);return zs(r,1)})}}SF.className="GlobalMaxPooling1D";le(SF);class IF extends at{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,on(this.dataFormat),this.inputSpec=[new vn({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,n){throw new et}getConfig(){const e={dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}class NF extends IF{call(e,n){return Y(()=>{const r=Ge(e);return this.dataFormat==="channelsLast"?Qt(r,[1,2]):Qt(r,[2,3])})}}NF.className="GlobalAveragePooling2D";le(NF);class CF extends IF{call(e,n){return Y(()=>{const r=Ge(e);return this.dataFormat==="channelsLast"?zs(r,[1,2]):zs(r,[2,3])})}}CF.className="GlobalMaxPooling2D";le(CF);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class TF extends at{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},n=super.getConfig();return Object.assign(e,n),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,n,r={}){const s=n.layer,a=ua(s,r);delete n.layer;const i={layer:a};return Object.assign(i,n),new e(i)}}class EF extends TF{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=gt(e),e.length<3)throw new H(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const n=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(n),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=gt(e);const n=[e[0]].concat(e.slice(2)),r=this.layer.computeOutputShape(n),s=e[1];return[r[0],s].concat(r.slice(1))}call(e,n){return Y(()=>(e=Ge(e),P_((r,s)=>[Ge(this.layer.call(r,n)),[]],e,[],!1,null,null,!1,!0)[1]))}}EF.className="TimeDistributed";le(EF);function $7(t){Ml(XK,"BidirectionalMergeMode",t)}const R7="concat";class $F extends TF{constructor(e){super(e);const n=e.layer.getConfig(),r={};r.className=e.layer.getClassName(),r.config=n,this.forwardLayer=ua(r),n.goBackwards=n.goBackwards!==!0;const s={};if(s.className=e.layer.getClassName(),s.config=n,this.backwardLayer=ua(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?R7:e.mergeMode,$7(this.mergeMode),e.weights)throw new et("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const n=e.length,r=Math.floor(n/2);this.forwardLayer.setWeights(e.slice(0,r)),this.backwardLayer.setWeights(e.slice(r))}computeOutputShape(e){let n=this.forwardLayer.computeOutputShape(e);Array.isArray(n)&&Array.isArray(n[0])||(n=[n]),n=n;let r,s,a;return this.returnState&&(a=n.slice(1)),r=n[0],r=r,this.mergeMode==="concat"?(r[r.length-1]*=2,s=[r]):this.mergeMode==null?s=[r,r.slice()]:s=[r],this.returnState?this.mergeMode==null?s.concat(a).concat(a.slice()):[r].concat(a).concat(a.slice()):vr(s)}apply(e,n){let r=n==null?null:n.initialState,s=n==null?null:n.constants;n==null&&(n={});const a=M_(e,r,s,this.numConstants);if(e=a.inputs,r=a.initialState,s=a.constants,Array.isArray(e)&&(r=e.slice(1),e=e[0]),(r==null||r.length===0)&&s==null)return super.apply(e,n);const i=[],o=[];if(r!=null){const u=r.length;if(u%2>0)throw new H("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");n.initialState=r,i.push(...r);const c=r.map(h=>new vn({shape:h.shape}));this.forwardLayer.stateSpec=c.slice(0,u/2),this.backwardLayer.stateSpec=c.slice(u/2),o.push(...c)}if(s!=null)throw new et("Support for constants in Bidirectional layers is not implemented yet.");const l=i[0]instanceof Ua;for(const u of i)if(u instanceof Ua!==l)throw new H("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const u=[e].concat(i),c=this.inputSpec.concat(o),h=this.inputSpec;this.inputSpec=c;const d=super.apply(u,n);return this.inputSpec=h,d}else return super.apply(e,n)}call(e,n){return Y(()=>{const r=n.initialState;let s,a;if(r==null)s=this.forwardLayer.call(e,n),a=this.backwardLayer.call(e,n);else{const l=r.slice(0,r.length/2),u=r.slice(r.length/2);s=this.forwardLayer.call(e,Object.assign(n,{initialState:l})),a=this.backwardLayer.call(e,Object.assign(n,{initialState:u}))}let i;this.returnState&&(Array.isArray(s)&&(i=s.slice(1).concat(a.slice(1))),s=s[0],a=a[0]),this.returnSequences&&(a=js(a,1));let o;return this.mergeMode==="concat"?o=Kk([s,a]):this.mergeMode==="sum"?o=ie(s,a):this.mergeMode==="ave"?o=z(.5,ie(s,a)):this.mergeMode==="mul"?o=z(s,a):this.mergeMode==null&&(o=[s,a]),this.returnState?this.mergeMode==null?o.concat(i):[o].concat(i):o})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Zo(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Zo(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,n){Array.isArray(n)&&(n=n[0]);let r;if(this.returnSequences?this.mergeMode==null?r=[n,n]:r=n:this.mergeMode==null?r=[null,null]:r=null,this.returnState){const s=this.forwardLayer.states.map(a=>null);return Array.isArray(r)?r.concat(s).concat(s):[r].concat(s).concat(s)}else return r}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},n=super.getConfig();return Object.assign(e,n),e}static fromConfig(e,n){const r=ua(n.layer);if(delete n.layer,n.numConstants!=null)throw new et("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const s=n;return s.layer=r,new e(s)}}$F.className="Bidirectional";le($F);/**
* @license
* Copyright 2022 CodeSmith LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class RF extends at{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},n=super.getConfig();return Object.assign(e,n),e}call(e,n){return Y(()=>(e=Ge(e),e.dtype!=="float32"&&(e=yi(e,"float32")),ie(z(e,this.scale),this.offset)))}}RF.className="Rescaling";le(RF);/**
* @license
* Copyright 2022 CodeSmith LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/const{resizeBilinear:A7,cropAndResize:_7}=hr;class AF extends at{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,n,r,s,a,i,o,l){return Y(()=>{let u,c=!1;const h=n/i,d=r/o,p=(s+n)/i,f=(a+r)/o,m=[h,d,p,f],y=[];e.rank===3?(c=!0,u=Tr([e])):u=e;for(let w=0;w<u.shape[0];w++)y.push(m);const g=Ls(y,[y.length,4]),b=Lu(0,y.length,1,"int32"),v=_7(u,g,b,[s,a],"nearest");return yi(c?Ge(Gs(v)):v,l)})}upsize(e,n,r,s){return Y(()=>{const a=A7(e,[n,r]);return yi(a,s)})}call(e,n){return Y(()=>{const r=Ge(e),s=r.dtype,a=r.shape,i=a[a.length-3],o=a[a.length-2];let l=0;i!==this.height&&(l=Math.floor((i-this.height)/2));let u=0;return o!==this.width&&(u=Math.floor((o-this.width)/2),u===0&&(u=1)),l>=0&&u>=0?this.centerCrop(r,l,u,this.height,this.width,i,o,s):this.upsize(e,this.height,this.width,s)})}getConfig(){const e={height:this.height,width:this.width},n=super.getConfig();return Object.assign(e,n),e}computeOutputShape(e){e=gt(e);const n=e.length-3,r=e.length-2;return e[n]=this.height,e[r]=this.width,e}}AF.className="CenterCrop";le(AF);/**
* @license
* Copyright 2022 CodeSmith LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function F7(t,e,n,r){let s=Ge(t);if(s.dtype!=="int32"&&(s=yi(s,"int32")),e==="int")return s;const a=s.shape;if(s.rank===0&&(s=hn(s,-1)),e==="oneHot"&&s.shape[s.shape.length-1]!==1&&(s=hn(s,-1)),s.rank>2)throw new H(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${a} which would result in output rank ${s.rank}.`);const i=["multiHot","oneHot"].includes(e),o=s;let l;if(typeof r<"u"&&e==="count"?l=K1(o,r,n,i):l=K1(o,[],n,i),e!=="tfIdf")return l;if(r)return z(l,r);throw new H("When outputMode is 'tfIdf', weights must be provided.")}/**
* @license
* Copyright 2022 CodeSmith LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class _F extends at{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},n=super.getConfig();return Object.assign(e,n),e}computeOutputShape(e){return e=gt(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,n){return Y(()=>{e=Ge(e),e.dtype!=="int32"&&(e=yi(e,"int32"));let r;if(typeof n.countWeights<"u"){if(this.outputMode!=="count")throw new H(`countWeights is not used when outputMode !== count.
              Received countWeights=${n.countWeights}`);r=Ge(n.countWeights)}const s=zs(e),a=Ed(e),i=_r(this.numTokens,s).bufferSync().get(0),o=vo(a,0).bufferSync().get(0);if(!(i&&o))throw new H(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return F7(e,this.outputMode,this.numTokens,r)})}}_F.className="CategoryEncoding";le(_F);/**
* @license
* Copyright 2022 CodeSmith LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/const O7=["bilinear","nearest"],DN=new Set(O7);class FF extends at{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(DN.has(e.interpolation))this.interpolation=e.interpolation;else throw new H(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=gt(e);const n=e[2];return[this.height,this.width,n]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},n=super.getConfig();return Object.assign(e,n),e}call(e,n){return Y(()=>{const r=[this.height,this.width];if(this.interpolation==="bilinear")return hr.resizeBilinear(e,r,!this.cropToAspectRatio);if(this.interpolation==="nearest")return hr.resizeNearestNeighbor(e,r,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...DN]} are supported`)})}}FF.className="Resizing";le(FF);/**
* @license
* Copyright 2023 CodeSmith LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class OF{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}OF.className="RandomSeed";/**
* @license
* Copyright 2023 CodeSmith LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class DF extends at{constructor(e){super(e),this.randomGenerator=new OF(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},n=super.getConfig();return Object.assign(e,n),e}}DF.className="BaseRandomLayer";/**
* @license
* Copyright 2023 CodeSmith LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/const D7=["bilinear","nearest"],MN=new Set(D7);class MF extends DF{constructor(e){super(e);const{factor:n,interpolation:r="bilinear"}=e;if(this.factor=n,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new H(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new H(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new H(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(r)if(MN.has(r))this.interpolation=r;else throw new H(`Invalid interpolation parameter: ${r} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},n=super.getConfig();return Object.assign(e,n),e}computeOutputShape(e){e=gt(e);const n=e[2];return[this.imgHeight,-1,n]}call(e,n){return Y(()=>{const r=Ge(e);this.imgHeight=r.shape[r.shape.length-3];const s=r.shape[r.shape.length-2];this.widthFactor=Al([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let a=this.widthFactor.dataSync()[0]*s;a=Math.round(a);const i=[this.imgHeight,a];switch(this.interpolation){case"bilinear":return hr.resizeBilinear(e,i);case"nearest":return hr.resizeNearestNeighbor(e,i);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...MN]} are supported`)}})}}MF.className="RandomWidth";le(MF);/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const M7=Z();M7.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* =============================================================================
*/var Wr;(function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF"})(Wr||(Wr={}));var PN;(function(t){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))})(PN||(PN={}));/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const p2={};function Yke(t,e){const n={tfOpName:t,category:"custom",inputs:[],attrs:[],customExecutor:e};p2[t]=n}function PF(t){return p2[t]}function Qke(t){delete p2[t]}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function I(t,e,n,r,s){const a=e.inputParams[t];if(a&&a.inputIndexStart!==void 0){const o=a.inputIndexStart,l=a.inputIndexEnd===0?void 0:a.inputIndexEnd===void 0?o+1:a.inputIndexEnd,u=o<0?e.inputNames.length+o:o;if(a.type==="tensor")return zn(e.inputNames[u],n,r,s);if(a.type==="tensors"){const d=e.inputs.slice(o,l);return e.inputNames.slice(o,l).filter((p,f)=>{var m;return((m=d[f])===null||m===void 0?void 0:m.op)!=="NoOp"}).map(p=>zn(p,n,r,s))}const c=zn(e.inputNames[u],n,r,s),h=c.dataSync();return a.type==="number"?h[0]:ds(c.shape,h)}const i=e.attrParams[t];return i&&i.value}function zn(t,e,n,r){const[s,a]=Ur(t,n);if(r!=null){const o=r.getHashTableHandleByName(s);if(o!=null)return o}const i=n.currentContextIds.find(o=>!!e[Ig(s,o)]);return i!==void 0?e[Ig(s,i)][a]:void 0}function LN(t,e,n){return e[Ig(t,n.currentContextId)]}function Ja(t,e){const[n,r,s]=Ur(t,e);return[Ig(n,e&&e.currentContextId),r,s]}function Ig(t,e){return e?`${t}-${e}`:t}function Ur(t,e){if(t==="")return["",0,void 0];const n=e!=null&&e.parseNodeNameCache!=null;if(n){const a=e.parseNodeNameCache.get(t);if(a!=null)return a}const r=t.split(":");let s;if(r.length===1)s=[t,0,void 0];else{const a=r[0],i=r.length===3?r[1]:void 0,o=Number(r[r.length-1]);s=[a,o,i]}return n&&e.parseNodeNameCache.set(t,s),s}function Nm(t,e,n){let r=I("pad",t,e,n);if(r==="explicit"){r=I("explicitPaddings",t,e,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let a=0;a<4;a++)s[a][0]=r[a*2],s[a][1]=r[a*2+1];return s}return r}function ei(t){return t.kept?t:ii(t)}/**
* @license
* Copyright 2023 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const P7=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],L7=Object.freeze(Object.defineProperty({__proto__:null,json:P7},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2023 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const z7=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],B7=Object.freeze(Object.defineProperty({__proto__:null,json:z7},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2023 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const W7=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],U7=Object.freeze(Object.defineProperty({__proto__:null,json:W7},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2023 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const V7=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],j7=Object.freeze(Object.defineProperty({__proto__:null,json:V7},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2023 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const G7=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],H7=Object.freeze(Object.defineProperty({__proto__:null,json:G7},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2023 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const K7=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],q7=Object.freeze(Object.defineProperty({__proto__:null,json:K7},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2023 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const X7=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],Y7=Object.freeze(Object.defineProperty({__proto__:null,json:X7},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2023 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Q7=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Z7=Object.freeze(Object.defineProperty({__proto__:null,json:Q7},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2023 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const J7=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],eX=Object.freeze(Object.defineProperty({__proto__:null,json:J7},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2023 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const tX=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],nX=Object.freeze(Object.defineProperty({__proto__:null,json:tX},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2023 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const rX=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],sX=Object.freeze(Object.defineProperty({__proto__:null,json:rX},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2023 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const aX=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],iX=Object.freeze(Object.defineProperty({__proto__:null,json:aX},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2023 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const oX=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],lX=Object.freeze(Object.defineProperty({__proto__:null,json:oX},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2023 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const uX=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],cX=Object.freeze(Object.defineProperty({__proto__:null,json:uX},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2023 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const hX=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],dX=Object.freeze(Object.defineProperty({__proto__:null,json:hX},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2023 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const pX=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],fX=Object.freeze(Object.defineProperty({__proto__:null,json:pX},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2023 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const mX=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],gX=Object.freeze(Object.defineProperty({__proto__:null,json:mX},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2023 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const yX=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],bX=Object.freeze(Object.defineProperty({__proto__:null,json:yX},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2023 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const xX=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],vX=Object.freeze(Object.defineProperty({__proto__:null,json:xX},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class zN{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[L7,B7,U7,j7,H7,q7,Y7,Z7,eX,nX,sX,iX,lX,cX,dX,fX,gX,bX,vX],n=[].concat(...e.map(r=>r.json));this.opMappers=n.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(e,n={}){const r=e.node,s=[],a=[],i=[],o=r.reduce((m,y)=>(m[y.name]=this.mapNode(y),y.op.startsWith("Placeholder")?s.push(m[y.name]):y.op==="Const"?a.push(m[y.name]):(y.input==null||y.input.length===0)&&i.push(m[y.name]),m),{});let l=[];const u=[];let c={},h={};n!=null&&(c=this.mapSignatureEntries(n.inputs),h=this.mapSignatureEntries(n.outputs));const d=Object.keys(o);d.forEach(m=>{const y=o[m];y.inputNames.forEach((g,b)=>{const[v,,w]=Ja(g),k=o[v];if(k.outputs!=null){const N=k.outputs.indexOf(w);if(N!==-1){const T=`${v}:${N}`;y.inputNames[b]=T}}y.inputs.push(k),k.children.push(y)})}),Object.keys(h).length===0?d.forEach(m=>{const y=o[m];y.children.length===0&&u.push(y)}):Object.keys(h).forEach(m=>{const[y]=Ja(m),g=o[y];g!=null&&(g.signatureKey=h[m],u.push(g))}),Object.keys(c).length>0?Object.keys(c).forEach(m=>{const[y]=Ja(m),g=o[y];g&&(g.signatureKey=c[m],l.push(g))}):l=s;let p={};e.library!=null&&e.library.function!=null&&(p=e.library.function.reduce((m,y)=>(m[y.signature.name]=this.mapFunction(y),m),{}));const f={nodes:o,inputs:l,outputs:u,weights:a,placeholders:s,signature:n,functions:p};return i.length>0&&(f.initNodes=i),f}mapSignatureEntries(e){return Object.keys(e||{}).reduce((n,r)=>(n[e[r].name]=r,n),{})}mapNode(e){const n=PF(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const r={name:e.name,op:e.op,category:n.category,inputNames:(e.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:n.outputs};return n.inputs!=null&&(r.inputParams=n.inputs.reduce((s,a)=>(s[a.name]={type:a.type,inputIndexStart:a.start,inputIndexEnd:a.end},s),{})),n.attrs!=null&&(r.attrParams=n.attrs.reduce((s,a)=>{const i=a.type;let o;switch(a.type){case"string":o=lv(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=lv(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":o=mv(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=mv(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":o=cv(e.attr,a.tfName,a.defaultValue||0),o===void 0&&a.tfDeprecatedName&&(o=cv(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":o=fv(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=fv(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":o=uv(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=uv(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":o=yv(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=yv(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":o=pv(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=pv(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":o=gv(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=gv(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":o=hv(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=hv(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":o=dv(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=dv(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":o=BN(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=BN(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${e.op}`)}return s[a.name]={value:o,type:i},s},{})),r}mapFunction(e){const n=e.nodeDef,r=[],s=[];let a={};n!=null&&(a=n.reduce((c,h)=>(c[h.name]=this.mapNode(h),h.op==="Const"&&s.push(c[h.name]),c),{}));const i=[],o=[];e.signature.inputArg.forEach(c=>{const[h]=Ja(c.name),d={name:h,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:f2(c.type),type:"dtype"}},children:[]};d.signatureKey=c.name,i.push(d),a[h]=d}),Object.keys(a).forEach(c=>{const h=a[c];h.inputNames.forEach((d,p)=>{const[f,,m]=Ja(d),y=a[f];if(y.outputs!=null){const g=y.outputs.indexOf(m);if(g!==-1){const b=`${f}:${g}`;h.inputNames[p]=b}}h.inputs.push(y),y.children.push(h)})});const l=e.ret;e.signature.outputArg.forEach(c=>{const[h,d]=Ja(l[c.name]),p=a[h];p!=null&&(p.defaultOutput=d,o.push(p))});const u=this.mapArgsToSignature(e);return{nodes:a,inputs:i,outputs:o,weights:s,placeholders:r,signature:u}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((n,r)=>(n[r.name]=this.mapArgToTensorInfo(r),n),{}),outputs:e.signature.outputArg.reduce((n,r)=>(n[r.name]=this.mapArgToTensorInfo(r,e.ret),n),{})}}mapArgToTensorInfo(e,n){let r=e.name;return n!=null&&(r=n[r]),{name:r,dtype:e.type}}}function wX(t){const e=Z().global;if(typeof e.atob<"u")return e.atob(t);if(typeof Buffer<"u")return new Buffer(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function LF(t,e){const n=Array.isArray(t)?String.fromCharCode.apply(null,t):wX(t);return e?n:n.toLowerCase()}function lv(t,e,n,r=!1){const s=t[e];return s!=null?LF(s.s,r):n}function uv(t,e,n){const r=t[e];return r?r.b:n}function cv(t,e,n){const r=t[e]||{},s=r.i!=null?r.i:r.f!=null?r.f:n;return typeof s=="number"?s:parseInt(s,10)}function f2(t){switch(typeof t=="string"&&(t=Wr[t]),t){case Wr.DT_FLOAT:case Wr.DT_HALF:return"float32";case Wr.DT_INT32:case Wr.DT_INT64:case Wr.DT_INT8:case Wr.DT_UINT8:return"int32";case Wr.DT_BOOL:return"bool";case Wr.DT_DOUBLE:return"float32";case Wr.DT_STRING:return"string";case Wr.DT_COMPLEX64:case Wr.DT_COMPLEX128:return"complex64";default:return null}}function BN(t,e,n){const r=t[e];return r&&r.func?r.func.name:n}function hv(t,e,n){const r=t[e];return r&&r.type?f2(r.type):n}function dv(t,e,n){const r=t[e];return r&&r.list&&r.list.type?r.list.type.map(s=>f2(s)):n}function zF(t){if(!t.unknownRank)return t.dim!=null?t.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function pv(t,e,n){const r=t[e];return r&&r.shape?zF(r.shape):n}function fv(t,e,n){const r=t[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):n}function mv(t,e,n,r=!1){const s=t[e];return s&&s.list&&s.list.s?s.list.s.map(a=>LF(a,r)):n}function gv(t,e,n){const r=t[e];return r&&r.list&&r.list.shape?r.list.shape.map(s=>zF(s)):n}function yv(t,e,n){const r=t[e];return r&&r.list&&r.list.b?r.list.b:n}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class kX{constructor(e,n,r){this.node=e,this.tensorMap=n,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(s=>this.getInput(s)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((s,a)=>(s[a]=this.getAttr(a),s),{}))}getInput(e){return zn(e,this.tensorMap,this.context)}getAttr(e,n){const r=this.node.rawAttrs[e];if(r.tensor!=null)return zn(e,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return cv(this.node.rawAttrs,e,n);if(r.s!=null)return lv(this.node.rawAttrs,e,n);if(r.b!=null)return uv(this.node.rawAttrs,e,n);if(r.shape!=null)return pv(this.node.rawAttrs,e,n);if(r.type!=null)return hv(this.node.rawAttrs,e,n);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return fv(this.node.rawAttrs,e,n);if(r.list.s!=null)return mv(this.node.rawAttrs,e,n);if(r.list.shape!=null)return gv(this.node.rawAttrs,e,n);if(r.list.b!=null)return yv(this.node.rawAttrs,e,n);if(r.list.type!=null)return dv(this.node.rawAttrs,e,n)}return n}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const jn=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:tR,abs:yn,acos:gR,acosh:yR,add:ie,addN:LW,all:ek,any:dg,argMax:hl,argMin:bR,asin:xR,asinh:vR,atan:wR,atan2:kR,atanh:SR,avgPool:ob,avgPool3d:IR,basicLSTMCell:oU,batchNorm:ef,batchNorm2d:NR,batchNorm3d:CR,batchNorm4d:TR,batchToSpaceND:lb,bincount:ER,bitwiseAnd:gU,booleanMaskAsync:ZG,broadcastArgs:bU,broadcastTo:Iu,buffer:Qe,cast:me,ceil:$R,clipByValue:Cr,clone:ii,complex:to,concat:qt,concat1d:RR,concat2d:AR,concat3d:_R,concat4d:FR,conv1d:nk,conv2d:so,conv2dTranspose:sk,conv3d:OR,conv3dTranspose:MR,cos:ub,cosh:ak,cosineWindow:Ak,cumprod:pg,cumsum:ik,denseBincount:K1,depthToSpace:PR,depthwiseConv2d:tf,diag:WU,dilation2d:LR,div:Se,divNoNan:zR,dot:BR,dropout:y3,einsum:nu,elu:nf,enclosingPowerOfTwo:b3,ensureShape:QU,equal:ms,erf:ok,euclideanNorm:VR,exp:pr,expandDims:hn,expm1:jR,eye:uk,fft:Sb,fill:Gc,floor:sf,floorDiv:Jw,fused:v6,gather:af,gatherND:l6,greater:_r,greaterEqual:vo,ifft:_d,imag:cb,image:hr,inTopKAsync:d6,irfft:Nk,isFinite:GR,isInf:HR,isNaN:KR,leakyRelu:hb,less:$d,lessEqual:$l,linalg:C3,linspace:SV,localResponseNormalization:qR,log:gs,log1p:db,logSigmoid:XR,logSoftmax:ck,logSumExp:fb,logicalAnd:da,logicalNot:mb,logicalOr:hk,logicalXor:YR,losses:QH,lowerBound:zV,matMul:ot,max:zs,maxPool:gb,maxPool3d:QR,maxPoolWithArgmax:VV,maximum:wi,mean:Qt,meshgrid:HV,min:Ed,minimum:ao,mirrorPad:pk,mod:ZR,moments:yb,movingAverage:t6,mul:z,multiRNNCell:ZV,multinomial:ej,neg:Lt,norm:rf,notEqual:Pu,oneHot:fk,ones:Kr,onesLike:ys,op:U,outerProduct:aj,pad:pa,pad1d:lj,pad2d:cj,pad3d:dj,pad4d:fj,pool:JR,pow:mi,prelu:xb,print:mR,prod:e3,raggedGather:kj,raggedRange:Ij,raggedTensorToTensor:Cj,rand:Ej,randomGamma:qj,randomNormal:gk,randomStandardNormal:Qj,randomUniform:Al,randomUniformInt:eG,range:Lu,real:Rd,reciprocal:l3,relu:Ka,relu6:yk,reshape:j,reverse:js,reverse1d:oG,reverse2d:uG,reverse3d:hG,reverse4d:pG,rfft:Ib,round:bk,rsqrt:xk,scalar:Me,scatterND:r6,searchSorted:dk,selu:vk,separableConv2d:wk,setdiff1dAsync:xG,sigmoid:ps,sign:u3,signal:YH,sin:kk,sinh:Sk,slice:je,slice1d:vb,slice2d:Ik,slice3d:wb,slice4d:Ad,softmax:kb,softplus:Hc,spaceToBatchND:bb,sparse:ZH,sparseToDense:i6,spectral:XH,split:Qr,sqrt:Vn,square:It,squaredDifference:Ck,squeeze:yt,stack:Tr,step:qc,stridedSlice:c3,string:JH,sub:Ie,sum:Re,tan:h3,tanh:pl,tensor:Ls,tensor1d:dn,tensor2d:Bs,tensor3d:d3,tensor4d:zG,tensor5d:BG,tensor6d:WG,tensorScatterUpdate:VG,tile:Ds,topk:p3,transpose:ht,truncatedNormal:Ek,unique:f3,unsortedSegmentSum:$k,unstack:Gs,upperBound:XG,variable:m3,where:Un,whereAsync:g3,zeros:rn,zerosLike:dt},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const SX=(t,e,n,r=jn)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(I("a",t,e,n),I("b",t,e,n))];case"AddN":return[r.addN(I("tensors",t,e,n))];case"FloorMod":case"Mod":return[r.mod(I("a",t,e,n),I("b",t,e,n))];case"Mul":return[r.mul(I("a",t,e,n),I("b",t,e,n))];case"RealDiv":case"Div":return[r.div(I("a",t,e,n),I("b",t,e,n))];case"DivNoNan":return[r.divNoNan(I("a",t,e,n),I("b",t,e,n))];case"FloorDiv":return[r.floorDiv(I("a",t,e,n),I("b",t,e,n))];case"Sub":return[r.sub(I("a",t,e,n),I("b",t,e,n))];case"Minimum":return[r.minimum(I("a",t,e,n),I("b",t,e,n))];case"Maximum":return[r.maximum(I("a",t,e,n),I("b",t,e,n))];case"Pow":return[r.pow(I("a",t,e,n),I("b",t,e,n))];case"SquaredDifference":return[r.squaredDifference(I("a",t,e,n),I("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const IX=(t,e,n,r=jn)=>{switch(t.op){case"Abs":case"ComplexAbs":return[r.abs(I("x",t,e,n))];case"Acos":return[r.acos(I("x",t,e,n))];case"Acosh":return[r.acosh(I("x",t,e,n))];case"Asin":return[r.asin(I("x",t,e,n))];case"Asinh":return[r.asinh(I("x",t,e,n))];case"Atan":return[r.atan(I("x",t,e,n))];case"Atan2":return[r.atan2(I("x",t,e,n),I("y",t,e,n))];case"Atanh":return[r.atanh(I("x",t,e,n))];case"Ceil":return[r.ceil(I("x",t,e,n))];case"Complex":return[r.complex(I("real",t,e,n),I("imag",t,e,n))];case"Cos":return[r.cos(I("x",t,e,n))];case"Cosh":return[r.cosh(I("x",t,e,n))];case"Elu":return[r.elu(I("x",t,e,n))];case"Erf":return[r.erf(I("x",t,e,n))];case"Exp":return[r.exp(I("x",t,e,n))];case"Expm1":return[r.expm1(I("x",t,e,n))];case"Floor":return[r.floor(I("x",t,e,n))];case"Log":return[r.log(I("x",t,e,n))];case"Log1p":return[r.log1p(I("x",t,e,n))];case"Imag":return[r.imag(I("x",t,e,n))];case"Neg":return[r.neg(I("x",t,e,n))];case"Reciprocal":return[r.reciprocal(I("x",t,e,n))];case"Real":return[r.real(I("x",t,e,n))];case"Relu":return[r.relu(I("x",t,e,n))];case"Round":return[r.round(I("x",t,e,n))];case"Selu":return[r.selu(I("x",t,e,n))];case"Sigmoid":return[r.sigmoid(I("x",t,e,n))];case"Sin":return[r.sin(I("x",t,e,n))];case"Sign":return[r.sign(I("x",t,e,n))];case"Sinh":return[r.sinh(I("x",t,e,n))];case"Softplus":return[r.softplus(I("x",t,e,n))];case"Sqrt":return[r.sqrt(I("x",t,e,n))];case"Square":return[r.square(I("x",t,e,n))];case"Tanh":return[r.tanh(I("x",t,e,n))];case"Tan":return[r.tan(I("x",t,e,n))];case"ClipByValue":return[r.clipByValue(I("x",t,e,n),I("clipValueMin",t,e,n),I("clipValueMax",t,e,n))];case"Relu6":return[r.relu6(I("x",t,e,n))];case"Rsqrt":return[r.rsqrt(zn(t.inputNames[0],e,n))];case"LeakyRelu":return[r.leakyRelu(I("x",t,e,n),I("alpha",t,e,n))];case"Prelu":return[r.prelu(I("x",t,e,n),I("alpha",t,e,n))];case"IsNan":return[r.isNaN(zn(t.inputNames[0],e,n))];case"IsInf":return[r.isInf(zn(t.inputNames[0],e,n))];case"IsFinite":return[r.isFinite(zn(t.inputNames[0],e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Es(t,e,n=""){if(!(typeof t=="number"||typeof e=="number")){R(t.length===e.length,()=>n+` Shapes ${t} and ${e} must match`);for(let r=0;r<t.length;r++){const s=t[r],a=e[r];R(s<0||a<0||s===a,()=>n+` Shapes ${t} and ${e} must match`)}}}function WN(t){return!(typeof t=="number"||t.some(e=>e<0))}function Eh(t,e,n){let r=bv(t,n);const s=!WN(r);if(s&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&e.forEach(a=>{r=bv(a.shape,r)}),!WN(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function bv(t,e){if(typeof t=="number")return e;if(typeof e=="number")return t;if(t.length!==e.length)throw new Error(`Incompatible ranks during merge: ${t} vs. ${e}`);const n=[];for(let r=0;r<t.length;++r){const s=t[r],a=e[r];if(s>=0&&a>=0&&s!==a)throw new Error(`Incompatible shape during merge: ${t} vs. ${e}`);n[r]=s>=0?s:a}return n}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class NX{constructor(e,n,r,s,a,i,o){this.name=e,this.dtype=n,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=a,this.dynamicSize=i,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=Me(0),An(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.tensor.id))&&n.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const n=this.tensors[e];if(n.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(n.cleared=!0),n.read=!0,n.tensor}readMany(e){return e.map(n=>this.read(n))}write(e,n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[e]||{};if(n.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${n.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=n.shape),Es(this.elementShape,n.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);r.tensor=n,An(n),r.written=!0,this.tensors[e]=r}writeMany(e,n){if(e.length!==n.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${n.length}.`);e.forEach((r,s)=>this.write(r,n[s]))}gather(e,n){if(n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${n}`);if(e)e=e.slice(0,this.size());else{e=[];for(let s=0;s<this.size();s++)e.push(s)}if(e.length===0)return Ls([],[0].concat(this.elementShape));const r=this.readMany(e);return Es(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),Tr(r,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Ls([],[0].concat(this.elementShape));const n=[];for(let s=0;s<this.size();s++)n.push(s);const r=this.readMany(n);return Es(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),qt(r,0)}scatter(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const r=Math.max(...e);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(e,Gs(n,0))}split(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);let r=0;const s=e.map(l=>(r+=l,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const a=r===0?0:n.size/r,i=[];Y(()=>{n=j(n,[1,r,a]);for(let l=0;l<e.length;++l){const u=[0,l===0?0:s[l-1],0],c=[1,e[l],a];i[l]=j(je(n,u,c),this.elementShape)}return i});const o=[];for(let l=0;l<e.length;l++)o[l]=l;this.writeMany(o,i)}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class gl{get id(){return this.idTensor.id}constructor(e,n,r,s=-1){this.tensors=e,this.elementShape=n,this.elementDtype=r,e!=null&&e.forEach(a=>{if(r!==a.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${a.dtype}`);Es(n,a.shape,"TensorList shape mismatch: "),An(a)}),this.idTensor=Me(0),this.maxNumElements=s,An(this.idTensor)}copy(){return new gl([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,n,r=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);Es(e,this.elementShape,"TensorList shape mismatch: ");const s=Eh(this.elementShape,this.tensors,e);return Y(()=>{const a=this.tensors.map(i=>j(i,s));return Tr(a,0)})}popBack(e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const r=Eh(this.elementShape,this.tensors,e),s=this.tensors.pop();return s.kept=!1,Es(s.shape,e,"TensorList shape mismatch: "),j(s,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Es(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");An(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const n=new gl([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=e;for(let r=0;r<Math.min(this.tensors.length,e);++r)n.tensors[r]=this.tensors[r];return n}getItem(e,n,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Es(this.tensors[e].shape,n,"TensorList shape mismatch: ");const s=Eh(this.elementShape,this.tensors,n);return j(this.tensors[e],s)}setItem(e,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Es(this.elementShape,n.shape,"TensorList shape mismatch: "),An(n),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=n}gather(e,n,r){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);Es(this.elementShape,r,"TensorList shape mismatch: "),e=e.slice(0,this.size());const s=Eh(this.elementShape,this.tensors,r);return e.length===0?Ls([],[0].concat(s)):Y(()=>{const a=e.map(i=>j(this.tensors[i],s));return Tr(a,0)})}concat(e,n){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Es(this.elementShape,n,"TensorList shape mismatch: ");const r=Eh(this.elementShape,this.tensors,n);return this.size()===0?Ls([],[0].concat(r)):Y(()=>{const s=this.tensors.map(a=>j(a,r));return qt(s,0)})}}function CX(t,e,n){const r=t.dtype;if(t.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);if(t.dtype!==n)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${n}`);const s=t.shape.slice(1);Es(s,e,"TensorList shape mismatch: ");const a=Gs(t);return new gl(a,e,r)}function TX(t,e,n,r){return new gl([],t,e,r)}function EX(t,e,n,r){if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const a=new gl([],n,t.dtype,r),i=Gs(t,0);return e.forEach((o,l)=>{a.setItem(o,i[l])}),a}function $X(t,e,n){let r=0;const s=e.map(c=>(r+=c,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);const a=t.shape.slice(1),i=bv(a,n),o=r===0?0:t.size/r,l=Y(()=>{const c=[];t=j(t,[1,r,o]);for(let h=0;h<e.length;++h){const d=[0,h===0?0:s[h-1],0],p=[1,e[h],o];c[h]=j(je(t,d,p),i)}return t.dispose(),c}),u=new gl([],n,t.dtype,e.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const RX=async(t,e,n)=>{switch(t.op){case"If":case"StatelessIf":{const r=I("thenBranch",t,e,n),s=I("elseBranch",t,e,n),a=I("cond",t,e,n),i=I("args",t,e,n);return(await a.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=I("body",t,e,n),s=I("cond",t,e,n),a=I("args",t,e,n),i=await n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),o=a.map(c=>c.id);let l=await i[0].data();i.forEach(c=>{!c.kept&&o.indexOf(c.id)===-1&&c.dispose()});let u=a;for(;l[0];){const c=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);const h=u.map(p=>p.id);c.forEach(p=>{!p.kept&&o.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()});const d=await n.functionMap[s].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await d[0].data(),d.forEach(p=>{!p.kept&&o.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()})}return u}case"LoopCond":{const r=I("pred",t,e,n);return[ei(r)]}case"Switch":{const r=I("pred",t,e,n);let s=I("data",t,e,n);return s.kept||(s=ei(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=t.inputNames.find(s=>zn(s,e,n)!==void 0);if(r){const s=zn(r,e,n);return[ei(s)]}return}case"Enter":{const r=I("frameName",t,e,n),s=I("tensor",t,e,n);return n.enterFrame(r),[ei(s)]}case"Exit":{const r=I("tensor",t,e,n);return n.exitFrame(),[ei(r)]}case"NextIteration":{const r=I("tensor",t,e,n);return n.nextIteration(),[ei(r)]}case"TensorArrayV3":{const r=I("size",t,e,n),s=I("dtype",t,e,n),a=I("elementShape",t,e,n),i=I("dynamicSize",t,e,n),o=I("clearAfterRead",t,e,n),l=I("identicalElementShapes",t,e,n),u=I("name",t,e,n),c=new NX(u,s,r,a,l,i,o);return n.addTensorArray(c),[c.idTensor,Me(1)]}case"TensorArrayWriteV3":{const r=I("tensorArrayId",t,e,n),s=I("index",t,e,n),a=I("tensor",t,e,n),i=n.getTensorArray(r.id);return i.write(s,a),[i.idTensor]}case"TensorArrayReadV3":{const r=I("tensorArrayId",t,e,n),s=I("index",t,e,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=I("tensorArrayId",t,e,n),s=I("indices",t,e,n),a=I("dtype",t,e,n);return[n.getTensorArray(r.id).gather(s,a)]}case"TensorArrayScatterV3":{const r=I("tensorArrayId",t,e,n),s=I("indices",t,e,n),a=I("tensor",t,e,n),i=n.getTensorArray(r.id);return i.scatter(s,a),[i.idTensor]}case"TensorArrayConcatV3":{const r=I("tensorArrayId",t,e,n),s=n.getTensorArray(r.id),a=I("dtype",t,e,n);return[s.concat(a)]}case"TensorArraySplitV3":{const r=I("tensorArrayId",t,e,n),s=I("tensor",t,e,n),a=I("lengths",t,e,n),i=n.getTensorArray(r.id);return i.split(a,s),[i.idTensor]}case"TensorArraySizeV3":{const r=I("tensorArrayId",t,e,n),s=n.getTensorArray(r.id);return[Me(s.size(),"int32")]}case"TensorArrayCloseV3":{const r=I("tensorArrayId",t,e,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=I("tensorListId",t,e,n),s=I("index",t,e,n),a=I("tensor",t,e,n),i=n.getTensorList(r.id);return i.setItem(s,a),[i.idTensor]}case"TensorListGetItem":{const r=I("tensorListId",t,e,n),s=I("index",t,e,n),a=I("elementShape",t,e,n),i=I("elementDType",t,e,n);return[n.getTensorList(r.id).getItem(s,a,i)]}case"TensorListScatterV2":case"TensorListScatter":{const r=I("indices",t,e,n),s=I("tensor",t,e,n),a=I("elementShape",t,e,n),i=I("numElements",t,e,n),o=EX(s,r,a,i);return n.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=I("elementShape",t,e,n),s=I("elementDType",t,e,n);let a;t.op==="TensorListReserve"?a="numElements":a="maxNumElements";const i=I(a,t,e,n),o=t.op==="TensorListReserve"?-1:i,l=TX(r,s,i,o);return n.addTensorList(l),[l.idTensor]}case"TensorListGather":{const r=I("tensorListId",t,e,n),s=I("indices",t,e,n),a=I("elementShape",t,e,n),i=I("elementDType",t,e,n);return[n.getTensorList(r.id).gather(s,i,a)]}case"TensorListStack":{const r=I("tensorListId",t,e,n),s=I("elementShape",t,e,n),a=I("elementDType",t,e,n),i=I("numElements",t,e,n);return[n.getTensorList(r.id).stack(s,a,i)]}case"TensorListFromTensor":{const r=I("tensor",t,e,n),s=I("elementShape",t,e,n),a=I("elementDType",t,e,n),i=CX(r,s,a);return n.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=I("tensorListId",t,e,n),s=n.getTensorList(r.id),a=I("dtype",t,e,n),i=I("elementShape",t,e,n);return[s.concat(a,i)]}case"TensorListPushBack":{const r=I("tensorListId",t,e,n),s=I("tensor",t,e,n),a=n.getTensorList(r.id);return a.pushBack(s),[a.idTensor]}case"TensorListPopBack":{const r=I("tensorListId",t,e,n),s=I("elementShape",t,e,n),a=I("elementDType",t,e,n);return[n.getTensorList(r.id).popBack(s,a)]}case"TensorListSplit":{const r=I("tensor",t,e,n),s=I("elementShape",t,e,n),a=I("lengths",t,e,n),i=$X(r,a,s);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{const r=I("tensorListId",t,e,n),s=n.getTensorList(r.id);return[Me(s.size(),"int32")]}case"TensorListResize":{const r=I("tensorListId",t,e,n),s=I("size",t,e,n),a=n.getTensorList(r.id).resize(s);return n.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function UN(t,e,n){const[r,s]=I("fusedOps",t,e,n),a=r==="biasadd",i=!a,o=s==="prelu",l=r==="fusedbatchnorm",u=I("numArgs",t,e,n);if(a){if(o&&u!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&a&&u!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=I("strides",t,e,n),h=Nm(t,e,n),d=I("dataFormat",t,e,n).toUpperCase(),p=I("dilations",t,e,n);let[f,m]=I("args",t,e,n);i&&(m=f,f=void 0);const y=I("leakyreluAlpha",t,e,n);return{stride:c,pad:h,dataFormat:d,dilations:p,biasArg:f,preluArg:m,activationFunc:s,leakyreluAlpha:y}}const AX=(t,e,n,r=jn)=>{switch(t.op){case"Conv1D":{const s=I("stride",t,e,n),a=I("pad",t,e,n),i=I("dataFormat",t,e,n).toUpperCase(),o=I("dilation",t,e,n);return[r.conv1d(I("x",t,e,n),I("filter",t,e,n),s,a,i,o)]}case"Conv2D":{const s=I("strides",t,e,n),a=Nm(t,e,n),i=I("dataFormat",t,e,n).toUpperCase(),o=I("dilations",t,e,n);return[r.conv2d(I("x",t,e,n),I("filter",t,e,n),[s[1],s[2]],a,i,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:h}=UN(t,e,n);return[r.fused.conv2d({x:I("x",t,e,n),filter:I("filter",t,e,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:h}=UN(t,e,n);return[r.fused.depthwiseConv2d({x:I("x",t,e,n),filter:I("filter",t,e,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=I("outputShape",t,e,n),a=I("strides",t,e,n),i=Nm(t,e,n);return[r.conv2dTranspose(I("x",t,e,n),I("filter",t,e,n),s,[a[1],a[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=I("strides",t,e,n),a=Nm(t,e,n),i=I("dilations",t,e,n),o=I("dataFormat",t,e,n).toUpperCase();return[r.depthwiseConv2d(I("input",t,e,n),I("filter",t,e,n),[s[1],s[2]],a,o,[i[1],i[2]])]}case"Conv3D":{const s=I("strides",t,e,n),a=I("pad",t,e,n),i=I("dataFormat",t,e,n).toUpperCase(),o=I("dilations",t,e,n);return[r.conv3d(I("x",t,e,n),I("filter",t,e,n),[s[1],s[2],s[3]],a,i,[o[1],o[2],o[3]])]}case"AvgPool":{const s=I("strides",t,e,n),a=I("pad",t,e,n),i=I("kernelSize",t,e,n);return[r.avgPool(I("x",t,e,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPool":{const s=I("strides",t,e,n),a=I("pad",t,e,n),i=I("kernelSize",t,e,n);return[r.maxPool(I("x",t,e,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPoolWithArgmax":{const s=I("strides",t,e,n),a=I("pad",t,e,n),i=I("kernelSize",t,e,n),o=I("includeBatchInIndex",t,e,n),{result:l,indexes:u}=r.maxPoolWithArgmax(I("x",t,e,n),[i[1],i[2]],[s[1],s[2]],a,o);return[l,u]}case"AvgPool3D":{const s=I("strides",t,e,n),a=I("pad",t,e,n),i=I("kernelSize",t,e,n);return[r.avgPool3d(I("x",t,e,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"MaxPool3D":{const s=I("strides",t,e,n),a=I("pad",t,e,n),i=I("kernelSize",t,e,n);return[r.maxPool3d(I("x",t,e,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"Dilation2D":{const s=I("strides",t,e,n),a=I("pad",t,e,n),i=I("dilations",t,e,n),o=s[1],l=s[2],u=i[1],c=i[2];return[r.dilation2d(I("x",t,e,n),I("filter",t,e,n),[o,l],a,[u,c],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const _X=(t,e,n,r=jn)=>{switch(t.op){case"Fill":{const s=I("shape",t,e,n),a=I("dtype",t,e,n),i=I("value",t,e,n);return[r.fill(s,i,a)]}case"LinSpace":{const s=I("start",t,e,n),a=I("stop",t,e,n),i=I("num",t,e,n);return[r.linspace(s,a,i)]}case"Multinomial":{const s=I("logits",t,e,n),a=I("numSamples",t,e,n),i=I("seed",t,e,n);return[r.multinomial(s,a,i)]}case"OneHot":{const s=I("indices",t,e,n),a=I("depth",t,e,n),i=I("onValue",t,e,n),o=I("offValue",t,e,n),l=I("dtype",t,e,n);return[r.oneHot(s,a,i,o,l)]}case"Ones":return[r.ones(I("shape",t,e,n),I("dtype",t,e,n))];case"OnesLike":return[r.onesLike(I("x",t,e,n))];case"RandomStandardNormal":return[r.randomStandardNormal(I("shape",t,e,n),I("dtype",t,e,n),I("seed",t,e,n))];case"RandomUniform":return[r.randomUniform(I("shape",t,e,n),I("minval",t,e,n),I("maxval",t,e,n),I("dtype",t,e,n))];case"RandomUniformInt":return[r.randomUniformInt(I("shape",t,e,n),I("minval",t,e,n),I("maxval",t,e,n),I("seed",t,e,n))];case"Range":{const s=I("start",t,e,n),a=I("stop",t,e,n),i=I("step",t,e,n);return[r.range(s,a,i,I("dtype",t,e,n))]}case"TruncatedNormal":{const s=I("shape",t,e,n),a=I("mean",t,e,n),i=I("stdDev",t,e,n),o=I("seed",t,e,n);return[r.truncatedNormal(s,a,i,I("dtype",t,e,n),o)]}case"Zeros":return[r.zeros(I("shape",t,e,n),I("dtype",t,e,n))];case"ZerosLike":return[r.zerosLike(I("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Cx(t,e,n){const r=I("boxes",t,e,n),s=I("scores",t,e,n),a=I("maxOutputSize",t,e,n),i=I("iouThreshold",t,e,n),o=I("scoreThreshold",t,e,n),l=I("softNmsSigma",t,e,n);return{boxes:r,scores:s,maxOutputSize:a,iouThreshold:i,scoreThreshold:o,softNmsSigma:l}}const FX=async(t,e,n,r,s=jn)=>{switch(t.op){case"NonMaxSuppressionV5":{const{boxes:a,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u,softNmsSigma:c}=Cx(t,e,n),h=await s.image.nonMaxSuppressionWithScoreAsync(a,i,o,l,u,c);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:a,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=Cx(t,e,n),c=I("padToMaxOutputSize",t,e,n),h=await s.image.nonMaxSuppressionPaddedAsync(a,i,o,l,u,c);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:a,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=Cx(t,e,n);return[await s.image.nonMaxSuppressionAsync(a,i,o,l,u)]}case"Where":{const a=s.cast(I("condition",t,e,n),"bool"),i=[await s.whereAsync(a)];return a.dispose(),i}case"ListDiff":return s.setdiff1dAsync(I("x",t,e,n),I("y",t,e,n));default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const OX=(t,e,n,r=jn)=>{switch(t.op){case"LowerBound":{const s=I("sortedSequence",t,e,n),a=I("values",t,e,n);return[r.lowerBound(s,a)]}case"TopKV2":{const s=I("x",t,e,n),a=I("k",t,e,n),i=I("sorted",t,e,n),o=r.topk(s,a,i);return[o.values,o.indices]}case"UpperBound":{const s=I("sortedSequence",t,e,n),a=I("values",t,e,n);return[r.upperBound(s,a)]}case"Unique":{const s=I("x",t,e,n),a=r.unique(s);return[a.values,a.indices]}case"UniqueV2":{const s=I("x",t,e,n),a=I("axis",t,e,n),i=r.unique(s,a);return[i.values,i.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const DX=(t,e,n,r=jn)=>{switch(t.op){case"Const":return e[t.name];case"PlaceholderWithDefault":const s=I("default",t,e,n);return[zn(t.name,e,n)||s];case"Placeholder":return[zn(t.name,e,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const c=I("x",t,e,n);return[ei(c)]}case"IdentityN":return I("x",t,e,n).map(c=>ei(c));case"Snapshot":const a=I("x",t,e,n);return[ei(a)];case"Shape":return[r.tensor1d(I("x",t,e,n).shape,"int32")];case"ShapeN":return I("x",t,e,n).map(c=>r.tensor1d(c.shape));case"Size":return[r.scalar(I("x",t,e,n).size,"int32")];case"Rank":return[r.scalar(I("x",t,e,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const i=I("x",t,e,n),o=I("data",t,e,n),l=I("message",t,e,n),u=I("summarize",t,e,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let c=0;c<o.length;c++)console.log(Array.prototype.slice.call(o[c].dataSync()).slice(0,u));return[i];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class MX{get id(){return this.handle.id}constructor(e,n){this.keyDType=e,this.valueDType=n,this.handle=Me(0),this.tensorMap=new Map,An(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Me(this.size(),"int32")}async import(e,n){this.checkKeyAndValueTensor(e,n);const r=await e.data();return this.tensorMap.forEach(s=>s.dispose()),this.tensorMap.clear(),Y(()=>{const s=Gs(n),a=r.length,i=s.length;R(a===i,()=>`The number of elements doesn't match, keys has ${a} elements, the values has ${i} elements.`);for(let o=0;o<a;o++){const l=r[o],u=s[o];An(u),this.tensorMap.set(l,u)}return this.handle})}async find(e,n){this.checkKeyAndValueTensor(e,n);const r=await e.data();return Y(()=>{const s=[];for(let a=0;a<r.length;a++){const i=r[a],o=this.findWithDefault(i,n);s.push(o)}return Tr(s)})}findWithDefault(e,n){return this.tensorMap.get(e)??n}checkKeyAndValueTensor(e,n){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(n.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${n.dtype}`)}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const PX=async(t,e,n,r)=>{switch(t.op){case"HashTable":case"HashTableV2":{const s=r.getHashTableHandleByName(t.name);if(s!=null)return[s];{const a=I("keyDType",t,e,n),i=I("valueDType",t,e,n),o=new MX(a,i);return r.addHashTable(t.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const s=I("tableHandle",t,e,n,r),a=I("keys",t,e,n),i=I("values",t,e,n);return[await r.getHashTableById(s.id).import(a,i)]}case"LookupTableFind":case"LookupTableFindV2":{const s=I("tableHandle",t,e,n,r),a=I("keys",t,e,n),i=I("defaultValue",t,e,n);return[await r.getHashTableById(s.id).find(a,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=I("tableHandle",t,e,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const LX=(t,e,n,r=jn)=>{switch(t.op){case"ResizeBilinear":{const s=I("images",t,e,n),a=I("size",t,e,n),i=I("alignCorners",t,e,n),o=I("halfPixelCenters",t,e,n);return[r.image.resizeBilinear(s,[a[0],a[1]],i,o)]}case"ResizeNearestNeighbor":{const s=I("images",t,e,n),a=I("size",t,e,n),i=I("alignCorners",t,e,n),o=I("halfPixelCenters",t,e,n);return[r.image.resizeNearestNeighbor(s,[a[0],a[1]],i,o)]}case"CropAndResize":{const s=I("image",t,e,n),a=I("boxes",t,e,n),i=I("boxInd",t,e,n),o=I("cropSize",t,e,n),l=I("method",t,e,n),u=I("extrapolationValue",t,e,n);return[r.image.cropAndResize(s,a,i,o,l,u)]}case"ImageProjectiveTransformV3":{const s=I("images",t,e,n),a=I("transforms",t,e,n),i=I("outputShape",t,e,n),o=I("fillValue",t,e,n),l=I("interpolation",t,e,n),u=I("fillMode",t,e,n);return[r.image.transform(s,a,l.toLowerCase(),u.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const zX=(t,e,n,r=jn)=>{switch(t.op){case"Equal":return[r.equal(I("a",t,e,n),I("b",t,e,n))];case"NotEqual":return[r.notEqual(I("a",t,e,n),I("b",t,e,n))];case"Greater":return[r.greater(I("a",t,e,n),I("b",t,e,n))];case"GreaterEqual":return[r.greaterEqual(I("a",t,e,n),I("b",t,e,n))];case"Less":return[r.less(I("a",t,e,n),I("b",t,e,n))];case"LessEqual":return[r.lessEqual(I("a",t,e,n),I("b",t,e,n))];case"LogicalAnd":return[r.logicalAnd(I("a",t,e,n),I("b",t,e,n))];case"LogicalNot":return[r.logicalNot(I("a",t,e,n))];case"LogicalOr":return[r.logicalOr(I("a",t,e,n),I("b",t,e,n))];case"Select":case"SelectV2":return[r.where(I("condition",t,e,n),I("a",t,e,n),I("b",t,e,n))];case"BitwiseAnd":return[r.bitwiseAnd(I("a",t,e,n),I("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const BX=(t,e,n,r=jn)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(I("a",t,e,n),I("b",t,e,n),I("transposeA",t,e,n),I("transposeB",t,e,n))];case"Einsum":return[r.einsum(I("equation",t,e,n),...I("tensors",t,e,n))];case"Transpose":return[r.transpose(I("x",t,e,n),I("perm",t,e,n))];case"_FusedMatMul":const[s,a]=I("fusedOps",t,e,n),i=s==="biasadd",o=a==="prelu",l=I("numArgs",t,e,n),u=I("leakyreluAlpha",t,e,n);if(i){if(o&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,h]=I("args",t,e,n);return[r.fused.matMul({a:I("a",t,e,n),b:I("b",t,e,n),transposeA:I("transposeA",t,e,n),transposeB:I("transposeB",t,e,n),bias:c,activation:a,preluActivationWeights:h,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(I("a",t,e,n),I("numLower",t,e,n),I("numUpper",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const WX=(t,e,n,r=jn)=>{switch(t.op){case"EuclideanNorm":return[r.euclideanNorm(I("x",t,e,n),I("axis",t,e,n),I("keepDims",t,e,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(I("x",t,e,n),I("mean",t,e,n),I("variance",t,e,n),I("offset",t,e,n),I("scale",t,e,n),I("epsilon",t,e,n))];case"FusedBatchNormV3":return[r.batchNorm(I("x",t,e,n),I("mean",t,e,n),I("variance",t,e,n),I("offset",t,e,n),I("scale",t,e,n),I("epsilon",t,e,n))];case"LRN":return[r.localResponseNormalization(I("x",t,e,n),I("radius",t,e,n),I("bias",t,e,n),I("alpha",t,e,n),I("beta",t,e,n))];case"Softmax":return[r.softmax(I("x",t,e,n))];case"LogSoftmax":return[r.logSoftmax(I("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const UX=(t,e,n,r=jn)=>{switch(t.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:a}=r.raggedGather(I("paramsNestedSplits",t,e,n),I("paramsDenseValues",t,e,n),I("indices",t,e,n),I("outputRaggedRank",t,e,n));return s.concat(a)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:a}=r.raggedRange(I("starts",t,e,n),I("limits",t,e,n),I("splits",t,e,n));return[s,a]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(I("shape",t,e,n),I("values",t,e,n),I("defaultValue",t,e,n),I("rowPartitionTensors",t,e,n),I("rowPartitionTypes",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const VX=(t,e,n,r=jn)=>{switch(t.op){case"Max":{const o=I("axis",t,e,n),l=I("keepDims",t,e,n);return[r.max(I("x",t,e,n),o,l)]}case"Mean":{const o=I("axis",t,e,n),l=I("keepDims",t,e,n);return[r.mean(I("x",t,e,n),o,l)]}case"Min":{const o=I("axis",t,e,n),l=I("keepDims",t,e,n);return[r.min(I("x",t,e,n),o,l)]}case"Sum":{const o=I("axis",t,e,n),l=I("keepDims",t,e,n);return[r.sum(I("x",t,e,n),o,l)]}case"All":{const o=I("axis",t,e,n),l=I("keepDims",t,e,n);return[r.all(I("x",t,e,n),o,l)]}case"Any":{const o=I("axis",t,e,n),l=I("keepDims",t,e,n);return[r.any(I("x",t,e,n),o,l)]}case"ArgMax":{const o=I("axis",t,e,n);return[r.argMax(I("x",t,e,n),o)]}case"ArgMin":{const o=I("axis",t,e,n);return[r.argMin(I("x",t,e,n),o)]}case"Prod":{const o=I("axis",t,e,n),l=I("keepDims",t,e,n);return[r.prod(I("x",t,e,n),o,l)]}case"Cumprod":{const o=I("axis",t,e,n),l=I("exclusive",t,e,n),u=I("reverse",t,e,n);return[r.cumprod(I("x",t,e,n),o,l,u)]}case"Cumsum":{const o=I("axis",t,e,n),l=I("exclusive",t,e,n),u=I("reverse",t,e,n);return[r.cumsum(I("x",t,e,n),o,l,u)]}case"Bincount":const s=I("x",t,e,n),a=I("weights",t,e,n),i=I("size",t,e,n);return[r.bincount(s,a,i)];case"DenseBincount":{const o=I("x",t,e,n),l=I("weights",t,e,n),u=I("size",t,e,n),c=I("binaryOutput",t,e,n);return[r.denseBincount(o,l,u,c)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const jX=(t,e,n,r=jn)=>{switch(t.op){case"ConcatV2":case"Concat":{const s=I("n",t,e,n),a=I("axis",t,e,n);let i=I("tensors",t,e,n);return i=i.slice(0,s),[r.concat(i,a)]}case"Gather":{const s=I("x",t,e,n),a=I("indices",t,e,n);return[r.gather(s,r.cast(a,"int32"),0)]}case"GatherV2":{const s=I("axis",t,e,n),a=I("batchDims",t,e,n),i=I("x",t,e,n),o=I("indices",t,e,n);return[r.gather(i,r.cast(o,"int32"),s,a)]}case"Reverse":{const s=I("dims",t,e,n),a=[];for(let o=0;o<s.length;o++)s[o]&&a.push(o);const i=I("x",t,e,n);return[r.reverse(i,a)]}case"ReverseV2":{const s=I("axis",t,e,n),a=I("x",t,e,n);return[r.reverse(a,s)]}case"Slice":{const s=I("begin",t,e,n),a=I("size",t,e,n);return[r.slice(I("x",t,e,n),s,a)]}case"StridedSlice":{const s=I("begin",t,e,n),a=I("end",t,e,n),i=I("strides",t,e,n),o=I("beginMask",t,e,n),l=I("endMask",t,e,n),u=I("ellipsisMask",t,e,n),c=I("newAxisMask",t,e,n),h=I("shrinkAxisMask",t,e,n),d=I("x",t,e,n);return[r.stridedSlice(d,s,a,i,o,l,u,c,h)]}case"Pack":return Y(()=>{const s=I("axis",t,e,n),a=I("tensors",t,e,n),i=a[0].shape,o=r.squeeze(a[0]).shape,l=a.map(u=>{const c=Je(u.shape,i);if(!c&&!Je(r.squeeze(u).shape,o))throw new Error("the input tensors shape does not match");return c?u:r.reshape(u,i)});return[r.stack(l,s)]});case"Unpack":{const s=I("axis",t,e,n),a=I("tensor",t,e,n);return r.unstack(a,s)}case"Tile":{const s=I("reps",t,e,n);return[r.tile(I("x",t,e,n),s)]}case"Split":case"SplitV":{const s=I("axis",t,e,n),a=I("numOrSizeSplits",t,e,n),i=I("x",t,e,n);return r.split(i,a,s)}case"ScatterNd":{const s=I("indices",t,e,n),a=I("values",t,e,n),i=I("shape",t,e,n);return[r.scatterND(s,a,i)]}case"GatherNd":{const s=I("x",t,e,n),a=I("indices",t,e,n);return[r.gatherND(s,a)]}case"SparseToDense":{const s=I("sparseIndices",t,e,n),a=I("outputShape",t,e,n),i=I("sparseValues",t,e,n),o=I("defaultValue",t,e,n);return[r.sparseToDense(s,i,a,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}case"TensorScatterUpdate":{const s=I("indices",t,e,n),a=I("values",t,e,n),i=I("tensor",t,e,n);return[r.tensorScatterUpdate(i,s,a)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const GX=(t,e,n,r=jn)=>{switch(t.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:a,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(I("indices",t,e,n),I("values",t,e,n),I("denseShape",t,e,n),I("defaultValue",t,e,n));return[s,a,i,o]}case"SparseReshape":{const{outputIndices:s,outputShape:a}=r.sparse.sparseReshape(I("inputIndices",t,e,n),I("inputShape",t,e,n),I("newShape",t,e,n));return[s,a]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(I("data",t,e,n),I("indices",t,e,n),I("segmentIds",t,e,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(I("data",t,e,n),I("indices",t,e,n),I("segmentIds",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const HX=(t,e,n,r=jn)=>{switch(t.op){case"FFT":return[r.fft(I("x",t,e,n))];case"IFFT":return[r.ifft(I("x",t,e,n))];case"RFFT":return[r.rfft(I("x",t,e,n))];case"IRFFT":return[r.irfft(I("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const KX=(t,e,n,r=jn)=>{switch(t.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(I("input",t,e,n),I("pattern",t,e,n),I("rewrite",t,e,n),I("replaceGlobal",t,e,n))];case"StringNGrams":{const{nGrams:s,nGramsSplits:a}=r.string.stringNGrams(I("data",t,e,n),I("dataSplits",t,e,n),I("separator",t,e,n),I("nGramWidths",t,e,n),I("leftPad",t,e,n),I("rightPad",t,e,n),I("padWidth",t,e,n),I("preserveShortSequences",t,e,n));return[s,a]}case"StringSplit":{const{indices:s,values:a,shape:i}=r.string.stringSplit(I("input",t,e,n),I("delimiter",t,e,n),I("skipEmpty",t,e,n));return[s,a,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(I("input",t,e,n),I("numBuckets",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const qX=(t,e,n,r=jn)=>{switch(t.op){case"Cast":return[r.cast(I("x",t,e,n),I("dtype",t,e,n))];case"ExpandDims":{const s=I("axis",t,e,n);return[r.expandDims(I("x",t,e,n),s)]}case"Squeeze":{const s=I("axis",t,e,n);return[r.squeeze(I("x",t,e,n),s)]}case"Reshape":return[r.reshape(I("x",t,e,n),I("shape",t,e,n))];case"EnsureShape":return[r.ensureShape(I("x",t,e,n),I("shape",t,e,n))];case"MirrorPad":return[r.mirrorPad(I("x",t,e,n),I("padding",t,e,n),I("mode",t,e,n))];case"PadV2":case"Pad":return[r.pad(I("x",t,e,n),I("padding",t,e,n),I("constantValue",t,e,n))];case"SpaceToBatchND":{const s=I("blockShape",t,e,n),a=I("paddings",t,e,n);return[r.spaceToBatchND(I("x",t,e,n),s,a)]}case"BatchToSpaceND":{const s=I("blockShape",t,e,n),a=I("crops",t,e,n);return[r.batchToSpaceND(I("x",t,e,n),s,a)]}case"DepthToSpace":{const s=I("blockSize",t,e,n),a=I("dataFormat",t,e,n).toUpperCase();return[r.depthToSpace(I("x",t,e,n),s,a)]}case"BroadcastTo":return[r.broadcastTo(I("x",t,e,n),I("shape",t,e,n))];case"BroadcastArgs":return[r.broadcastArgs(I("s0",t,e,n),I("s1",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function VN(t,e,n,r,s=Y){const a=((i,o,l)=>{switch(i.category){case"arithmetic":return s(()=>SX(i,o,l));case"basic_math":return s(()=>IX(i,o,l));case"control":return RX(i,o,l);case"convolution":return s(()=>AX(i,o,l));case"creation":return s(()=>_X(i,o,l));case"dynamic":return FX(i,o,l);case"evaluation":return s(()=>OX(i,o,l));case"image":return s(()=>LX(i,o,l));case"graph":return s(()=>DX(i,o,l));case"logical":return s(()=>zX(i,o,l));case"matrices":return s(()=>BX(i,o,l));case"normalization":return s(()=>WX(i,o,l));case"ragged":return s(()=>UX(i,o,l));case"reduction":return s(()=>VX(i,o,l));case"slice_join":return s(()=>jX(i,o,l));case"sparse":return s(()=>GX(i,o,l));case"spectral":return s(()=>HX(i,o,l));case"string":return s(()=>KX(i,o,l));case"transformation":return s(()=>qX(i,o,l));case"hash_table":return PX(i,o,l,r);case"custom":const u=PF(i.op);if(u&&u.customExecutor)return u.customExecutor(new kX(i,o,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,e,n);return di(a)?a.then(i=>[].concat(i)):[].concat(a)}class jN{constructor(e={},n={},r={},s={},a){this.weightMap=e,this.tensorArrayMap=n,this.tensorListMap=r,this.functionMap=s,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,n){return{id:e,frameName:n,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let n=0;n<this.contexts.length-1;n++){const r=this.contexts.slice(0,this.contexts.length-n);e.push(this.contextIdforContexts(r))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(n=>n.id===0&&n.iterationId===0?"":`${n.frameName}-${n.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const n in this.tensorArrayMap)this.tensorArrayMap[n].clearAndClose(e);for(const n in this.tensorListMap)this.tensorListMap[n].clearAndClose(e)}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function GN(t,e,n,r){const s=new Set,a=[];let i=null,o=null;const l=new Set,u=new Set(Object.keys(t).map(d=>Ur(d)[0]));r=r||[];const c=new Set(r.map(d=>Ur(d.name)[0])),h=[...e];for(;h.length>0;){const d=h.pop();if((Lo(d)||n9(d)||r9(d))&&i==null&&(i=d,o=i.children.map(p=>p.name).filter(p=>s.has(p))),s.add(d.name),n[d.name]==null&&!u.has(d.name)&&!c.has(d.name)){if(d.inputs.length===0){a.push(d.name);continue}d.inputs.forEach(p=>{l.has(p.name)||(l.add(p.name),h.push(p))})}}return{inputs:t,outputs:e,usedNodes:s,missingInputs:a,dynamicNode:i,syncInputs:o}}function XX(t,e){const{usedNodes:n,inputs:r}=e,s=Object.keys(r).map(y=>Ur(y)[0]).map(y=>t.nodes[y]),a=t.initNodes||[],i=y=>n.has(typeof y=="string"?y:y.name);function o(y){return[...new Map(y.map(g=>[g.name,g])).values()]}const l=o([...s,...t.weights,...a]).filter(i),u=o([...l,...Object.values(t.nodes)]).filter(i),c=new Map(u.map(y=>[y.name,y])),h={};for(const y of u){h[y.name]=h[y.name]||0;for(const g of y.children)i(g)||(h[g.name]=Number.POSITIVE_INFINITY),h[g.name]=(h[g.name]||0)+1}const d=Object.entries(h).filter(([,y])=>y===0).map(([y])=>y),p=[...d];for(;d.length>0;){const y=d.pop(),g=c.get(y);for(const b of g.children.filter(i))--h[b.name]===0&&(p.push(b.name),d.push(b.name))}const f=p.map(y=>c.get(y)),m=YX(f,l);return QX(m,l),m}function YX(t,e){const n=new Map(t.map(a=>[a.name,a])),r=e.map(a=>a.name),s=new Set(r);for(;r.length>0;){const a=r.pop(),i=n.get(a);for(const o of i.children)!n.has(o.name)||s.has(o.name)||(s.add(o.name),r.push(o.name))}return t.filter(a=>s.has(a.name))}class im extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function QX(t,e){const n=new Map(t.map((o,l)=>[o.name,l])),r=new Set(e.map(o=>o.name)),s=o=>r.has(typeof o=="string"?o:o.name),a=new Set(t.map(o=>o.name)),i=o=>a.has(typeof o=="string"?o:o.name);for(const o of t){for(const l of o.children.filter(i)){if(!n.has(l.name))throw new im(`Child ${l.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(l.name))throw new im(`Node ${o.name} is scheduled to run after its child ${l.name}.`)}if(!s(o))for(const l of o.inputs){if(!n.has(l.name))throw new im(`Input ${l.name} of node ${o.name} is unreachable.`);if(n.get(l.name)>n.get(o.name))throw new im(`Node ${o.name} is scheduled to run before its input ${l.name}.`)}}}function ZX(t){const e=new Map(t.map((o,l)=>[o.name,l])),n=Number.MAX_SAFE_INTEGER,r=t.map((o,l)=>Lo(o)?n:l),s=o=>r[e.get(o.name)]??-1,a=t.map((o,l)=>o.children.map(s).reduce((u,c)=>Math.max(u,c),r[l])),i=new Map;for(let o=0;o<t.length;++o){const l=a[o];if(l===n)continue;const u=t[o],c=t[l];i.has(c.name)||i.set(c.name,[]),i.get(c.name).push(u)}return i}const JX=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),e9=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),t9=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Lo(t){return JX.has(t.op)}function n9(t){return e9.has(t.op)}function r9(t){return t9.has(t.op)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Ng{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const n=Object.keys(e).map(r=>e[r].map(s=>s.id));this._weightIds=[].concat(...n),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const n=e.signatureKey||e.name;return e.defaultOutput?`${n}:${e.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((e,n)=>(e[n]=this._functions[n].signature,e),{})}constructor(e,n){this.graph=e,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(r=>{this._functionExecutorMap[r]=new Ng(e.functions[r],this)})}getCompilationKey(e,n){const r=e.map(a=>a.name).sort(),s=n.map(a=>a.name).sort();return r.join(this.SEPARATOR)+"--"+s.join(this.SEPARATOR)}compile(e,n){const r=GN(e,n,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:a,syncInputs:i}=r;if(a!=null)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(s.length>0){const u=n.map(h=>h.name),c=Object.keys(e);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${c}]. Missing the following inputs: [${s}]`)}const o=XX(this.graph,r),l=ZX(o);return{orderedNodes:o,nodeLiveUntilMap:l}}cloneAndKeepTensor(e){if(e==null)return null;const n=e.clone();return An(n),n}cloneTensorList(e){return e?e.map(n=>this.cloneAndKeepTensor(n)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([n,r])=>[n,this.cloneTensorList(r)]))}execute(e,n){this.disposeIntermediateTensors(),e=this.mapInputs(e);const r=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n);const s=r.map(d=>this.graph.nodes[Ur(d)[0]]),a=n.map(d=>Ur(d)[0]),i=new Set(a);let o=a.map(d=>this.graph.nodes[d]);o.length===0&&(o=this._outputs);const l=this.getCompilationKey(s,o);let u=this.compiledMap.get(l);u==null&&(u=this.compile(e,o),this.compiledMap.set(l,u));try{this.keepIntermediateTensors=Z().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const c={},h={};return Y(()=>{const d=new jN(this.weightMap,c,h,this.functionExecutorMap,this.parseNodeNameCache),p=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(g=>{const[b,v]=Ur(g,d),w=[];w[v]=e[g],p[b]=w,this.keepIntermediateTensors&&(this.clonedTensorsMap[b]=this.cloneTensorList(w))});const f=this.getFrozenTensorIds(p),{orderedNodes:m,nodeLiveUntilMap:y}=u;for(const g of m){if(p[g.name])continue;const b=VN(g,p,d,this._resourceManager);if(di(b))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);p[g.name]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[g.name]=this.cloneTensorList(b)),this.checkTensorForDisposalWithNodeLiveUntilInfo(g,p,d,f,i,y.get(g.name))}return this.parent==null&&d.dispose(f),n.map(g=>zn(g,p,d))})}getFrozenTensorIds(e){const n=[].concat.apply([],Object.keys(e).map(r=>e[r]).map(r=>r.map(s=>s.id)));return new Set(n)}checkTensorForDisposal(e,n,r,s,a,i,o){if(!(Lo(n)||i.has(e))){for(const l of r[e])l!=null&&(o[l.id]=(o[l.id]||0)+n.children.length);for(const l of n.inputs){if(Lo(l))continue;const u=LN(l.name,r,s);if(u!=null)for(const c of u){if(!c||c.kept||a.has(c.id))continue;const h=o[c.id];h===1?(c.dispose(),delete o[c.id]):h!=null&&o[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,n,r,s,a,i){function o(l){return Lo(l)||a.has(l.name)}if(!(Lo(e)||i==null))for(const l of i){if(o(l))continue;const u=LN(l.name,n,r);for(const c of u)!c||c.kept||s.has(c.id)||c.dispose()}}async executeAsync(e,n){return this._executeAsync(e,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const n of e)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,n,r=!1,s={},a={}){this.disposeIntermediateTensors(),r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=Z().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const i=new jN(this.weightMap,s,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const o=await this.executeWithControlFlow(e,i,n,r),l=n.map(d=>zn(d,o,i)),u=l.map(d=>d.id),c=Object.keys(e).map(d=>e[d].id),h=new Set([...u,...c,...this.weightIds]);return Object.values(o).forEach(d=>{d.forEach(p=>{p&&!p.isDisposed&&!h.has(p.id)&&p.dispose()})}),this.parent==null&&i.dispose(h),l}async executeFunctionAsync(e,n,r){const s=e.reduce((a,i,o)=>(a[this.inputs[o].name]=i,a),{});return this._executeAsync(s,this.outputNodes,!0,n,r)}async executeWithControlFlow(e,n,r,s){const a=Object.keys(e),i=a.map(w=>this.graph.nodes[Ur(w)[0]]),o=r.map(w=>Ur(w)[0]),l=new Set(o);let u=o.map(w=>this.graph.nodes[w]);u.length===0&&(u=this._outputs);const{usedNodes:c,missingInputs:h,dynamicNode:d,syncInputs:p}=GN(e,u,this.weightMap,this._initNodes),f=[...i,...this.graph.weights,...this._initNodes||[]].map(w=>({node:w,contexts:n.currentContext})),m=Object.assign({},this.weightMap);Object.keys(e).forEach(w=>{const[k,N]=Ur(w),T=[];T[N]=e[w],m[k]=T});const y={},g=this.getFrozenTensorIds(m),b={};for(;f.length>0;){const w=this.processStack(i,f,n,m,b,g,l,y,c);await Promise.all(w)}d==null&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const v=u.filter(w=>!Lo(w)&&!zn(w.name,m,n)).map(w=>w.name);if(v.length>0){let w="";throw d!=null&&(w=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${v}] from the provided inputs [${a}]. Consider providing the following inputs: [${h}]. ${w}`)}return m}processStack(e,n,r,s,a,i,o,l,u){const c=[];for(;n.length>0;){const h=n.pop();r.currentContext=h.contexts;let d="";if(h.node.op==="Enter"&&I("isConstant",h.node,s,r)&&([d]=Ja(h.node.name,r)),s[h.node.name]==null){const p=VN(h.node,s,r,this._resourceManager);d||([d]=Ja(h.node.name,r));const f=r.currentContext;di(p)?c.push(p.then(m=>(s[d]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(m)),r.currentContext=f,this.checkTensorForDisposal(d,h.node,s,r,i,o,l),this.processChildNodes(h.node,n,r,s,a,u),m))):(s[d]=p,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(p)),this.checkTensorForDisposal(d,h.node,s,r,i,o,l),this.processChildNodes(h.node,n,r,s,a,u))}else this.processChildNodes(h.node,n,r,s,a,u)}return c}processChildNodes(e,n,r,s,a,i){e.children.forEach(o=>{const[l]=Ja(o.name,r);a[l]||!i.has(o.name)||(o.op==="Merge"?o.inputNames.some(u=>!!zn(u,s,r))&&(a[l]=!0,n.push({contexts:r.currentContext,node:o})):o.inputNames.every(u=>!!zn(u,s,r))&&(a[l]=!0,n.push({contexts:r.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(n=>n.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(n=>{const r=e[n],[s]=Ur(n),a=this.graph.nodes[s];if(a.attrParams.shape&&a.attrParams.shape.value){const i=a.attrParams.shape.value,o=i.length===r.shape.length&&r.shape.every((l,u)=>i[u]===-1||i[u]===l);R(o,()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${i}], but was [${r.shape}]`)}a.attrParams.dtype&&a.attrParams.dtype.value&&R(r.dtype===a.attrParams.dtype.value,()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){var n,r;const s={};for(const a in e){const i=(r=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||r===void 0?void 0:r[a];i!=null?s[i.name]=e[a]:s[a]=e[a]}return s}checkInputs(e){const n=Object.keys(e).filter(r=>{const[s]=Ur(r);return this.graph.nodes[s]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(e){return e.map(n=>{var r,s;const a=(s=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||s===void 0?void 0:s[n];return a!=null?a.name:n},{})}checkOutputs(e){e.forEach(n=>{const[r]=Ur(n);if(!this.graph.nodes[r])throw new Error(`The output '${n}' is not found in the graph`)})}}class s9{constructor(e={},n={}){this.hashTableNameToHandle=e,this.hashTableMap=n}addHashTable(e,n){this.hashTableNameToHandle[e]=n.handle,this.hashTableMap[n.id]=n}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const a9="?tfjs-format=file",i9="model.json";class BF{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,n={},r=z3){this.modelUrl=e,this.loadOptions=n,this.version="n/a",this.io=r,n==null&&(this.loadOptions={}),this.resourceManager=new s9}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const n=this.io.getLoadHandlers(e,this.loadOptions);if(n.length===0)n.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(n.length>1)throw new Error(`Found more than one (${n.length}) load handlers for URL '${[e]}'`);this.handler=n[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return di(e)?e.then(n=>n.getWeightStream==null?this.loadSync(n):this.loadStreaming(n)):this.loadSync(e)}loadSync(e){const n=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,n)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const n=await rR(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,n)}loadWithWeightMap(e,n){this.artifacts=e;const r=this.artifacts.modelTopology;let s=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const a=this.artifacts.userDefinedMetadata;a.signature!=null&&(s=a.signature),a.structuredOutputKeys!=null&&(this.structuredOutputKeys=a.structuredOutputKeys)}if(this.signature=s,this.version=`${r.versions.producer}.${r.versions.minConsumer}`,this.executor=new Ng(zN.Instance.transformGraph(r,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(n),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const a=zN.Instance.transformGraph(e.modelInitializer);this.initializer=new Ng(a),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,n){if(typeof e=="string"){const r=this.io.getSaveHandlers(e);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const n=e instanceof st?[e]:e,r={};return n.forEach((s,a)=>r[this.structuredOutputKeys[a]]=s),r}return e}predict(e,n){const r=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(r)}async predictAsync(e,n){const r=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(r)}normalizeInputs(e){var n;if(!(e instanceof st)&&!Array.isArray(e)){const a=(n=this.signature)===null||n===void 0?void 0:n.inputs;if(a!=null)for(const i in a){const o=a[i];o.resourceId!=null&&(e[i]=this.resourceIdToCapturedInput[o.resourceId])}return e}e=Array.isArray(e)?e:[e];const r=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${e.length} input tensors provided.`);let s=0;return this.inputNodes.reduce((a,i)=>{var o,l,u;const c=(u=(l=(o=this.signature)===null||o===void 0?void 0:o.inputs)===null||l===void 0?void 0:l[i])===null||u===void 0?void 0:u.resourceId;return c!=null?a[i]=this.resourceIdToCapturedInput[c]:a[i]=e[s++],a},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const n=this.initializerSignature.outputs,r=Object.keys(n);for(let s=0;s<r.length;s++){const a=r[s],i=n[a];this.resourceIdToCapturedInput[i.resourceId]=e[s]}}}execute(e,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const r=this.executor.execute(e,n);return r.length>1?r:r[0]}async executeAsync(e,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const r=await this.executor.executeAsync(e,n);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((n,r)=>(n[r]=[e[r]],n),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Pe(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function Bu(t,e={},n=z3){if(t==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof t=="string"&&(t=o9(t));const r=new BF(t,e,n);return await r.load(),r}function Zke(t){if(t==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(t instanceof Array){const[r,s]=t;if(!r)throw new Error("modelJSON must be the first element of the array");if(!s||!(s instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in r))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in r))throw new Error("Model JSON is missing 'weightsManifest'");const a=hg(r.weightsManifest),i=Qw(r,a,s);e=fg(i)}else if("load"in t)e=t;else if("modelTopology"in t&&"weightSpecs"in t&&"weightData"in t)e=fg(t);else throw new Error("Unknown model format");const n=new BF(e);return n.load(),n}function o9(t){return t.endsWith("/")||(t=t+"/"),`${t}${i9}${a9}`}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* =============================================================================
*/function l9(t,e){return Cg(t,e)}function Cg(t,e,n=new Map,r=new Set){if(t==null)return null;if(typeof Blob=="function"&&t instanceof Blob)return t.slice();if(r.has(t))throw new Error("Circular references are not supported.");if(n.has(t))return n.get(t);const s=e(t);if(s.recurse&&s.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse)if(Wu(t)){const a=Array.isArray(t)?[]:{};r.add(t);for(const i in t){const o=t[i],l=Cg(o,e,n,r);a[i]=l}return r.delete(t),t.__proto__&&(a.__proto__=t.__proto__),a}else throw new Error(`Can't recurse into non-iterable type: ${t}`);else return n.set(t,s.value),s.value}function u9(t,e=UF){return WF(t,e)}function WF(t,e,n=new Set){const r=t[0];if(n.has(r))throw new Error("Circular references are not supported.");const s=e(t);if(s.recurse&&s.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse)if(Wu(r)){const a=Array.isArray(r)?[]:{};n.add(r);for(const i in r){const o=t.map(u=>u[i]),l=WF(o,e,n);a[i]=l}return n.delete(r),a}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return s.value}function UF(t){return t===null?null:Wu(t[0])?{value:null,recurse:!0}:{value:t,recurse:!1}}async function VF(t,e){const n=new Map;Cg(t,e,n);for(const r of Array.from(n.keys())){const s=n.get(r);if(di(s)){const a=await s;n.set(r,a)}}return Cg(t,e,n)}function Wu(t){let e=!1;if(Z().get("IS_BROWSER"))e=t instanceof TextDecoder;else{const{StringDecoder:n}=require("string_decoder");e=t instanceof n}return t!=null&&!ArrayBuffer.isView(t)&&(Array.isArray(t)||typeof t=="object"&&!(t instanceof st)&&!(t instanceof Promise)&&!e)}function c9(t){return t==null||h9(t)||Array.isArray(t)||typeof t=="object"&&t instanceof st||Zr(t)}function h9(t){return t===null||typeof t!="object"&&typeof t!="function"}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* =============================================================================
*/function d9(t){return l9(t,p9)}function p9(t){return t instanceof st?{value:t.clone(),recurse:!1}:Wu(t)?{value:null,recurse:!0}:{value:t,recurse:!1}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* =============================================================================
*/class jF{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,n){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=n}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const n of e)this.push(n)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const n=this.wrap(this.begin+e),r=this.get(n);return this.set(n,this.pop()),r}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* =============================================================================
*/class h0 extends jF{constructor(){super(h0.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=this.capacity*2,n=new Array(e),r=this.length();for(let s=0;s<r;s++)n[s]=this.get(this.wrap(this.begin+s));this.data=n,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=r}}h0.INITIAL_CAPACITY=32;/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* =============================================================================
*/function GF(t){return new y9(t)}function f9(t){return new b9(t)}function m9(t,e){return new HF(t,e)}function g9(t,e=Mi.FAIL){return new E9(t,e)}class Er{async toArray(){const e=[];let n=await this.next();for(;!n.done;)e.push(n.value),n=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),n=[];let r=await e.next();for(;!r.done;)n.push(r.value),r=await e.next();return n}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let n=await this.next(),r=e(n.value);for(;!n.done&&r;)n=await this.next(),r=e(n.value)}handleErrors(e){return new N9(this,e)}filter(e){return new S9(this,e)}map(e){return new I9(this,e)}mapAsync(e){return new HN(this,e)}serialMapAsync(e){return new HN(this,e).serial()}flatmap(e){return new T9(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(n=>n===!0)}rowMajorBatch(e,n=!0){return new k9(this,e,n)}columnMajorBatch(e,n=!0,r=UF){return this.rowMajorBatch(e,n).map(s=>u9(s,r))}concatenate(e,n){return new HF(GF([this,e]),n)}take(e){return e<0||e==null?this:new w9(this,e)}skip(e){return e<0||e==null?this:new v9(this,e)}prefetch(e){return new KF(this,e)}shuffle(e,n){return new $9(this,e,n)}serial(){return new x9(this)}}class y9 extends Er{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:d9(e),done:!1}}}class b9 extends Er{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class x9 extends Er{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class v9 extends Er{constructor(e,n){super(),this.upstream=e,this.maxCount=n,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;Pe(e.value)}return this.upstream.next()}}class w9 extends Er{constructor(e,n){super(),this.upstream=e,this.maxCount=n,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class k9 extends Er{constructor(e,n,r=!0){super(),this.upstream=e,this.batchSize=n,this.enableSmallLastBatch=r,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const n=await this.upstream.next();if(n.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(n.value)}return{value:e,done:!1}}}class S9 extends Er{constructor(e,n){super(),this.upstream=e,this.predicate=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Pe(e.value)}}}class I9 extends Er{constructor(e,n){super(),this.upstream=e,this.transform=n}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const n=pi(e.value),r=this.transform(e.value),s=pi(r);for(const a of n)ib(a,s)||a.dispose();return{value:r,done:!1}}}class N9 extends Er{constructor(e,n){super(),this.upstream=e,this.handler=n,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class HN extends Er{constructor(e,n){super(),this.upstream=e,this.transform=n}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const n=pi(e.value),r=await this.transform(e.value),s=pi(r);for(const a of n)ib(a,s)||a.dispose();return{value:r,done:!1}}}class C9 extends Er{constructor(){super(),this.outputQueue=new h0,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class T9 extends C9{constructor(e,n){super(),this.upstream=e,this.transform=n}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const n=pi(e.value),r=this.transform(e.value),s=pi(r);this.outputQueue.pushAll(r);for(const a of n)ib(a,s)||a.dispose();return!0}}class HF extends Er{constructor(e,n){super(),this.baseErrorHandler=n,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){const r=await this.moreIterators.next();if(r.done)return{value:null,done:!0};this.iterator=r.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const n=await this.iterator.next();return n.done?(this.iterator=null,this.readFromChain(e)):n}}var Mi;(function(t){t[t.FAIL=0]="FAIL",t[t.SHORTEST=1]="SHORTEST",t[t.LONGEST=2]="LONGEST"})(Mi||(Mi={}));class E9 extends Er{constructor(e,n=Mi.FAIL){super(),this.iterators=e,this.mismatchMode=n,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let n=0,r=0;function s(i){return i instanceof Er?{value:i.next().then(o=>(n++,o.done&&r++,o.value)),recurse:!1}:{value:null,recurse:!0}}const a=await VF(this.iterators,s);if(n===r)return{value:null,done:!0};if(r>0)switch(this.mismatchMode){case Mi.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case Mi.SHORTEST:return{value:null,done:!0};case Mi.LONGEST:}return this.count++,{value:a,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class KF extends Er{constructor(e,n){super(),this.upstream=e,this.bufferSize=n,this.buffer=new jF(n)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class $9 extends KF{constructor(e,n,r){super(e,n),this.upstream=e,this.windowSize=n,this.upstreamExhausted=!1,this.random=Kc.alea(r||Ln().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),n=await this.buffer.shuffleExcise(e);if(n.done)this.upstreamExhausted=!0;else return this.refill(),n}return{value:null,done:!0}}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* =============================================================================
*/class m2{constructor(){this.size=null}batch(e,n=!0){const r=this;R(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let s;return this.size===1/0||this.size==null?s=this.size:n?s=Math.ceil(this.size/e):s=Math.floor(this.size/e),Cs(async()=>(await r.iterator()).columnMajorBatch(e,n,R9),s)}concatenate(e){const n=this;let r;return this.size===1/0||e.size===1/0?r=1/0:this.size!=null&&e.size!=null?r=this.size+e.size:r=null,Cs(async()=>(await n.iterator()).concatenate(await e.iterator()),r)}filter(e){const n=this;let r;return this.size===1/0?r=1/0:r=null,Cs(async()=>(await n.iterator()).filter(s=>Y(()=>e(s))),r)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const n=this;return Cs(async()=>(await n.iterator()).map(r=>Y(()=>e(r))),this.size)}mapAsync(e){const n=this;return Cs(async()=>(await n.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const n=this;return Cs(async()=>(await n.iterator()).prefetch(e),this.size)}repeat(e){const n=this;let r;return this.size!=null&&e>0?r=this.size*e:e===0?r=0:this.size!=null&&(e===void 0||e<0)?r=1/0:r=null,Cs(async()=>{const s=f9(async()=>({value:await n.iterator(),done:!1}));return m9(s.take(e))},r)}skip(e){const n=this;let r;return this.size!=null&&e>=0&&this.size>=e?r=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?r=0:r=null,Cs(async()=>(await n.iterator()).skip(e),r)}shuffle(e,n,r=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const s=this,a=Kc.alea(n||Ln().toString());return Cs(async()=>{let i=a.int32();return r&&(i+=a.int32()),(await s.iterator()).shuffle(e,i.toString())},this.size)}take(e){const n=this;let r;return this.size!=null&&this.size>e?r=e:this.size!=null&&this.size<=e?r=this.size:r=null,Cs(async()=>(await n.iterator()).take(e),r)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}m2.MAX_BUFFER_SIZE=1e4;function Cs(t,e=null){return new class extends m2{constructor(){super(...arguments),this.size=e}async iterator(){return t()}}}function Jke(t){return Cs(async()=>GF(t),t.length)}function e2e(t){if(!Wu(t))throw new Error("The argument to zip() must be an object or array.");let e;if(Array.isArray(t))for(let n=0;n<t.length;n++)e=e==null?t[n].size:Math.min(e,t[n].size);else if(t instanceof Object)for(const n in t)e=e==null?t[n].size:Math.min(e,t[n].size);return Cs(async()=>{const n=await VF(t,r=>{if(r instanceof m2)return{value:r.iterator(),recurse:!1};if(Wu(r))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return g9(n,Mi.SHORTEST)},e)}function R9(t){if(t===null)return null;const e=t[0];return c9(e)?{value:A9(t),recurse:!1}:{value:null,recurse:!0}}function A9(t){if(t.length===0)throw new Error("Can't make a batch of zero elements.");return t[0]instanceof st?Tr(t):Ls(t)}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _e(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&R(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const _9=Rk;class d0 extends ty{nextDataId(){return d0.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Rw(this,ir())}write(e,n,r){this.firstUse&&(this.firstUse=!1,Z().get("IS_NODE")&&is(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const s={id:this.nextDataId()};return this.data.set(s,{values:e,dtype:r,refCount:1}),s}makeTensorInfo(e,n,r){let s;if(n==="string"&&r!=null&&r.length>0&&Nl(r[0])){const a=r.map(i=>za(i));s=this.write(a,e,n)}else s=this.write(r,e,n);return{dataId:s,shape:e,dtype:n}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const n=this.data.get(e);n.refCount++}decRef(e){if(this.data.has(e)){const n=this.data.get(e);n.refCount--}}move(e,n,r,s,a){this.data.set(e,{values:n,dtype:s,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:n,complexTensorInfos:r}=this.data.get(e);if(n==="complex64"){const s=this.readSync(r.real.dataId),a=this.readSync(r.imag.dataId);return fa(s,a)}return Jh(this.data.get(e).values,n)}bufferSync(e){const n=this.readSync(e.dataId);if(e.dtype==="string")try{const r=n.map(s=>Vs(s));return Qe(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Qe(e.shape,e.dtype,n)}makeOutput(e,n,r){return ir().makeTensorFromTensorInfo(this.makeTensorInfo(n,r,e),this)}disposeData(e,n=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!n&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:r}=this.data.get(e);r!=null&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const n=Ln();return e(),{kernelMs:Ln()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){_e([e],"where");const n=this.readSync(e.dataId);return _9(e.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}d0.nextDataId=0;/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function qF(t){const e=new Float32Array(t.length);for(let n=0;n<t.length;++n)e[n]=Math.abs(t[n]);return e}const F9=t=>{const{x:e}=t.inputs,n=t.backend;_e(e,"abs");let r=new Float32Array(Q(e.shape));const s=n.data.get(e.dataId).values;return r=qF(s),n.makeOutput(r,e.shape,e.dtype)},O9={kernelName:Qd,backendName:"cpu",kernelFunc:F9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ln(t){return(e,n,r,s,a)=>{const i=Ue(e,n),o=i.length,l=Fe(i),u=Q(i),c=pn(a,u),h=e.length,d=n.length,p=Fe(e),f=Fe(n),m=fi(e,i),y=fi(n,i);if(m.length+y.length===0)for(let g=0;g<c.length;++g)c[g]=t(r[g%r.length],s[g%s.length]);else for(let g=0;g<c.length;++g){const b=Cl(g,o,l),v=b.slice(-h);m.forEach(T=>v[T]=0);const w=la(v,h,p),k=b.slice(-d);y.forEach(T=>k[T]=0);const N=la(k,d,f);c[g]=t(r[w],s[N])}return[c,i]}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function jr(t){const{inputs:e,backend:n}=t,{real:r,imag:s}=e,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=n.makeTensorInfo(r.shape,"complex64"),l=n.data.get(o.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",a),imag:n.makeTensorInfo(s.shape,"float32",i)},o}const D9={kernelName:py,backendName:"cpu",kernelFunc:jr};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Tg(t,e,n="float32"){if(n==="complex64"){const s=Tg(t,e,"float32"),a=Tg(t,e,"float32");return jr({inputs:{real:s,imag:a},backend:t})}const r=Fn(Q(e),n);return t.makeTensorInfo(e,n,r)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Va(t){const{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const M9={kernelName:gc,backendName:"cpu",kernelFunc:Va};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function yl(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.data.get(r.dataId).complexTensorInfos.real,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const P9={kernelName:Uy,backendName:"cpu",kernelFunc:yl};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function XF(t,e,n,r){if(r==="int32"){const s=Int32Array.from(t);return[e,"int32",s]}if(r==="bool"){const s=go([0],n),[a,i]=ln((o,l)=>o!==l?1:0)(e,[],t,s,"bool");return[i,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function co(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dtype:a}=r;if(a==="complex64"){if(s.dtype==="complex64")return Va({inputs:{x:s},backend:n});const c=Tg(n,s.shape,s.dtype),h=co({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),d=jr({inputs:{real:h,imag:c},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),d}if(s.dtype==="complex64"){const c=yl({inputs:{input:s},backend:n}),h=co({inputs:{x:c},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(c),h}if(!sy(s.dtype,a)){const c=Va({inputs:{x:s},backend:n});return{dataId:c.dataId,shape:c.shape,dtype:a}}const i=n.data.get(s.dataId).values,[o,l,u]=XF(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,l,u)}const L9={kernelName:rc,backendName:"cpu",kernelFunc:co};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Nn(t,e,n,r){return n==null?({inputs:s,backend:a})=>{const{a:i,b:o}=s,l=a;_e([i,o],t);const u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,h=i.dtype==="string"?ma(u):u,d=i.dtype==="string"?ma(c):c,p=r||i.dtype,[f,m]=e(i.shape,o.shape,h,d,p);return l.makeTensorInfo(m,p,f)}:({inputs:s,backend:a})=>{const{a:i,b:o}=s,l=a;if(i.dtype==="complex64"||o.dtype==="complex64"){const u=co({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),h=c.complexTensorInfos.real,d=c.complexTensorInfos.imag,p=l.data.get(h.dataId).values,f=l.data.get(d.dataId).values,m=co({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),y=l.data.get(m.dataId),g=y.complexTensorInfos.real,b=y.complexTensorInfos.imag,v=l.data.get(g.dataId).values,w=l.data.get(b.dataId).values,[k,N,T]=n(i.shape,o.shape,p,f,v,w),E=l.makeTensorInfo(T,"float32",k),_=l.makeTensorInfo(T,"float32",N),O=jr({inputs:{real:E,imag:_},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(E),l.disposeIntermediateTensorInfo(_),O}else{const u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,h=r||i.dtype,[d,p]=e(i.shape,o.shape,u,c,h);return l.makeTensorInfo(p,h,d)}}}function g2(t){return(e,n,r,s,a,i)=>{const o=Ue(e,n),l=Q(o),u=o.length,c=Fe(o),h=pn("float32",l),d=pn("float32",l),p=fi(e,o),f=fi(n,o),m=fa(r,s),y=fa(a,i),g=e.length,b=Fe(e),v=n.length,w=Fe(n);if(p.length+f.length===0)for(let k=0;k<h.length;k++){const N=k%m.length,T=k%y.length,E=t(m[N*2],m[N*2+1],y[T*2],y[T*2+1]);h[k]=E.real,d[k]=E.imag}else for(let k=0;k<h.length;k++){const N=Cl(k,u,c),T=N.slice(-g);p.forEach(V=>T[V]=0);const E=la(T,g,b),_=N.slice(-v);f.forEach(V=>_[V]=0);const O=la(_,v,w),M=t(m[E*2],m[E*2+1],y[O*2],y[O*2+1]);h[k]=M.real,d[k]=M.imag}return[h,d,o]}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const YF=ln((t,e)=>t+e),z9=g2((t,e,n,r)=>({real:t+n,imag:e+r})),Uu=Nn(Tl,YF,z9),B9={kernelName:Tl,backendName:"cpu",kernelFunc:Uu};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function y2(t,e,n,r,s){const a=Q(r),i=Fn(s,n);for(let o=0;o<t.length;o++){const l=t[o];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(a>0?i[l]+=e[o]:i[l]+=1)}return i}function QF(t,e,n,r=!1){const s=t.shape[0],a=t.shape[1],i=Qe([s,n],e.dtype);for(let o=0;o<s;o++)for(let l=0;l<a;l++){const u=t.get(o,l);if(u<0)throw new Error("Input x must be non-negative!");u>=n||(r?i.set(1,o,u):e.size>0?i.set(i.get(o,u)+e.get(o,l),o,u):i.set(i.get(o,u)+1,o,u))}return i}/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ZF=ln((t,e)=>t&e),W9=Nn(hy,ZF),U9={kernelName:hy,backendName:"cpu",kernelFunc:W9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function qa(t){return(e,n,r)=>{const s=Ht(n,e.length);for(let a=0;a<e.length;++a)s[a]=t(e[a],r);return s}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function St(t,e,n){const r=qa(e);return So(t,r,n)}function So(t,e,n){return({inputs:r,attrs:s,backend:a})=>{const{x:i}=r;_e(i,t);const o=a,l=o.data.get(i.dataId).values;let u;if(i.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=ma(l)}else u=l;const c=n||i.dtype,h=e(u,c,s);return o.makeTensorInfo(i.shape,c,h)}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const JF=qa(t=>Math.ceil(t)),V9=So(sc,JF),j9={kernelName:sc,backendName:"cpu",kernelFunc:V9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function eO(t,e,n,r){const s=Ht(n,Q(e));if(r&&n!=="string"){let a=0;t.forEach(i=>{const o=Q(i.shape);s.set(i.vals,a),a+=o})}else{let a=0;t.forEach(i=>{const o=n==="string"?ma(i.vals):i.vals;let l=0;for(let u=0;u<i.shape[0];++u){const c=u*e[1]+a;for(let h=0;h<i.shape[1];++h)s[c+h]=o[l++]}a+=i.shape[1]})}return s}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const tO=ln((t,e)=>t===e?1:0),nO=Nn(pp,tO,null,"bool"),G9={kernelName:pp,backendName:"cpu",kernelFunc:nO};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const rO=qa(t=>Math.exp(t)),sO=So(hc,rO,"float32"),H9={kernelName:hc,backendName:"cpu",kernelFunc:sO};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const aO=qa(t=>Math.expm1(t)),K9=So(dc,aO),q9={kernelName:dc,backendName:"cpu",kernelFunc:K9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const iO=qa(t=>Math.floor(t)),X9=So(pc,iO),Y9={kernelName:pc,backendName:"cpu",kernelFunc:X9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const oO=ln((t,e)=>Math.floor(t/e)),Q9=Nn(fc,oO,null,"int32"),Z9={kernelName:fc,backendName:"cpu",kernelFunc:Q9};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function lO(t,e,n,r,s,a,i,o,l){const u=Qe([r,a],n);for(let c=0;c<r;c++){const h=[];let d=0;for(let p=0;p<s;p++){const f=t[c*s+p];d+=f*i[p],h.push(f)}if(d<0||d>=l/a)throw new Error(`Invalid indices: ${h} does not index into ${o}`);for(let p=0;p<a;p++)u.values[c*a+p]=e.get(...e.indexToLoc(d*a+p))}return u}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function uO(t,e,n){const r=Qe(n,t.dtype);for(let s=0;s<r.size;++s){const a=r.indexToLoc(s).slice(),i=a[0],o=a[2],l=e.locToIndex([i,o]);a[2]=e.values[l];const u=t.locToIndex(a);0<=u&&u<t.values.length&&(r.values[s]=t.values[u])}return r}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const cO=ln((t,e)=>t>e?1:0),J9=Nn(yp,cO,null,"bool"),eY={kernelName:yp,backendName:"cpu",kernelFunc:J9};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const hO=ln((t,e)=>t>=e?1:0),tY=Nn(mc,hO,null,"bool"),nY={kernelName:mc,backendName:"cpu",kernelFunc:tY};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const dO=ln((t,e)=>t<e?1:0),rY=Nn(xp,dO,null,"bool"),sY={kernelName:xp,backendName:"cpu",kernelFunc:rY};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const pO=ln((t,e)=>t<=e?1:0),aY=Nn(vp,pO,null,"bool"),iY={kernelName:vp,backendName:"cpu",kernelFunc:aY};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function fO(t,e,n){const r=(e-t)/(n-1),s=Fn(n,"float32");s[0]=t;for(let a=1;a<s.length;a++)s[a]=s[a-1]+r;return s}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const mO=qa(t=>Math.log(t)),oY=So(vc,mO),lY={kernelName:vc,backendName:"cpu",kernelFunc:oY};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function gO(t,e,n,r){const s=pn(r,Q(n));for(let a=0;a<s.length;++a){const i=a*e;let o=t[i];for(let l=0;l<e;++l){const u=t[i+l];(Number.isNaN(u)||u>o)&&(o=u)}s[a]=o}return s}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const yO=ln((t,e)=>Math.max(t,e)),uY=Nn(kc,yO),cY={kernelName:kc,backendName:"cpu",kernelFunc:uY};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const bO=ln((t,e)=>Math.min(t,e)),hY=Nn(Sc,bO),dY={kernelName:Sc,backendName:"cpu",kernelFunc:hY};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const b2=ln((t,e)=>t*e),pY=g2((t,e,n,r)=>({real:t*n-e*r,imag:t*r+e*n})),p0=Nn(Nc,b2,pY),fY={kernelName:Nc,backendName:"cpu",kernelFunc:p0};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function xO(t,e,n){const r=vi(-1,n);return b2([],e,r,t,n)}function mY(t){const{inputs:e,backend:n}=t,{x:r}=e;_e(r,"neg");const s=n.data.get(r.dataId).values,[a,i]=xO(s,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,a)}const gY={kernelName:Ap,backendName:"cpu",kernelFunc:mY};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const vO=ln((t,e)=>t!==e?1:0),yY=Nn(_p,vO,null,"bool"),bY={kernelName:_p,backendName:"cpu",kernelFunc:yY};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function x2(t,e,n,r,s){const a=e.length,i=Q(e),o=Fe(e),l=Fe(s),u=pn(n,Q(s));for(let c=0;c<i;++c){const h=Cl(c,a,o),d=new Array(h.length);for(let f=0;f<d.length;f++)d[f]=h[r[f]];const p=la(d,a,l);u[p]=t[c]}return u}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function $r(t){const{inputs:e,attrs:n,backend:r}=t,{x:s}=e,{perm:a}=n;_e(s,"transpose");const i=s.shape.length,o=new Array(i);for(let c=0;c<o.length;c++)o[c]=s.shape[a[c]];const l=r.data.get(s.dataId).values,u=x2(l,s.shape,s.dtype,a,o);return{dataId:r.write(u,o,s.dtype),shape:o,dtype:s.dtype}}const xY={kernelName:Qo,backendName:"cpu",kernelFunc:$r};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function wO(t,e,n,r){const[s,a]=an(t,r),i=On(e,"int32"),o=Fn(Q(s),i),l=Q(a);for(let u=0;u<o.length;++u){const c=u*l;let h=1;for(let d=0;d<l;++d)h*=n[c+d];o[u]=h}return{outVals:o,outShape:s,outDtype:i}}function vY(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:a,keepDims:i}=r;_e(s,"prod");const o=s.shape.length,l=Ze(a,s.shape),u=Tt(l,o);let c=l,h=s;const d=[];u!=null&&(h=$r({inputs:{x:s},backend:n,attrs:{perm:u}}),d.push(h),c=Ft(c.length,o));const p=n.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:y}=wO(h.shape,h.dtype,p,c);let g=m;return i&&(g=en(m,l)),d.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.makeTensorInfo(g,y,f)}const wY={kernelName:Lp,backendName:"cpu",kernelFunc:vY};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function kY(t,e,n){t.forEach((r,s)=>{if(r<0||r>=n){const a=Cl(s,e.length,Fe(e)).join(",");throw new Error(`indices[${a}] = ${r} is not in [0, ${n})`)}})}function SY(t,e){for(let n=0;n<t.length;++n){const r=t[n],s=n===t.length-1?e:t[n+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let a=1;a<r.length;++a)if(r[a-1]>r[a])throw new Error("Ragged splits must be sorted in ascending order")}}function IY(t,e,n,r){const s=[];let a=0;const i=e.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);SY(n,r);let l=1;for(let u=0;u<e.length-1;++u){l*=e[u];const c=e[u+1];for(let h=1;h<l+1;++h)o[u].push(h*c)}for(let u=0;u<t.length;++u){let c=t[u],h=t[u]+1;for(let d=0;d<n.length;++d){const p=n[d],f=d+e.length-1;if(f>=0){const m=o[f],y=m[m.length-1]-p[c];for(let g=c;g<h;++g)o[f].push(p[g+1]+y)}c=p[c],h=p[h]}h!==c&&(s.push([c,h]),a+=h-c)}return{outSplits:o,valueSlices:s,numValues:a}}function NY(t){const e=[];for(let n=0;n<t.length;++n){const r=t[n].length,s=Ht("int32",r);e.push(s),t[n].forEach((a,i)=>s[i]=a)}return e}function KN(t,e){const n=t.slice(0,e);for(;n.length<e;)n.push(1);for(let r=e;r<t.length;r++)n[e-1]*=t[r];return n}function CY(t,e,n,r,s,a){const i=KN(e,2)[1],o=KN(a,2)[1];let l=0;for(const u of n)for(let c=u[0];c<u[1];++c){for(let h=0;h<r;++h)s[l*o+h]=t[c*i+h];++l}}function TY(t,e,n,r,s){const a=e.slice();a[0]=s;const i=Ht(n,Q(a)),o=t.length,l=o===0?0:o/e[0];return CY(t,e,r,l,i,a),[i,a]}function kO(t,e,n,r,s,a,i,o){if(t.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(kY(a,i,l),r.length===0)throw new Error("params.rank must be nonzero");const u=r[0],{outSplits:c,valueSlices:h,numValues:d}=IY(a,i,t,u),p=NY(c),f=TY(n,r,s,h,d);return[p,f[0],f[1]]}/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const qN=2147483647;function SO(t,e,n,r,s,a,i){if(e.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const o=e.length===0,l=s.length===0,u=i.length===0,c=[];o||c.push(e[0]),l||c.push(s[0]),u||c.push(i[0]);for(let y=1;y<c.length;++y)if(c[y]!==c[y-1])throw new Error("starts, limits, and deltas must have the same shape");const h=c.length===0?1:c[0],d=Ht("int32",h+1);d[0]=0;for(let y=0;y<h;++y){const g=o?t[0]:t[y],b=l?r[0]:r[y],v=u?a[0]:a[y];if(v===0)throw new Error("Requires delta != 0");let w;if(v>0&&b<g||v<0&&b>g)w=0;else if(w=Math.ceil(Math.abs((b-g)/v)),w>qN)throw new Error(`Requires ((limit - start) / delta) <= ${qN}`);d[y+1]=d[y]+w}const p=d[h],f=Ht(n,p);let m=0;for(let y=0;y<h;++y){const g=d[y+1]-d[y];let b=o?t[0]:t[y];const v=u?a[0]:a[y];for(let w=0;w<g;++w)f[m++]=b,b+=v}return[d,f]}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/var Ns=sa;class Eg{constructor(e,n,r,s,a,i,o,l,u,c){this.shape=e,this.shapeShape=n,this.values=r,this.valuesShape=s,this.valuesDType=a,this.defaultValue=i,this.defaultValueShape=o,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=Z3(c),this.raggedRank=J3(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Ns.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Ns.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const n=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Ns.VALUE_ROWIDS:return Eg.getMaxWidthValueRowID(n);case Ns.ROW_SPLITS:return Eg.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${Ns[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const n=e.length;if(n===0||n===1)return 0;let r=0;for(let s=0;s<n-1;++s){const a=e[s+1]-e[s];a>r&&(r=a)}return r}static getMaxWidthValueRowID(e){const n=e.length;if(n===0)return 0;let r=0,s=e[0],a=0;for(let i=1;i<n;++i){const o=e[i];o!==s&&(s=o,a=Math.max(i-r,a),r=i)}return Math.max(n-r,a)}tensorShapeFromTensor(e,n,r=!0){if(n.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return YN(e,r)}calculateOutputSize(e){const n=this.valuesShape,r=this.defaultValueShape;eA(r,n);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=Q3(this.raggedRank,s,n);a[0]<0&&(a[0]=e);for(let i=1;i<=this.raggedRank;++i)a[i]<0&&(a[i]=this.getMaxWidth(i));return a}calculateFirstParentOutputIndex(e,n,r){const s=Math.min(e,r),a=[];let i=0;for(let o=0;o<s;++o,i+=n)a.push(i);for(let o=s;o<e;++o)a.push(-1);return R(a.length===e,()=>"Final length of result must be equal to firstDimension."),a}calculateOutputIndexRowSplit(e,n,r,s){const a=e.length,i=[];for(let o=0;o<a-1;++o){const l=e[o+1]-e[o];let u=Math.min(s,l),c=n[o];c===-1&&(u=0);for(let h=0;h<u;++h)i.push(c),c+=r;for(let h=0;h<l-u;++h)i.push(-1)}if(a>0&&i.length!==e[a-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(e,n,r,s){const a=e.length,i=[];if(a===0)return[];let o=0,l=e[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let u=n[l];i.push(u);for(let c=1;c<a;++c){const h=e[c];if(h===l)u>=0&&(++o,o<s?u+=r:u=-1);else{if(o=0,l=h,h>=n.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${n.length}`);u=n[h]}i.push(u)}if(i.length!==e.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(e,n,r,s){const a=this.getRowPartitionTensor(e),i=this.getRowPartitionTypeByDimension(e);switch(i){case Ns.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,n,r,s);case Ns.ROW_SPLITS:if(a.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(a,n,r,s);default:throw new Error(`Unsupported partition type: ${Ns[i]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const n=this.rowPartitionTypes[0];switch(n){case Ns.FIRST_DIM_SIZE:return e[0];case Ns.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Ns.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Ns[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),n=this.calculateOutputSize(e),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let i=r.length-2;i>=0;--i)r[i]=r[i+1]*n[i+1];const s=YN(n,!1),a=Ht(this.valuesDType,Q(s));if(r[0]*n[0]>0){let i=this.calculateFirstParentOutputIndex(e,r[0],n[0]);for(let o=1;o<=this.raggedRank;++o)i=this.calculateOutputIndex(o-1,i,r[o],n[o]);this.setOutput(this.raggedRank,i,a,s)}return[s,a]}setOutput(e,n,r,s){if(r.length===0)return;const a=this.values,i=r;let o=s.slice();o=o.slice(e+1);const l=Q(o),u=n.length;let c=this.defaultValue;if(c.length!==l&&c.length!==1){const f=this.defaultValueShape;Y(()=>{const m=j(c,f);c=Iu(m,o).dataSync()})}let h=0,d=0,p=0;for(let f=0;f<=u;++f){let m=f<u?n[f]:-1;if(m===p){++p;continue}if(d<p){const y=a.subarray(h*l),g=i.subarray(d*l),b=(p-d)*l;XN(g,y,b)}if(f>=u){const y=r.length;m=Math.floor(y/l)}if(m>p)if(this.defaultValue.length===1)i.subarray(p*l,m*l).fill(this.defaultValue[0]),p=m;else for(;m>p;){const y=i.slice(p*l);XN(y,c,l),++p}m<0?(h=f+1,d=p):(h=f,d=p,p=d+1)}}}function XN(t,e,n){for(let r=0;r<n;r++)t[r]=e[r]}function YN(t,e){const n=[];for(let r of t){if(r<0){if(!e)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function IO(t,e,n,r,s,a,i,o,l,u){return new Eg(t,e,n,r,s,a,i,o,l,u).compute()}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function NO(t,e,n,r){const s=t===e,a=t<e&&n<0,i=e<t&&n>1;if(s||a||i)return Fn(0,r);const o=Math.abs(Math.ceil((e-t)/n)),l=Fn(o,r);e<t&&n===1&&(n=-1),l[0]=t;for(let u=1;u<l.length;u++)l[u]=l[u-1]+n;return l}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const CO=qa(t=>1/Math.sqrt(t)),EY=So(Ac,CO),$Y={kernelName:Ac,backendName:"cpu",kernelFunc:EY};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ho(t,e,n,r,s,a,i,o,l,u){const c=[r/s,s],h=t.values,d=e.values;if(r===0)return Qe(n,e.dtype);const p=l instanceof wn?l:Qe(c,e.dtype);typeof l=="string"||typeof l=="number"?p.values.fill(l):typeof l=="boolean"&&p.values.fill(+l);for(let f=0;f<a;f++){const m=[];let y=0;for(let g=0;g<i;g++){const b=h[f*i+g];m.push(b),y+=b*o[g]}if(y<0||y>=r/s)throw new Error(`Invalid indices: ${m} does not index into ${n}`);for(let g=0;g<s;g++)u?p.values[y*s+g]+=d[f*s+g]:p.values[y*s+g]=e.rank===0?d[0]:d[f*s+g]}return p}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const RY=qa(t=>1/(1+Math.exp(-t))),TO=St(Mc,t=>1/(1+Math.exp(-t))),AY={kernelName:Mc,backendName:"cpu",kernelFunc:TO};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function EO(t,e,n,r,s){const a=zk(r,e,n),i=Q(n),o=Fe(r);if(a){const h=Bk(e,o);return s==="string"?t.slice(h,h+i):t.subarray(h,h+i)}const l=s==="string"?ma(t):t,u=Qe(r,s,l),c=Qe(n,s);for(let h=0;h<c.size;++h){const d=c.indexToLoc(h),p=d.map((f,m)=>f+e[m]);c.set(u.get(...p),...d)}return s==="string"?xA(c.values):c.values}function bl(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:a,size:i}=r;_e(s,"slice");const[o,l]=lf(s,a,i);Fb(s,o,l);const u=n.data.get(s.dataId).values,c=EO(u,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,c)}const _Y={kernelName:jp,backendName:"cpu",kernelFunc:bl};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function $O(t,e,n,r,s,a,i){const o=e[0],l=a[0],u=new Array(l),c=new Array(o),h=e[1];if(l===0){if(o!==0)throw new Error(oA(o));const y=Ht(n,0),g=Ht(s,0);return[y,[0,h],g,u,c]}let d=!0,p=0;const f=new Array(l).fill(0);for(let y=0;y<o;++y){const g=t[y*h];if(g<0)throw new Error(lA(y,g));if(g>=l)throw new Error(uA(y,g,l));++f[g],d=d&&g>=p,p=g}let m=!0;for(let y=0;y<l;++y){const g=f[y]===0;u[y]=g,m=m&&!g,f[y]=Math.max(f[y],1),y>0&&(f[y]+=f[y-1])}if(m&&d){const y=t,g=r;for(let b=0;b<o;++b)c[b]=b;return[y,[o,h],g,u,c]}else{const y=f[l-1],g=Ht(n,y*h),b=Ht(s,y),v=new Array(l).fill(0);for(let w=0;w<o;++w){const k=t[w*h],N=v[k],T=(k===0?0:f[k-1])+N;v[k]++;for(let E=0;E<h;++E)g[T*h+E]=t[w*h+E];b[T]=r[w],c[w]=T}for(let w=0;w<l;++w)if(v[w]===0){const k=w===0?0:f[w-1];g[k*h+0]=w;for(let N=1;N<h;++N)g[k*h+N]=0;b[k]=i}return[g,[y,h],b,u,c]}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function RO(t,e,n,r,s){const a=Q(r),i=e[0],o=s.length,l=[];let u=1,c=-1;for(let m=0;m<o;++m){const y=s[m];if(y===-1){if(c!==-1)throw new Error(cA(c,m));c=m,l.push(1)}else{if(y<0)throw new Error(hA(m,y));u*=y,l.push(y)}}if(c!==-1){if(u<=0)throw new Error(dA());const m=Math.trunc(a/u);if(u*m!==a)throw new Error(pA(r,l));l[c]=m}if(Q(l)!==a)throw new Error(fA(r,l));const h=r.length,d=[];if(h>0){d[h-1]=1;for(let m=h-2;m>=0;--m)d[m]=d[m+1]*r[m+1]}const p=[];if(o>0){p[o-1]=1;for(let m=o-2;m>=0;--m)p[m]=p[m+1]*l[m+1]}const f=Ht(n,i*o);for(let m=0;m<i;++m){let y=0;for(let g=0;g<h;++g)y+=t[m*h+g]*d[g];for(let g=0;g<o;++g)f[m*o+g]=Math.trunc(y/p[g]),y%=p[g]}return[f,[i,o],l]}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function v2(t,e,n,r,s,a=!1,i=0){const o=r.length,l=[e[0],t.length/e[0]],u=l[1],c=o>0?s[o-1]+1:0;if(c<0)throw new Error(Z1());const h=e.slice();h[0]=c;const d=h.reduce((b,v)=>b*v,1),p=Ht(n,d);if(o===0)return c>0&&p.fill(i),[p,h];if(c<=0)throw new Error(Z1());let f=0,m=1,y=0,g=s[f];for(;;){let b=0;if(m<o){if(b=s[m],g===b){++m;continue}if(g>=b)throw new Error(mA())}if(g<0||g>=c)throw new Error(gA(g,c));g>y&&p.fill(i,y*u,g*u);for(let v=f;v<m;++v){const w=r[v];if(w<0||w>=l[0])throw new Error(yA(v,r[v],l[0]));for(let k=0;k<u;k++)p[g*u+k]+=t[w*u+k]}if(a)for(let v=0;v<u;v++)p[g*u+v]/=m-f;if(f=m,++m,y=g+1,g=b,m>o)break}return y<c&&p.fill(i,y*u,c*u),[p,h]}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const FY=qa(t=>Math.sqrt(t)),OY=St(Lc,t=>Math.sqrt(t)),DY={kernelName:Lc,backendName:"cpu",kernelFunc:OY};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const AO=ln((t,e)=>{const n=t-e;return n*n}),MY=Nn(zc,AO),PY={kernelName:zc,backendName:"cpu",kernelFunc:MY};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const _O=qa((t,e)=>{const{pattern:n,replaceGlobal:r,rewrite:s}=e;return t.replace(new RegExp(n,r?"g":""),s)}),LY=So(Zy,_O),zY={kernelName:Zy,backendName:"cpu",kernelFunc:LY};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function FO(t,e,n,r){const s=Qe(t,e.dtype);for(let a=0;a<s.size;a++){const i=s.indexToLoc(a),o=new Array(i.length);for(let l=0;l<o.length;l++)o[l]=i[l]*n[l]+r[l];s.set(e.get(...o),...i)}return s}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class BY{constructor(e,n,r,s,a,i){this.separator=za(e),this.nGramWidths=n,this.leftPad=za(r),this.rightPad=za(s),this.padWidth=a,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,n){const r=this.getPadWidth(n);return Math.max(0,e+2*r-n+1)}createNGrams(e,n,r,s,a,i){for(let o=0;o<a;++o){const l=this.getPadWidth(i),u=Math.max(0,l-o),c=Math.max(0,l-(a-(o+1))),h=i-(u+c),d=n+(u>0?0:o-l);let p=0;p+=u*this.leftPad.length;for(let b=0;b<h;++b)p+=e[d+b].length;p+=c*this.rightPad.length;const f=u+c+h-1;p+=f*this.separator.length,r[s+o]=new Uint8Array(p);const m=r[s+o];let y=0;const g=b=>b.forEach(v=>m[y++]=v);for(let b=0;b<u;++b)g(this.leftPad),g(this.separator);for(let b=0;b<h-1;++b)g(e[d+b]),g(this.separator);if(h>0){g(e[d+h-1]);for(let b=0;b<c;++b)g(this.separator),g(this.rightPad)}else{for(let b=0;b<c-1;++b)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(e,n){const r=e.length,s=n.length;if(s>0){let l=n[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let u=1;u<s;++u){let c=n[u]>=l;if(c=c&&n[u]<=r,!c)throw new Error(`Invalid split value ${n[u]}, must be in [${l}, ${r}]`);l=n[u]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}const a=s-1,i=Ht("int32",s);if(r===0||s===0){const l=new Array(r);for(let u=0;u<=a;++u)i[u]=0;return[l,i]}i[0]=0;for(let l=1;l<=a;++l){const u=n[l]-n[l-1];let c=0;this.nGramWidths.forEach(h=>{c+=this.getNumNGrams(u,h)}),this.preserveShort&&u>0&&c===0&&(c=1),i[l]=i[l-1]+c}const o=new Array(i[a]);for(let l=0;l<a;++l){const u=n[l];let c=i[l];if(this.nGramWidths.forEach(h=>{const d=n[l+1]-n[l],p=this.getNumNGrams(d,h);this.createNGrams(e,u,o,c,p,h),c+=p}),this.preserveShort&&c===i[l]){const h=n[l+1]-n[l];if(h===0)continue;const d=h+2*this.padWidth;this.createNGrams(e,u,o,c,1,d)}}return[o,i]}}function OO(t,e,n,r,s,a,i,o){return new BY(n,r,s,a,i,o).compute(t,e)}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function WY(t,e,n,r){if(!t.length)return;if(e.length===0){for(let a=0;a<t.length;++a)r.push(t.subarray(a,a+1));return}if(e.length===1){const a=e[0];let i=t.indexOf(a);for(;i!==-1;){const o=t.subarray(0,i);(!n||o.length!==0)&&r.push(o),t=t.subarray(i+1),i=t.indexOf(a)}(!n||t.length!==0)&&r.push(t);return}let s=0;for(let a=0;a<t.length+1;a++)if(a===t.length||e.indexOf(t[a])!==-1){const i=t.subarray(s,a);(!n||i.length!==0)&&r.push(i),s=a+1}}function DO(t,e,n){const r=t.length,s=[];let a=0,i=0;const o=new Array(r);for(let d=0;d<r;++d){const p=s.length;WY(t[d],e,n,s);const f=s.length-p;o[d]=f,a+=f,i=Math.max(i,f)}const l=Ht("int32",a*2),u=new Array(a),c=[r,i];let h=0;for(let d=0;d<r;++d)for(let p=0;p<o[d];++p)l[h*2]=d,l[h*2+1]=p,u[h]=s[h],++h;return[l,u,c]}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function MO(t,e){const n=Ht("int32",t.length);for(let r=0;r<t.length;++r)n[r]=K$(t[r]).modulo(e).getLowBitsUnsigned();return n}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const PO=ln((t,e)=>t-e),UY=g2((t,e,n,r)=>({real:t-n,imag:e-r})),w2=Nn(Bc,PO,UY),VY={kernelName:Bc,backendName:"cpu",kernelFunc:w2};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function LO(t,e){const n=new Array(t.rank);for(let s=0;s<n.length;s++)n[s]=t.shape[s]*e[s];const r=Qe(n,t.dtype);for(let s=0;s<r.values.length;++s){const a=r.indexToLoc(s),i=new Array(t.rank);for(let l=0;l<i.length;l++)i[l]=a[l]%t.shape[l];const o=t.locToIndex(i);r.values[s]=t.values[o]}return r}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Ph=(t,e)=>{const n=e.value-t.value;return n===0?t.index-e.index:n};function zO(t,e,n=0,r=t.length-1){for(;r>n;){if(r-n>600){const o=r-n+1,l=e-n+1,u=Math.log(o),c=.5*Math.exp(2*u/3),h=.5*Math.sqrt(u*c*(o-c)/o)*Math.sign(l-o/2),d=Math.max(n,Math.floor(e-l*c/o+h)),p=Math.min(r,Math.floor(e+(o-l)*c/o+h));zO(t,e,d,p)}const s=t[e];let a=n,i=r;for(ti(t,n,e),Ph(t[r],s)>0&&ti(t,n,r);a<i;){for(ti(t,a,i),a++,i--;Ph(t[a],s)<0;)a=a+1;for(;Ph(t[i],s)>0;)i=i-1}Ph(t[n],s)===0?ti(t,n,i):(i=i+1,ti(t,i,r)),i<=e&&(n=i+1),e<=i&&(r=i-1)}}function BO(t,e,n,r,s){const a=e[e.length-1],[i,o]=[t.length/a,a],l=pn(n,i*r),u=pn("int32",i*r);for(let h=0;h<i;h++){const d=h*o,p=t.subarray(d,d+o);let f=new Array(p.length);p.forEach((b,v)=>f[v]={value:b,index:v}),r<f.length&&(zO(f,r),f=f.slice(0,r)),s&&f.sort(Ph);const m=h*r,y=l.subarray(m,m+r),g=u.subarray(m,m+r);for(let b=0;b<r;b++)y[b]=f[b].value,g[b]=f[b].index}const c=e.slice();return c[c.length-1]=r,[Qe(c,n,l),Qe(c,"int32",u)]}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function WO(t,e,n,r){const s=Ze(e,n)[0],a=[1,n[0],1];for(let f=0;f<s;f++)a[0]*=n[f];a[1]=n[s];for(let f=s+1;f<n.length;f++)a[2]*=n[f];const i=new Map,o=new Int32Array(n[s]),l=new wn(a,r,t),u=[],c=a[0]===1&&a[2]===1;for(let f=0;f<n[s];f++){let m;if(c)m=t[f].toString();else{const g=[];for(let b=0;b<a[0];b++)for(let v=0;v<a[2];v++)g.push(l.get(b,f,v));m=g.join(",")}const y=i.get(m);if(y!=null)o[f]=y;else{const g=i.size;i.set(m,g),o[f]=g,u.push(f)}}const h=a.slice();h[1]=i.size;const d=new wn(h,r);u.forEach((f,m)=>{for(let y=0;y<a[0];y++)for(let g=0;g<a[2];g++)d.set(l.get(y,f,g),y,m,g)});const p=n.slice();return p[s]=h[1],{outputValues:d.values,outputShape:p,indices:o}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const UO=Object.freeze(Object.defineProperty({__proto__:null,addImpl:YF,bincountImpl:y2,bincountReduceImpl:QF,bitwiseAndImpl:ZF,castImpl:XF,ceilImpl:JF,concatImpl:eO,equalImpl:tO,expImpl:rO,expm1Impl:aO,floorDivImpl:oO,floorImpl:iO,gatherNdImpl:lO,gatherV2Impl:uO,greaterEqualImpl:hO,greaterImpl:cO,lessEqualImpl:pO,lessImpl:dO,linSpaceImpl:fO,logImpl:mO,maxImpl:gO,maximumImpl:yO,minimumImpl:bO,multiplyImpl:b2,negImpl:xO,notEqualImpl:vO,prodImpl:wO,raggedGatherImpl:kO,raggedRangeImpl:SO,raggedTensorToTensorImpl:IO,rangeImpl:NO,rsqrtImpl:CO,scatterImpl:Ho,sigmoidImpl:RY,simpleAbsImpl:qF,sliceImpl:EO,sparseFillEmptyRowsImpl:$O,sparseReshapeImpl:RO,sparseSegmentReductionImpl:v2,sqrtImpl:FY,squaredDifferenceImpl:AO,staticRegexReplaceImpl:_O,stridedSliceImpl:FO,stringNGramsImpl:OO,stringSplitImpl:DO,stringToHashBucketFastImpl:MO,subImpl:PO,tileImpl:LO,topKImpl:BO,transposeImpl:x2,uniqueImpl:WO},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/qw("cpu",()=>new d0,1);/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const VO=St(uc,t=>t>=0?t:Math.exp(t)-1),jY={kernelName:uc,backendName:"cpu",kernelFunc:VO};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function jO(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{alpha:a}=r;_e([s],"leakyRelu");const i=Q(s.shape),o=n.data.get(s.dataId).values,l=pn("float32",i);for(let u=0;u<o.length;u++)l[u]=o[u]<0?a*o[u]:o[u];return n.makeTensorInfo(s.shape,"float32",l)}const GY={kernelName:bp,backendName:"cpu",kernelFunc:jO};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const HY=ln((t,e)=>t<0?e*t:t);function GO(t){const{inputs:e,backend:n}=t,{x:r,alpha:s}=e;_e([r,s],"prelu");const a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,[o,l]=HY(r.shape,s.shape,a,i,"float32");return n.makeTensorInfo(l,"float32",o)}const KY={kernelName:Pp,backendName:"cpu",kernelFunc:GO};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const HO=St(Ec,t=>Math.max(0,t)),qY={kernelName:Ec,backendName:"cpu",kernelFunc:HO};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const KO=St($c,t=>Math.min(Math.max(0,t),6)),XY={kernelName:$c,backendName:"cpu",kernelFunc:KO};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function $g(t,e,n,r,s){if(n==="linear")return Va({inputs:{x:e},backend:t});if(n==="relu")return HO({inputs:{x:e},backend:t});if(n==="elu")return VO({inputs:{x:e},backend:t});if(n==="relu6")return KO({inputs:{x:e},backend:t});if(n==="prelu")return GO({inputs:{x:e,alpha:r},backend:t});if(n==="leakyrelu")return jO({inputs:{x:e},backend:t,attrs:{alpha:s}});if(n==="sigmoid")return TO({inputs:{x:e},backend:t});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function At(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{shape:a}=r,i=Q(s.shape),o=ry(a,i),l=Q(o);R(i===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(s.dataId);const u=n.data.get(s.dataId);if(u.complexTensorInfos!=null){const c=u.complexTensorInfos.real,h=u.complexTensorInfos.imag;c.shape=o,h.shape=o}return{dataId:s.dataId,shape:o,dtype:s.dtype}}const YY={kernelName:zp,backendName:"cpu",kernelFunc:At};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function qO(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:a}=e,{transposeA:i,transposeB:o}=r;_e([s,a],"matMul");const l=s.shape.length,u=a.shape.length,c=i?s.shape[l-2]:s.shape[l-1],h=o?a.shape[u-1]:a.shape[u-2],d=i?s.shape[l-1]:s.shape[l-2],p=o?a.shape[u-2]:a.shape[u-1],f=s.shape.slice(0,-2),m=a.shape.slice(0,-2),y=Q(f),g=Q(m),b=Ue(s.shape.slice(0,-2),a.shape.slice(0,-2)).concat([d,p]);R(c===h,()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`);const v=i?[y,c,d]:[y,d,c],w=o?[g,p,h]:[g,h,p],k=At({inputs:{x:s},backend:n,attrs:{shape:v}}),N=At({inputs:{x:a},backend:n,attrs:{shape:w}}),T=i?k.shape[1]:k.shape[2],E=i?k.shape[2]:k.shape[1],_=o?N.shape[1]:N.shape[2],O=Math.max(y,g),M=n.data.get(k.dataId).values,V=n.data.get(N.dataId).values,W=Fe(k.shape),K=Fe(N.shape),[q,ee,te]=i?[W[0],1,W[1]]:[W[0],W[1],1],[G,J,ne]=o?[1,K[1],K[0]]:[K[1],1,K[0]],ae=E*_,oe=Qe([O,E,_],k.dtype),ue=oe.values,ce=n.blockSize;for(let de=0;de<O;de++){const Te=de%y,Ee=de%g;for(let De=0;De<E;De+=ce){const Be=Math.min(De+ce,E);for(let We=0;We<_;We+=ce){const Ke=Math.min(We+ce,_);for(let nt=0;nt<T;nt+=ce){const qe=Math.min(nt+ce,T);for(let xe=De;xe<Be;xe++)for(let He=We;He<Ke;He++){let tt=0;for(let xt=nt;xt<qe;xt++){const wt=M[Te*q+xe*ee+xt*te],Fr=V[xt*G+He*J+Ee*ne];tt+=wt*Fr}ue[de*ae+(xe*_+He)]+=tt}}}}}return n.disposeIntermediateTensorInfo(k),n.disposeIntermediateTensorInfo(N),n.makeTensorInfo(b,oe.dtype,oe.values)}const QY={kernelName:rp,backendName:"cpu",kernelFunc:qO};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ZY(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:a,bias:i,preluActivationWeights:o}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=r;let d,p,f;const m=[];d=qO({inputs:{a:s,b:a},attrs:{transposeA:l,transposeB:u},backend:n}),i&&(p=Uu({inputs:{a:d,b:i},backend:n}),m.push(d),d=p),c&&(f=$g(n,d,c,o,h),m.push(d),d=f);for(const y of m)n.disposeIntermediateTensorInfo(y);return d}const JY={kernelName:vd,backendName:"cpu",kernelFunc:ZY};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const eQ=St(Yu,t=>Math.acos(t)),tQ={kernelName:Yu,backendName:"cpu",kernelFunc:eQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const nQ=St(Qu,t=>Math.acosh(t)),rQ={kernelName:Qu,backendName:"cpu",kernelFunc:nQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function sQ(t){const{inputs:e,backend:n}=t,r=e;_e(e,"addN");const s=r.map(o=>n.data.get(o.dataId).values),a=Qe(r[0].shape,r[0].dtype),i=a.values;for(let o=0;o<r.length;o++){const l=s[o];for(let u=0;u<i.length;u++)i[u]+=l[u]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}const aQ={kernelName:Zd,backendName:"cpu",kernelFunc:sQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function iQ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:a,keepDims:i}=r;_e(s,"all");const o=Ze(a,s.shape);let l=o;const u=Tt(l,s.shape.length);let c=s;u!=null&&(c=$r({inputs:{x:s},backend:n,attrs:{perm:u}}),l=Ft(l.length,s.shape.length)),mn("all",l,c.shape.length);const[h,d]=an(c.shape,l),p=Q(d),f=Fn(Q(h),c.dtype),m=n.data.get(c.dataId).values;for(let g=0;g<f.length;++g){const b=g*p;let v=m[b];for(let w=0;w<p;++w){const k=m[b+w];v=v&&k}f[g]=v}u!=null&&n.disposeIntermediateTensorInfo(c);const y=n.makeTensorInfo(h,c.dtype,f);if(i){const g=en(h,o),b=At({inputs:{x:y},backend:n,attrs:{shape:g}});return n.disposeIntermediateTensorInfo(y),b}return y}const oQ={kernelName:iy,backendName:"cpu",kernelFunc:iQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function lQ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:a,keepDims:i}=r;_e(s,"any");const o=Ze(a,s.shape);let l=o;const u=Tt(l,s.shape.length);let c=s;u!=null&&(c=$r({inputs:{x:s},backend:n,attrs:{perm:u}}),l=Ft(l.length,s.shape.length)),mn("any",l,c.shape.length);const[h,d]=an(c.shape,l),p=Q(d),f=Fn(Q(h),c.dtype),m=n.data.get(c.dataId).values;for(let g=0;g<f.length;++g){const b=g*p;let v=m[b];for(let w=0;w<p;++w){const k=m[b+w];v=v||k}f[g]=v}u!=null&&n.disposeIntermediateTensorInfo(c);const y=n.makeTensorInfo(h,c.dtype,f);if(i){const g=en(h,o),b=At({inputs:{x:y},backend:n,attrs:{shape:g}});return n.disposeIntermediateTensorInfo(y),b}return y}const uQ={kernelName:oy,backendName:"cpu",kernelFunc:lQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function cQ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:a}=r;_e(s,"argMax");let i=Ze(a,s.shape);const o=Tt(i,s.shape.length);let l=s;const u=[];o!=null&&(l=$r({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=Ft(i.length,l.shape.length)),i=[i[0]],mn("argMax",i,l.shape.length);const[c,h]=an(l.shape,i),d=Q(c),p=Fn(d,"int32"),f=Q(h),m=n.data.get(l.dataId).values;for(let y=0;y<p.length;++y){const g=y*f;let b=m[g],v=0;for(let w=0;w<f;++w){const k=m[g+w];k>b&&(b=k,v=w)}p[y]=v}return u.forEach(y=>n.disposeIntermediateTensorInfo(y)),n.makeTensorInfo(c,"int32",p)}const hQ={kernelName:Jd,backendName:"cpu",kernelFunc:cQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function dQ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:a}=r;_e(s,"argMin");let i=Ze(a,s.shape);const o=Tt(i,s.shape.length);let l=s;const u=[];o!=null&&(l=$r({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=Ft(i.length,l.shape.length)),i=[i[0]],mn("argMin",i,l.shape.length);const[c,h]=an(l.shape,i),d=Q(c),p=Fn(d,"int32"),f=Q(h),m=n.data.get(l.dataId).values;for(let y=0;y<p.length;++y){const g=y*f;let b=m[g],v=0;for(let w=0;w<f;++w){const k=m[g+w];k<b&&(b=k,v=w)}p[y]=v}return u.forEach(y=>n.disposeIntermediateTensorInfo(y)),n.makeTensorInfo(c,"int32",p)}const pQ={kernelName:ep,backendName:"cpu",kernelFunc:dQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const fQ=St(Zu,t=>Math.asin(t)),mQ={kernelName:Zu,backendName:"cpu",kernelFunc:fQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const gQ=St(Ju,t=>Math.asinh(t)),yQ={kernelName:Ju,backendName:"cpu",kernelFunc:gQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const bQ=St(ec,t=>Math.atan(t)),xQ={kernelName:ec,backendName:"cpu",kernelFunc:bQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const vQ=ln((t,e)=>Math.atan2(t,e)),wQ=Nn(nc,vQ),kQ={kernelName:nc,backendName:"cpu",kernelFunc:wQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const SQ=St(tc,t=>Math.atanh(t)),IQ={kernelName:tc,backendName:"cpu",kernelFunc:SQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function k2(t,e,n,r,s,a){const i=s.strideHeight,o=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,h=s.effectiveFilterWidth,d=s.padInfo.top,p=s.padInfo.left,f=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Qe(s.outShape,n),y=m.values,g=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],v=s.outShape[3];for(let w=0;w<s.batchSize;++w){const k=w*g,N=w*r[0];for(let T=0;T<s.inChannels;++T)for(let E=0;E<s.outHeight;++E){const _=E*i-d,O=Math.max(0,_),M=Math.min(s.inHeight,c+_),V=k+E*b;for(let W=0;W<s.outWidth;++W){const K=W*o-p,q=Math.max(0,K),ee=Math.min(s.inWidth,h+K);let te=f,G=0,J=0;for(let ae=O;ae<M;ae+=l){const oe=N+ae*r[1];for(let ue=q;ue<ee;ue+=u){const ce=oe+ue*r[2],de=t[ce+T];a==="max"&&de>te?te=de:a==="avg"&&(G+=de,J++)}if(isNaN(te))break}const ne=V+W*v+T;y[ne]=a==="avg"?G/J:te}}}return m}function XO(t,e,n,r,s=!1,a=!1){const i=Qe(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,h=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=Qe(e,n,t);for(let y=0;y<r.batchSize;++y)for(let g=0;g<r.inChannels;++g)for(let b=0;b<r.outHeight;++b){const v=b*o-p;let w=v;for(;w<0;)w+=u;const k=Math.min(r.inHeight,h+v);for(let N=0;N<r.outWidth;++N){const T=N*l-f;let E=T;for(;E<0;)E+=c;const _=Math.min(r.inWidth,d+T);let O=Number.NEGATIVE_INFINITY,M=-1;for(let V=w;V<k;V+=u){const W=V-v;for(let K=E;K<_;K+=c){const q=K-T,ee=m.get(y,V,K,g);ee>O&&(O=ee,s?M=a?((y*r.inHeight+V)*r.inWidth+K)*r.inChannels+g:(V*r.inWidth+K)*r.inChannels+g:M=W*d+q)}}i.set(M,y,b,N,g)}}return i}function YO(t,e,n,r,s,a){const i=s.strideDepth,o=s.strideHeight,l=s.strideWidth,u=s.dilationDepth,c=s.dilationHeight,h=s.dilationWidth,d=s.effectiveFilterDepth,p=s.effectiveFilterHeight,f=s.effectiveFilterWidth,m=s.padInfo.front,y=s.padInfo.top,g=s.padInfo.left,b=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=Qe(s.outShape,n),w=v.values,k=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],N=s.outShape[2]*s.outShape[3]*s.outShape[4],T=s.outShape[3]*s.outShape[4],E=s.outShape[4];for(let _=0;_<s.batchSize;++_){const O=_*k,M=_*r[0];for(let V=0;V<s.inChannels;++V)for(let W=0;W<s.outDepth;++W){const K=W*i-m;let q=K;for(;q<0;)q+=u;const ee=Math.min(s.inDepth,d+K),te=O+W*N;for(let G=0;G<s.outHeight;++G){const J=G*o-y;let ne=J;for(;ne<0;)ne+=c;const ae=Math.min(s.inHeight,p+J),oe=te+G*T;for(let ue=0;ue<s.outWidth;++ue){const ce=ue*l-g;let de=ce;for(;de<0;)de+=h;const Te=Math.min(s.inWidth,f+ce),Ee=oe+ue*E;let De=b,Be=0,We=0;for(let nt=q;nt<ee;nt+=u){const qe=M+nt*r[1];for(let xe=ne;xe<ae;xe+=c){const He=qe+xe*r[2];for(let tt=de;tt<Te;tt+=h){const xt=He+tt*r[3],wt=t[xt+V];if(a==="max"&&wt>De?De=wt:a==="avg"&&(Be+=wt,We++),isNaN(De))break}if(isNaN(De))break}if(isNaN(De))break}const Ke=Ee+V;w[Ke]=a==="avg"?Be/Math.max(We,1):De}}}}return v}function NQ(t,e){const n=Qe(e.outShape,"int32"),r=e.strideDepth,s=e.strideHeight,a=e.strideWidth,i=e.dilationDepth,o=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left;for(let m=0;m<e.batchSize;++m)for(let y=0;y<e.inChannels;++y)for(let g=0;g<e.outDepth;++g){const b=g*r-d;let v=b;for(;v<0;)v+=i;const w=Math.min(e.inDepth,u+b);for(let k=0;k<e.outHeight;++k){const N=k*s-p;let T=N;for(;T<0;)T+=o;const E=Math.min(e.inHeight,c+N);for(let _=0;_<e.outWidth;++_){const O=_*a-f;let M=O;for(;M<0;)M+=l;const V=Math.min(e.inWidth,h+O);let W=Number.NEGATIVE_INFINITY,K=-1;for(let q=v;q<w;q+=i){const ee=q-b;for(let te=T;te<E;te+=o){const G=te-N;for(let J=M;J<V;J+=l){const ne=J-O,ae=t.get(m,q,te,J,y);ae>=W&&(W=ae,K=ee*c*h+G*c+ne)}}}n.set(K,m,g,k,_,y)}}}return n}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function CQ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;_e(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;R(In(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=er(s.shape,a,i,u,o,l);let h;if(c.filterWidth===1&&c.filterHeight===1&&Je(c.inShape,c.outShape))h=Va({inputs:{x:s},backend:n});else{const d=n.data.get(s.dataId).values,p=Fe(s.shape),f=k2(d,s.shape,s.dtype,p,c,"avg");h=n.makeTensorInfo(c.outShape,s.dtype,f.values)}return h}const TQ={kernelName:tp,backendName:"cpu",kernelFunc:CQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function EQ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;_e(s,"avgPool3d");const c=vs(s.shape,a,i,1,o,l,u),h=n.data.get(s.dataId).values,d=YO(h,s.shape,s.dtype,Fe(s.shape),c,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}const $Q={kernelName:np,backendName:"cpu",kernelFunc:EQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function RQ(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:a}=e,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;_e([s,a],"avgPool3DGrad");const c=vs(a.shape,i,o,1,l,u),h=c.strideDepth,d=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,y=c.filterWidth,g=c.dilationDepth,b=c.dilationHeight,v=c.dilationWidth,w=c.effectiveFilterDepth,k=c.effectiveFilterHeight,N=c.effectiveFilterWidth,T=w-1-c.padInfo.front,E=N-1-c.padInfo.left,_=k-1-c.padInfo.top,O=Qe(a.shape,"float32"),M=1/(f*m*y),V=n.bufferSync(s);for(let W=0;W<c.batchSize;++W)for(let K=0;K<c.inChannels;++K)for(let q=0;q<c.inDepth;++q)for(let ee=0;ee<c.inHeight;++ee)for(let te=0;te<c.inWidth;++te){const G=q-T,J=ee-_,ne=te-E;let ae=0;for(let oe=0;oe<w;oe+=g){const ue=(G+oe)/h;if(!(ue<0||ue>=c.outDepth||Math.floor(ue)!==ue))for(let ce=0;ce<k;ce+=b){const de=(J+ce)/d;if(!(de<0||de>=c.outHeight||Math.floor(de)!==de))for(let Te=0;Te<N;Te+=v){const Ee=(ne+Te)/p;if(Ee<0||Ee>=c.outWidth||Math.floor(Ee)!==Ee)continue;const De=V.get(W,ue,de,Ee,K);ae+=De}}}O.set(ae*M,W,q,ee,te,K)}return n.makeTensorInfo(O.shape,O.dtype,O.values)}const AQ={kernelName:uy,backendName:"cpu",kernelFunc:RQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _Q(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:a}=e,i=a;_e([s,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=er(i.shape,o,l,1,u),h=c.strideHeight,d=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,y=c.dilationWidth,g=c.effectiveFilterHeight,b=c.effectiveFilterWidth,v=b-1-c.padInfo.left,w=g-1-c.padInfo.top,k=Qe(i.shape,"float32"),N=1/(p*f),T=n.data.get(s.dataId).values,E=Qe(s.shape,"float32",T);for(let _=0;_<c.batchSize;++_)for(let O=0;O<c.inChannels;++O)for(let M=0;M<c.inHeight;++M)for(let V=0;V<c.inWidth;++V){const W=M-w,K=V-v;let q=0;for(let ee=0;ee<g;ee+=m){const te=(W+ee)/h;if(!(te<0||te>=c.outHeight||Math.floor(te)!==te))for(let G=0;G<b;G+=y){const J=(K+G)/d;if(J<0||J>=c.outWidth||Math.floor(J)!==J)continue;const ne=E.get(_,te,J,O);q+=ne}}k.set(q*N,_,M,V,O)}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const FQ={kernelName:ly,backendName:"cpu",kernelFunc:_Q};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function OQ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,scale:a,offset:i,mean:o,variance:l}=e;R(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),R(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),R(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),_e([s,o,l,a,i],"batchNorm");let{varianceEpsilon:u}=r;u==null&&(u=.001);const c=n.data.get(s.dataId).values,h=n.data.get(o.dataId).values,d=n.data.get(l.dataId).values,p=a?n.data.get(a.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),y=f.length,g=p.length,b=d.length,v=h.length;let w=0,k=0,N=0,T=0;for(let E=0;E<c.length;++E)m[E]=f[w++]+(c[E]-h[k++])*p[N++]/Math.sqrt(d[T++]+u),w>=y&&(w=0),k>=v&&(k=0),N>=g&&(N=0),T>=b&&(T=0);return n.makeTensorInfo(s.shape,s.dtype,m)}const DQ={kernelName:mp,backendName:"cpu",kernelFunc:OQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function MQ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:a,crops:i}=r;_e([s],"batchToSpaceND");const o=a.reduce((g,b)=>g*b),l=Fl(s.shape,a,o),u=Ol(l.length,a.length),c=Dl(s.shape,a,o),h=zb(i,a.length),d=Bb(c,i,a.length),p=At({inputs:{x:s},backend:n,attrs:{shape:l}}),f=$r({inputs:{x:p},backend:n,attrs:{perm:u}}),m=At({inputs:{x:f},backend:n,attrs:{shape:c}}),y=bl({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),y}const PQ={kernelName:sp,backendName:"cpu",kernelFunc:MQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function LQ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:a}=e,{size:i}=r,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,u=y2(o,l,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,u)}const zQ={kernelName:cy,backendName:"cpu",kernelFunc:LQ};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function BQ(t){const{inputs:e,backend:n}=t,{s0:r,s1:s}=e,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=Ue(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const WQ={kernelName:dy,backendName:"cpu",kernelFunc:BQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const UQ=St(ac,(t,e)=>{const n=e;return t>n.clipValueMax?n.clipValueMax:t<n.clipValueMin?n.clipValueMin:t}),VQ={kernelName:ac,backendName:"cpu",kernelFunc:UQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const jQ=t=>{const{x:e}=t.inputs,n=t.backend,r=new Float32Array(Q(e.shape)),s=n.data.get(e.dataId),a=s.complexTensorInfos.real,i=s.complexTensorInfos.imag,o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values;for(let u=0;u<o.length;u++){const c=o[u],h=l[u];r[u]=Math.hypot(c,h)}return n.makeOutput(r,e.shape,"float32")},GQ={kernelName:ap,backendName:"cpu",kernelFunc:jQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Vu(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.data.get(r.dataId).complexTensorInfos.imag,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const HQ={kernelName:_y,backendName:"cpu",kernelFunc:Vu};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ju(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r,a=Ze(s,e[0].shape)[0],i=e.map(m=>m.shape);Mb(i,a);let o=Sr(e.map(m=>m.shape),a);if(Q(o)===0)return n.makeTensorInfo(o,e[0].dtype,[]);const l=e.filter(m=>Q(m.shape)>0);if(l.length===1)return Va({inputs:{x:l[0]},backend:n});if(l[0].dtype==="complex64"){const m=l.map(w=>yl({inputs:{input:w},backend:n})),y=l.map(w=>Vu({inputs:{input:w},backend:n})),g=ju({inputs:m,backend:n,attrs:{axis:a}}),b=ju({inputs:y,backend:n,attrs:{axis:a}}),v=jr({inputs:{real:g,imag:b},backend:n});return m.forEach(w=>n.disposeIntermediateTensorInfo(w)),y.forEach(w=>n.disposeIntermediateTensorInfo(w)),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),v}const u=l.map(m=>{const y=[-1,Q(m.shape.slice(a))];return At({inputs:{x:m},backend:n,attrs:{shape:y}})}),c=u.map(m=>({vals:n.data.get(m.dataId).values,shape:m.shape}));o=Sr(u.map(m=>m.shape),1);const h=u[0].shape[0]===1,d=eO(c,o,e[0].dtype,h),p=Sr(l.map(m=>m.shape),a),f=n.makeTensorInfo(p,e[0].dtype,d);return u.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}const KQ={kernelName:ip,backendName:"cpu",kernelFunc:ju};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function QO(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:a}=e,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r;_e([s,a],"conv2d");const h=ss(l),d=_t(s.shape,a.shape,i,u,o,c,!1,h),p=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,y=d.dilationWidth,g=d.padInfo.left,b=d.padInfo.top,v=d.dataFormat==="channelsLast",w=new wn(d.outShape,s.dtype),k=Fe(s.shape),N=Fe(a.shape),T=k[0],E=v?k[1]:k[2],_=v?k[2]:1,O=v?1:k[1],M=w.strides[0],V=v?w.strides[1]:w.strides[2],W=v?w.strides[2]:1,K=v?1:w.strides[1],q=n.data.get(s.dataId).values,ee=n.data.get(a.dataId).values,te=w.values;for(let G=0;G<d.batchSize;++G){const J=G*T,ne=G*M;for(let ae=0;ae<d.outHeight;++ae){const oe=ne+ae*V,ue=ae*d.strideHeight-b;for(let ce=0;ce<p;++ce){const de=ue+ce*m;if(de<0||de>=d.inHeight)continue;const Te=ce*N[0],Ee=J+de*E;for(let De=0;De<d.outWidth;++De){const Be=oe+De*W,We=De*d.strideWidth-g;for(let Ke=0;Ke<f;++Ke){const nt=We+Ke*y;if(nt<0||nt>=d.inWidth)continue;const qe=Te+Ke*N[1],xe=Ee+nt*_;let He=qe;for(let tt=0;tt<d.inChannels;++tt){const xt=q[xe+tt*O];for(let wt=0;wt<d.outChannels;++wt)te[Be+wt*K]+=xt*ee[He+wt];He+=d.outChannels}}}}}}return n.makeTensorInfo(w.shape,w.dtype,te)}const qQ={kernelName:op,backendName:"cpu",kernelFunc:QO};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function XQ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:a}=e,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;_e([s,a],"conv2dBackpropFilter");const h=ss(l),d=_t(s.shape,c,i,1,o,u,!1,h),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:y}=d,g=d.dataFormat==="channelsLast",b=new wn(d.filterShape,"float32"),v=d.padInfo.left,w=d.padInfo.top,k=n.data.get(s.dataId).values,N=n.data.get(a.dataId).values,T=new wn(s.shape,s.dtype,k),E=new wn(a.shape,a.dtype,N);for(let _=0;_<m;++_){const O=Math.max(0,Math.ceil((w-_)/p)),M=Math.min(d.outHeight,(d.inHeight+w-_)/p);for(let V=0;V<y;++V){const W=Math.max(0,Math.ceil((v-V)/f)),K=Math.min(d.outWidth,(d.inWidth+v-V)/f);for(let q=0;q<d.inChannels;++q)for(let ee=0;ee<d.outChannels;++ee){let te=0;for(let G=0;G<d.batchSize;++G)for(let J=O;J<M;++J){const ne=_+J*p-w;for(let ae=W;ae<K;++ae){const oe=V+ae*f-v;g?te+=T.get(G,ne,oe,q)*E.get(G,J,ae,ee):te+=T.get(G,q,ne,oe)*E.get(G,ee,J,ae)}}b.set(te,_,V,q,ee)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}const YQ={kernelName:fy,backendName:"cpu",kernelFunc:XQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function QQ(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:a}=e,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r;_e([s,a],"conv2dBackpropInput");const h=Fe(a.shape),d=Fe(s.shape);let p=ss(u);const f=_t(i,a.shape,o,1,l,c,!1,p),m=new wn(f.inShape,"float32"),y=m.values,g=n.data.get(s.dataId).values,b=n.data.get(a.dataId).values,[v,w,k]=h,{batchSize:N,filterHeight:T,filterWidth:E,inChannels:_,inHeight:O,inWidth:M,outChannels:V,outHeight:W,outWidth:K,strideHeight:q,strideWidth:ee}=f;p=f.dataFormat;const te=T-1-f.padInfo.top,G=E-1-f.padInfo.left,J=p==="channelsLast",ne=m.strides[0],ae=J?m.strides[1]:m.strides[2],oe=J?m.strides[2]:1,ue=J?1:m.strides[1],ce=d[0],de=J?d[1]:d[2],Te=J?d[2]:1,Ee=J?1:d[1];for(let De=0;De<N;++De)for(let Be=0;Be<_;++Be)for(let We=0;We<O;++We){const Ke=We-te,nt=Math.max(0,Math.ceil(Ke/q)),qe=Math.min(W,(T+Ke)/q);for(let xe=0;xe<M;++xe){const He=xe-G,tt=Math.max(0,Math.ceil(He/ee)),xt=Math.min(K,(E+He)/ee);let wt=0;for(let tn=nt;tn<qe;++tn){const Or=tn*q-Ke;for(let gn=tt;gn<xt;++gn){const yr=gn*ee-He,Cn=ce*De+de*tn+Te*gn,br=v*(T-1-Or)+w*(E-1-yr)+k*Be;for(let Tn=0;Tn<V;++Tn){const Dr=g[Cn+Ee*Tn],Hn=b[br+Tn];wt+=Dr*Hn}}}const Fr=ne*De+ae*We+oe*xe+ue*Be;y[Fr]=wt}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}const ZQ={kernelName:lp,backendName:"cpu",kernelFunc:QQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function JQ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:a}=e,{strides:i,pad:o,dilations:l}=r;_e([s,a],"conv3d");const u=wa(s.shape,a.shape,i,l,o),{filterDepth:c,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:y}=u,g=y.front,b=y.left,v=y.top,w=new wn(u.outShape,s.dtype),k=n.data.get(s.dataId).values,N=n.data.get(a.dataId).values,T=w.values,E=Fe(s.shape),_=Fe(a.shape);for(let O=0;O<u.batchSize;++O){const M=O*E[0],V=O*w.strides[0];for(let W=0;W<u.outDepth;++W){const K=V+W*w.strides[1],q=W*u.strideDepth-g;for(let ee=0;ee<c;++ee){const te=q+ee*p;if(te<0||te>=u.inDepth)continue;const G=ee*_[0],J=M+te*E[1];for(let ne=0;ne<u.outHeight;++ne){const ae=K+ne*w.strides[2],oe=ne*u.strideHeight-v;for(let ue=0;ue<h;++ue){const ce=oe+ue*f;if(ce<0||ce>=u.inHeight)continue;const de=G+ue*_[1],Te=J+ce*E[2];for(let Ee=0;Ee<u.outWidth;++Ee){const De=ae+Ee*u.outChannels,Be=Ee*u.strideWidth-b;for(let We=0;We<d;++We){const Ke=Be+We*m;if(Ke<0||Ke>=u.inWidth)continue;const nt=de+We*_[2],qe=Te+Ke*u.inChannels;let xe=nt;for(let He=0;He<u.inChannels;++He){const tt=k[qe+He];for(let xt=0;xt<u.outChannels;++xt)T[De+xt]+=tt*N[xe+xt];xe+=u.outChannels}}}}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}const eZ={kernelName:up,backendName:"cpu",kernelFunc:JQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function tZ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:a}=e,{strides:i,pad:o,filterShape:l}=r;_e([s,a],"conv3dBackpropFilterV2");const u=Fe(s.shape),c=Fe(a.shape),h=wa(s.shape,l,i,1,o),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,m=h.filterDepth,y=h.filterHeight,g=h.filterWidth,b=new wn(h.filterShape,"float32"),v=b.values,[w,k,N,T]=b.strides,E=n.data.get(a.dataId).values,[_,O,M,V]=c,W=n.data.get(s.dataId).values,[K,q,ee,te]=u,G=h.padInfo.front,J=h.padInfo.left,ne=h.padInfo.top;for(let ae=0;ae<m;++ae){const oe=Math.max(0,Math.ceil((G-ae)/d)),ue=Math.min(h.outDepth,(h.inDepth+G-ae)/d),ce=ae*w;for(let de=0;de<y;++de){const Te=Math.max(0,Math.ceil((ne-de)/p)),Ee=Math.min(h.outHeight,(h.inHeight+ne-de)/p),De=de*k+ce;for(let Be=0;Be<g;++Be){const We=Math.max(0,Math.ceil((J-Be)/f)),Ke=Math.min(h.outWidth,(h.inWidth+J-Be)/f),nt=Be*N+De;for(let qe=0;qe<h.inChannels;++qe){const xe=qe*T+nt;for(let He=0;He<h.outChannels;++He){let tt=0;for(let xt=0;xt<h.batchSize;++xt){const wt=xt*K,Fr=xt*_;for(let tn=oe;tn<ue;++tn){const Or=(ae+tn*d-G)*q+wt,gn=tn*O+Fr;for(let yr=Te;yr<Ee;++yr){const Cn=(de+yr*p-ne)*ee+Or,br=yr*M+gn;for(let Tn=We;Tn<Ke;++Tn){const Dr=(Be+Tn*f-J)*te+Cn,Hn=Tn*V+br;tt+=W[Dr+qe]*E[Hn+He]}}}}v[xe+He]=tt}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}const nZ={kernelName:my,backendName:"cpu",kernelFunc:tZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function rZ(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:a}=e,{pad:i,strides:o,inputShape:l}=r;_e([s],"conv3dBackpropInputV2");const u=Fe(s.shape),c=Fe(a.shape),h=wa(l,a.shape,o,1,i),d=new wn(h.inShape,"float32"),p=d.values,[f,m,y,g]=d.strides,b=n.data.get(s.dataId).values,[v,w,k,N]=u,T=n.data.get(a.dataId).values,[E,_,O,M]=c,{batchSize:V,filterDepth:W,filterHeight:K,filterWidth:q,inChannels:ee,inDepth:te,inHeight:G,inWidth:J,outChannels:ne,outDepth:ae,outHeight:oe,outWidth:ue,strideDepth:ce,strideHeight:de,strideWidth:Te}=h,Ee=W-1-h.padInfo.front,De=K-1-h.padInfo.top,Be=q-1-h.padInfo.left;for(let We=0;We<V;++We)for(let Ke=0;Ke<ee;++Ke)for(let nt=0;nt<te;++nt){const qe=nt-Ee,xe=Math.max(0,Math.ceil(qe/ce)),He=Math.min(ae,(W+qe)/ce);for(let tt=0;tt<G;++tt){const xt=tt-De,wt=Math.max(0,Math.ceil(xt/de)),Fr=Math.min(oe,(K+xt)/de);for(let tn=0;tn<J;++tn){const Or=tn-Be,gn=Math.max(0,Math.ceil(Or/Te)),yr=Math.min(ue,(q+Or)/Te);let Cn=0;for(let br=xe;br<He;++br){const Tn=br*ce-qe;for(let Dr=wt;Dr<Fr;++Dr){const Hn=Dr*de-xt;for(let Kn=gn;Kn<yr;++Kn){const Ia=Kn*Te-Or,Mr=v*We+w*br+k*Dr+N*Kn,qs=E*(W-1-Tn)+_*(K-1-Hn)+O*(q-1-Ia)+M*Ke;for(let Pr=0;Pr<ne;++Pr){const uh=b[Mr+Pr],Nf=T[qs+Pr];Cn+=uh*Nf}}}}p[f*We+m*nt+y*tt+g*tn+Ke]=Cn}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}const sZ={kernelName:gy,backendName:"cpu",kernelFunc:rZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const aZ=St(ic,t=>Math.cos(t)),iZ={kernelName:ic,backendName:"cpu",kernelFunc:aZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const oZ=St(oc,t=>Math.cosh(t)),lZ={kernelName:oc,backendName:"cpu",kernelFunc:oZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function uZ(t){const{inputs:e,backend:n,attrs:r}=t,{image:s,boxes:a,boxInd:i}=e,{cropSize:o,method:l,extrapolationValue:u}=r,[c,h,d,p]=s.shape,f=a.shape[0],[m,y]=o,g=Qe([f,m,y,p],"float32"),b=n.data.get(a.dataId).values,v=n.data.get(i.dataId).values,w=n.data.get(s.dataId).values,k=Fe(s.shape),N=Fe(g.shape);for(let T=0;T<f;T++){const E=T*4,_=b[E],O=b[E+1],M=b[E+2],V=b[E+3],W=v[T];if(W>=c)continue;const K=m>1?(M-_)*(h-1)/(m-1):0,q=y>1?(V-O)*(d-1)/(y-1):0;for(let ee=0;ee<m;ee++){const te=m>1?_*(h-1)+ee*K:.5*(_+M)*(h-1);if(te<0||te>h-1){for(let G=0;G<y;G++)for(let J=0;J<p;J++){const ne=J+G*N[2]+ee*N[1]+T*N[0];g.values[ne]=u}continue}if(l==="bilinear"){const G=Math.floor(te),J=Math.ceil(te),ne=te-G;for(let ae=0;ae<y;ae++){const oe=y>1?O*(d-1)+ae*q:.5*(O+V)*(d-1);if(oe<0||oe>d-1){for(let Te=0;Te<p;Te++){const Ee=Te+ae*N[2]+ee*N[1]+T*N[0];g.values[Ee]=u}continue}const ue=Math.floor(oe),ce=Math.ceil(oe),de=oe-ue;for(let Te=0;Te<p;Te++){let Ee=Te+ue*k[2]+G*k[1]+W*k[0];const De=w[Ee];Ee=Te+ce*k[2]+G*k[1]+W*k[0];const Be=w[Ee];Ee=Te+ue*k[2]+J*k[1]+W*k[0];const We=w[Ee];Ee=Te+ce*k[2]+J*k[1]+W*k[0];const Ke=w[Ee],nt=De+(Be-De)*de,qe=We+(Ke-We)*de;Ee=Te+ae*N[2]+ee*N[1]+T*N[0],g.values[Ee]=nt+(qe-nt)*ne}}}else for(let G=0;G<y;++G){const J=y>1?O*(d-1)+G*q:.5*(O+V)*(d-1);if(J<0||J>d-1){for(let oe=0;oe<p;oe++){const ue=oe+G*N[2]+ee*N[1]+T*N[0];g.values[ue]=u}continue}const ne=Math.round(J),ae=Math.round(te);for(let oe=0;oe<p;oe++){const ue=oe+ne*k[2]+ae*k[1]+W*k[0],ce=oe+G*N[2]+ee*N[1]+T*N[0];g.values[ce]=w[ue]}}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}const cZ={kernelName:by,backendName:"cpu",kernelFunc:uZ};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function hZ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:a,exclusive:i,reverse:o}=r;_e(s,"cumprod");const l=Tt([a],s.shape.length);let u=s;l!=null&&(u=$r({inputs:{x:s},backend:n,attrs:{perm:l}}));const c=Ft(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=On(u.dtype,"int32"),d=ay(Q(u.shape),h),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(g,b)=>g+f-b-1:(g,b)=>g+b;for(let g=0;g<p.length;g+=f)for(let b=0;b<f;b++){const v=m(g,b);if(b===0)d[v]=i?1:p[v];else{const w=m(g,b-1);d[v]=i?p[w]*d[w]:p[v]*d[w]}}const y=n.makeTensorInfo(u.shape,h,d);if(l!=null){const g=Ha(l),b=$r({inputs:{x:y},backend:n,attrs:{perm:g}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(u),b}return y}const dZ={kernelName:yy,backendName:"cpu",kernelFunc:hZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function pZ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:a,exclusive:i,reverse:o}=r;_e(s,"cumsum");const l=Tt([a],s.shape.length);let u=s;l!=null&&(u=$r({inputs:{x:s},backend:n,attrs:{perm:l}}));const c=Ft(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=On(u.dtype,"int32"),d=Fn(Q(u.shape),h),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(g,b)=>g+f-b-1:(g,b)=>g+b;for(let g=0;g<p.length;g+=f)for(let b=0;b<f;b++){const v=m(g,b);if(b===0)d[v]=i?0:p[v];else{const w=m(g,b-1);d[v]=i?p[w]+d[w]:p[v]+d[w]}}const y=n.makeTensorInfo(u.shape,h,d);if(l!=null){const g=Ha(l),b=$r({inputs:{x:y},backend:n,attrs:{perm:g}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(u),b}return y}const fZ={kernelName:cp,backendName:"cpu",kernelFunc:pZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function mZ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:a}=e,{size:i,binaryOutput:o}=r;if(s.shape.length===1){const l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=y2(l,u,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,c)}else if(s.shape.length===2){const l=n.bufferSync(s),u=n.bufferSync(a),c=QF(l,u,i,o);return n.makeTensorInfo(c.shape,a.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const gZ={kernelName:xy,backendName:"cpu",kernelFunc:mZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function yZ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockSize:a,dataFormat:i}=r;R(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);const o=s.shape[0],l=s.shape[1],u=s.shape[2],c=s.shape[3],h=l*a,d=u*a,p=c/(a*a),f=n.data.get(s.dataId).values,m=new Float32Array(o*h*d*p);let y=0;for(let g=0;g<o;++g)for(let b=0;b<h;++b){const v=Math.floor(b/a),w=b%a;for(let k=0;k<d;++k){const N=Math.floor(k/a),T=k%a,E=(w*a+T)*p;for(let _=0;_<p;++_){const O=_+E+c*(N+u*(v+l*g));m[y++]=f[O]}}}return n.makeTensorInfo([o,h,d,p],s.dtype,m)}const bZ={kernelName:vy,backendName:"cpu",kernelFunc:yZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ZO(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:a}=e,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;_e([s,a],"depthwiseConv2DNative");const c=Fe(s.shape),h=Fe(a.shape);let d=l;d==null&&(d=[1,1]),R(In(i,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);const p=_t(s.shape,a.shape,i,d,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:y,dilationWidth:g,padInfo:b}=p,v=b.left,w=b.top,k=p.outChannels/p.inChannels,N=new wn(p.outShape,s.dtype),T=n.data.get(s.dataId).values,E=n.data.get(a.dataId).values,_=N.values;for(let O=0;O<p.batchSize;++O){const M=O*c[0],V=O*N.strides[0];for(let W=0;W<p.outHeight;++W){const K=V+W*N.strides[1],q=W*p.strideHeight-w;for(let ee=0;ee<f;++ee){const te=q+ee*y;if(te<0||te>=p.inHeight)continue;const G=ee*h[0],J=M+te*c[1];for(let ne=0;ne<p.outWidth;++ne){const ae=K+ne*N.strides[2],oe=ne*p.strideWidth-v;for(let ue=0;ue<m;++ue){const ce=oe+ue*g;if(ce<0||ce>=p.inWidth)continue;const de=G+ue*h[1],Te=J+ce*p.inChannels;let Ee=ae,De=de;for(let Be=0;Be<p.inChannels;++Be){const We=T[Te+Be];for(let Ke=0;Ke<k;++Ke)_[Ee+Ke]+=We*E[De+Ke];Ee+=k,De+=k}}}}}}return n.makeTensorInfo(N.shape,N.dtype,N.values)}const xZ={kernelName:hp,backendName:"cpu",kernelFunc:ZO};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function vZ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:a}=e,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r;_e([s,a],"depthwiseConv2dNativeBackpropFilter");const h=_t(s.shape,c,i,o,l,u,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:m}=h,y=new wn(h.filterShape,"float32"),g=h.padInfo.left,b=h.padInfo.top,v=h.outChannels/h.inChannels,w=n.data.get(s.dataId).values,k=new wn(s.shape,s.dtype,w),N=n.data.get(a.dataId).values,T=new wn(a.shape,a.dtype,N);for(let E=0;E<f;++E){const _=Math.max(0,Math.ceil((b-E)/d)),O=Math.min(h.outHeight,(h.inHeight+b-E)/d);for(let M=0;M<m;++M){const V=Math.max(0,Math.ceil((g-M)/p)),W=Math.min(h.outWidth,(h.inWidth+g-M)/p);for(let K=0;K<h.outChannels;++K){const q=Math.trunc(K/v),ee=K%v;let te=0;for(let G=0;G<h.batchSize;++G)for(let J=_;J<O;++J){const ne=E+J*d-b;for(let ae=V;ae<W;++ae){const oe=M+ae*p-g;te+=k.get(G,ne,oe,q)*T.get(G,J,ae,K)}}y.set(te,E,M,q,ee)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}const wZ={kernelName:wy,backendName:"cpu",kernelFunc:vZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function kZ(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:a}=e,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r;_e([s,a],"depthwiseConv2DNativeBackpropInput");const h=Fe(s.shape),d=Fe(a.shape),p=_t(c,a.shape,i,o,l,u,!0),f=new wn(p.inShape,"float32"),m=f.values,[y,g,b]=f.strides,v=n.data.get(s.dataId).values,[w,k,N]=h,T=n.data.get(a.dataId).values,[E,_,O]=d,{batchSize:M,filterHeight:V,filterWidth:W,inChannels:K,inHeight:q,inWidth:ee,outChannels:te,outHeight:G,outWidth:J,strideHeight:ne,strideWidth:ae}=p,oe=V-1-p.padInfo.top,ue=W-1-p.padInfo.left,ce=te/K;for(let de=0;de<M;++de)for(let Te=0;Te<K;++Te)for(let Ee=0;Ee<q;++Ee){const De=Ee-oe,Be=Math.max(0,Math.ceil(De/ne)),We=Math.min(G,(V+De)/ne);for(let Ke=0;Ke<ee;++Ke){const nt=Ke-ue,qe=Math.max(0,Math.ceil(nt/ae)),xe=Math.min(J,(W+nt)/ae);let He=0;for(let tt=Be;tt<We;++tt){const xt=tt*ne-De;for(let wt=qe;wt<xe;++wt){const Fr=wt*ae-nt,tn=w*de+k*tt+N*wt,Or=E*(V-1-xt)+_*(W-1-Fr)+O*Te;for(let gn=0;gn<ce;++gn){const yr=Te*ce+gn,Cn=v[tn+yr],br=T[Or+gn];He+=Cn*br}}}m[y*de+g*Ee+b*Ke+Te]=He}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}const SZ={kernelName:ky,backendName:"cpu",kernelFunc:kZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function IZ(t){const{inputs:e,backend:n}=t,{x:r}=e,s=Q(r.shape),a=n.data.get(r.dataId).values,i=Qe([s,s],r.dtype),o=i.values;for(let u=0;u<a.length;u++)o[u*s+u]=a[u];const l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}const NZ={kernelName:Sy,backendName:"cpu",kernelFunc:IZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const CZ={kernelName:dp,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,filter:s}=t,{strides:a,pad:i,dilations:o}=n,l=e,u=l.data.get(r.dataId).values,c=r.shape.length,h=l.data.get(s.dataId).values,d=s.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:y,outHeight:g,outWidth:b,padInfo:v,strideHeight:w,strideWidth:k,filterHeight:N,filterWidth:T,dilationHeight:E,dilationWidth:_,outShape:O}=xo(r.shape,s.shape,a,i,"NHWC",o),M=Q(O),V=O.length,W=Ht(r.dtype,M);for(let K=0;K<p;++K)for(let q=0;q<g;++q){const ee=q*w-v.top;for(let te=0;te<b;++te){const G=te*k-v.left;for(let J=0;J<y;++J){let ne=Number.MIN_SAFE_INTEGER;for(let oe=0;oe<N;++oe){const ue=ee+oe*E;if(ue>=0&&ue<f)for(let ce=0;ce<T;++ce){const de=G+ce*_;if(de>=0&&de<m){const Te=la([K,ue,de,J],c,Fe(r.shape)),Ee=la([oe,ce,J],d,Fe(s.shape)),De=u[Te]+h[Ee];De>ne&&(ne=De)}}}const ae=la([K,q,te,J],V,Fe(O));W[ae]=ne}}}return{dataId:l.write(go(W,r.dtype),O,r.dtype),shape:O,dtype:r.dtype}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const TZ={kernelName:ig,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,filter:s,dy:a}=t,{strides:i,pad:o,dilations:l}=n,u=e,c=ds(r.shape,u.data.get(r.dataId).values),h=ds(s.shape,u.data.get(s.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:y,outWidth:g,padInfo:b,strideHeight:v,strideWidth:w,filterHeight:k,filterWidth:N,dilationHeight:T,dilationWidth:E,outShape:_}=xo(r.shape,s.shape,i,o,"NHWC",l);R(a.rank===_.length,()=>`Error in ${ig}, dy must have the same rank as output ${_.length}, but got ${a.rank}`);const O=ds(_,u.data.get(a.dataId).values),M=Fw(s.shape,s.dtype);for(let V=0;V<d;++V)for(let W=0;W<y;++W){const K=W*v-b.top;for(let q=0;q<g;++q){const ee=q*w-b.left;for(let te=0;te<m;++te){let G=Number.MIN_SAFE_INTEGER,J=0,ne=0;for(let ae=0;ae<k;++ae){const oe=K+ae*T;if(oe>=0&&oe<p)for(let ue=0;ue<N;++ue){const ce=ee+ue*E;if(ce>=0&&ce<f){const de=c[V][oe][ce][te]+h[ae][ue][te];de>G&&(G=de,J=ae,ne=ue)}}}M[J][ne][te]+=O[V][W][q][te]}}}return{dataId:u.write(go(M,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const EZ={kernelName:ag,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,filter:s,dy:a}=t,{strides:i,pad:o,dilations:l}=n,u=e,c=ds(r.shape,u.data.get(r.dataId).values),h=ds(s.shape,u.data.get(s.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:y,outWidth:g,padInfo:b,strideHeight:v,strideWidth:w,filterHeight:k,filterWidth:N,dilationHeight:T,dilationWidth:E,outShape:_}=xo(r.shape,s.shape,i,o,"NHWC",l);R(a.rank===_.length,()=>`Error in ${ag}, dy must have the same rank as output ${_.length}, but got ${a.rank}`);const O=ds(_,u.data.get(a.dataId).values),M=Fw(r.shape,r.dtype);for(let V=0;V<d;++V)for(let W=0;W<y;++W){const K=W*v-b.top;for(let q=0;q<g;++q){const ee=q*w-b.left;for(let te=0;te<m;++te){let G=Number.MIN_SAFE_INTEGER,J=K<0?0:K,ne=ee<0?0:ee;for(let ae=0;ae<k;++ae){const oe=K+ae*T;if(oe>=0&&oe<p)for(let ue=0;ue<N;++ue){const ce=ee+ue*E;if(ce>=0&&ce<f){const de=c[V][oe][ce][te]+h[ae][ue][te];de>G&&(G=de,J=oe,ne=ce)}}}M[V][J][ne][te]+=O[V][W][q][te]}}}return{dataId:u.write(go(M,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function $Z(t){const{inputs:e,backend:n,attrs:r}=t,{image:s}=e,{canvas:a,options:i}=r,{contextOptions:o,imageOptions:l}=i||{},u=(l==null?void 0:l.alpha)||1,c=(o==null?void 0:o.contextType)||"2d";if(c!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const h=a.getContext(c,(o==null?void 0:o.contextAttributes)||{});if(h==null)throw new Error(`Could not get the context with ${c} type.`);const[d,p]=s.shape.slice(0,2),f=s.shape.length===2?1:s.shape[2],m=n.data.get(s.dataId).values,y=s.dtype==="float32"?255:1,g=new Uint8ClampedArray(p*d*4);for(let v=0;v<d*p;++v){const w=[0,0,0,255*u];for(let N=0;N<f;N++){const T=m[v*f+N];if(s.dtype==="float32"){if(T<0||T>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${T}.`)}else if(s.dtype==="int32"&&(T<0||T>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${T}.`);f===1?(w[0]=T*y,w[1]=T*y,w[2]=T*y):w[N]=T*y}const k=v*4;g[k+0]=Math.round(w[0]),g[k+1]=Math.round(w[1]),g[k+2]=Math.round(w[2]),g[k+3]=Math.round(w[3])}a.width=p,a.height=d;const b=new ImageData(g,p,d);return h.putImageData(b,0,0),s}const RZ={kernelName:Iy,backendName:"cpu",kernelFunc:$Z};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function xf(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:a,keepDims:i}=r;_e(s,"sum");let o;s.dtype==="bool"?o=co({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):o=Va({inputs:{x:s},backend:n});const l=o.shape.length,u=Ze(a,o.shape),c=Tt(u,l);let h=u,d=o;c!=null&&(d=$r({inputs:{x:o},backend:n,attrs:{perm:c}}),h=Ft(h.length,l)),mn("sum",h,d.shape.length);const[p,f]=an(d.shape,h),m=On(d.dtype,"int32");let y=Tg(n,p,m);const g=Q(f),b=n.data.get(y.dataId).values,v=n.data.get(d.dataId).values;for(let w=0;w<b.length;++w){const k=w*g;let N=0;for(let T=0;T<g;++T)N+=v[k+T];b[w]=N}if(i){const w=en(y.shape,u),k=y;y=At({inputs:{x:y},backend:n,attrs:{shape:w}}),n.disposeIntermediateTensorInfo(k)}return n.disposeIntermediateTensorInfo(o),c!=null&&n.disposeIntermediateTensorInfo(d),y}const AZ={kernelName:Gp,backendName:"cpu",kernelFunc:xf};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _Z(t){const{inputs:e,backend:n,attrs:r}=t,{equation:s}=r,a=e,{allDims:i,summedDims:o,idDims:l}=Kb(s,a.length);Xb(i.length,l,a);const{path:u,steps:c}=Yb(o,l),h=c.length;let d=null,p=i.length;const f=[];for(let m=0;m<h;++m){for(const y of c[m]){const{permutationIndices:g,expandDims:b}=qb(p,l[y]);let v;Qb(g)?v=a[y]:(v=$r({inputs:{x:a[y]},backend:n,attrs:{perm:g}}),f.push(v));const w=v.shape.slice();for(let k=0;k<b.length;++k)w.splice(b[k],0,1);Je(v.shape,w)||(v=At({inputs:{x:v},backend:n,attrs:{shape:w}}),f.push(v)),d===null?d=v:(d=p0({inputs:{a:v,b:d},backend:n}),f.push(d))}m<h-1&&(u[m]>=0&&(d=xf({inputs:{x:d},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}const FZ={kernelName:Ny,backendName:"cpu",kernelFunc:_Z};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function OZ(t){const{inputs:e,backend:n}=t,{dy:r,y:s}=e;_e([r,s],"eluGrad");const a=new Float32Array(Q(s.shape)),i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<i.length;++l){const u=i[l];u>=0?a[l]=o[l]:a[l]=o[l]*(u+1)}return n.makeTensorInfo(s.shape,"float32",a)}const DZ={kernelName:Cy,backendName:"cpu",kernelFunc:OZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const MZ=Wb,PZ=Ub,LZ=Vb,zZ=jb,BZ=Gb,WZ=Hb,UZ=St(cc,t=>{const e=Math.sign(t),n=Math.abs(t),r=1/(1+MZ*n);return e*(1-((((WZ*r+BZ)*r+zZ)*r+LZ)*r+PZ)*r*Math.exp(-n*n))}),VZ={kernelName:cc,backendName:"cpu",kernelFunc:UZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Rg(t){const{inputs:e,backend:n,attrs:r}=t,{input:s}=e,{dim:a}=r,i=s.shape.length,o=s.shape.slice();let l=a;return a<0&&(R(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+a+1),o.splice(l,0,1),At({inputs:{x:s},backend:n,attrs:{shape:o}})}const jZ={kernelName:fp,backendName:"cpu",kernelFunc:Rg};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const GZ=ln((t,e)=>t/e),S2=Nn(lc,GZ),xv={kernelName:lc,backendName:"cpu",kernelFunc:S2};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function JO(t,e,n){const r=t.shape,s=r[0],a=r[1],i=n.data.get(t.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[s,a],c=Q(u),h=pn("float32",c),d=pn("float32",c);for(let y=0;y<s;y++){const g=bl({inputs:{x:o},backend:n,attrs:{begin:[y,0],size:[1,a]}}),b=bl({inputs:{x:l},backend:n,attrs:{begin:[y,0],size:[1,a]}}),v=jr({inputs:{real:g,imag:b},backend:n}),{real:w,imag:k}=HZ(v,e,n),N=fa(w,k);for(let T=0;T<a;T++){const E=Uk(N,T);h[y*a+T]=E.real,d[y*a+T]=E.imag}n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(v)}const p=n.makeTensorInfo(u,"float32",h),f=n.makeTensorInfo(u,"float32",d),m=jr({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function HZ(t,e,n){const r=Q(t.shape),s=n.data.get(t.dataId),a=n.data.get(s.complexTensorInfos.real.dataId).values,i=n.data.get(s.complexTensorInfos.imag.dataId).values;if(KZ(r)){const o=vv(a,i,r,e,n),l=[t.shape[0],t.shape[1]];if(e){const u=n.makeTensorInfo(l,"float32",o.real),c=n.makeTensorInfo(l,"float32",o.imag),h=n.makeTensorInfo([],"float32",vi(r,"float32")),d=Va({inputs:{x:h},backend:n}),p=xv.kernelFunc({inputs:{a:u,b:h},backend:n}),f=xv.kernelFunc({inputs:{a:c,b:d},backend:n}),m=n.data.get(p.dataId).values,y=n.data.get(f.dataId).values;return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),{real:m,imag:y}}return o}else{const o=fa(a,i),l=qZ(o,r,e);return tA(l)}}function KZ(t){return(t&t-1)===0}function vv(t,e,n,r,s){if(n===1)return{real:t,imag:e};const a=fa(t,e),i=n/2,o=nA(a),l=o.real,u=o.imag,c=[l.length],h=s.makeTensorInfo(c,"float32",l),d=s.makeTensorInfo(c,"float32",u),p=jr({inputs:{real:h,imag:d},backend:s}),f=rA(a),m=f.real,y=f.imag,g=[m.length],b=s.makeTensorInfo(g,"float32",m),v=s.makeTensorInfo(g,"float32",y),w=jr({inputs:{real:b,imag:v},backend:s}),k=vv(l,u,i,r,s),N=k.real,T=k.imag,E=[N.length],_=s.makeTensorInfo(E,"float32",N),O=s.makeTensorInfo(E,"float32",T),M=jr({inputs:{real:_,imag:O},backend:s}),V=vv(m,y,i,r,s),W=V.real,K=V.imag,q=[W.length],ee=s.makeTensorInfo(q,"float32",W),te=s.makeTensorInfo(q,"float32",K),G=jr({inputs:{real:ee,imag:te},backend:s}),J=aA(n,r),ne=[J.real.length],ae=s.makeTensorInfo(ne,"float32",J.real),oe=s.makeTensorInfo(ne,"float32",J.imag),ue=jr({inputs:{real:ae,imag:oe},backend:s}),ce=p0({inputs:{a:ue,b:G},backend:s}),de=Uu({inputs:{a:M,b:ce},backend:s}),Te=w2({inputs:{a:M,b:ce},backend:s}),Ee=yl({inputs:{input:de},backend:s}),De=yl({inputs:{input:Te},backend:s}),Be=Vu({inputs:{input:de},backend:s}),We=Vu({inputs:{input:Te},backend:s}),Ke=ju({inputs:[Ee,De],backend:s,attrs:{axis:0}}),nt=ju({inputs:[Be,We],backend:s,attrs:{axis:0}}),qe=s.data.get(Ke.dataId).values,xe=s.data.get(nt.dataId).values;return s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(w),s.disposeIntermediateTensorInfo(_),s.disposeIntermediateTensorInfo(O),s.disposeIntermediateTensorInfo(M),s.disposeIntermediateTensorInfo(ee),s.disposeIntermediateTensorInfo(te),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(ae),s.disposeIntermediateTensorInfo(oe),s.disposeIntermediateTensorInfo(ue),s.disposeIntermediateTensorInfo(ce),s.disposeIntermediateTensorInfo(de),s.disposeIntermediateTensorInfo(Te),s.disposeIntermediateTensorInfo(Ee),s.disposeIntermediateTensorInfo(Be),s.disposeIntermediateTensorInfo(De),s.disposeIntermediateTensorInfo(We),s.disposeIntermediateTensorInfo(Ke),s.disposeIntermediateTensorInfo(nt),{real:qe,imag:xe}}function qZ(t,e,n){const r=new Float32Array(e*2);for(let s=0;s<e;s++){let a=0,i=0;for(let o=0;o<e;o++){const l=iA(s*o,e,n),u=Uk(t,o);a+=u.real*l.real-u.imag*l.imag,i+=u.real*l.imag+u.imag*l.real}n&&(a/=e,i/=e),sA(r,a,i,s)}return r}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function XZ(t){const{inputs:e,backend:n}=t,{input:r}=e,s=Q(r.shape),a=r.shape[r.shape.length-1],i=s/a,o=At({inputs:{x:r},backend:n,attrs:{shape:[i,a]}}),l=JO(o,!1,n),u=At({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}const YZ={kernelName:Ty,backendName:"cpu",kernelFunc:XZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function I2(t){const{backend:e,attrs:n}=t,{shape:r,value:s,dtype:a}=n,i=a||mo(s),o=Ht(i,Q(r));return ZZ(o,s),e.makeTensorInfo(r,i,o)}const QZ={kernelName:Ey,backendName:"cpu",kernelFunc:I2};function ZZ(t,e,n){t.fill(e)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const JZ={kernelName:$y,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,s=n,a=pn(r.dtype,Q(r.shape)),[i,o,l,u]=r.shape,c=s.data.get(r.dataId).values;for(let h=0;h<i;h++){const d=h*l*o*u;for(let p=0;p<o;p++){const f=p*(l*u);for(let m=0;m<l;m++){const y=m*u;for(let g=0;g<u;g++){const b=Math.round(l-m-1),v=d+f+y+g;let w=c[v];if(b>=0&&b<l){const k=b*u,N=d+f+k+g;w=c[N]}a[v]=w}}}}return{dataId:s.write(a,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function eJ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:a,bias:i,preluActivationWeights:o}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let m=QO({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(i){const y=m;if(c==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){const g=At({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=Uu({inputs:{a:m,b:g},backend:n}),n.disposeIntermediateTensorInfo(g)}else m=Uu({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(y)}if(p){const y=m;if(c==="NCHW"&&p==="prelu"&&o.shape.length===1&&o.shape[0]!==1){const g=At({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=$g(n,m,p,g,f),n.disposeIntermediateTensorInfo(g)}else m=$g(n,m,p,o,f);n.disposeIntermediateTensorInfo(y)}return m}const tJ={kernelName:wd,backendName:"cpu",kernelFunc:eJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function nJ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:a,bias:i,preluActivationWeights:o}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let m=ZO({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(i){const y=m;m=Uu({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(y)}if(p){const y=m;m=$g(n,m,p,o,f),n.disposeIntermediateTensorInfo(y)}return m}const rJ={kernelName:kd,backendName:"cpu",kernelFunc:nJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function sJ(t){const{inputs:e,backend:n}=t,{params:r,indices:s}=e,a=Q(r.shape),i=s.shape,o=i[i.length-1],[l,u,c,h]=of(r,s);if(u===0)return n.makeTensorInfo(l,r.dtype,[]);const d=n.data.get(s.dataId).values,p=n.bufferSync(r),f=lO(d,p,r.dtype,u,o,c,h,r.shape,a);return n.makeTensorInfo(l,r.dtype,f.values)}const aJ={kernelName:Ry,backendName:"cpu",kernelFunc:sJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function iJ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,indices:a}=e,{axis:i,batchDims:o}=r;_e([s,a],"gatherV2");const l=Ze(i,s.shape)[0],u=n.data.get(a.dataId).values,c=s.shape[l];for(let w=0;w<u.length;++w){const k=u[w];R(k<=c-1&&k>=0,()=>`GatherV2: the index value ${k} is not in [0, ${c-1}]`)}let h=o;o==null&&(h=0);const d=Q(a.shape),p=Jb(s,a,l,h),f=At({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=At({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,d/p.batchSize]}}),y=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],g=n.bufferSync(m),b=n.bufferSync(f),v=uO(b,g,y);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,v.dtype,v.values)}const oJ={kernelName:gp,backendName:"cpu",kernelFunc:iJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function lJ(t){const{inputs:e,backend:n}=t,{input:r}=e,s=Q(r.shape),a=r.shape[r.shape.length-1],i=s/a,o=At({inputs:{x:r},backend:n,attrs:{shape:[i,a]}}),l=JO(o,!0,n),u=At({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}const uJ={kernelName:Ay,backendName:"cpu",kernelFunc:lJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const cJ=St(yc,t=>Number.isFinite(t)?1:0,"bool"),hJ={kernelName:yc,backendName:"cpu",kernelFunc:cJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const dJ=St(bc,t=>Math.abs(t)===1/0?1:0,"bool"),pJ={kernelName:bc,backendName:"cpu",kernelFunc:dJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const fJ=St(xc,t=>Number.isNaN(t)?1:0,"bool"),mJ={kernelName:xc,backendName:"cpu",kernelFunc:fJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function gJ(t){const{backend:e,attrs:n}=t,{start:r,stop:s,num:a}=n,i=fO(r,s,a);return e.makeTensorInfo([i.length],"float32",i)}const yJ={kernelName:Fy,backendName:"cpu",kernelFunc:gJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const bJ=St(wc,t=>Math.log1p(t)),xJ={kernelName:wc,backendName:"cpu",kernelFunc:bJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const vJ=ln((t,e)=>t&&e),wJ=Nn(wp,vJ,null,"bool"),kJ={kernelName:wp,backendName:"cpu",kernelFunc:wJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const SJ=St(kp,t=>t?0:1,"bool"),IJ={kernelName:kp,backendName:"cpu",kernelFunc:SJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const NJ=ln((t,e)=>t||e),CJ=Nn(Sp,NJ,null,"bool"),TJ={kernelName:Sp,backendName:"cpu",kernelFunc:CJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function EJ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{depthRadius:a,bias:i,alpha:o,beta:l}=r;_e(s,"LRN");const u=s.shape[3],c=u-1,h=n.data.get(s.dataId).values,d=Q(s.shape),p=new Float32Array(d);function f(m){const y=m%u;let g=m-y+Math.max(0,y-a);const b=m-y+Math.min(y+a,c);let v=0;for(;g<=b;g++){const w=h[g];v+=w*w}return v}for(let m=0;m<d;m++){const y=f(m),g=h[m]*Math.pow(i+o*y,-l);p[m]=g}return n.makeTensorInfo(s.shape,s.dtype,p)}const $J={kernelName:Ip,backendName:"cpu",kernelFunc:EJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function RJ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,y:a,dy:i}=e,{depthRadius:o,bias:l,alpha:u,beta:c}=r;_e(i,"LRNGrad");const h=Q(i.shape),d=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(s.dataId).values,m=n.data.get(a.dataId).values,y=new Float32Array(h),g=h;for(let b=0;b<g;b++){const v=b%d,w=b-v+Math.max(0,v-o),k=b-v+Math.min(d,v+o+1);let N=0;for(let T=w;T<k;T++)N+=Math.pow(f[T],2);N=u*N+l;for(let T=w;T<k;T++){let E=-2*u*c*f[T]*m[b]/N;b===T&&(E+=Math.pow(N,-c)),E*=p[b],y[T]+=E}}return n.makeTensorInfo(i.shape,s.dtype,y)}const AJ={kernelName:Oy,backendName:"cpu",kernelFunc:RJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function eD(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reductionIndices:a,keepDims:i}=r,o=n;let l=s.shape;const u=l.length,c=Ze(a,l);let h=c;const d=Tt(h,u);let p=o.data.get(s.dataId).values;if(d!=null){const w=new Array(u);for(let k=0;k<w.length;k++)w[k]=l[d[k]];p=x2(p,l,s.dtype,d,w),h=Ft(h.length,u),l=w}_e(s,"max"),mn("max",h,u);const[f,m]=an(l,h),y=Q(m),g=gO(p,y,f,s.dtype),b=o.write(g,f,s.dtype);let v=f;return i&&(v=en(f,c)),{dataId:b,shape:v,dtype:s.dtype}}const _J={kernelName:Np,backendName:"cpu",kernelFunc:eD};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function FJ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;_e(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;R(In(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=er(s.shape,a,i,u,o,l);let h;if(c.filterWidth===1&&c.filterHeight===1&&Je(c.inShape,c.outShape))h=Va({inputs:{x:s},backend:n});else{const d=n.data.get(s.dataId).values,p=Fe(s.shape),f=k2(d,s.shape,s.dtype,p,c,"max");h=n.makeTensorInfo(c.outShape,s.dtype,f.values)}return h}const OJ={kernelName:Cp,backendName:"cpu",kernelFunc:FJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function DJ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;_e(s,"maxPool3d");const c=vs(s.shape,a,i,1,o,l,u),h=n.data.get(s.dataId).values,d=YO(h,s.shape,s.dtype,Fe(s.shape),c,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}const MJ={kernelName:Tp,backendName:"cpu",kernelFunc:DJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function PJ(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:a}=e,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;_e([s,a],"maxPool3DGrad");const c=vs(a.shape,i,o,1,l,u),h=n.bufferSync(a),d=NQ(h,c),p=c.strideDepth,f=c.strideHeight,m=c.strideWidth,y=c.dilationDepth,g=c.dilationHeight,b=c.dilationWidth,v=c.effectiveFilterDepth,w=c.effectiveFilterHeight,k=c.effectiveFilterWidth,N=v-1-c.padInfo.front,T=k-1-c.padInfo.left,E=w-1-c.padInfo.top,_=Qe(a.shape,"float32"),O=n.bufferSync(s);for(let M=0;M<c.batchSize;++M)for(let V=0;V<c.inChannels;++V)for(let W=0;W<c.inDepth;++W)for(let K=0;K<c.inHeight;++K)for(let q=0;q<c.inWidth;++q){const ee=W-N,te=K-E,G=q-T;let J=0;for(let ne=0;ne<v;ne+=y){const ae=(ee+ne)/p;if(!(ae<0||ae>=c.outDepth||Math.floor(ae)!==ae))for(let oe=0;oe<w;oe+=g){const ue=(te+oe)/f;if(!(ue<0||ue>=c.outHeight||Math.floor(ue)!==ue))for(let ce=0;ce<k;ce+=b){const de=(G+ce)/m;if(de<0||de>=c.outWidth||Math.floor(de)!==de)continue;const Te=v*w*k-1-d.get(M,ae,ue,de,V),Ee=ne*w*k+oe*k+ce,De=Te===Ee?1:0;if(De===0)continue;const Be=O.get(M,ae,ue,de,V);J+=Be*De}}}_.set(J,M,W,K,q,V)}return n.makeTensorInfo(_.shape,_.dtype,_.values)}const LJ={kernelName:My,backendName:"cpu",kernelFunc:PJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zJ(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:a,output:i}=e,o=a;_e([a,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=r,d=er(o.shape,l,u,1,c,h),p=n.data.get(o.dataId).values,f=Qe(d.outShape,o.dtype,XO(p,o.shape,o.dtype,d).values),m=d.strideHeight,y=d.strideWidth,g=d.dilationHeight,b=d.dilationWidth,v=d.effectiveFilterHeight,w=d.effectiveFilterWidth,k=w-1-d.padInfo.left,N=v-1-d.padInfo.top,T=Qe(o.shape,"float32"),E=n.data.get(s.dataId).values,_=Qe(s.shape,"float32",E);for(let O=0;O<d.batchSize;++O)for(let M=0;M<d.inChannels;++M)for(let V=0;V<d.inHeight;++V)for(let W=0;W<d.inWidth;++W){const K=V-N,q=W-k;let ee=0;for(let te=0;te<v;te+=g){const G=(K+te)/m;if(!(G<0||G>=d.outHeight||Math.floor(G)!==G))for(let J=0;J<w;J+=b){const ne=(q+J)/y;if(ne<0||ne>=d.outWidth||Math.floor(ne)!==ne)continue;const ae=v*w-1-f.get(O,G,ne,M),oe=te*w+J,ue=ae===oe?1:0;if(ue===0)continue;const ce=_.get(O,G,ne,M);ee+=ce*ue}}T.set(ee,O,V,W,M)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}const BJ={kernelName:Dy,backendName:"cpu",kernelFunc:zJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function WJ(t,e,n,r,s){const a=Fe(e),i=k2(t,e,n,a,s,"max"),o=XO(t,e,n,s,!0,r);return[i.values,o.values]}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const UJ={kernelName:Py,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=e,l=n;_e(r,"MaxPoolWithArgmax");const u=l.data.get(r.dataId).values,c=er(r.shape,s,a,[1,1],i),[h,d]=WJ(u,r.shape,r.dtype,o,c),p=l.write(h,c.outShape,r.dtype),f=l.write(d,c.outShape,r.dtype);return[{dataId:p,shape:c.outShape,dtype:r.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function VJ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:a,keepDims:i}=r,o=Ze(a,s.shape),l=an(s.shape,o)[1],u=Q(l),c=[],h=n.makeTensorInfo([],"float32",new Float32Array([u]));c.push(h);const d=co({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});c.push(d);const p=S2({inputs:{a:d,b:h},backend:n});c.push(p);const f=xf({inputs:{x:p},backend:n,attrs:{axis:a,keepDims:i}});return c.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}const jJ={kernelName:Ep,backendName:"cpu",kernelFunc:VJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function GJ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:a,keepDims:i}=r;_e(s,"min");const o=Ze(a,s.shape);let l=o;const u=Tt(l,s.shape.length);let c=s;u!=null&&(c=$r({inputs:{x:s},backend:n,attrs:{perm:u}}),l=Ft(l.length,s.shape.length)),mn("min",l,c.shape.length);const[h,d]=an(c.shape,l),p=Q(d),f=Fn(Q(h),c.dtype),m=n.data.get(c.dataId).values;for(let g=0;g<f.length;++g){const b=g*p;let v=m[b];for(let w=0;w<p;++w){const k=m[b+w];(Number.isNaN(k)||k<v)&&(v=k)}f[g]=v}u!=null&&n.disposeIntermediateTensorInfo(c);const y=n.makeTensorInfo(h,c.dtype,f);if(i){const g=en(h,o),b=At({inputs:{x:y},backend:n,attrs:{shape:g}});return n.disposeIntermediateTensorInfo(y),b}return y}const HJ={kernelName:$p,backendName:"cpu",kernelFunc:GJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function KJ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{paddings:a,mode:i}=r;_e(s,"mirrorPad");const o=a.map((b,v)=>b[0]+s.shape[v]+b[1]),l=a.map(b=>b[0]),u=a.map((b,v)=>b[0]+s.shape[v]),c=i==="reflect"?0:1,h=n.data.get(s.dataId).values,d=s.shape.length,p=Fe(s.shape),f=Q(o),m=o.length,y=Fe(o),g=pn(s.dtype,f);for(let b=0;b<f;b++){let v=Cl(b,m,y);for(let k=0;k<m;k++)v[k]<l[k]?v[k]=l[k]*2-v[k]-c:v[k]>=u[k]&&(v[k]=(u[k]-1)*2-v[k]+c);v=v.map((k,N)=>k-l[N]);const w=la(v,d,p);g[b]=h[w]}return{dataId:n.write(g,o,s.dtype),shape:o,dtype:s.dtype}}const qJ={kernelName:Rp,backendName:"cpu",kernelFunc:KJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const XJ=ln((t,e)=>{const n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e}),YJ=Nn(Ic,XJ),QJ={kernelName:Ic,backendName:"cpu",kernelFunc:YJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function tD(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{dim:a}=r,i=s.shape.length;let o=a;if(o===-1&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);const l=Ze([o],s.shape),u=eD({inputs:{x:s},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=en(u.shape,l),h=At({inputs:{x:u},backend:n,attrs:{shape:c}}),d=w2({inputs:{a:s,b:h},backend:n}),p=sO({inputs:{x:d},backend:n}),f=xf({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=At({inputs:{x:f},backend:n,attrs:{shape:c}}),y=S2({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),y}const ZJ={kernelName:qp,backendName:"cpu",kernelFunc:tD};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function JJ(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{numSamples:a,seed:i,normalized:o}=r;_e(s,"multinomial");const l=o?s:tD({inputs:{logits:s},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],h=n.data.get(l.dataId).values,d=[u,a],p=Fn(Q(d),"int32");for(let f=0;f<u;++f){const m=f*c,y=new Float32Array(c-1);y[0]=h[m];for(let v=1;v<y.length;++v)y[v]=y[v-1]+h[m+v];const g=Kc.alea(i.toString()),b=f*a;for(let v=0;v<a;++v){const w=g();p[b+v]=y.length;for(let k=0;k<y.length;k++)if(w<y[k]){p[b+v]=k;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(d,"int32",p)}const eee={kernelName:Ly,backendName:"cpu",kernelFunc:JJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const tee=Rb;function nee(t){const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:a}=e,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;_e(s,"NonMaxSuppression");const u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,{selectedIndices:h}=tee(u,c,i,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}const ree={kernelName:zy,backendName:"cpu",kernelFunc:nee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const see=Fk;function aee(t){const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:a}=e,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;_e(s,"NonMaxSuppressionPadded");const c=n.data.get(s.dataId).values,h=n.data.get(a.dataId).values,{selectedIndices:d,validOutputs:p}=see(c,h,i,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}const iee={kernelName:Dw,backendName:"cpu",kernelFunc:aee};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const oee=Ab;function lee(t){const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:a}=e,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;_e(s,"NonMaxSuppressionWithScore");const c=n.data.get(s.dataId).values,h=n.data.get(a.dataId).values,d=i,p=o,f=l,m=u,{selectedIndices:y,selectedScores:g}=oee(c,h,d,p,f,m);return[n.makeTensorInfo([y.length],"int32",new Int32Array(y)),n.makeTensorInfo([g.length],"float32",new Float32Array(g))]}const uee={kernelName:By,backendName:"cpu",kernelFunc:lee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function cee(t){const{inputs:e,backend:n,attrs:r}=t,{indices:s}=e,{dtype:a,depth:i,onValue:o,offValue:l}=r;_e(s,"oneHot");const u=Q(s.shape),c=new Float32Array(u*i);c.fill(l);const h=n.data.get(s.dataId).values;for(let d=0;d<u;++d)h[d]>=0&&h[d]<i&&(c[d*i+h[d]]=o);return n.makeTensorInfo([...s.shape,i],a,c)}const hee={kernelName:Op,backendName:"cpu",kernelFunc:cee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ag(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){const s=yl({inputs:{input:r},backend:n}),a=Ag({inputs:{x:s},backend:n}),i=Vu({inputs:{input:r},backend:n}),o=Ag({inputs:{x:i},backend:n}),l=jr({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return I2({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const dee={kernelName:Qp,backendName:"cpu",kernelFunc:Ag};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function nD(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){const s=yl({inputs:{input:r},backend:n}),a=nD({inputs:{x:s},backend:n}),i=Vu({inputs:{input:r},backend:n}),o=Ag({inputs:{x:i},backend:n}),l=jr({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return I2({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}const pee={kernelName:Fp,backendName:"cpu",kernelFunc:nD};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function rD(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r;if(e.length===1)return Rg({inputs:{input:e[0]},backend:n,attrs:{dim:s}});const a=e[0].shape,i=e[0].dtype;e.forEach(c=>{Dn(a,c.shape,"All tensors passed to stack must have matching shapes"),R(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=e.map(c=>{const h=Rg({inputs:{input:c},backend:n,attrs:{dim:s}});return o.push(h),h}),u=ju({inputs:l,backend:n,attrs:{axis:s}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}const fee={kernelName:Dp,backendName:"cpu",kernelFunc:rD};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function mee(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{paddings:a,constantValue:i}=r;_e(s,"pad");const o=a.map((g,b)=>g[0]+s.shape[b]+g[1]),l=a.map(g=>g[0]),u=n.data.get(s.dataId).values,c=Q(s.shape),h=s.shape.length,d=Fe(s.shape),p=Q(o),f=o.length,m=Fe(o),y=pn(s.dtype,p);i!==0&&y.fill(i);for(let g=0;g<c;g++){const b=Cl(g,h,d).map((w,k)=>w+l[k]),v=la(b,f,m);y[v]=u[g]}return{dataId:n.write(y,o,s.dtype),shape:o,dtype:s.dtype}}const sD={kernelName:Mp,backendName:"cpu",kernelFunc:mee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const gee=ln((t,e)=>Math.pow(t,e)),yee=Nn(Cc,gee),bee={kernelName:Cc,backendName:"cpu",kernelFunc:yee};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function xee(t){const{inputs:e,backend:n,attrs:r}=t,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=e,o=s.map(y=>n.data.get(y.dataId).values),l=s.map(y=>y.shape),u=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values,[h,d,p]=kO(o,l,u,a.shape,a.dtype,c,i.shape),f=h.map(y=>n.makeTensorInfo([y.length],"int32",y)),m=n.makeTensorInfo(p,a.dtype,d);return f.concat([m])}const vee={kernelName:Mw,backendName:"cpu",kernelFunc:xee};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function wee(t){const{inputs:e,backend:n}=t,{starts:r,limits:s,deltas:a}=e,i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=SO(i,r.shape,r.dtype,o,s.shape,l,a.shape),h=n.makeTensorInfo([u.length],"int32",u),d=n.makeTensorInfo([c.length],r.dtype,c);return[h,d]}const kee={kernelName:Pw,backendName:"cpu",kernelFunc:wee};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function See(t){const{inputs:e,backend:n,attrs:r}=t,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=e,{rowPartitionTypes:l}=r,u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,h=n.data.get(i.dataId).values,d=o.map(y=>n.data.get(y.dataId).values),p=o.map(y=>y.shape),[f,m]=IO(u,s.shape,c,a.shape,a.dtype,h,i.shape,d,p,l);return n.makeTensorInfo(f,a.dtype,m)}const Iee={kernelName:Lw,backendName:"cpu",kernelFunc:See};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Nee(t){const{backend:e,attrs:n}=t,{start:r,stop:s,dtype:a,step:i}=n,o=NO(r,s,i,a);return e.makeTensorInfo([o.length],a,o)}const Cee={kernelName:Wy,backendName:"cpu",kernelFunc:Nee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Tee=St(Tc,t=>1/t),Eee={kernelName:Tc,backendName:"cpu",kernelFunc:Tee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function $ee(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:a,halfPixelCenters:i,size:o}=r;_e(s,"resizeBilinear");const l=Fe(s.shape),[u,c]=o,[h,d,p,f]=s.shape,m=n.data.get(s.dataId).values,y=new Float32Array(Q([h,u,c,f])),g=[a&&u>1?d-1:d,a&&c>1?p-1:p],b=[a&&u>1?u-1:u,a&&c>1?c-1:c];let v=0;const w=g[0]/b[0],k=g[1]/b[1];for(let N=0;N<h;N++)for(let T=0;T<u;T++){let E;i?E=w*(T+.5)-.5:E=w*T;const _=Math.max(0,Math.floor(E)),O=E-_,M=Math.min(d-1,Math.ceil(E)),V=N*l[0]+_*l[1],W=N*l[0]+M*l[1];for(let K=0;K<c;K++){let q;i?q=k*(K+.5)-.5:q=k*K;const ee=Math.max(0,Math.floor(q)),te=q-ee,G=Math.min(p-1,Math.ceil(q)),J=V+ee*l[2],ne=W+ee*l[2],ae=V+G*l[2],oe=W+G*l[2];for(let ue=0;ue<f;ue++){const ce=m[J+ue],de=m[ne+ue],Te=m[ae+ue],Ee=m[oe+ue],De=ce+(Te-ce)*te,Be=de+(Ee-de)*te,We=De+(Be-De)*O;y[v++]=We}}}return n.makeTensorInfo([h,u,c,f],"float32",y)}const Ree={kernelName:Wp,backendName:"cpu",kernelFunc:$ee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Aee(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:a}=e,{alignCorners:i}=r;_e([a,s],"resizeBilinearGrad");const o=Fe(s.shape),[l,u,c,h]=s.shape,[,d,p]=a.shape,f=new Float32Array(l*u*c*h),m=[i&&d>1?u-1:u,i&&p>1?c-1:c],y=[i&&d>1?d-1:d,i&&p>1?p-1:p],g=m[0]/y[0],b=m[1]/y[1],v=n.data.get(a.dataId).values;let w=0;for(let k=0;k<l;k++){const N=k*o[0];for(let T=0;T<d;T++){const E=T*g,_=Math.floor(E),O=Math.min(Math.ceil(E),u-1),M=N+_*o[1],V=N+O*o[1],W=E-_,K=1-W;for(let q=0;q<p;q++){const ee=q*b,te=Math.floor(ee),G=Math.min(Math.ceil(ee),c-1),J=ee-te,ne=1-J,ae=M+te*o[2],oe=M+G*o[2],ue=V+te*o[2],ce=V+G*o[2],de=K*ne,Te=K*J,Ee=W*ne,De=W*J;for(let Be=0;Be<h;Be++){const We=v[w++];f[ae+Be]+=We*de,f[oe+Be]+=We*Te,f[ue+Be]+=We*Ee,f[ce+Be]+=We*De}}}}return n.makeTensorInfo([l,c,u,h],"float32",f)}const _ee={kernelName:jy,backendName:"cpu",kernelFunc:Aee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Fee(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:a,halfPixelCenters:i,size:o}=r;_e(s,"resizeNearestNeighbor");const l=Fe(s.shape),[u,c]=o,[h,d,p,f]=s.shape,m=n.data.get(s.dataId).values,y=new Float32Array(h*u*c*f),g=[a&&u>1?d-1:d,a&&c>1?p-1:p],b=[a&&u>1?u-1:u,a&&c>1?c-1:c],v=g[0]/b[0],w=g[1]/b[1];let k=0;for(let N=0;N<h;N++){const T=N*l[0];for(let E=0;E<u;E++){const _=i?v*(E+.5):v*E;let O=Math.min(d-1,a?Math.round(_):Math.floor(_));i&&(O=Math.max(0,O));const M=T+O*l[1];for(let V=0;V<c;V++){const W=i?w*(V+.5):w*V;let K=Math.min(p-1,a?Math.round(W):Math.floor(W));i&&(K=Math.max(0,K));const q=M+K*l[2];for(let ee=0;ee<f;ee++){const te=m[q+ee];y[k++]=te}}}}return n.makeTensorInfo([h,u,c,f],s.dtype,y)}const Oee={kernelName:Bp,backendName:"cpu",kernelFunc:Fee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Dee(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:a}=e,{alignCorners:i}=r;_e([a,s],"resizeNearestNeighborGrad");const o=Fe(s.shape),l=Fe(a.shape),[u,c,h,d]=s.shape,[,p,f]=a.shape,m=new Float32Array(u*c*h*d),y=n.data.get(a.dataId).values,g=[i&&p>1?c-1:c,i&&f>1?h-1:h],b=[i&&p>1?p-1:p,i&&f>1?f-1:f],v=g[0]/b[0],w=g[1]/b[1],k=1/v,N=1/w,T=Math.ceil(k)*2+2,E=Math.ceil(N)*2+2;for(let _=0;_<u;_++){const O=_*o[0];for(let M=0;M<c;M++){const V=O+M*o[1],W=Math.floor(M*k),K=Math.floor(W-T/2);for(let q=0;q<h;q++){const ee=V+q*o[2],te=Math.floor(q*N),G=Math.floor(te-E/2);for(let J=0;J<d;J++){let ne=0;for(let ae=0;ae<T;ae++){const oe=ae+K;if(oe<0||oe>=p)continue;const ue=O+oe*l[1],ce=oe*v,de=Math.min(c-1,i?Math.round(ce):Math.floor(ce));if(M===de)for(let Te=0;Te<E;Te++){const Ee=Te+G;if(Ee<0||Ee>=f)continue;const De=ue+Ee*l[2],Be=Ee*w,We=Math.min(h-1,i?Math.round(Be):Math.floor(Be));q===We&&(ne+=y[De+J])}}m[ee+J]=ne}}}}return n.makeTensorInfo(s.shape,s.dtype,m)}const Mee={kernelName:Vy,backendName:"cpu",kernelFunc:Dee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Pee(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dims:a}=r;_e(s,"reverse");const i=s.shape.length,o=Ze(a,s.shape);if(i===0)return Va({inputs:{x:s},backend:n});const l=new wn(s.shape,s.dtype),u=n.bufferSync(s);for(let c=0;c<l.size;c++){const h=l.indexToLoc(c),d=h.slice();o.forEach(p=>d[p]=s.shape[p]-1-d[p]),l.set(u.get(...d),...h)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}const Lee={kernelName:Up,backendName:"cpu",kernelFunc:Pee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const zee={kernelName:rb,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:s,fillValue:a,center:i}=e,o=n,l=pn(r.dtype,Q(r.shape)),[u,c,h,d]=r.shape,[p,f]=Lb(i,c,h),m=255,y=Math.sin(s),g=Math.cos(s),b=o.data.get(r.dataId).values;for(let v=0;v<u;v++){const w=v*h*c*d;for(let k=0;k<c;k++){const N=k*(h*d);for(let T=0;T<h;T++){const E=T*d;for(let _=0;_<d;_++){const O=[u,k,T,_],M=O[2],V=O[1];let W=(M-p)*g-(V-f)*y,K=(M-p)*y+(V-f)*g;W=Math.round(W+p),K=Math.round(K+f);let q=a;if(typeof a!="number"&&(_===3?q=m:q=a[_]),W>=0&&W<h&&K>=0&&K<c){const te=K*(h*d),G=W*d,J=w+te+G+_;q=b[J]}const ee=w+N+E+_;l[ee]=q}}}}return{dataId:o.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Bee=St(Rc,t=>{const e=Math.floor(t);return t-e<.5?Math.floor(t):t-e>.5?Math.ceil(t):e%2===0?e:e+1}),Wee={kernelName:Rc,backendName:"cpu",kernelFunc:Bee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Uee(t){const{inputs:e,backend:n,attrs:r}=t,{indices:s,updates:a}=e,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=ka(a,s,i),d=!0,p=n.bufferSync(s),f=n.bufferSync(a),m=Ho(p,f,i,h,u,l,o,c,0,d);return n.makeTensorInfo(i,m.dtype,m.values)}const Vee={kernelName:Gy,backendName:"cpu",kernelFunc:Uee};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function jee(t,e){let n=0,r=t.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),t[s]<e?n=s+1:r=s;return r}function Gee(t,e){let n=0,r=t.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),t[s]<=e?n=s+1:r=s;return r}function Hee(t,e,n,r,s,a){const i=Ht("int32",n*s);for(let o=0;o<n;++o){const l=t.slice(o*r,(o+1)*r),u=o*s;for(let c=0;c<s;++c)i[u+c]=a==="left"?jee(l,e[c+u]):Gee(l,e[c+u])}return i}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Kee(t){const{inputs:e,backend:n,attrs:r}=t,{sortedSequence:s,values:a}=e,{side:i}=r,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,u=Hee(o,l,s.shape[0],s.shape[1],a.shape[1],i);return n.makeTensorInfo(a.shape,"int32",u)}const qee={kernelName:Ky,backendName:"cpu",kernelFunc:Kee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Xee(t){const{inputs:e,backend:n}=t,{condition:r,t:s,e:a}=e;_e([r,s,a],"select");const i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=On(s.dtype,a.dtype),h=Fn(Q(s.shape),c);let d=0;const p=i===0||i>1||s.shape.length===1?1:Q(s.shape.slice(1));for(let f=0;f<o.length;f++)for(let m=0;m<p;m++)o[f]===1?h[d++]=l[f]:h[d++]=u[f];return n.makeTensorInfo(s.shape,c,h)}const Yee={kernelName:Vp,backendName:"cpu",kernelFunc:Xee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Qee=uf,Zee=cf,Jee=St(_c,t=>t>=0?Zee*t:Qee*(Math.exp(t)-1)),ete={kernelName:_c,backendName:"cpu",kernelFunc:Jee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const tte=St(Dc,t=>t<0?-1:t>0?1:0),nte={kernelName:Dc,backendName:"cpu",kernelFunc:tte};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const rte=St(Fc,t=>Math.sin(t)),ste={kernelName:Fc,backendName:"cpu",kernelFunc:rte};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ate=St(Oc,t=>Math.sinh(t)),ite={kernelName:Oc,backendName:"cpu",kernelFunc:ate};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ote=11920928955078125e-23,QN=Math.log(ote)+2,lte=St(Pc,t=>{const e=t>-QN,n=t<QN,r=Math.exp(t);let s;return n?s=r:e?s=t:s=Math.log(1+r),s}),ute={kernelName:Pc,backendName:"cpu",kernelFunc:lte};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function cte(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:a,paddings:i}=r;_e([s],"spaceToBatchND");const o=Q(a),l=[[0,0]];l.push(...i);for(let y=1+a.length;y<s.shape.length;++y)l.push([0,0]);const u=sD.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),c=Fl(u.shape,a,o,!1),h=Ol(c.length,a.length,!1),d=Dl(u.shape,a,o,!1),p=At({inputs:{x:u},backend:n,attrs:{shape:c}}),f=$r({inputs:{x:p},backend:n,attrs:{perm:h}}),m=At({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}const hte={kernelName:Hp,backendName:"cpu",kernelFunc:cte};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function dte(t){const{inputs:e,backend:n}=t,{indices:r,values:s,denseShape:a,defaultValue:i}=e;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${a.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${s.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values[0],[h,d,p,f,m]=$O(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(y=>Number(y)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}const pte={kernelName:zw,backendName:"cpu",kernelFunc:dte};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function fte(t){const{inputs:e,backend:n}=t,{inputIndices:r,inputShape:s,newShape:a}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.data.get(s.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(a.dataId).values),[u,c,h]=RO(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([h.length],a.dtype,new Int32Array(h))]}const mte={kernelName:Bw,backendName:"cpu",kernelFunc:fte};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function gte(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:a}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=v2(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}const yte={kernelName:qy,backendName:"cpu",kernelFunc:gte};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function bte(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:a}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=v2(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}const xte={kernelName:Xy,backendName:"cpu",kernelFunc:bte};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function vte(t){const{inputs:e,backend:n,attrs:r}=t,{sparseIndices:s,sparseValues:a,defaultValue:i}=e,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=ka(a,s,o),p=!1,f=n.bufferSync(s);let m;switch(a.dtype){case"bool":{const y=n.bufferSync(a),g=!!n.data.get(i.dataId).values[0];m=Ho(f,y,o,d,c,u,l,h,g,p);break}case"float32":{const y=n.bufferSync(a),g=n.data.get(i.dataId).values[0];m=Ho(f,y,o,d,c,u,l,h,g,p);break}case"int32":{const y=n.bufferSync(a),g=n.data.get(i.dataId).values[0];m=Ho(f,y,o,d,c,u,l,h,g,p);break}case"string":{const y=n.bufferSync(a),g=Vs(n.data.get(i.dataId).values[0]);m=Ho(f,y,o,d,c,u,l,h,g,p);break}default:throw new Error(`Unsupported type ${a.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}const wte={kernelName:Yy,backendName:"cpu",kernelFunc:vte};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function kte(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{numOrSizeSplits:a,axis:i}=r,o=Ze(i,s.shape)[0],l=Zb(s,a,o),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map(h=>{const d=[...c];d[o]=h;const p=bl({inputs:{x:s},backend:n,attrs:{begin:u,size:d}});return u[o]+=h,p})}const Ste={kernelName:Kp,backendName:"cpu",kernelFunc:kte};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Ite={kernelName:Qy,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,r=e;_e(n,"square");const s=r.data.get(n.dataId).values,a=new Float32Array(s.length);for(let i=0;i<s.length;++i){const o=s[i];a[i]=o*o}return{dataId:r.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Nte=St(jc,(t,e)=>{const n=e;return isNaN(t)?NaN:t>0?1:n.alpha}),Cte={kernelName:jc,backendName:"cpu",kernelFunc:Nte};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Tte(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=r;_e(s,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:y,isSimpleSlice:g,begin:b,end:v,strides:w}=Db(s.shape,a,i,o,l,u,c,h,d);let k;if(m)k=At({inputs:{x:s},backend:n,attrs:{shape:f}});else if(y||g){R(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const N=Ob(b,v,w),T=bl({inputs:{x:s},backend:n,attrs:{begin:b,size:N}});k=At({inputs:{x:T},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(T)}else{const N=n.bufferSync(s),T=FO(p,N,w,b);k=n.makeTensorInfo(f,T.dtype,T.values)}return k}const Ete={kernelName:Jy,backendName:"cpu",kernelFunc:Tte};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function $te(t){const{inputs:e,backend:n,attrs:r}=t,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:h}=e,d=n.data.get(c.dataId).values,p=n.data.get(h.dataId).values,[f,m]=OO(d,p,s,a,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}const Rte={kernelName:eb,backendName:"cpu",kernelFunc:$te};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ate(t){const{inputs:e,backend:n,attrs:r}=t,{skipEmpty:s}=r,{input:a,delimiter:i}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values[0],[u,c,h]=DO(o,l,s),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}const _te={kernelName:Ww,backendName:"cpu",kernelFunc:Ate};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Fte(t){const{inputs:e,backend:n,attrs:r}=t,{numBuckets:s}=r,{input:a}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.data.get(a.dataId).values,o=MO(i,s);return n.makeTensorInfo(a.shape,"int32",o)}const Ote={kernelName:Uw,backendName:"cpu",kernelFunc:Fte};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Dte=St(Wc,t=>Math.tan(t)),Mte={kernelName:Wc,backendName:"cpu",kernelFunc:Dte};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Pte=St(Uc,t=>Math.tanh(t)),Lte={kernelName:Uc,backendName:"cpu",kernelFunc:Pte};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zte(t){const{inputs:e,backend:n}=t,{tensor:r,indices:s,updates:a}=e,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=ka(a,s,r.shape),h=!1,d=n.bufferSync(s),p=n.bufferSync(a),f=n.bufferSync(r),m=Ho(d,p,r.shape,c,l,o,i,u,f,h);return n.makeTensorInfo(r.shape,m.dtype,m.values)}const Bte={kernelName:Hy,backendName:"cpu",kernelFunc:zte};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Wte(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reps:a}=r;_e(s,"tile");const i=LO(n.bufferSync(s),a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const Ute={kernelName:Vc,backendName:"cpu",kernelFunc:Wte};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Vte(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{k:a,sorted:i}=r;_e(s,"topk");const o=n.data.get(s.dataId).values,[l,u]=BO(o,s.shape,s.dtype,a,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}const jte={kernelName:tb,backendName:"cpu",kernelFunc:Vte};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Gte(t){const{inputs:e,attrs:n,backend:r}=t,{image:s,transforms:a}=e,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[c,h,d,p]=s.shape,[f,m]=u??[h,d],y=[c,f,m,p],g=Fe(s.shape),b=g[0],v=g[1],w=g[2],k=Fe(y),N=k[0],T=k[1],E=k[2],_=pn(s.dtype,Q(y));_.fill(l);const O=r.data.get(s.dataId).values,M=r.data.get(a.dataId).values;for(let V=0;V<c;++V){const W=a.shape[0]===1?M:M.subarray(V*8,V*8+8);for(let K=0;K<f;++K)for(let q=0;q<m;++q)for(let ee=0;ee<p;++ee){let te;const G=W[6]*q+W[7]*K+1;if(G===0)continue;const J=(W[0]*q+W[1]*K+W[2])/G,ne=(W[3]*q+W[4]*K+W[5])/G,ae=ZN(J,d,o),oe=ZN(ne,h,o);switch(i){case"nearest":te=Qte(O,h,d,b,v,w,V,oe,ae,ee,l);break;case"bilinear":te=Zte(O,h,d,b,v,w,V,oe,ae,ee,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}const ue=V*N+K*T+q*E+ee;_[ue]=te}return r.makeTensorInfo(y,s.dtype,_)}return{dataId:r.write(_,y,s.dtype),shape:s.shape,dtype:s.dtype}}const Hte={kernelName:nb,backendName:"cpu",kernelFunc:Gte};function ZN(t,e,n){switch(n){case"reflect":return Kte(t,e);case"wrap":return qte(t,e);case"nearest":return Yte(t,e);case"constant":default:return Xte(t)}}function Kte(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const r=2*e;n<r&&(n=r*Math.trunc(-n/r)+n),n=n<-e?n+r:-n-1}else if(n>e-1)if(e<=1)n=0;else{const r=2*e;n-=r*Math.trunc(n/r),n>=e&&(n=r-n-1)}return Ji(0,n,e-1)}function qte(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const r=e-1;n+=e*(Math.trunc(-n/r)+1)}else if(n>e-1)if(e<=1)n=0;else{const r=e-1;n-=e*Math.trunc(n/r)}return Ji(0,n,e-1)}function Xte(t,e){return t}function Yte(t,e){return Ji(0,t,e-1)}function Lh(t,e,n,r,s,a,i,o,l,u,c){const h=i*r+o*s+l*a+u;return 0<=o&&o<e&&0<=l&&l<n?t[h]:c}function Qte(t,e,n,r,s,a,i,o,l,u,c){const h=Math.round(o),d=Math.round(l);return Lh(t,e,n,r,s,a,i,h,d,u,c)}function Zte(t,e,n,r,s,a,i,o,l,u,c){const h=Math.floor(o),d=Math.floor(l),p=h+1,f=d+1,m=(f-l)*Lh(t,e,n,r,s,a,i,h,d,u,c)+(l-d)*Lh(t,e,n,r,s,a,i,h,f,u,c),y=(f-l)*Lh(t,e,n,r,s,a,i,p,d,u,c)+(l-d)*Lh(t,e,n,r,s,a,i,p,f,u,c);return(p-o)*m+(o-h)*y}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Jte(t){const{inputs:e,attrs:n,backend:r}=t,{axis:s}=n,{x:a}=e;_e(a,"unique");const i=r.data.get(a.dataId).values,{outputValues:o,outputShape:l,indices:u}=WO(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}const ene={kernelName:Vw,backendName:"cpu",kernelFunc:Jte};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function tne(t){const{inputs:e,backend:n,attrs:r}=t,{value:s}=e;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s.shape.length,o=s.shape[a],l=new Array(i-1);let u=0;for(let p=0;p<i;p++)p!==a&&(l[u++]=s.shape[p]);const c=new Array(i).fill(0),h=s.shape.slice();h[a]=1;const d=new Array(o);for(let p=0;p<d.length;p++){c[a]=p;const f=bl({inputs:{x:s},backend:n,attrs:{begin:c,size:h}});d[p]=At({inputs:{x:f},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(f)}return d}const nne={kernelName:Xp,backendName:"cpu",kernelFunc:tne};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function rne(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,segmentIds:a}=e,{numSegments:i}=r;_e(s,"unsortedSegmentSum");const o=s.shape.length,l=a.shape.length,u=[],c=[],h=o-l;let d=a;for(let f=0;f<h;++f){const m=Rg({inputs:{input:d},backend:n,attrs:{dim:f+1}});d=m,c.push(m)}for(let f=0;f<i;++f){const m=vi(f,"int32"),y=n.makeTensorInfo([],"int32",m),g=nO({inputs:{a:y,b:d},backend:n}),b=co({inputs:{x:g},backend:n,attrs:{dtype:"float32"}}),v=p0({inputs:{a:b,b:s},backend:n}),w=xf({inputs:{x:v},backend:n,attrs:{axis:0,keepDims:!1}});u.push(w),c.push(y),c.push(g),c.push(b),c.push(v),c.push(w)}const p=rD({inputs:u,backend:n,attrs:{axis:0}});return c.forEach(f=>n.disposeIntermediateTensorInfo(f)),p}const sne={kernelName:Yp,backendName:"cpu",kernelFunc:rne};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ane=[JY,O9,tQ,rQ,B9,aQ,oQ,uQ,hQ,pQ,mQ,yQ,xQ,kQ,IQ,TQ,$Q,AQ,FQ,QY,DQ,PQ,zQ,U9,WQ,L9,j9,VQ,D9,GQ,KQ,qQ,YQ,ZQ,eZ,nZ,sZ,iZ,lZ,cZ,dZ,fZ,gZ,bZ,xZ,wZ,SZ,NZ,CZ,TZ,EZ,RZ,FZ,jY,DZ,G9,VZ,H9,jZ,q9,YZ,QZ,JZ,Y9,Z9,tJ,rJ,aJ,oJ,eY,nY,M9,uJ,HQ,hJ,pJ,mJ,GY,sY,iY,yJ,lY,xJ,kJ,IJ,TJ,$J,AJ,_J,cY,OJ,MJ,LJ,BJ,UJ,jJ,HJ,dY,qJ,QJ,eee,fY,gY,ree,iee,uee,bY,hee,pee,fee,sD,bee,KY,wY,vee,kee,Iee,Cee,P9,xv,Eee,qY,XY,YY,Ree,_ee,Oee,Mee,Lee,zee,Wee,$Y,Vee,qee,Yee,ete,AY,nte,ste,ite,_Y,ZJ,ute,hte,pte,mte,yte,xte,wte,Ste,DY,Ite,PY,zY,Cte,Ete,Rte,_te,Ote,VY,AZ,Mte,Lte,Bte,Ute,jte,Hte,xY,ene,nne,sne,dee];for(const t of ane)sb(t);/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const zo={},om={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function ine(t,e){zo[t]=e}function ba(t,e){if(!(t in zo)||e!=null){const r=lne(t,e);if(r!==null)zo[t]=r;else return console.log("Could not get context for WebGL version",t),null}const n=zo[t];return n==null||n.isContextLost()?(delete zo[t],ba(t)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),zo[t])}function one(t){if(!Z().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&t===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function lne(t,e){if(t!==1&&t!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=e??one(t);return n.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete zo[t]},!1),Z().getBool("SOFTWARE_WEBGL_ENABLED")&&(om.failIfMajorPerformanceCaveat=!1),t===1?n.getContext("webgl",om)||n.getContext("experimental-webgl",om):n.getContext("webgl2",om)}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/var Ld;(function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"})(Ld||(Ld={}));var us;(function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"})(us||(us={}));var Bn;(function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Bn||(Bn={}));function vf(t,e){return[e,t]}function une(t,e){return t*e}function lm(t){const e=Q(t),n=Math.ceil(e/4);return ng(n)}function Qc(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function cne(t,e){const[n,r]=Qc(t,e);return n*r*4}function N2(t,e){const n=t;let r,s,a,i,o,l,u,c,h,d;return Z().getNumber("WEBGL_VERSION")===2?(r=n.R32F,s=n.R16F,a=n.RGBA16F,i=n.RGBA32F,o=n.RED,u=4,c=1,h=n.HALF_FLOAT,d=n.FLOAT,l=n.RGBA8):(r=t.RGBA,s=t.RGBA,a=t.RGBA,i=n.RGBA,o=t.RGBA,u=4,c=4,h=e!=null?e.HALF_FLOAT_OES:null,d=t.FLOAT,l=t.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function we(t,e){const n=e();return Z().getBool("DEBUG")&&hne(t),n}function hne(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+iD(t,e))}const dne=596e-10,pne=65504;function aD(t){return!!(Z().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||t===0||dne<Math.abs(t)&&Math.abs(t)<pne)}function iD(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function zh(t,e){return Si(t,()=>t.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function oD(t,e){const n=Si(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(we(t,()=>t.shaderSource(n,e)),we(t,()=>t.compileShader(n)),t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function lD(t,e){const n=Si(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(we(t,()=>t.shaderSource(n,e)),we(t,()=>t.compileShader(n)),Z().get("ENGINE_COMPILE_ONLY"))return n;if(t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw C2(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const fne=/ERROR: [0-9]+:([0-9]+):/g;function C2(t,e){const n=fne.exec(e);if(n==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(t);return}const r=+n[1],s=t.split(`
`),a=s.length.toString().length+2,i=s.map((h,d)=>Yo((d+1).toString(),a)+h);let o=0;for(let h=0;h<i.length;h++)o=Math.max(i[h].length,o);const l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${Yo(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function uD(t){return Si(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}function cD(t,e){if(we(t,()=>t.linkProgram(e)),!Z().get("ENGINE_COMPILE_ONLY")&&t.getProgramParameter(e,t.LINK_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function Cm(t,e){if(we(t,()=>t.validateProgram(e)),t.getProgramParameter(e,t.VALIDATE_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function hD(t,e){const n=Si(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return we(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),we(t,()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function dD(t,e){const n=Si(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return we(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n)),we(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function mne(){return Z().getNumber("WEBGL_VERSION")===2?1:4}function pD(t){return Si(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}function fD(t,e){const n=Z().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0){const r=`[${t}x${e}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(t>n||e>n){const r=`[${t}x${e}]`,s=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function mD(t){return Si(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function wv(t,e,n,r,s,a,i){const o=t.getAttribLocation(e,n);return o===-1?!1:(we(t,()=>t.bindBuffer(t.ARRAY_BUFFER,r)),we(t,()=>t.vertexAttribPointer(o,s,t.FLOAT,!1,a,i)),we(t,()=>t.enableVertexAttribArray(o)),!0)}function gD(t,e,n){wD(t,n),we(t,()=>t.activeTexture(t.TEXTURE0+n)),we(t,()=>t.bindTexture(t.TEXTURE_2D,e))}function gne(t,e){wD(t,e),we(t,()=>t.activeTexture(t.TEXTURE0+e)),we(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function yD(t,e,n){return Si(t,()=>t.getUniformLocation(e,n),'uniform "'+n+'" not present in program.')}function bD(t,e,n){return t.getUniformLocation(e,n)}function xD(t,e,n,r){we(t,()=>gD(t,e,r)),we(t,()=>t.uniform1i(n,r))}function yne(t){we(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),we(t,()=>t.viewport(0,0,t.canvas.width,t.canvas.height)),we(t,()=>t.scissor(0,0,t.canvas.width,t.canvas.height))}function Tm(t,e,n){we(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),we(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0))}function kv(t,e){we(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),we(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function Bh(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+vD(t,e))}function vD(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Si(t,e,n){const r=we(t,()=>e());if(r==null)throw new Error(n);return r}function wD(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+t.TEXTURE0;if(r<t.TEXTURE0||r>n){const s=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${s}.`)}}function xl(t,e=2){return Q(t.slice(0,t.length-e))}function vl(t){if(t.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function Wh(t){let e=[1,1,1];return t.length===0||t.length===1&&t[0]===1||(e=[xl(t),...vl(t)]),e}function kD(t,e=!1){let n=Z().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=Z().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&Z().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),e&&(n=n*2,r=r*2,t=t.map((o,l)=>l>=t.length-2?ny(t[l]):t[l]),t.length===1&&(t=[2,t[0]])),t.length!==2&&(t=xi(t).newShape);let s=Q(t),a=null;t.length<=1&&s<=n?a=[1,s]:t.length===2&&t[0]<=n&&t[1]<=n?a=t:t.length===3&&t[0]*t[1]<=n&&t[2]<=n?a=[t[0]*t[1],t[2]]:t.length===3&&t[0]<=n&&t[1]*t[2]<=n?a=[t[0],t[1]*t[2]]:t.length===4&&t[0]*t[1]*t[2]<=n&&t[3]<=n?a=[t[0]*t[1]*t[2],t[3]]:t.length===4&&t[0]<=n&&t[1]*t[2]*t[3]<=n&&(a=[t[0],t[1]*t[2]*t[3]]);const i=a!=null&&Math.max(...a)>r&&Math.min(...a)<=(e?2:1)&&Math.min(...a)>0;if(a==null||i)if(e){const o=xl(t);let l=2,u=2;t.length&&([l,u]=vl(t)),s=o*(l/2)*(u/2),a=ng(s).map(c=>c*2)}else a=ng(s);return a}function um(t){return t%2===0}function zd(t,e){if(t=t.slice(-2),e=e.slice(-2),Je(t,e)||!t.length||!e.length||t[0]===0||t[1]===0||e[0]===0||e[1]===0)return!0;if(t.length!==e.length){const n=t[t.length-1],r=e[e.length-1];if(n===r||um(n)&&um(r)&&(t[0]===1||e[0]===1))return!0}return t[1]===e[1]&&um(t[0])&&um(e[0])}let Em,$m;function SD(t){if(Em==null){const e=ba(t);Em=e.getParameter(e.MAX_TEXTURE_SIZE)}return Em}function bne(){Em=null}function xne(){$m=null}function ID(t){if($m==null){const e=ba(t);$m=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,$m)}function ND(t){if(t===0)return 0;let e;const n=ba(t);return cs(n,"EXT_disjoint_timer_query_webgl2")&&t===2?e=2:cs(n,"EXT_disjoint_timer_query")?e=1:e=0,e}function cs(t,e){return t.getExtension(e)!=null}function Sv(t){try{if(ba(t)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function CD(t){if(t===0)return!1;const e=ba(t);if(t===1){if(!cs(e,"OES_texture_float"))return!1}else if(!cs(e,"EXT_color_buffer_float"))return!1;return Iv(e)}function TD(t){if(t===0)return!1;const e=ba(t);if(t===1){if(!cs(e,"OES_texture_float")||!cs(e,"WEBGL_color_buffer_float"))return!1}else{if(cs(e,"EXT_color_buffer_float"))return Iv(e);const n="EXT_color_buffer_half_float";if(cs(e,n)){const r=e.getExtension(n);return vne(e,r)}return!1}return Iv(e)}function Iv(t){const e=N2(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const s=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(r),s}function vne(t,e){const n=N2(t,e),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const s=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,s),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);const a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(s),a}function ED(t){return t!==2?!1:ba(t).fenceSync!=null}function Zc(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&R(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}const t2e=Object.freeze(Object.defineProperty({__proto__:null,assertNotComplex:Zc,bindCanvasToFramebuffer:yne,bindColorTextureToFramebuffer:Tm,bindTextureToProgramUniformSampler:xD,bindTextureUnit:gD,bindVertexBufferToProgramAttribute:wv,callAndCheck:we,canBeRepresented:aD,createFragmentShader:lD,createFramebuffer:mD,createProgram:uD,createStaticIndexBuffer:dD,createStaticVertexBuffer:hD,createTexture:pD,createVertexShader:oD,getBatchDim:xl,getExtensionOrThrow:zh,getFramebufferErrorMessage:vD,getMaxTexturesInShader:ID,getNumChannels:mne,getProgramUniformLocation:bD,getProgramUniformLocationOrThrow:yD,getRowsCols:vl,getShapeAs3D:Wh,getTextureShapeFromLogicalShape:kD,getWebGLDisjointQueryTimerVersion:ND,getWebGLErrorMessage:iD,getWebGLMaxTextureSize:SD,hasExtension:cs,isCapableOfRenderingToFloatTexture:CD,isDownloadFloatTextureEnabled:TD,isReshapeFree:zd,isWebGLFenceEnabled:ED,isWebGLVersionEnabled:Sv,linkProgram:cD,logShaderSourceAndInfoLog:C2,resetMaxTextureSize:bne,resetMaxTexturesInShader:xne,unbindColorTextureFromFramebuffer:kv,unbindTextureUnit:gne,validateFramebuffer:Bh,validateProgram:Cm,validateTextureSize:fD},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Oe=Z();Oe.registerFlag("HAS_WEBGL",()=>Oe.getNumber("WEBGL_VERSION")>0);Oe.registerFlag("WEBGL_VERSION",()=>Sv(2)?2:Sv(1)?1:0);Oe.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Oe.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Oe.get("WEBGL_VERSION")===2);Oe.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Oe.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Oe.registerFlag("WEBGL_PACK",()=>Oe.getBool("HAS_WEBGL"));Oe.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Oe.getBool("WEBGL_PACK"));Oe.registerFlag("WEBGL_PACK_CLIP",()=>Oe.getBool("WEBGL_PACK"));Oe.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Oe.getBool("WEBGL_PACK"));Oe.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Oe.getBool("WEBGL_PACK"));Oe.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Oe.getBool("WEBGL_PACK"));Oe.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Oe.getBool("WEBGL_PACK"));Oe.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Oe.getBool("WEBGL_PACK"));Oe.registerFlag("WEBGL_PACK_REDUCE",()=>Oe.getBool("WEBGL_PACK"));Oe.registerFlag("WEBGL_LAZILY_UNPACK",()=>Oe.getBool("WEBGL_PACK"));Oe.registerFlag("WEBGL_CONV_IM2COL",()=>Oe.getBool("WEBGL_PACK"));Oe.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Oe.getBool("WEBGL_PACK"));Oe.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>SD(Oe.getNumber("WEBGL_VERSION")));Oe.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>ID(Oe.getNumber("WEBGL_VERSION")));Oe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=Oe.getNumber("WEBGL_VERSION");return t===0?0:ND(t)});Oe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Oe.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Hw());Oe.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>CD(Oe.getNumber("WEBGL_VERSION")));Oe.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Oe.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Oe.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Oe.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>TD(Oe.getNumber("WEBGL_VERSION")));Oe.registerFlag("WEBGL_FENCE_API_ENABLED",()=>ED(Oe.getNumber("WEBGL_VERSION")));Oe.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Oe.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Oe.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)});Oe.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Hw()?1:-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)});Oe.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Oe.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Oe.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Oe.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Oe.registerFlag("WEBGL_EXP_CONV",()=>!1);Oe.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Oe.getBool("IS_TEST"));Oe.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Oe.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Oe.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Oe.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function gr(){let t,e,n,r,s,a,i,o,l,u;return Z().getNumber("WEBGL_VERSION")===2?(t="#version 300 es",e="in",n="out",r="in",s="texture",a="outputColor",i="out vec4 outputColor;",o=Z().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(t="",e="attribute",n="varying",r="varying",s="texture2D",a="gl_FragColor",i="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:t,attribute:e,varyingVs:n,varyingFs:r,texture2D:s,output:a,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ll(t,e,n="index"){const r=Fe(e);return r.map((s,a)=>{const i=`int ${t[a]} = ${n} / ${s}`,o=a===r.length-1?`int ${t[a+1]} = ${n} - ${t[a]} * ${s}`:`index -= ${t[a]} * ${s}`;return`${i}; ${o};`}).join("")}function f0(t,e,n="index"){const r=Fe(e);return r.map((s,a)=>{const i=`int ${t[a]} = ${n} / outShapeStrides[${a}]`,o=a===r.length-1?`int ${t[a+1]} = ${n} - ${t[a]} * outShapeStrides[${a}]`:`index -= ${t[a]} * outShapeStrides[${a}]`;return`${i}; ${o};`}).join("")}function wne(t,e){const n=t.length,r=t.map(a=>`${e}[${a}]`),s=new Array(n-1);s[n-2]=r[n-1];for(let a=n-3;a>=0;--a)s[a]=`(${s[a+1]} * ${r[a+1]})`;return s}function kne(t,e,n="index"){const r=t.map((a,i)=>i),s=wne(r,e);return s.map((a,i)=>{const o=`int ${t[i]} = ${n} / ${s[i]}`,l=i===s.length-1?`int ${t[i+1]} = ${n} - ${t[i]} * ${s[i]}`:`index -= ${t[i]} * ${s[i]}`;return`${o}; ${l};`}).join("")}function T2(t){const e=Fe(t).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function E2(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const $D=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const{getBroadcastDims:RD}=M5;function Sne(t,e,n){const r=[];if(t.forEach(d=>{const p=Q(d.shapeInfo.logicalShape);if(d.shapeInfo.isUniform?r.push(`uniform float ${d.name}${p>1?`[${p}]`:""};`):(r.push(`uniform sampler2D ${d.name};`),r.push(`uniform int offset${d.name};`)),n.enableShapeUniforms){const{uniformShape:f}=$2(n.packedInputs,d.shapeInfo.logicalShape,d.shapeInfo.texShape);switch(f.length){case 1:r.push(`uniform int ${d.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${d.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${d.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${d.name}Shape;`);break}r.push(`uniform ivec2 ${d.name}TexShape;`)}}),n.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(d=>{r.push(`uniform ${d.type} ${d.name}${d.arrayIndex?`[${d.arrayIndex}]`:""};`)});const s=r.join(`
`),a=t.map(d=>Ine(d,e,n.packedInputs,n.enableShapeUniforms)).join(`
`),i=e.texShape,o=gr(),l=Tne(o);let u,c,h=Rne(o);return e.isPacked?(u=Nne(e.logicalShape,i,n.enableShapeUniforms),c=$ne(o)):(u=Cne(e.logicalShape,i,n.enableShapeUniforms),c=Ene(o)),n.packedInputs&&(h+=One),[h,l,c,s,u,a,n.userCode].join(`
`)}function Jc(t,e=!1){const n=t.shapeInfo.logicalShape;switch(n.length){case 0:return Hne(t,e);case 1:return qne(t,e);case 2:return Yne(t,e);case 3:return Zne(t,e);case 4:return ere(t,e);case 5:return tre(t);case 6:return nre(t);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function AD(t,e){switch(t.shapeInfo.logicalShape.length){case 0:return Gne(t);case 1:return Kne(t,e);case 2:return Xne(t,e);case 3:return Qne(t,e);default:return Jne(t,e)}}function Ine(t,e,n=!1,r){let s="";n?s+=AD(t,r):s+=Jc(t,r);const a=t.shapeInfo.logicalShape,i=e.logicalShape;return a.length<=i.length&&(n?s+=rre(t,e):s+=sre(t,e)),s}function Nne(t,e,n){switch(t.length){case 0:return _D();case 1:return Dne(t,e,n);case 2:return Vne(t,e,n);case 3:return Pne(t,e,n);default:return zne(t,e,n)}}function Cne(t,e,n){switch(t.length){case 0:return _D();case 1:return Mne(t,e,n);case 2:return jne(t,e,n);case 3:return Lne(t,e,n);case 4:return Bne(t,e,n);case 5:return Wne(t,e);case 6:return Une(t,e);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}function Tne(t){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${t.texture2D}(textureSampler, uv).r;
    }
  `}function Ene(t){return`
    void setOutput(float val) {
      ${t.output} = vec4(val, 0, 0, 0);
    }
  `}function $ne(t){return`
    void setOutput(vec4 val) {
      ${t.output} = val;
    }
  `}function Rne(t){return`${t.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${t.varyingFs} vec2 resultUV;
    ${t.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${t.defineSpecialNaN}
    ${t.defineSpecialInf}
    ${t.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Ane}
    ${_ne}
    ${Fne}
  `}const Ane=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,_ne=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Fne=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,One=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function _D(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function Dne(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function Mne(t,e,n){return e[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function Pne(t,e,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(t[2]/2),a=s*Math.ceil(t[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function Lne(t,e,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${f0(["r","c","d"],t)}
    return ivec3(r, c, d);
  }
`;const r=Ll(["r","c","d"],t);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function zne(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(t[t.length-1]/2),a=s*Math.ceil(t[t.length-2]/2);let i=a,o="",l="b, r, c";for(let u=2;u<t.length-1;u++)i*=t[t.length-u-1],o=`
      int b${u} = index / ${i};
      index -= b${u} * ${i};
    `+o,l=`b${u}, `+l;return`
    ivec${t.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${o}

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${t.length}(${l});
    }
  `}function Bne(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${f0(["r","c","d","d2"],t)}
      return ivec4(r, c, d, d2);
    }
  `;const r=Ll(["r","c","d","d2"],t);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function Wne(t,e){const n=Ll(["r","c","d","d2","d3"],t);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function Une(t,e){const n=Ll(["r","c","d","d2","d3","d4"],t);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Vne(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(Je(t,e))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;const s=Math.ceil(t[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function jne(t,e,n){return Je(t,e)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:t[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:t[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${t[1]};
      int c = index - r * ${t[1]};
      return ivec2(r, c);
    }
  `}function zl(t){return`offset${t}`}function Gne(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=gr();return`
    vec4 ${n}() {
      return ${r.texture2D}(${e}, halfCR);
    }
  `}function Hne(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[s,a]=t.shapeInfo.texShape;if(s===1&&a===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;const i=zl(n);if(e)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});
      return sampleTexture(${n}, uv);
    }
  `;const[o,l]=t.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${i});
      return sampleTexture(${n}, uv);
    }
  `}function Kne(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t.shapeInfo.texShape,a=gr();if(e)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${a.texture2D}(${n}, uv);
    }
  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${a.texture2D}(${n}, uv);
    }
  `}function qne(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${eh(t)}
      }
    `;const s=t.shapeInfo.texShape,a=s[0],i=s[1];if(i===1&&a===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;const o=zl(n);return i===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${a}.0);
        return sampleTexture(${n}, uv);
      }
    `:a===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:e?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${a}, ${i}, index + ${o});
      return sampleTexture(${n}, uv);
    }
  `}function Xne(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=t.shapeInfo.texShape,i=a[0],o=a[1],l=gr();if(a!=null&&Je(n,a))return e?`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(e)return`
    vec4 ${s}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;const u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=Math.ceil(n[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function Yne(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=t.shapeInfo.texShape;if(a!=null&&Je(n,a)){if(e)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;const d=a[0],p=a[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `}const{newShape:i,keptDims:o}=xi(n),l=i;if(l.length<n.length){const d=th(t,l),p=["row","col"];return`
      ${Jc(d,e)}
      float ${s}(int row, int col) {
        return ${s}(${nh(p,o)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${eh(t)}
      }
    `;const u=a[0],c=a[1],h=zl(r);return c===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${r}, uv);
    }
  `:u===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:e?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${h};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${r}, uv);
  }
`}function Qne(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=t.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(n[0]===1){const d=n.slice(1),p=[1,2],f=th(t,d),m=["b","row","col"];return`
        ${AD(f,e)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${nh(m,p)});
        }
      `}const o=gr();if(e)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `;const l=i[0],u=i[1],c=Math.ceil(n[2]/2),h=c*Math.ceil(n[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${h}, ${c}, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `}function Zne(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=xi(n),u=o;if(u.length<n.length){const m=th(t,u),y=["row","col","depth"];return`
        ${Jc(m,e)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${nh(y,l)});
        }
      `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${a}, ${i}, 1)));
        ${eh(t)}
      }
    `;const c=t.shapeInfo.texShape,h=c[0],d=c[1],p=t.shapeInfo.flatOffset;if(d===a&&p==null)return e?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${h}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(d===i&&p==null)return e?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);
      return sampleTexture(${r}, uv);
    }
  `;const f=zl(r);return e?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a} + col * ${i} + depth + ${f};
        vec2 uv = uvFromFlat(${h}, ${d}, index);
        return sampleTexture(${r}, uv);
      }
  `}function Jne(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=gr();if(e)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);
    }
  `;const a=t.shapeInfo.logicalShape,i=a.length,o=t.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],h=Math.ceil(a[i-1]/2);let d=h*Math.ceil(a[i-2]/2),p="int b, int row, int col",f=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let m=2;m<i-1;m++)p=`int b${m}, `+p,d*=a[i-m-1],f=`b${m} * ${d} + `+f;return`
    vec4 ${r}(${p}) {
      int index = ${f};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${s.texture2D}(${n}, uv);
    }
  `}function ere(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[3],i=n[2]*a,o=n[1]*i,{newShape:l,keptDims:u}=xi(n);if(l.length<n.length){const b=th(t,l),v=["row","col","depth","depth2"];return`
      ${Jc(b,e)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${nh(v,u)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${i}, ${a}, 1)));
        ${eh(t)}
      }
    `;const c=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,d=h[0],p=h[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,y=`int stride0 = ${r}Shape[1] * stride1;`;if(p===o&&c==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${f}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(p===a&&c==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;const g=zl(r);return e?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${m}
      ${y}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${g});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} +
          depth * ${a} + depth2;
      vec2 uv = uvFromFlat(${d}, ${p}, index + ${g});
      return sampleTexture(${r}, uv);
    }
  `}function tre(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[4],a=e[3]*s,i=e[2]*a,o=e[1]*i,{newShape:l,keptDims:u}=xi(e);if(l.length<e.length){const m=th(t,l),y=["row","col","depth","depth2","depth3"];return`
      ${Jc(m)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${nh(y,u)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${i}, ${a}, ${s})) +
          depth3;
        ${eh(t)}
      }
    `;const c=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,d=h[0],p=h[1];if(p===o&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${a}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(p===s&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;const f=zl(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} + depth * ${a} +
          depth2 * ${s} + depth3 + ${f};
      vec2 uv = uvFromFlat(${d}, ${p}, index);
      return sampleTexture(${n}, uv);
    }
  `}function nre(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:a}=xi(e);if(s.length<e.length){const y=th(t,s),g=["row","col","depth","depth2","depth3","depth4"];return`
      ${Jc(y)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${nh(g,a)});
      }
    `}const i=e[5],o=e[4]*i,l=e[3]*o,u=e[2]*l,c=e[1]*u;if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${eh(t)}
      }
    `;const h=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,p=d[0],f=d[1];if(f===c&&h==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${o}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===i&&h==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;const m=zl(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};
      vec2 uv = uvFromFlat(${p}, ${f}, index);
      return sampleTexture(${n}, uv);
    }
  `}function eh(t){const e=t.name,n=Q(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function rre(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=t.shapeInfo.logicalShape.length,i=e.logicalShape.length,o=RD(t.shapeInfo.logicalShape,e.logicalShape),l=Ct(i),u=i-a;let c;const h=["x","y","z","w","u","v"];a===0?c="":i<2&&o.length>=1?c="coords = 0;":c=o.map(y=>`coords.${h[y+u]} = 0;`).join(`
`);let d="";i<2&&a>0?d="coords":d=t.shapeInfo.logicalShape.map((y,g)=>`coords.${h[g+u]}`).join(", ");let p="return outputValue;";const f=Q(t.shapeInfo.logicalShape)===1,m=Q(e.logicalShape)===1;if(a===1&&!f&&!m)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(f&&!m)i===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(o.length){const y=a-2,g=a-1;o.indexOf(y)>-1&&o.indexOf(g)>-1?p="return vec4(outputValue.x);":o.indexOf(y)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(g)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${r}(${d});
      ${p}
    }
  `}function sre(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=e.texShape,i=t.shapeInfo.texShape,o=t.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!t.shapeInfo.isUniform&&o===l&&t.shapeInfo.flatOffset==null&&Je(i,a))return`
      float ${s}() {
        return sampleTexture(${n}, resultUV);
      }
    `;const u=Ct(l),c=RD(t.shapeInfo.logicalShape,e.logicalShape),h=l-o;let d;const p=["x","y","z","w","u","v"];o===0?d="":l<2&&c.length>=1?d="coords = 0;":d=c.map(m=>`coords.${p[m+h]} = 0;`).join(`
`);let f="";return l<2&&o>0?f="coords":f=t.shapeInfo.logicalShape.map((m,y)=>`coords.${p[y+h]}`).join(", "),`
    float ${s}() {
      ${u} coords = getOutputCoords();
      ${d}
      return get${r}(${f});
    }
  `}function Ct(t){if(t<=1)return"int";if(t===2)return"ivec2";if(t===3)return"ivec3";if(t===4)return"ivec4";if(t===5)return"ivec5";if(t===6)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function $2(t,e,n){const{newShape:r,keptDims:s}=xi(e),a=e.length,i=t&&a===3&&e[0]===1,o=i?e.slice(1):r,l=!t&&a>1&&!Je(e,n)&&r.length<a||i;return{useSqueezeShape:l,uniformShape:l?o:e,keptDims:s}}function th(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function nh(t,e){return e.map(n=>t[n]).join(", ")}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function are(t,e,n,r){const s=n.map((c,h)=>{const d={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(d.flatOffset=c.texData.slice.flatOffset),{name:e.variableNames[h],shapeInfo:d}}),a=s.map(c=>c.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=Sne(s,i,e),l=lD(t.gl,o),u=t.createProgram(l);return Z().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:a,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(t.buildVao(u),Object.assign({program:e,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:a,outShapeInfo:i},FD(t,e,u)))}function FD(t,e,n){const r=[],s=[];let a,i,o,l=null,u=null;u=t.getUniformLocation(n,"NAN",!1),Z().getNumber("WEBGL_VERSION")===1&&(l=t.getUniformLocation(n,"INFINITY",!1));const c=!1;for(const h of e.variableNames){const d={name:h,uniform:t.getUniformLocation(n,h,c),offset:t.getUniformLocation(n,`offset${h}`,c)};e.enableShapeUniforms&&(d.shape=t.getUniformLocation(n,`${h}Shape`,c),d.texShape=t.getUniformLocation(n,`${h}TexShape`,c)),r.push(d)}if(e.enableShapeUniforms&&(a=t.getUniformLocation(n,"outShape",c),o=t.getUniformLocation(n,"outShapeStrides",c),i=t.getUniformLocation(n,"outTexShape",c)),e.customUniforms)for(const h of e.customUniforms)s.push(t.getUniformLocation(n,h.name,c));return{variablesLocations:r,customUniformLocations:s,infLoc:l,nanLoc:u,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:i}}function JN(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach((n,r)=>{const s=n.logicalShape,a=e[r],i=a.shape;if(!Je(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(n.isUniform&&a.isUniform)return;const o=n.texShape,l=a.isUniform?null:a.texData.texShape;if(!Je(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function ire(t,e,n,r,s){e.program.enableShapeUniforms||(JN(e.inShapeInfos,n),JN([e.outShapeInfo],[r]));const a=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(a.texture,i[0],i[1]):t.setOutputMatrixTexture(a.texture,i[0],i[1]),t.setProgram(e.webGLProgram),t.bindVertexArray(e.webGLProgram.vao),Z().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&t.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&t.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<n.length;++l){const u=n[l],{uniform:c,offset:h,shape:d,texShape:p}=e.variablesLocations[l];if(d){const{uniformShape:f}=$2(e.program.packedInputs,u.shape,u.texData.texShape);switch(f.length){case 1:t.gl.uniform1iv(d,new Int32Array(f));break;case 2:t.gl.uniform2iv(d,new Int32Array(f));break;case 3:t.gl.uniform3iv(d,new Int32Array(f));break;case 4:t.gl.uniform4iv(d,new Int32Array(f));break}}if(p&&t.gl.uniform2i(p,u.texData.texShape[0],u.texData.texShape[1]),c!=null){if(u.isUniform){if(Q(u.shape)<2)t.gl.uniform1f(c,u.uniformValues[0]);else{let f=u.uniformValues;f instanceof Float32Array||(f=new Float32Array(f)),t.gl.uniform1fv(c,f)}continue}u.texData.slice!=null&&h!=null&&t.gl.uniform1i(h,u.texData.slice.flatOffset),t.setInputMatrixTexture(u.texData.texture.texture,c,l)}}const o=e.outShapeLocation;if(o)switch(r.shape.length){case 1:t.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:t.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:t.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:t.gl.uniform4iv(o,new Int32Array(r.shape));break}if(e.outShapeStridesLocation){const l=Fe(r.shape);switch(r.shape.length){case 2:t.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:t.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:t.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}if(e.outTexShapeLocation&&t.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&s)for(let l=0;l<e.program.customUniforms.length;++l){const u=e.program.customUniforms[l],c=e.customUniformLocations[l],h=s[l];if(u.type==="float")t.gl.uniform1fv(c,h);else if(u.type==="vec2")t.gl.uniform2fv(c,h);else if(u.type==="vec3")t.gl.uniform3fv(c,h);else if(u.type==="vec4")t.gl.uniform4fv(c,h);else if(u.type==="int")t.gl.uniform1iv(c,h);else if(u.type==="ivec2")t.gl.uniform2iv(c,h);else if(u.type==="ivec3")t.gl.uniform3iv(c,h);else if(u.type==="ivec4")t.gl.uniform4iv(c,h);else throw Error(`uniform type ${u.type} is not supported yet.`)}t.executeProgram()}function ore(t,e,n){let r="";e.concat(n).forEach(i=>{const o=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!i.isUniform){const l=i.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:h}=$2(t.packedInputs,i.shape,l);let d="",p="",f="";if(c.length===1&&t.packedInputs){const k=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];d=`${k[0]>1}_${k[1]>1}`}else if(c.length===2&&!t.packedInputs)p=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!t.packedInputs){const k=Fe(c);f=`${k[0]===l[1]}_${k[k.length-1]===l[1]}`}const m=i.shape.length,y=c.length===2&&Je(i.shape,l),g=Q(i.shape)===1,b=fi(i.shape,n.shape),v=!t.packedInputs&&m===n.shape.length&&Je(l,n.texData.texShape),w=t.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${m}_${v}_${u?h:""}_${c.length}_${g}_${b}_${y}_${d}_${p}_${f}_${w}_${o}`}else{const l=i.isUniform?"uniform":i.texData.texShape;r+=`${i.shape}_${l}_${o}`}});const s=t.userCode;let a=t.constructor.name;return a+="_"+r+"_"+s+`${Z().getNumber("WEBGL_VERSION")}`,a}function nr(t){return Z().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class lre{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Ld.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=gr();this.outputShape=e,this.enableShapeUniforms=nr(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?f0(["r","c","d"],e):Ll(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${n.output} = result;
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class ure{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Ld.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=gr();this.outputShape=e,this.enableShapeUniforms=nr(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?f0(["r","c","d"],e):Ll(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${n.output} = result;
      }
    `}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class cre{constructor(e){this.variableNames=["A"],this.outTexUsage=us.DOWNLOAD;const n=gr();this.outputShape=e,this.userCode=`
      ${$D}

      void main() {
        float x = getAAtOutCoords();
        ${n.output} = encode_float(x);
      }
    `}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class hre{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=us.DOWNLOAD;const n=gr();this.outputShape=e,this.userCode=`
      ${$D}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${n.output} = encode_float(x);
      }
    `}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const dre={R:0,G:1,B:2,A:3};class eC{constructor(e,n=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=gr();this.outputShape=e,this.enableShapeUniforms=nr(this.outputShape.length);let a="result";n&&(a="floor(result * 255. + 0.5)");let i="";for(let o=0;o<r.length;o++){const l=r[o];i+=`
          if(offset == ${o}) {
            result = values[${dre[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?E2():T2(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${s.texture2D}(A, uv);
          ${i}
        }
        ${s.output} = vec4(${a}, 0., 0., 0.);
      }
    `}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class pre{constructor(e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=gr();this.outputShape=e,this.enableShapeUniforms=nr(this.outputShape.length);let s="",a="result";n&&(a="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let o=0;o<=1;o++){const l=i*2+o;s+=`
          localCoords = coords;
          if(localCoords[2] + ${o} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${o};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?E2():T2(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${s}

          ${r.output} = ${a};
        }
    `}}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function OD(t){const e=gr(),n=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return oD(t,n)}function DD(t){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return hD(t,e)}function MD(t){const e=new Uint16Array([0,1,2,2,1,3]);return dD(t,e)}function wf(t,e,n,r,s,a){fD(e,n);const i=pD(t),o=t.TEXTURE_2D;return we(t,()=>t.bindTexture(o,i)),we(t,()=>t.texParameteri(o,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),we(t,()=>t.texParameteri(o,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),we(t,()=>t.texParameteri(o,t.TEXTURE_MIN_FILTER,t.NEAREST)),we(t,()=>t.texParameteri(o,t.TEXTURE_MAG_FILTER,t.NEAREST)),Z().getNumber("WEBGL_VERSION")===1?we(t,()=>t.texImage2D(o,0,r,e,n,0,s,a,null)):we(t,()=>t.texStorage2D(o,1,r,e,n)),we(t,()=>t.bindTexture(t.TEXTURE_2D,null)),{texture:i,texShape:[n,e]}}function R2(t){return t.internalFormatFloat}function PD(t,e,n,r){const[s,a]=vf(e,n);return wf(t,s,a,R2(r),r.textureFormatFloat,t.FLOAT)}function A2(t){return t.internalFormatHalfFloat}function LD(t,e,n,r){const[s,a]=vf(e,n);return wf(t,s,a,A2(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function _2(t){return t.downloadTextureFormat}function zD(t,e,n,r){const[s,a]=vf(e,n);return wf(t,s,a,_2(r),t.RGBA,t.UNSIGNED_BYTE)}function F2(t){return t.internalFormatPackedFloat}function BD(t,e,n,r){const[s,a]=Qc(e,n);return wf(t,s,a,F2(r),t.RGBA,t.FLOAT)}function O2(t){return t.internalFormatPackedHalfFloat}function WD(t,e,n,r){const[s,a]=Qc(e,n);return wf(t,s,a,O2(r),t.RGBA,r.textureTypeHalfFloat)}function UD(t,e,n){return we(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),wv(t,e,"clipSpacePos",n,3,20,0)&&wv(t,e,"uv",n,2,20,12)}function VD(t,e,n,r,s,a){we(t,()=>t.bindTexture(t.TEXTURE_2D,e));let i,o,l;s instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=t.UNSIGNED_BYTE,l=t.RGBA):(i=new Float32Array(n*r*4),o=t.FLOAT,l=a.internalFormatPackedFloat),i.set(s),Z().getNumber("WEBGL_VERSION")===2?we(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n,r,t.RGBA,o,i)):we(t,()=>t.texImage2D(t.TEXTURE_2D,0,l,n,r,0,t.RGBA,o,i)),we(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function jD(t,e,n){we(t,()=>t.bindTexture(t.TEXTURE_2D,e)),n.data instanceof Uint8Array?Z().getNumber("WEBGL_VERSION")===2?we(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n.width,n.height,t.RGBA,t.UNSIGNED_BYTE,n.data)):we(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data)):Z().getNumber("WEBGL_VERSION")===2?we(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,n)):we(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n)),we(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function GD(t,e,n,r){const s=t.createBuffer();we(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,s));const a=4*4*e*n;return we(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,a,t.STREAM_READ)),we(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0)),we(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),s}function HD(t,e,n){const r=t,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function KD(t,e,n,r){const[s,a]=vf(e,n),i=4,o=new Uint8Array(une(e*n,i));return we(t,()=>t.readPixels(0,0,s,a,r.downloadTextureFormat,t.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function qD(t,e,n,r,s,a,i,o){const l=t,u=new Float32Array(cne(a,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function XD(t,e,n){const r=new Float32Array(e*n*4);return we(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,r)),r}const n2e=Object.freeze(Object.defineProperty({__proto__:null,bindVertexProgramAttributeStreams:UD,createBufferFromOutputTexture:GD,createFloat16MatrixTexture:LD,createFloat16PackedMatrixTexture:WD,createFloat32MatrixTexture:PD,createIndexBuffer:MD,createPackedMatrixTexture:BD,createUnsignedBytesMatrixTexture:zD,createVertexBuffer:DD,createVertexShader:OD,downloadByteEncodedFloatMatrixFromOutputTexture:KD,downloadFloat32MatrixFromBuffer:HD,downloadMatrixFromPackedOutputTexture:XD,downloadPackedMatrixFromBuffer:qD,getInternalFormatForFloat16MatrixTexture:A2,getInternalFormatForFloat16PackedMatrixTexture:O2,getInternalFormatForFloat32MatrixTexture:R2,getInternalFormatForPackedMatrixTexture:F2,getInternalFormatForUnsignedBytesMatrixTexture:_2,uploadDenseMatrixToTexture:VD,uploadPixelDataToTexture:jD},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Tx{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const n=Z().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,ine(n,e)):this.gl=ba(n),e=this.gl,Z().getNumber("WEBGL_VERSION")===2){const a=e;this.createVertexArray=()=>we(a,()=>a.createVertexArray()),this.bindVertexArray=i=>we(a,()=>a.bindVertexArray(i)),this.deleteVertexArray=i=>we(a,()=>a.deleteVertexArray(i)),this.getVertexArray=()=>we(a,()=>a.getParameter(a.VERTEX_ARRAY_BINDING))}else if(e!=null){const a=e.getExtension("OES_vertex_array_object");if(a==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>we(e,()=>a.createVertexArrayOES()),this.bindVertexArray=i=>we(e,()=>a.bindVertexArrayOES(i)),this.deleteVertexArray=i=>we(e,()=>a.deleteVertexArrayOES(i)),this.getVertexArray=()=>we(e,()=>e.getParameter(a.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),Z().getNumber("WEBGL_VERSION")===1){const a="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=zh(this.gl,a),cs(this.gl,i))this.textureHalfFloatExtension=zh(this.gl,i);else if(Z().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),cs(this.gl,s))this.colorBufferHalfFloatExtension=zh(this.gl,s);else if(Z().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",cs(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(cs(this.gl,s))this.colorBufferHalfFloatExtension=this.gl.getExtension(s);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=DD(this.gl),this.indexBuffer=MD(this.gl),this.framebuffer=mD(this.gl),this.textureConfig=N2(this.gl,this.textureHalfFloatExtension)}get debug(){return Z().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;we(e,()=>e.finish()),we(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),we(e,()=>e.deleteFramebuffer(this.framebuffer)),we(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),we(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),we(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,n){return this.throwIfDisposed(),PD(this.gl,e,n,this.textureConfig)}createFloat16MatrixTexture(e,n){return this.throwIfDisposed(),LD(this.gl,e,n,this.textureConfig)}createUnsignedBytesMatrixTexture(e,n){return this.throwIfDisposed(),zD(this.gl,e,n,this.textureConfig)}uploadPixelDataToTexture(e,n){this.throwIfDisposed(),jD(this.gl,e,n)}uploadDenseMatrixToTexture(e,n,r,s){this.throwIfDisposed(),VD(this.gl,e,n,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(e,n){return this.throwIfDisposed(),WD(this.gl,e,n,this.textureConfig)}createPackedMatrixTexture(e,n){return this.throwIfDisposed(),BD(this.gl,e,n,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(kv(this.gl,this.framebuffer),this.outputTexture=null),we(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,n,r){return this.downloadMatrixDriver(e,()=>KD(this.gl,n,r,this.textureConfig))}downloadPackedMatrixFromBuffer(e,n,r,s,a,i){return qD(this.gl,e,n,r,s,a,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,n){return HD(this.gl,e,n)}createBufferFromTexture(e,n,r){this.bindTextureToFrameBuffer(e);const s=GD(this.gl,n,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let n,r;if(Z().getBool("WEBGL_FENCE_API_ENABLED")){const s=e,a=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=()=>{const i=s.clientWaitSync(a,0,0);return i===s.ALREADY_SIGNALED||i===s.CONDITION_SATISFIED},n=a}else Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(n,Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:n,isFencePassed:r}}downloadMatrixFromPackedTexture(e,n,r){return this.downloadMatrixDriver(e,()=>XD(this.gl,n,r))}createProgram(e){this.throwIfDisposed();const n=this.gl;this.vertexShader==null&&(this.vertexShader=OD(n));const r=uD(n);we(n,()=>n.attachShader(r,this.vertexShader)),we(n,()=>n.attachShader(r,e)),cD(n,r);const s=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&Cm(n,s),s}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const n=this.gl;we(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),UD(n,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(we(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Cm(this.gl,this.program),we(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,n,r=!0){return this.throwIfDisposed(),r?yD(this.gl,e,n):bD(this.gl,e,n)}getAttributeLocation(e,n){return this.throwIfDisposed(),we(this.gl,()=>this.gl.getAttribLocation(e,n))}getUniformLocationNoThrow(e,n){return this.throwIfDisposed(),this.gl.getUniformLocation(e,n)}setInputMatrixTexture(e,n,r){this.throwIfDisposed(),this.throwIfNoProgram(),xD(this.gl,e,n,r)}setOutputMatrixTexture(e,n,r){this.setOutputMatrixTextureDriver(e,r,n)}setOutputPackedMatrixTexture(e,n,r){this.throwIfDisposed();const[s,a]=Qc(n,r);this.setOutputMatrixTextureDriver(e,s,a)}setOutputMatrixWriteRegion(e,n,r,s){this.setOutputMatrixWriteRegionDriver(r,e,s,n)}setOutputPackedMatrixWriteRegion(e,n,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Cm(this.gl,this.program),Bh(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const n=this.getVertexArray();console.assert(n===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}we(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),we(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=zh(this.gl,Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),a=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,a),a}const e=this.getQueryTimerExtensionWebGL1(),n=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,n),n}endQuery(){if(Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const n=this.gl,r=this.getQueryTimerExtensionWebGL2();n.endQuery(r.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await F1(()=>this.disposed||this.isQueryAvailable(e,Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,n){if(n===0)return null;if(n===2){const r=this.gl;return r.getQueryParameter(e,r.QUERY_RESULT)/1e6}else{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(e,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,n){if(n===0)return!0;if(n===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),a=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),a&&!this.disjoint}else{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(e,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(e){return new Promise(n=>{this.addItemToPoll(()=>e.isFencePassed(),()=>n())})}pollItems(){const e=fre(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=e;++n){const{resolveFn:r}=this.itemsToPoll[n];r()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,n){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:n}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in Z().platform&&(r=Z().platform.setTimeoutCustom.bind(Z().platform)),F1(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Tm(this.gl,e,this.framebuffer),this.debug&&Bh(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Tm(this.gl,this.outputTexture,this.framebuffer),this.debug&&Bh(this.gl)):kv(this.gl,this.framebuffer)}downloadMatrixDriver(e,n){this.bindTextureToFrameBuffer(e);const r=n();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(e,n,r){this.throwIfDisposed();const s=this.gl;Tm(s,e,this.framebuffer),this.debug&&Bh(s),this.outputTexture=e,we(s,()=>s.viewport(0,0,n,r)),we(s,()=>s.scissor(0,0,n,r))}setOutputMatrixWriteRegionDriver(e,n,r,s){this.throwIfDisposed(),we(this.gl,()=>this.gl.scissor(e,n,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function fre(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const{addImpl:mre,bincountImpl:YD,bincountReduceImpl:gre,bitwiseAndImpl:yre,castImpl:bre,ceilImpl:xre,concatImpl:vre,equalImpl:wre,expImpl:kre,expm1Impl:Sre,floorImpl:Ire,gatherNdImpl:Nre,gatherV2Impl:Cre,greaterImpl:Tre,greaterEqualImpl:Ere,lessImpl:$re,lessEqualImpl:Rre,linSpaceImpl:Are,logImpl:_re,maxImpl:Fre,maximumImpl:Ore,minimumImpl:Dre,multiplyImpl:Mre,negImpl:Pre,notEqualImpl:Lre,prodImpl:zre,raggedGatherImpl:Bre,raggedRangeImpl:Wre,raggedTensorToTensorImpl:Ure,rangeImpl:Vre,rsqrtImpl:jre,scatterImpl:Gre,sigmoidImpl:Hre,simpleAbsImpl:QD,sliceImpl:Kre,sparseFillEmptyRowsImpl:qre,sparseReshapeImpl:Xre,sparseSegmentReductionImpl:ZD,sqrtImpl:Yre,staticRegexReplaceImpl:Qre,stridedSliceImpl:Zre,stringNGramsImpl:Jre,stringSplitImpl:ese,stringToHashBucketFastImpl:tse,subImpl:nse,tileImpl:rse,topKImpl:sse,transposeImpl:D2,uniqueImpl:ase}=UO;/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function JD(t,e){return["x","y","z","w","u","v"].slice(0,e).map(n=>`${t}.${n}`)}function cr(t,e){return e===1?[t]:JD(t,e)}function ise(t,e){if(t===1)return"rc";let n="";for(let r=0;r<t;r++)n+=e[r],r<t-1&&(n+=",");return n}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class ose{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=nr(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const n=cr("rc",this.rank),r=Ct(this.rank),s=this.getOutOfBoundsCondition(n),a=this.getSetup(n),i=this.getOutput(n);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${s}) {
            setOutput(vec4(0));
          } else {
            ${a}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(e){const n=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let a=`${r===0?"r":"rp1"}, ${s===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)a=`${e[e.length-1-i]},`+a;n.push(a)}return n}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let n="";for(let r=this.rank-2;r<this.rank;r++)n+=`${e[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(n+="||");return n}getSetup(e){if(this.rank===1)return"";const n=e.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],s=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${n[0]};
      int c = ${n[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${s};
    `}getOutput(e){const n=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${n[0]}),
            cEdge ? 0. : getA(${n[1]}),
            rEdge ? 0. : getA(${n[2]}),
            rEdge || cEdge ? 0. : getA(${n[3]})`}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class eM{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=nr(this.outputShape.length);let r="";for(let s=0;s<4;s++){let a="thisRC = rc;";s%2===1&&(a+="thisRC.z += 1;"),s>1&&(a+="thisRC.y += 1;"),r+=`
        ${a}
        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${s}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${s>0?"}":""}
      `}this.userCode=`
      ${lse(n,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?E2():T2(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${r}

        setOutput(result);
      }
    `}}function lse(t,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?kne(["r","c","d"],"inputShape"):Ll(["r","c","d"],t)}
      return ivec3(r, c, d);
    }
  `}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let use=class{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,e,n){const r=nC(e,n),s=rC(t,r,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const a=tC(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const o=this.freeTextures[s].pop();return this.usedTextures[s].push(o),o}let i;return r===Bn.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):r===Bn.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):r===Bn.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):r===Bn.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):r===Bn.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(t,e,n,r){if(this.freeTextures==null)return;const s=nC(n,r),a=rC(e,s,r);a in this.freeTextures||(this.freeTextures[a]=[]);const i=tC(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=Z().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");o!==-1&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=i):(this.freeTextures[a].push(t),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const l=this.usedTextures[a],u=l&&l.indexOf(t);if(u==null||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function cse(t,e){const n=t;if(e===n.R32F)return 4;if(e===n.R16F)return 2;if(e===n.RGBA32F||e===t.RGBA)return 16;if(e===n.RGBA16F)return 8;if(e===n.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function tC(t,e,n,r,s){const a=hse(e,r);let i;if(s){const[l,u]=Qc(t[0],t[1]);i=l*u}else{const[l,u]=vf(t[0],t[1]);i=l*u}const o=cse(n,a);return i*o}function hse(t,e){switch(t){case Bn.PACKED_2X2_FLOAT32:return F2(e);case Bn.PACKED_2X2_FLOAT16:return O2(e);case Bn.UNPACKED_FLOAT32:return R2(e);case Bn.UNPACKED_FLOAT16:return A2(e);case Bn.PACKED_4X1_UNSIGNED_BYTE:return _2(e);default:throw new Error(`Unknown physical texture type ${t}`)}}function dse(t){return Z().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?Bn.PACKED_2X2_FLOAT32:Bn.UNPACKED_FLOAT32:t?Bn.PACKED_2X2_FLOAT16:Bn.UNPACKED_FLOAT16}function nC(t,e){if(t===us.UPLOAD)return Bn.PACKED_2X2_FLOAT32;if(t===us.RENDER||t==null)return dse(e);if(t===us.DOWNLOAD||t===us.PIXELS)return Bn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function rC(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let Ma=class{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=nr(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${e}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}};const Ks="if (isnan(x)) return x;",pse="return x;",sC="return abs(x);",fse="return (x >= 0.0) ? x : (exp(x) - 1.0);",mse=Ks+`
  return (x < 0.0) ? 0.0 : x;
`,gse=Ks+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,$i="return x;",yse="return 1.0 / (1.0 + exp(-1.0 * x));";/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const bse="return x;",xse=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,vse=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,wse=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,kse="return 1.0 / (1.0 + exp(-1.0 * x));";class Pi{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=nr(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${n}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Sse{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=nr(this.outputShape.length);const n=e.length,r=cr("rc",n),s=Ct(n),a=ise(n,r),i=r.slice(-2),o=n<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${s} rc = getOutputCoords();
        vec4 packedInput = getA(${a});

        setOutput(getChannel(packedInput, ${o}));
      }
    `}}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Ise=Rk,Nse=1e-7,Cse=1e-4,Ex={};function Tse(t){return t in Ex||(Ex[t]={}),Ex[t]}const Ese=Z().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),$se=600;function Rse(){return Z().global.screen==null?1024:Z().global.screen.height*Z().global.screen.width*window.devicePixelRatio*$se/1024/1024}class m0 extends ty{nextDataId(){return m0.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Z().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(e!=null){if(e instanceof Tx)n=e;else{const r=ba(Z().getNumber("WEBGL_VERSION"),e);n=new Tx(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=ba(Z().getNumber("WEBGL_VERSION"));n=new Tx(r),this.binaryCache=Tse(Z().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new use(this.gpgpu),this.numMBBeforeWarning=Rse(),this.texData=new Rw(this,ir())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,n,r,s,a,i){const o=this.makeTensorInfo(n,r),l=this.texData.get(o.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[s,a]},l.texShape=[s,a];const u=Wh(n),c=new eC(u,!1,i),h=this.runWebGLProgram(c,[o],r,[[s,a]]);return h.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(o),h.dataId}write(e,n,r){if((Z().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Z().getBool("DEBUG"))&&this.checkNumericalProblems(e),r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:n,dtype:r,values:e,usage:us.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const n=this.texData.get(e);n.refCount++}decRef(e){if(this.texData.has(e)){const n=this.texData.get(e);n.refCount--}}move(e,n,r,s,a){if(Z().getBool("DEBUG")&&this.checkNumericalProblems(n),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:s,values:n,usage:us.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const n=this.texData.get(e),{values:r,dtype:s,complexTensorInfos:a,slice:i,shape:o,isPacked:l}=n;if(i!=null){let d;l?d=new Pi(o,$i):d=new Ma(o,$i);const p=this.runWebGLProgram(d,[{dataId:e,shape:o,dtype:s}],s),f=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),f}if(r!=null)return this.convertAndCacheOnCPU(e);if(s==="string")return r;const u=this.activeTimers!=null;let c;u&&(c=Ln());let h;if(s==="complex64"){const d=this.readSync(a.real.dataId),p=this.readSync(a.imag.dataId);h=fa(d,p)}else h=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=Ln()-c),this.convertAndCacheOnCPU(e,h)}async read(e){if(this.pendingRead.has(e)){const f=this.pendingRead.get(e);return new Promise(m=>f.push(m))}const n=this.texData.get(e),{values:r,shape:s,slice:a,dtype:i,complexTensorInfos:o,isPacked:l}=n;if(a!=null){let f;l?f=new Pi(s,$i):f=new Ma(s,$i);const m=this.runWebGLProgram(f,[{dataId:e,shape:s,dtype:i}],i),y=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),y}if(r!=null)return this.convertAndCacheOnCPU(e);if(Z().getBool("DEBUG")&&!Z().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&Z().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,c;if(i!=="complex64"&&Z().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const f=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(f.texture.texture,...lm(s))}this.pendingRead.set(e,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(i==="complex64"){const f=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),m=f[0],y=f[1];h=fa(m,y)}else if(u==null)h=this.getValuesFromTexture(e);else{const f=Q(s);h=this.gpgpu.downloadFloat32MatrixFromBuffer(u,f)}if(c!=null&&this.disposeIntermediateTensorInfo(c),u!=null){const f=this.gpgpu.gl;we(f,()=>f.deleteBuffer(u))}const d=this.convertAndCacheOnCPU(e,h),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach(f=>f(d)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&ir().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e,n={}){const r=this.texData.get(e),{values:s,shape:a,slice:i,dtype:o,isPacked:l,texture:u}=r;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let p;l?p=new Pi(a,$i):p=new Ma(a,$i);const f=this.runWebGLProgram(p,[{dataId:e,shape:a,dtype:o}],o),m=this.readToGPU(f,n);return this.disposeIntermediateTensorInfo(f),m}if(u==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(e,n.customTexShape),h=ir().makeTensorFromTensorInfo(c),d=this.texData.get(c.dataId);return Object.assign({tensorRef:h},d.texture)}bufferSync(e){const n=this.readSync(e.dataId);if(e.dtype==="string")try{const r=n.map(s=>Vs(s));return Qe(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Qe(e.shape,e.dtype,n)}checkNumericalProblems(e){if(e!=null)for(let n=0;n<e.length;n++){const r=e[n];if(!aD(r))throw Z().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:n,dtype:r,isPacked:s}=this.texData.get(e),a=Q(n);if(Z().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const d=this.decode(e),p=this.texData.get(d.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...lm(n)).subarray(0,a);return this.disposeIntermediateTensorInfo(d),f}const i=Z().getBool("WEBGL_PACK")&&s===!0,o=i?Wh(n):n,l=i?new hre(o):new cre(o),u=this.runWebGLProgram(l,[{shape:o,dtype:r,dataId:e}],"float32"),c=this.texData.get(u.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(u),h}timerAvailable(){return Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const n=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,e();const a=Wa(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=Wa(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,s&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(a);o.kernelMs=_w(l),o.getExtraProfileInfo=()=>l.map((u,c)=>({name:i[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Ln(),endMs:null}}endTimer(e){return Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Ln(),e)}async getQueryTime(e){if(Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const n=e;return n.endMs-n.startMs}disposeData(e,n=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(n?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!n&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:r}=this.texData.get(e);return r!=null&&(this.disposeData(r.real.dataId,n),this.disposeData(r.imag.dataId,n)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:n,dtype:r,texShape:s,usage:a,isPacked:i,slice:o}=this.texData.get(e),l=o&&o.origDataId||e,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(s,r),this.textureManager.releaseTexture(n,s,a,i)));const c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,n=Ese){return Z().getBool("WEBGL_CPU_FORWARD")&&e.every(r=>this.texData.get(r.dataId).texture==null&&Q(r.shape)<n)}getGPGPUContext(){return this.gpgpu}where(e){is("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const n=e.dataSync();return Ise(e.shape,n)}packedUnaryOp(e,n,r){const s=new Pi(e.shape,n),a=this.compileAndRun(s,[e],r);return ir().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const s=QD(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,s)}if(Z().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,sC,e.dtype);const n=new Ma(e.shape,sC),r=this.compileAndRun(n,[e]);return ir().makeTensorFromTensorInfo(r)}makeTensorInfo(e,n,r){let s;if(n==="string"&&r!=null&&r.length>0&&Nl(r[0])){const a=r.map(i=>za(i));s=this.write(a,e,n)}else s=this.write(r,e,n);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:n}}makeOutput(e,n,r){return ir().makeTensorFromTensorInfo(this.makeTensorInfo(e,n,r),this)}unpackTensor(e){const n=new Sse(e.shape);return this.runWebGLProgram(n,[e],e.dtype)}packTensor(e){const n=new ose(e.shape);return this.runWebGLProgram(n,[e],e.dtype,null,!0)}packedReshape(e,n){const r=[xl(e.shape),...vl(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},a=[xl(n),...vl(n)],i=new eM(a,r),o=!0,l=[r],u=this.runWebGLProgram(i,[s],e.dtype,l,o);return{dataId:u.dataId,shape:n,dtype:u.dtype}}decode(e,n){const r=this.texData.get(e),{isPacked:s,shape:a,dtype:i}=r;if(n!=null){const d=Q(a),p=n[0]*n[1]*4;R(d<=p,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const o=Wh(a);let l;s?l=new ure(o):l=new lre(o);const u=!0,c=[n??lm(o)],h=this.runWebGLProgram(l,[{shape:o,dtype:i,dataId:e}],i,c,u,n);return{dtype:i,shape:a,dataId:h.dataId}}runWebGLProgram(e,n,r,s,a=!1,i){const o=this.makeTensorInfo(e.outputShape,r),l=this.texData.get(o.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===Ld.DENSE){const g=i??lm(e.outputShape);l.texShape=g.map(b=>b*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),Q(o.shape)===0)return l.values=pn(o.dtype,0),o;const u=[],c=n.map(g=>{if(g.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(g.dataId);if(b.texture==null){if(!e.packedInputs&&Q(g.shape)<=Z().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:g.shape,texData:null,isUniform:!0,uniformValues:b.values};e.packedInputs&&(b.isPacked=!0,b.shape=g.shape)}if(this.uploadToGPU(g.dataId),!!b.isPacked!=!!e.packedInputs)g=b.isPacked?this.unpackTensor(g):this.packTensor(g),u.push(g),b=this.texData.get(g.dataId);else if(b.isPacked&&!zd(b.shape,g.shape)){const v=g,w=g.shape;g.shape=b.shape,g=this.packedReshape(g,w),u.push(g),b=this.texData.get(g.dataId),v.shape=w}return{shape:g.shape,texData:b,isUniform:!1}});this.uploadToGPU(o.dataId);const h={shape:o.shape,texData:l,isUniform:!1},d=ore(e,c,h),p=this.getAndSaveBinary(d,()=>are(this.gpgpu,e,c,h)),f=this.activeTimers!=null;let m;f&&(m=this.startTimer()),Z().get("ENGINE_COMPILE_ONLY")||ire(this.gpgpu,p,c,h,s),u.forEach(g=>this.disposeIntermediateTensorInfo(g)),f&&(m=this.endTimer(m),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(m)}));const y=Z().getNumber("WEBGL_FLUSH_THRESHOLD");if(y>0){const g=Ln();g-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=g)}if(!Z().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&a===!1){const g=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),g}return o}compileAndRun(e,n,r,s,a=!1){return r=r||n[0].dtype,this.runWebGLProgram(e,n,r,s,a)}getAndSaveBinary(e,n){return e in this.binaryCache||(this.binaryCache[e]=n()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Z().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=Y(()=>{if(!Z().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=Z().getBool("DEBUG");Z().set("DEBUG",!1);const n=this.abs(Me(1e-8)).dataSync()[0];if(Z().set("DEBUG",e),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?Nse:Cse}uploadToGPU(e){const n=this.texData.get(e),{shape:r,dtype:s,values:a,texture:i,usage:o,isPacked:l}=n;if(i!=null)return;const u=this.activeTimers!=null;let c;u&&(c=Ln());let h=n.texShape;if(h==null&&(h=kD(r,l),n.texShape=h),a!=null){const d=Wh(r);let p,f=h[1],m=h[0];const y=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(l||!y)&&([f,m]=Qc(h[0],h[1])),l?p=new pre(d,y):p=new eC(d,y);const g=y?[m,f]:h,b=this.makeTensorInfo(g,s),v=this.texData.get(b.dataId);y?v.usage=us.PIXELS:v.usage=us.UPLOAD,v.texShape=g,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),f,m,a);const w=[[m,f]],k=this.runWebGLProgram(p,[b],s,w,!0),N=this.texData.get(k.dataId);n.texShape=N.texShape,n.isPacked=N.isPacked,n.usage=N.usage,Z().get("ENGINE_COMPILE_ONLY")?this.disposeData(k.dataId):(n.texture=N.texture,n.values=null,this.texData.delete(k.dataId)),this.disposeIntermediateTensorInfo(b),u&&(this.uploadWaitMs+=Ln()-c)}else{const d=this.acquireTexture(h,o,s,l);n.texture=d}}convertAndCacheOnCPU(e,n){const r=this.texData.get(e),{dtype:s}=r;return n!=null&&(r.values=Ase(n,s)),r.values}acquireTexture(e,n,r,s){if(this.numBytesInGPU+=this.computeBytes(e,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const a=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${a} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,n,s)}computeBytes(e,n){return e[0]*e[1]*xd(n)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,n]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(n));return Promise.all(e)}else{for(const[,n]of Object.entries(this.binaryCache)){const r=new Promise(s=>{try{this.checkCompletion_(n),s(!0)}catch(a){throw a}});e.push(r)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Y3(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(C2(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:n,customUniformLocations:r,infLoc:s,nanLoc:a,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:l}=FD(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=n,e.customUniformLocations=r,e.infLoc=s,e.nanLoc=a,e.outShapeLocation=i,e.outShapeStridesLocation=o,e.outTexShapeLocation=l}}createTensorFromGPUData(e,n,r){e.channels=e.channels||"RGBA";const{texture:s,height:a,width:i,channels:o}=e,l=ir().backend;if(!l.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const u=l.writeTexture(s,n,r,a,i,o);return ir().makeTensorFromDataId(u,n,r,l)}}m0.nextDataId=0;function Ase(t,e){if(e==="float32"||e==="complex64")return t;if(e==="int32"||e==="bool"){const n=e==="int32"?new Int32Array(t.length):new Uint8Array(t.length);for(let r=0;r<n.length;++r)n[r]=Math.round(t[r]);return n}else throw new Error(`Unknown dtype ${e}`)}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _se(){Z().set("WEBGL_FORCE_F16_TEXTURES",!0)}/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Kw()&&qw("webgl",()=>new m0,2);const r2e={forceHalfFloat:_se};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const M2=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;let wl=class{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=Ue(e,n),this.enableShapeUniforms=nr(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Bl=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class rh{constructor(e,n,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Ue(n,r);const a=this.outputShape.length;this.enableShapeUniforms=nr(a);let i="";if(s)if(a===0||Q(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${Ct(a)} coords = getOutputCoords();
        `,a===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const o=cr("coords",a);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${o[a-2]} + 1) >= outShape[${a} - 2];
            bool nextColOutOfBounds =
              (${o[a-1]} + 1) >= outShape[${a} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${o[a-2]} + 1) >= ${this.outputShape[a-2]};
            bool nextColOutOfBounds =
              (${o[a-1]} + 1) >= ${this.outputShape[a-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function es(t){const{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const Fse={kernelName:gc,backendName:"webgl",kernelFunc:es};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Io(t){const{inputs:e,backend:n}=t,{real:r,imag:s}=e,a=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(a.dataId),o=es({inputs:{x:r},backend:n}),l=es({inputs:{x:s},backend:n});return i.complexTensorInfos={real:o,imag:l},a}const Ose={kernelName:py,backendName:"webgl",kernelFunc:Io};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const tM="return (a < 0.) ? b * a : a;",nM=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Dse(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{alpha:a}=r,i=n.makeTensorInfo([],"float32",vi(a,"float32")),o=Z().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new rh(nM,s.shape,i.shape):new wl(tM,s.shape,i.shape),l=n.runWebGLProgram(o,[s,i],"float32");return n.disposeIntermediateTensorInfo(i),l}const Mse={kernelName:bp,backendName:"webgl",kernelFunc:Dse};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const rM="return (a < 0.) ? b * a : a;",sM=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Pse(t){const{inputs:e,backend:n}=t,{x:r,alpha:s}=e,a=Z().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new rh(sM,r.shape,s.shape):new wl(rM,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],"float32")}const Lse={kernelName:Pp,backendName:"webgl",kernelFunc:Pse};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const sh="if (isnan(x)) return x;";function pt({opSnippet:t,packedOpSnippet:e,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:a})=>{const{x:i}=s,o=a,l=r||i.dtype;if(o.shouldExecuteOnCPU([i])&&n!=null){const h=o.texData.get(i.dataId),d=n(h.values,l);return o.makeTensorInfo(i.shape,l,d)}const u=Z().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let c;return u?c=new Pi(i.shape,e):c=new Ma(i.shape,t),o.runWebGLProgram(c,[i],l)}}function Gn({opSnippet:t,packedOpSnippet:e,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:a}){return({inputs:i,backend:o})=>{const{a:l,b:u}=i,c=o;if(r&&l.dtype==="complex64"){const f=c.texData.get(l.dataId),m=c.texData.get(u.dataId),[y,g]=[[f.complexTensorInfos.real,m.complexTensorInfos.real],[f.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(v=>{const[w,k]=v,N={dataId:w.dataId,dtype:w.dtype,shape:l.shape},T={dataId:k.dataId,dtype:k.dtype,shape:u.shape},E=new wl(t,l.shape,u.shape);return c.runWebGLProgram(E,[N,T],On(w.dtype,k.dtype))}),b=Io({inputs:{real:y,imag:g},backend:c});return c.disposeIntermediateTensorInfo(y),c.disposeIntermediateTensorInfo(g),b}const h=a||On(l.dtype,u.dtype);if((l.dtype==="string"||u.dtype==="string"||c.shouldExecuteOnCPU([l,u]))&&s!=null){const f=c.texData.get(l.dataId).values,m=c.texData.get(u.dataId).values,y=l.dtype==="string"?ma(f):f,g=l.dtype==="string"?ma(m):m,[b,v]=s(l.shape,u.shape,y,g,h),w=c.makeTensorInfo(v,h),k=c.texData.get(w.dataId);return k.values=b,w}const d=Z().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let p;return d?p=new rh(e,l.shape,u.shape,n):p=new wl(t,l.shape,u.shape),c.runWebGLProgram(p,[l,u],h)}}function Bd(t,e=!1){if(t==="linear")return e?bse:pse;if(t==="relu")return e?vse:mse;if(t==="elu")return e?xse:fse;if(t==="relu6")return e?wse:gse;if(t==="prelu")return e?sM:rM;if(t==="leakyrelu")return e?nM:tM;if(t==="sigmoid")return e?kse:yse;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let aM=class{constructor(t,e,n,r=!1,s=!1,a=!1,i=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=nr(this.outputShape.length);const u=r?t[1]:t[2],c=Math.ceil(u/2),h=r?"i * 2, rc.y":"rc.y, i * 2",d=s?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",y="";i&&(o?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:l?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:m=`vec4 activation(vec4 x) {
          ${i}
        }`,y="result = activation(result);");const g=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let b="rc.x",v="rc.x";t[0]<e[0]?b=`imod(rc.x, ${t[0]})`:e[0]<t[0]&&(v=`imod(rc.x, ${e[0]})`),this.userCode=`
      ${m}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${c}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${b};
        int batchB = ${v};
        for (int i = 0; i < ${c}; i++) {
          vec4 a = getMatrixA(batchA, ${h});
          vec4 b = getMatrixB(batchB, ${d});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${p[0]} * ${f[0]});
          result += (${p[1]} * ${f[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${g}

        ${y}

        setOutput(result);
      }
    `}};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const aC={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};let iC=class{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Ue(e,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const oC="return a * b;";function P2(t){const{inputs:e,backend:n}=t,{a:r,b:s}=e,a=On(r.dtype,s.dtype);if(r.dtype==="complex64"){const o=n.texData.get(r.dataId),l=n.texData.get(s.dataId),u=new iC(aC.REAL,r.shape,s.shape),c=new iC(aC.IMAG,r.shape,s.shape),h=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:r.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],d=n.runWebGLProgram(u,h,"float32"),p=n.runWebGLProgram(c,h,"float32"),f=Io({inputs:{real:d,imag:p},backend:n});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}if(n.shouldExecuteOnCPU([r,s])){const o=n.texData.get(r.dataId),l=n.texData.get(s.dataId),[u,c]=Mre(r.shape,s.shape,o.values,l.values,a),h=n.makeTensorInfo(c,a),d=n.texData.get(h.dataId);return d.values=u,h}let i;return Z().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new rh(oC,r.shape,s.shape):i=new wl(oC,r.shape,s.shape),n.runWebGLProgram(i,[r,s],a)}const zse={kernelName:Nc,backendName:"webgl",kernelFunc:P2};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Bse(t,e,n){const r=[xl(t.shape),...vl(t.shape)],s={dtype:t.dtype,shape:r,dataId:t.dataId},a=[xl(e),...vl(e)],i=new eM(a,r),o=!0,l=[r],u=n.runWebGLProgram(i,[s],t.dtype,l,o);return{dataId:u.dataId,shape:e,dtype:u.dtype}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function be(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{shape:a}=r,i=n,o=Q(s.shape),l=ry(a,o),u=Q(l);R(o===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);const c=i.texData.get(s.dataId);return c.isPacked&&!zd(s.shape,l)&&!(c.texture!==null&&zd(c.shape,l))?Bse(s,l,i):(i.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype})}const Wse={kernelName:zp,backendName:"webgl",kernelFunc:be};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class lC{constructor(e,n){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:a,outSize:i}=e;this.outputShape=[s,i];const o=Math.floor(r/4)*4,l=r%4;let u="sumValue += dot(values, ones);";if(n!=null){const h=1/n;u=`sumValue += dot(values * ${il(h)?h.toPrecision(2):h}, ones);`}let c="";a%r>0&&(c=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${o}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${o};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let Use=class{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:a}=t;this.outputShape=[r,a];let i="0.0",o="";e==="prod"?i="1.0":e==="min"?(i="1.0 / 1e-20",o="min"):e==="max"&&(i="-1.0 / 1e-20",o="max");let l=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="sum"?l="sumValue":e==="prod"?l="prodValue":e==="all"?l="allValue":e==="any"&&(l="anyValue");const u=Math.floor(n/4)*4,c=n%4;let h=`
      if (${e==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${e==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${o}(values, minMaxValue);
        if (${e==="min"} || ${e==="max"}) {
          minMaxValue = ${o}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,d="vec4";e==="all"?(i="1.0",h=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,d="bvec4"):e==="any"&&(i="0.0",h=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,d="bvec4");let p="";s%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${h}
        }

        int inIdx = inOffset + ${u};
        if (${c===1}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${c===2}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${c===3}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${h}
        }
        setOutput(${l});
      }
    `}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Vse(t){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const n=e.length?e[e.length-1].outSize:t[1],r=Pb(n);e.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return e}function Wl(t,e,n,r){const s=Vse(t.shape);let a=t;for(let i=0;i<s.length;i++){const{inSize:o,windowSize:l,outSize:u}=s[i];let c,h;n==="mean"?c=i===0?new lC({windowSize:l,inSize:o,batchSize:t.shape[0],outSize:u},o):new lC({windowSize:l,inSize:o,batchSize:t.shape[0],outSize:u}):c=new Use({windowSize:l,inSize:o,batchSize:t.shape[0],outSize:u},n),h=a,a=r.runWebGLProgram(c,[a],e),h.dataId!==t.dataId&&r.disposeIntermediateTensorInfo(h)}return a}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let jse=class{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let a=0;a<n.length;a++)n[a]=t[e[a]];this.outputShape=n,this.rank=n.length;const r=Ct(this.rank),s=Gse(e);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function Gse(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let s=0;s<t.length;s++)r[t[s]]=n[s];return r.join()}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Hse{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(e.length);for(let c=0;c<r.length;c++)r[c]=e[n[c]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=Ct(this.rank),a=JD("rc",this.rank),i=new Array(this.rank);for(let c=0;c<n.length;c++)i[n[c]]=a[c];const o=`vec2(${i.slice(-2).join()})`,l=`++${a[this.rank-1]} < ${r[this.rank-1]}`,u=`getChannel(getA(${i.join()}), ${o})`;this.userCode=`
    void main() {
      ${s} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${l}) {
        result[1] = ${u};
      }
      --${a[this.rank-1]};
      if(++${a[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${u};
        if(${l}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function g0(t,e,n){const r=Z().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Hse(t.shape,e):new jse(t.shape,e);return n.runWebGLProgram(r,[t],t.dtype)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Kse(t,e,n,r){const s=e,a=t.shape.length,i=Ze(s,t.shape);let o=i;const l=Tt(o,a),u=l!=null;let c=t;u&&(c=g0(t,l,r),o=Ft(o.length,a)),mn("sum",o,a);const[h,d]=an(c.shape,o);let p=h;n&&(p=en(h,i));const f=Q(d),m=Q(t.shape)/f,y=be({inputs:{x:c},attrs:{shape:[m,f]},backend:r}),g=ab(t.dtype),b=Wl(y,g,"sum",r),v=be({inputs:{x:b},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(b),u&&r.disposeIntermediateTensorInfo(c),v}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function y0(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:a,keepDims:i}=r;return Kse(s,a,i,n)}const qse={kernelName:Gp,backendName:"webgl",kernelFunc:y0};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function fr(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{perm:a}=r,i=n,o=s.shape.length,l=new Array(o);for(let c=0;c<l.length;c++)l[c]=s.shape[a[c]];let u;if(i.shouldExecuteOnCPU([s])){const c=i.texData.get(s.dataId).values,h=D2(c,s.shape,s.dtype,a,l);u=i.makeTensorInfo(l,s.dtype);const d=i.texData.get(u.dataId);d.values=h}else u=g0(s,a,i);return u}const Xse={kernelName:Qo,backendName:"webgl",kernelFunc:fr};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const iM=1e3;function _g({a:t,b:e,transposeA:n,transposeB:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){const u=t.shape.length,c=e.shape.length,h=n?t.shape[u-2]:t.shape[u-1],d=r?e.shape[c-1]:e.shape[c-2],p=n?t.shape[u-1]:t.shape[u-2],f=r?e.shape[c-2]:e.shape[c-1],m=t.shape.slice(0,-2),y=e.shape.slice(0,-2),g=Q(m),b=Q(y),v=Ue(t.shape.slice(0,-2),e.shape.slice(0,-2)).concat([p,f]);R(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${r} must match.`);const w=n?[g,h,p]:[g,p,h],k=r?[b,f,d]:[b,d,f],N=be({inputs:{x:t},backend:s,attrs:{shape:w}}),T=be({inputs:{x:e},backend:s,attrs:{shape:k}}),E=[N,T],_=Math.max(g,b),O=n?N.shape[1]:N.shape[2],M=a!=null,V=i!=null,W=l==="leakyrelu",K=l!=null?Bd(l,!0):null,q=M||V||W||K!=null;let ee;if((p===1||f===1)&&O>iM&&q===!1){let G=N,J=T;n&&(G=fr({inputs:{x:N},backend:s,attrs:{perm:[0,2,1]}}),E.push(G)),r&&(J=fr({inputs:{x:T},backend:s,attrs:{perm:[0,2,1]}}),E.push(J));const ne=f!==1,ae=f===1;let oe=G;ne&&(oe=be({inputs:{x:G},backend:s,attrs:{shape:[_,O,1]}}),E.push(oe));const ue=f===1?2:1;let ce=J;ae&&(ce=be({inputs:{x:J},backend:s,attrs:{shape:[_,1,O]}}),E.push(ce));const de=P2({inputs:{a:oe,b:ce},backend:s});ee=y0({inputs:{x:de},backend:s,attrs:{axis:ue,keepDims:!0}}),E.push(de)}else{const G=On(t.dtype,e.dtype),J=new aM(w,k,[_,p,f],n,r,M,K,V,W),ne=[N,T];if(a!=null&&ne.push(a),V&&ne.push(i),W){const ae=s.makeTensorInfo([],"float32",vi(o,"float32"));ne.push(ae),E.push(ae)}ee=s.runWebGLProgram(J,ne,G)}const te=be({inputs:{x:ee},backend:s,attrs:{shape:v}});E.push(ee);for(const G of E)s.disposeIntermediateTensorInfo(G);return te}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Yse(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:a,bias:i,preluActivationWeights:o}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=r;return _g({a:s,b:a,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:h,activation:c})}const Qse={kernelName:vd,backendName:"webgl",kernelFunc:Yse};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const uC="return abs(x);";function Zse(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){const a=n.texData.get(r.dataId),i=QD(a.values);return n.makeTensorInfo(r.shape,r.dtype,i)}let s;return Z().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Pi(r.shape,uC):s=new Ma(r.shape,uC),n.runWebGLProgram(s,[r],r.dtype)}const Jse={kernelName:Qd,backendName:"webgl",kernelFunc:Zse};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const eae=Ks+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,tae=pt({opSnippet:eae}),nae={kernelName:Yu,backendName:"webgl",kernelFunc:tae};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const rae=Ks+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,sae=pt({opSnippet:rae}),aae={kernelName:Qu,backendName:"webgl",kernelFunc:sae};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const cC="return a + b;",iae=Gn({opSnippet:cC,packedOpSnippet:cC,supportsComplex:!0,cpuKernelImpl:mre}),oae={kernelName:Tl,backendName:"webgl",kernelFunc:iae};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class lae{constructor(e,n){this.outputShape=[],this.outputShape=e,this.variableNames=n.map((a,i)=>`T${i}`);const r=[];this.variableNames.forEach(a=>{r.push(`float v${a} = get${a}AtOutCoords();`)});const s=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${s};
        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let uae=class{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((s,a)=>`T${a}`);const n=[];this.variableNames.forEach(s=>{n.push(`vec4 v${s} = get${s}AtOutCoords();`)});const r=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Rm(t){const{inputs:e,backend:n}=t,r=e;if(r.length===1)return es({inputs:{x:r[0]},backend:n});if(r.length>Z().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const o=Math.floor(r.length/2),l=Rm({inputs:r.slice(0,o),backend:n}),u=Rm({inputs:r.slice(o),backend:n});return Rm({inputs:[l,u],backend:n})}const s=r.map(o=>o.dtype).reduce((o,l)=>On(o,l)),a=r.map(o=>o.shape),i=Z().getBool("WEBGL_PACK")?new uae(r[0].shape,a):new lae(r[0].shape,a);return n.runWebGLProgram(i,r,s)}const cae={kernelName:Zd,backendName:"webgl",kernelFunc:Rm};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function hae(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:a,keepDims:i}=r,o=s.shape.length,l=Ze(a,s.shape);let u=l;const c=Tt(u,o);let h=s;c!=null&&(h=fr({inputs:{x:s},backend:n,attrs:{perm:c}}),u=Ft(u.length,o)),mn("all",u,o);const[d,p]=an(h.shape,u),f=Q(p),m=be({inputs:{x:h},backend:n,attrs:{shape:[-1,f]}}),y=Wl(m,m.dtype,"all",n);let g;if(i){const b=en(d,l);g=be({inputs:{x:y},backend:n,attrs:{shape:b}})}else g=be({inputs:{x:y},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),c!=null&&n.disposeIntermediateTensorInfo(h),g}const dae={kernelName:iy,backendName:"webgl",kernelFunc:hae};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function pae(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:a,keepDims:i}=r,o=s.shape.length,l=Ze(a,s.shape);let u=l;const c=Tt(u,o);let h=s;c!=null&&(h=fr({inputs:{x:s},backend:n,attrs:{perm:c}}),u=Ft(u.length,o)),mn("any",u,o);const[d,p]=an(h.shape,u),f=Q(p),m=be({inputs:{x:h},backend:n,attrs:{shape:[-1,f]}}),y=Wl(m,m.dtype,"any",n);let g;if(i){const b=en(d,l);g=be({inputs:{x:y},backend:n,attrs:{shape:b}})}else g=be({inputs:{x:y},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),c!=null&&n.disposeIntermediateTensorInfo(h),g}const fae={kernelName:oy,backendName:"webgl",kernelFunc:pae};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let mae=class{constructor(t,e,n){this.variableNames=["A"];const{windowSize:r,batchSize:s,outSize:a}=t;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a];const i=e==="max"?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${o};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class gae{constructor(e,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,R(e.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const a=e[e.length-1],i=Math.ceil(a/n);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),s||this.variableNames.push("bestIndicesA");const o=this.outputShape,l=o.length,u=Ct(l),c=cr("coords",l);let h,d;if(i===1){d=l+1;const E=Ct(d);h=`
        ${E} sourceLocR = ${E}(${c.join()}, 0);
        ++${c[l-1]};
        ${E} sourceLocG = ${E}(${c.join()}, 0);
        ++${c[l-2]};
        ${E} sourceLocA = ${E}(${c.join()}, 0);
        --${c[l-1]};
        ${E} sourceLocB = ${E}(${c.join()}, 0);
        --${c[l-2]};`}else d=l,h=`
        ${u} sourceLocR = coords;
        ++${c[l-1]};
        ${u} sourceLocG = coords;
        ++${c[l-2]};
        ${u} sourceLocA = coords;
        --${c[l-1]};
        ${u} sourceLocB = coords;
        --${c[l-2]};`;const p=["x","y","z","w","u","v"].slice(0,d),f="."+p[d-1],m=p.map(E=>"int "+E),y=cr("sourceLocR",d-1).concat("inIdx.r"),g=cr("sourceLocG",d-1).concat("inIdx.g"),b=cr("sourceLocB",d-1).concat("inIdx.b"),v=cr("sourceLocA",d-1).concat("inIdx.a"),w=r==="max"?"greaterThan":"lessThan",k=s?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${v.join()})));`,N=`vec4(
            getAChannel(${y.join()}),
            hasNextCol ? getAChannel(${g.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`,T=s?"":`
      float getBestIndicesAChannel(${m.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${m.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${T}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[l-1]} < ${o[l-1]-1};
        bool hasNextRow = ${c[l-2]} < ${o[l-2]-1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${n};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${N};

        for (int i = 0; i < ${n}; i++) {
          inIdx = srcIdx;
          ${k}
          vec4 candidate = ${N};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function oM(t,e,n,r=null){let s=e.shape[0],a=e.shape[1];r!=null&&(s=r.shape[0],a=r.shape[1]);const i=Pb(a),o={windowSize:i,inSize:a,batchSize:s,outSize:Math.ceil(a/i)},l=new mae(o,n,r==null),u=[e];r!=null&&u.push(r);const c=t.runWebGLProgram(l,u,"int32");if(c.shape[1]===1)return c;const h=oM(t,e,n,c);return t.disposeIntermediateTensorInfo(c),h}function lM(t,e,n,r=null){const s=r!=null?r.shape:e.shape,a=s[s.length-1],i=Pb(a),o=new gae(s,i,n,r==null),l=r==null?[e]:[e,r],u=t.runWebGLProgram(o,l,"int32");if(u.shape.length===e.shape.length){const c=lM(t,e,n,u);return t.disposeIntermediateTensorInfo(u),c}return u}function uM(t,e,n,r){const s=[n];if(mn("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,e.shape.length),!Z().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const a=[],i=t.texData.get(e.dataId),o=i!==null&&i.isPacked;let l=e;o&&(l=t.unpackTensor(e),a.push(l));const[u,c]=an(l.shape,s),h=Q(c),d=be({inputs:{x:l},backend:t,attrs:{shape:[-1,h]}});a.push(d);const p=oM(t,d,r);a.push(p);const f=be({inputs:{x:p},backend:t,attrs:{shape:u}});return a.forEach(m=>t.disposeIntermediateTensorInfo(m)),f}return lM(t,e,r)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function yae(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:a}=r;let i=Ze(a,s.shape);const o=Tt(i,s.shape.length);let l=s;const u=[];o!=null&&(l=fr({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=Ft(i.length,l.shape.length)),mn("argMax",[i[0]],l.shape.length);const c=uM(n,l,i[0],"max");return u.forEach(h=>n.disposeIntermediateTensorInfo(h)),c}const bae={kernelName:Jd,backendName:"webgl",kernelFunc:yae};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function xae(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:a}=r;let i=Ze(a,s.shape);const o=Tt(i,s.shape.length);let l=s;const u=[];o!=null&&(l=fr({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=Ft(i.length,l.shape.length)),mn("argMin",[i[0]],l.shape.length);const c=uM(n,l,i[0],"min");return u.forEach(h=>n.disposeIntermediateTensorInfo(h)),c}const vae={kernelName:ep,backendName:"webgl",kernelFunc:xae};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const wae=Ks+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,kae=pt({opSnippet:wae}),Sae={kernelName:Zu,backendName:"webgl",kernelFunc:kae};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Iae=Ks+"return log(x + sqrt(x * x + 1.0));",Nae=pt({opSnippet:Iae}),Cae={kernelName:Ju,backendName:"webgl",kernelFunc:Nae};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Tae=Ks+`
  return atan(x);
`,Eae=pt({opSnippet:Tae}),$ae={kernelName:ec,backendName:"webgl",kernelFunc:Eae};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Rae=M2+`
  return atan(a, b);
`,Aae=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Bl+`
  return result;
`,_ae=Gn({opSnippet:Rae,packedOpSnippet:Aae}),Fae={kernelName:nc,backendName:"webgl",kernelFunc:_ae};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Oae=Ks+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Dae=pt({opSnippet:Oae}),Mae={kernelName:tc,backendName:"webgl",kernelFunc:Dae};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let Wd=class{constructor(t,e,n,r=!1,s=!1){if(this.variableNames=["x"],e==="avg"&&n)throw new Error("Cannot compute positions for average pool.");const a=t.filterWidth,i=t.strideHeight,o=t.strideWidth,l=t.dilationHeight,u=t.dilationWidth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.top,p=t.padInfo.left;this.outputShape=t.outShape;const f=e==="avg",m=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,y=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;let g="0.0";if(f||(g="-1.0 / 1e-20"),n){const T=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${o});
        const ivec2 pads = ivec2(${d}, ${p});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${c};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${T} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?s?m:y:`wR * ${h} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const b="max";let v=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(v="avgValue / max(count, 1.0)");const w=Math.floor(a/4)*4,k=a%4,N=`
      if (${f}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${b}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${d}, ${p});
      const float initializationValue = ${g};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${g});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${c};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${w}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${N}
          }

          int xC = xCCorner + ${w};
          if (${k===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${N}
          } else if (${k===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${N}
          } else if (${k===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${N}
          }
        }
        setOutput(${v});
      }
    `}},L2=class{constructor(t,e,n,r=!1,s=!1){if(this.variableNames=["x"],e==="avg"&&n)throw new Error("Cannot compute positions for average pool.");const a=t.filterWidth,i=t.strideDepth,o=t.strideHeight,l=t.strideWidth,u=t.dilationDepth,c=t.dilationHeight,h=t.dilationWidth,d=t.effectiveFilterDepth,p=t.effectiveFilterHeight,f=t.effectiveFilterWidth,m=t.padInfo.front,y=t.padInfo.top,g=t.padInfo.left;this.outputShape=t.outShape;const b=e==="avg";let v="0.0";if(b||(v="-1.0 / 1e-20"),n){const _=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${o}, ${l});
        const ivec3 pads = ivec3(${m}, ${y}, ${g});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${p};
                wR += ${c}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${f};
                  wC += ${h}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${_} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?s?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${p} * ${f} +
                      wR * ${f} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const w="max";let k=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(k="avgValue / max(count, 1.0)");const N=Math.floor(a/4)*4,T=a%4,E=`
      if (${b}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${o}, ${l});
      const ivec3 pads = ivec3(${m}, ${y}, ${g});
      const float initializationValue = ${v};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${v});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p};
            wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${N}; wC += 4) {
              int xC = xCCorner + wC * ${h};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                getValue(batch, xD, xR, xC + 3 * ${h}, ch)
              );

              ${E}
            }

            int xC = xCCorner + ${N};
            if (${T===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${E}
            } else if (${T===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                initializationValue,
                initializationValue
              );

              ${E}
            } else if (${T===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                initializationValue
              );

              ${E}
            }
          }
        }
        setOutput(${k});
      }
    `}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Pae(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;Zc(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;R(In(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=er(s.shape,a,i,u,o,l);if(c.filterWidth===1&&c.filterHeight===1&&Je(c.inShape,c.outShape))return es({inputs:{x:s},backend:n});const h=new Wd(c,"avg",!1);return n.runWebGLProgram(h,[s],"float32")}const Lae={kernelName:tp,backendName:"webgl",kernelFunc:Pae};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zae(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=[1,1,1],h=vs(s.shape,a,i,c,o,l,u),d=new L2(h,"avg",!1);return n.runWebGLProgram(d,[s],"float32")}const Bae={kernelName:np,backendName:"webgl",kernelFunc:zae};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let Wae=class{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,s=t.strideWidth,a=t.dilationHeight,i=t.dilationWidth,o=t.effectiveFilterHeight,l=t.effectiveFilterWidth,u=o-1-t.padInfo.top,c=l-1-t.padInfo.left,h=1/(e*n);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${c});
      const float avgMultiplier = float(${h});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},Uae=class{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,s=t.strideDepth,a=t.strideHeight,i=t.strideWidth,o=t.dilationDepth,l=t.dilationHeight,u=t.dilationWidth,c=t.effectiveFilterDepth,h=t.effectiveFilterHeight,d=t.effectiveFilterWidth,p=c-1-t.padInfo.front,f=h-1-t.padInfo.top,m=d-1-t.padInfo.left,y=1/(e*n*r);this.userCode=`
      const ivec3 pads = ivec3(${p}, ${f}, ${m});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c};
            wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${h};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Vae(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:a}=e,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,h=[1,1,1],d=vs(i.shape,o,l,h,u,c),p=new Uae(d);return n.runWebGLProgram(p,[s],i.dtype)}const jae={kernelName:uy,backendName:"webgl",kernelFunc:Vae};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Gae(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:a}=e,i=a;Zc([s,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=er(i.shape,o,l,1,u),h=new Wae(c);return n.runWebGLProgram(h,[s],i.dtype)}const Hae={kernelName:ly,backendName:"webgl",kernelFunc:Gae};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Kae(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:a}=e,{transposeA:i,transposeB:o}=r;return _g({a:s,b:a,transposeA:i,transposeB:o,backend:n})}const qae={kernelName:rp,backendName:"webgl",kernelFunc:Kae};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let Xae=class{constructor(t,e,n,r,s,a){this.outputShape=[],this.variableNames=["x","mean","variance"],Ue(t,e),Ue(t,n);let i="0.0";r!=null&&(Ue(t,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";s!=null&&(Ue(t,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${o};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Yae{constructor(e,n,r,s,a,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Ue(e,n),Ue(e,r);let o="vec4(0.0)";s!=null&&(Ue(e,s),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="vec4(1.0)";a!=null&&(Ue(e,a),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${o};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Qae=({inputs:t,backend:e,attrs:n})=>{const{x:r,mean:s,variance:a,offset:i,scale:o}=t;R(s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),R(i==null||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),R(o==null||s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);const u=[r,s,a];let c=null;i!=null&&(c=i.shape,u.push(i));let h=null;o!=null&&(h=o.shape,u.push(o));const d=Z().getBool("WEBGL_PACK_NORMALIZATION")?new Yae(r.shape,s.shape,a.shape,c,h,l):new Xae(r.shape,s.shape,a.shape,c,h,l);return e.runWebGLProgram(d,u,u[0].dtype)},Zae={kernelName:mp,backendName:"webgl",kernelFunc:Qae};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let Jae=class{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=Ct(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=eie(this.rank);let r;const s=t.map((a,i)=>`sourceLoc.${Nv[i]} = start[${i}] + coords.${Nv[i]};`);r=`
        ${e} sourceLoc;
        ${e} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${n}));
      }
    `}};const Nv=["x","y","z","w","u","v"];function eie(t){if(t===1)return"sourceLoc";if(t<=6)return Nv.slice(0,t).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class tie{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=Ct(this.rank),r=cr("coords",this.rank),s=cr("sourceLoc",this.rank),a=this.rank===1?"sourceLoc":`vec2(${s.slice(-2).join()})`,i=`getChannel(getSource(${s.join()}), ${a})`,o=`
      result.x = ${i};
      if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
        ++${s[this.rank-1]};
        result.y = ${i};
        --${s[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${e[this.rank-2]}) {
        ++${s[this.rank-2]};
        result.z = ${i};
        if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
          ++${s[this.rank-1]};
          result.w = ${i};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${n}(${e.map((c,h)=>`start[${h}]`).join()});`:e.map((c,h)=>`${s[h]} = ${r[h]} + start[${h}];`).join(`
`);this.userCode=`
      void main() {
        ${n} coords = getOutputCoords();
        ${n} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${o}
        ${l}
        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function nie(t,e,n,r){const s=r.texData.get(t.dataId),a=r.makeTensorInfo(n,t.dtype),i=r.texData.get(a.dataId);Object.assign(i,s),i.refCount=1,i.shape=n,i.dtype=t.dtype;let o=Bk(e,Fe(t.shape));s.slice&&(o+=s.slice.flatOffset),i.slice={flatOffset:o,origDataId:s.slice&&s.slice.origDataId||t.dataId};const l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),a}function ah(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:a,size:i}=r,[o,l]=lf(s,a,i);if(Fb(s,o,l),Q(l)===0)return n.makeTensorInfo(l,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||s.dtype==="string"){const h=n.texData.get(s.dataId),d=Kre(h.values,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,d)}const{isPacked:u}=n.texData.get(s.dataId),c=zk(s.shape,o,l);if(u||!c){const h=Z().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new tie(l):new Jae(l),d=[o];return n.runWebGLProgram(h,[s],s.dtype,d)}return n.uploadToGPU(s.dataId),nie(s,o,l,n)}const rie={kernelName:jp,backendName:"webgl",kernelFunc:ah};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const sie=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:a,crops:i}=r;R(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce((b,v)=>b*v),l=Fl(s.shape,a,o),u=Ol(l.length,a.length),c=Dl(s.shape,a,o),h=zb(i,a.length),d=Bb(c,i,a.length),p=[],f=be({inputs:{x:s},backend:n,attrs:{shape:l}}),m=fr({inputs:{x:f},backend:n,attrs:{perm:u}}),y=be({inputs:{x:m},backend:n,attrs:{shape:c}}),g=ah({inputs:{x:y},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(y),p.forEach(b=>n.disposeIntermediateTensorInfo(b)),g},aie={kernelName:sp,backendName:"webgl",kernelFunc:sie};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function iie(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:a}=e,{size:i}=r,o=n.readSync(s.dataId),l=n.readSync(a.dataId),u=YD(o,l,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,u)}const oie={kernelName:cy,backendName:"webgl",kernelFunc:iie};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const lie=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,uie=`
  return float(int(a.r) & int(b.r));
`;function cie(t){const{inputs:e,backend:n}=t,{a:r,b:s}=e,a=Z().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=Z().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,s])||i===1){const l=n.texData.get(r.dataId).values,u=n.texData.get(s.dataId).values,[c,h]=yre(r.shape,s.shape,l,u,r.dtype),d=n.makeTensorInfo(h,r.dtype),p=n.texData.get(d.dataId);return p.values=c,d}let o;return a?o=new rh(lie,r.shape,s.shape,!1):o=new wl(uie,r.shape,s.shape),n.runWebGLProgram(o,[r,s],r.dtype)}const hie={kernelName:hy,backendName:"webgl",kernelFunc:cie};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function die(t){const{inputs:e,backend:n}=t,{s0:r,s1:s}=e,a=n.readSync(r.dataId),i=n.readSync(s.dataId),o=Ue(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const pie={kernelName:dy,backendName:"webgl",kernelFunc:die};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const fie="return float(a != b);",cM=Gn({opSnippet:fie,cpuKernelImpl:Lre,dtype:"bool"}),mie={kernelName:_p,backendName:"webgl",kernelFunc:cM};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function kf(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.texData.get(r.dataId);return es({inputs:{x:s.complexTensorInfos.real},backend:n})}const gie={kernelName:Uy,backendName:"webgl",kernelFunc:kf};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const yie="return float(int(x));";function bie(t,e){const n=new Ma(t.shape,yie),r=e.runWebGLProgram(n,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Cv(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dtype:a}=r;if(a==="complex64"){if(s.dtype==="complex64")return es({inputs:{x:s},backend:n});const i=rn(s.shape),o=Cv({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),l=Io({inputs:{real:o,imag:i},backend:n});return i.dispose(),n.disposeIntermediateTensorInfo(o),l}if(s.dtype==="complex64"){const i=kf({inputs:{input:s},backend:n}),o=Cv({inputs:{x:i},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(i),o}if(!sy(s.dtype,a)){const i=es({inputs:{x:s},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:a}}if(n.shouldExecuteOnCPU([s])){const i=n.texData.get(s.dataId).values,[o,l,u]=bre(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,l,u)}if(a==="int32")return bie(s,n);if(a==="bool"){const i=n.makeTensorInfo([],"bool",pn("bool",1)),o=cM({inputs:{a:s,b:i},backend:n});return n.disposeIntermediateTensorInfo(i),o}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${a}`)}const xie={kernelName:rc,backendName:"webgl",kernelFunc:Cv};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const hC="return ceil(x);",vie=pt({opSnippet:hC,packedOpSnippet:hC,cpuKernelImpl:xre}),wie={kernelName:sc,backendName:"webgl",kernelFunc:vie};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let kie=class{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Sie{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Iie(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{clipValueMin:a,clipValueMax:i}=r;let o;Z().getBool("WEBGL_PACK_CLIP")?o=new Sie(s.shape):o=new kie(s.shape);const l=[[a],[i]];return n.runWebGLProgram(o,[s],s.dtype,l)}const Nie={kernelName:ac,backendName:"webgl",kernelFunc:Iie};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let Cie=class{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function dC(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}function Tie(t){const{inputs:e,backend:n}=t,{x:r}=e,s=n.texData.get(r.dataId),a=new Cie(r.shape),i=[dC(r,s.complexTensorInfos.real),dC(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(a,i,i[0].dtype)}const Eie={kernelName:ap,backendName:"webgl",kernelFunc:Tie};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let $ie=class{constructor(t){this.outputShape=[],this.outputShape=Sr(t,1),this.variableNames=t.map((a,i)=>`T${i}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let a=1;a<e.length;a++)e[a]=e[a-1]+t[a][1];const n=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<e.length;a++){const i=e[a-1];n.push(`else if (yC < ${e[a]}) setOutput(getT${a}(yR, yC-${i}));`)}const r=e.length,s=e[e.length-1];n.push(`else setOutput(getT${r}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Rie{constructor(e,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Sr(e,n);const r=this.outputShape,s=r.length,a=Ct(s),i=cr("coords",s),o=["x","y","z","w","u","v"].slice(0,s);this.variableNames=e.map((m,y)=>`T${y}`);const l=new Array(e.length-1);l[0]=e[0][n];for(let m=1;m<l.length;m++)l[m]=l[m-1]+e[m][n];const u=o[n],c=o.slice(-2),h=o.join();let d=`if (${u} < ${l[0]}) {
        return getChannel(
            getT0(${h}), vec2(${c.join()}));
        }`;for(let m=1;m<l.length;m++){const y=l[m-1];d+=`
        if (${u} < ${l[m]}  && ${u} >= ${l[m-1]}) {
          return getChannel(
            getT${m}(${cm(o,u,y)}),
            vec2(${cm(c,u,y)}));
        }`}const p=l.length,f=l[l.length-1];d+=`
        return getChannel(
          getT${p}(${cm(o,u,f)}),
          vec2(${cm(c,u,f)}));`,this.userCode=`
      float getValue(${o.map(m=>"int "+m)}) {
        ${d}
      }

      void main() {
        ${a} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[s-1]} = ${i[s-1]} + 1;
        if (${i[s-1]} < ${r[s-1]}) {
          result.g = getValue(${i});
        }

        ${i[s-2]} = ${i[s-2]} + 1;
        if (${i[s-2]} < ${r[s-2]}) {
          result.a = getValue(${i});
        }

        ${i[s-1]} = ${i[s-1]} - 1;
        if (${i[s-2]} < ${r[s-2]} &&
            ${i[s-1]} < ${r[s-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}}function cm(t,e,n){const r=t.indexOf(e);return t.map((s,a)=>a===r?`${s} - ${n}`:s).join()}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function b0(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.texData.get(r.dataId);return es({inputs:{x:s.complexTensorInfos.imag},backend:n})}const Aie={kernelName:_y,backendName:"webgl",kernelFunc:b0};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Uh(t,e,n){const r=t[0].dtype;if(r==="complex64"){const p=t.map(b=>kf({inputs:{input:b},backend:n})),f=t.map(b=>b0({inputs:{input:b},backend:n})),m=Uh(p,e,n),y=Uh(f,e,n),g=Io({inputs:{real:m,imag:y},backend:n});return p.forEach(b=>n.disposeIntermediateTensorInfo(b)),f.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),g}let s=n.shouldExecuteOnCPU(t);if(r==="string"&&(s=!0),s){const p=t.map(w=>{const k=[-1,Q(w.shape.slice(e))];return be({inputs:{x:w},backend:n,attrs:{shape:k}})}),f=p.map(w=>({vals:n.readSync(w.dataId),shape:w.shape})),m=Sr(p.map(w=>w.shape),1),y=p[0].shape[0]===1,g=vre(f,m,r,y),b=Sr(t.map(w=>w.shape),e),v=n.makeTensorInfo(b,r,g);return p.forEach(w=>n.disposeIntermediateTensorInfo(w)),v}const a=t.filter(p=>Q(p.shape)>0),i=Z().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(a.length===1){const p=i?new Ma(t[0].shape,$i):new Pi(t[0].shape,$i);return n.runWebGLProgram(p,t,r)}const o=Z().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>o){const p=[];for(let m=0;m<a.length;m+=o){const y=a.slice(m,m+o);p.push(Uh(y,e,n))}const f=Uh(p,e,n);for(const m of p)n.disposeIntermediateTensorInfo(m);return f}if(i){const p=new Rie(a.map(f=>f.shape),e);return n.runWebGLProgram(p,a,r)}const{tensors2D:l,outShape:u}=_ie(a,e,n),c=new $ie(l.map(p=>p.shape)),h=n.runWebGLProgram(c,l,r);l.forEach(p=>n.disposeIntermediateTensorInfo(p));const d=be({inputs:{x:h},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(h),d}function _ie(t,e,n){const r=Sr(t.map(s=>s.shape),e);return{tensors2D:t.map(s=>be({inputs:{x:s},attrs:{shape:[-1,Q(s.shape.slice(e))]},backend:n})),outShape:r}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function hM(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r,a=Ze(s,e[0].shape)[0],i=e.map(u=>u.shape);Mb(i,a);const o=Sr(e.map(u=>u.shape),a);if(Q(o)===0)return n.makeTensorInfo(o,e[0].dtype,[]);const l=e.filter(u=>Q(u.shape)>0);return l.length===1?es({inputs:{x:l[0]},backend:n}):Uh(l,a,n)}const Fie={kernelName:ip,backendName:"webgl",kernelFunc:hM};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class dM{constructor(e,n=!1,r=null,s=!1,a=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const i=e.padInfo.top,o=e.padInfo.left,l=e.strideHeight,u=e.strideWidth,c=e.dilationHeight,h=e.dilationWidth,d=e.filterHeight,p=e.filterWidth,f=Math.floor(e.inChannels/4)*4,m=e.inChannels%4,y=e.dataFormat==="channelsLast",g=y?1:2,b=y?2:3,v=y?3:1;let w="",k="";r&&(s?w=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:a?w=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:w=`
          float activation(float x) {
            ${r}
          }
        `,k="result = activation(result);");const N=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${w}

      const ivec2 strides = ivec2(${l}, ${u});
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${v}];

        ivec2 xRCCorner =
            ivec2(coords[${g}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${y}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${m===1}) {

              if (${y}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${m===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${y}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${m===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${y}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${N}
        ${k}
        setOutput(result);
      }
    `}}class Oie{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const n=e.padInfo.front,r=e.padInfo.top,s=e.padInfo.left,a=e.strideDepth,i=e.strideHeight,o=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,h=e.filterDepth,d=e.filterHeight,p=e.filterWidth,f=Math.floor(e.inChannels/4)*4,m=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${a}, ${i}, ${o});
      const ivec3 pads = ivec3(${n}, ${r}, ${s});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${m===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${m===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${m===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class pM{constructor(e,n=!1,r=null,s=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=nr(this.outputShape.length);const i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,h=c;let d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<c;y++)d+=`
           vec4 xTexelC${y*2};
           int xTexelC${y*2}Ready;
           vec4 xTexelC${y*2+1};
           int xTexelC${y*2+1}Ready;
           vec4 xC${y};`;d+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let y=0;y<c;y++)d+=`
           xTexelC${y*2} = vec4(0.0);
           xTexelC${y*2}Ready = 0;
           xTexelC${y*2+1} = vec4(0.0);
           xTexelC${y*2+1}Ready = 0;
           xC${y} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let y=0;y<(h+1)/2;y++){const g=y*2;if(d+=`
           xC = xCCorner + ${g*l};
           `,o===1){if(g<c&&(i%2===1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }
               `,l===1&&g>0?d+=`
                 xC${g} = vec4(xTexelC${g-2}.zw, xTexelC${g}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${g} = vec4(previous.zw, xTexelC${g}.xy);
                   } else {
                     xC${g} = vec4(0.0, 0.0, xTexelC${g}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xC${g} = xTexelC${g};
                 `,g+1<c)){const b=i%2===0?ny(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${b};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                     xTexelC${g+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${g+1}.zw = vec2(0.0);
                     }
                     xTexelC${g+1}Ready = 1;
                   }
                   `,l>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${g+1} = vec4(previous.zw, xTexelC${g+1}.xy);
                     } else {
                      xC${g+1} = vec4(0.0, 0.0, xTexelC${g+1}.xy);
                     }
                     `:d+=`
                     xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.xy);
                     `):b===1?d+=`
                     xC${g+1} = xTexelC${g};
                     `:d+=`
                     xCOffset = xC + ${b};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                       xTexelC${g+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${g+1}.zw = vec2(0.0);
                       }
                       xTexelC${g+1}Ready = 1;
                     }

                     xC${g+1} = xTexelC${g+1};
                     `}}else g<c&&(i%2===1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${g+1}Ready == 0) {
                   xTexelC${g+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${g+1}.zw = vec2(0.0);
                   }
                   xTexelC${g+1}Ready = 1;
                 }

                 xC${g} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);
               `,g+1<c&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${g+1} = vec4(xTexelC${g+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                   xTexelC${g+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g+1}.zw = vec2(0.);
                   }
                   xTexelC${g+1}Ready = 1;
                 }

                 xC${g} = vec4(
                   xTexelC${g}.xy, xTexelC${g+1}.xy);
               `,g+1<c&&(d+=`
                   xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);
                 `)));g<c&&(d+=`
             wTexel = getW(r, ${g}, d1, d2);
             dotProd += xC${g}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${g}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,g+1<c&&(d+=`
               wTexel = getW(r, ${g+1}, d1, d2);
               dotProd += xC${g+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${g+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let p="",f="";r&&(s?p=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:a?p=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:p=`vec4 activation(vec4 x) {
           ${r}
         }`,f="result = activation(result);");const m=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${p}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${m}
         ${f}
         setOutput(result);
       }
     `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Die{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=nr(this.outputShape.length);const{dataFormat:r}=n,s=gr(),a=r==="channelsLast",i=a?1:2,o=a?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let u="";for(let c=0;c<=1;c++)for(let h=0;h<=1;h++)u+=`
          blockIndex = rc.z + ${h};
          pos = rc.y + ${c};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${o}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${a}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+h}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+h}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${s.output} = result;
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Fg(t,e){const n=t.length;return n>=3?e?[...t.slice(0,-3),t[n-3]*t[n-2],t[n-1]]:[...t.slice(0,-3),t[n-3],t[n-2]*t[n-1]]:!e&&n===1&&t[0]>1?[t[0],1]:null}function fM({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const l=t.shape,u=r.texData.get(t.dataId),c=n.inChannels,h=l[0]*l[1]*l[2],d=n.outChannels,p=n.dataFormat==="channelsLast",f=!1,m=!1;let y;const g=[];if(a!=null){const b=Fg(a.shape,p);b!=null&&(a=be({inputs:{x:a},backend:r,attrs:{shape:b}}),g.push(a))}if(s!=null){const b=Fg(s.shape,p);b!=null&&(s=be({inputs:{x:s},backend:r,attrs:{shape:b}}),g.push(s))}if(!((h===1||d===1)&&c>iM)&&u.isPacked&&p&&u.texture!=null&&l[2]%2!==0&&Je(u.shape.slice(-3),l.slice(-3))){const b=l[0]*l[1]*(l[2]+1),v={dataId:t.dataId,shape:[1,b,n.inChannels],dtype:t.dtype},w=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,R(zd(u.shape,v.shape),()=>`packed reshape ${u.shape} to ${v.shape} isn't free`);const k=be({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});g.push(k);const N=_g({a:v,b:k,backend:r,transposeA:f,transposeB:m,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i}),T=r.texData.get(N.dataId);R(T.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=w,T.shape=n.outShape,y=es({inputs:{x:N},backend:r}),y.shape=n.outShape,g.push(N)}else{const b=n.outHeight*n.outWidth,v=be({inputs:{x:t},backend:r,attrs:{shape:p?[n.batchSize,b,n.inChannels]:[n.batchSize,n.inChannels,b]}}),w=be({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),k=_g({a:p?v:w,b:p?w:v,transposeA:!p,transposeB:m,backend:r,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i});y=be({inputs:{x:k},backend:r,attrs:{shape:n.outShape}}),g.push(v),g.push(w),g.push(k)}for(const b of g)r.disposeIntermediateTensorInfo(b);return y}function mM({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:h,outHeight:d,dataFormat:p}=n,f=p==="channelsLast",m=l*u*c,y=d*h,g=[n.batchSize,m,y],b=!0,v=!1,w=[];if(a!=null){const G=Fg(a.shape,f);G!=null&&(a=be({inputs:{x:a},backend:r,attrs:{shape:G}}),w.push(a))}if(s!=null){const G=Fg(s.shape,f);G!=null&&(s=be({inputs:{x:s},backend:r,attrs:{shape:G}}),w.push(s))}const k=be({inputs:{x:e},backend:r,attrs:{shape:[1,m,Q(e.shape)/m]}});w.push(k);const N=new Die(g,n),T=[t.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],E=r.runWebGLProgram(N,[t],"float32",T),_=be({inputs:{x:E},backend:r,attrs:{shape:g}});w.push(E),w.push(_);const O=s!=null,M=a!=null,V=o==="leakyrelu",W=o?Bd(o,!0):null,K=new aM(f?_.shape:k.shape,f?k.shape:_.shape,f?[n.batchSize,y,n.outChannels]:[n.batchSize,n.outChannels,y],b,v,O,W,M,V),q=f?[_,k]:[k,_];if(s&&q.push(s),M&&q.push(a),V){const G=r.makeTensorInfo([],"float32",vi(i,"float32"));q.push(G),w.push(G)}const ee=r.runWebGLProgram(K,q,"float32"),te=be({inputs:{x:ee},backend:r,attrs:{shape:n.outShape}});w.push(ee);for(const G of w)r.disposeIntermediateTensorInfo(G);return te}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Mie(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:a}=e,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r,h=ss(l),d=_t(s.shape,a.shape,i,u,o,c,!1,h);let p;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))p=fM({x:s,filter:a,convInfo:d,backend:n});else if(d.strideWidth<=2&&h==="channelsLast"&&Z().getBool("WEBGL_EXP_CONV")){const m=new pM(d),y=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=n.runWebGLProgram(m,[s,a],"float32",y)}else if(Z().getBool("WEBGL_CONV_IM2COL"))p=mM({x:s,filter:a,convInfo:d,backend:n});else{const m=new dM(d);p=n.runWebGLProgram(m,[s,a],"float32")}const f=be({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}const Pie={kernelName:op,backendName:"webgl",kernelFunc:Mie};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let Lie=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,s=t.padInfo.left,a=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${r};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              ${a?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},zie=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,s=t.strideWidth,a=t.dataFormat==="channelsLast",i=e-1-t.padInfo.top,o=n-1-t.padInfo.left,l=a?1:2,u=a?2:3,c=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${c}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Bie=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,s=t.padInfo.front,a=t.padInfo.top,i=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${e} - ${s};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${a};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${i};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Wie=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,s=t.strideDepth,a=t.strideHeight,i=t.strideWidth,o=e-1-t.padInfo.front,l=n-1-t.padInfo.top,u=r-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${o}, ${l}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${e}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${e} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Uie(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:a}=e,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,h=ss(l),d=_t(s.shape,c,i,1,o,u,!1,h),p=new Lie(d);return n.runWebGLProgram(p,[s,a],"float32")}const Vie={kernelName:fy,backendName:"webgl",kernelFunc:Uie};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class jie{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=nr(this.outputShape.length);const n=e.filterHeight,r=e.filterWidth,s=n-1-e.padInfo.top,a=r-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Gie(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:a}=e,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,h=ss(u),d=_t(i,a.shape,o,1,l,c,!1,h);if(Z().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&h==="channelsLast"){const p=[[d.strideHeight,d.strideWidth]],f=new jie(d);return n.runWebGLProgram(f,[s,a],"float32",p)}else{const p=new zie(d);return n.runWebGLProgram(p,[s,a],"float32")}}const Hie={kernelName:lp,backendName:"webgl",kernelFunc:Gie};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Kie(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:a}=e,{strides:i,pad:o,dilations:l}=r,u=wa(s.shape,a.shape,i,l,o),c=new Oie(u);return n.runWebGLProgram(c,[s,a],"float32")}const qie={kernelName:up,backendName:"webgl",kernelFunc:Kie};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Xie(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:a}=e,{strides:i,pad:o,filterShape:l}=r,u=wa(s.shape,l,i,1,o),c=new Bie(u);return n.runWebGLProgram(c,[s,a],"float32")}const Yie={kernelName:my,backendName:"webgl",kernelFunc:Xie};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Qie(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:a}=e,{pad:i,strides:o,inputShape:l}=r,u=wa(l,a.shape,o,1,i),c=new Wie(u);return n.runWebGLProgram(c,[s,a],"float32")}const Zie={kernelName:gy,backendName:"webgl",kernelFunc:Qie};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Jie=sh+`
  return cos(x);
`,eoe=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Bl}
  return result;
`,toe=pt({opSnippet:Jie,packedOpSnippet:eoe}),noe={kernelName:ic,backendName:"webgl",kernelFunc:toe};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const roe=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,soe=pt({opSnippet:roe}),aoe={kernelName:oc,backendName:"webgl",kernelFunc:soe};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let ioe=class{constructor(t,e,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,i,o,l]=t,[u]=e,[c,h]=n;this.outputShape=[u,c,h,l];const d=r==="bilinear"?1:0,[p,f]=[`${i-1}.0`,`${o-1}.0`],[m,y,g]=c>1?[`${(i-1)/(c-1)}`,"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[b,v,w]=h>1?[`${(o-1)/(h-1)}`,"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`
      const float height_ratio = float(${m});
      const float width_ratio = float(${b});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${v};

        float in_y = ${g};
        if( in_y < 0.0 || in_y > ${p} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${w};
        if( in_x < 0.0 || in_x > ${f} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${d} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ooe=t=>{const{inputs:e,backend:n,attrs:r}=t,{image:s,boxes:a,boxInd:i}=e,{cropSize:o,method:l,extrapolationValue:u}=r,c=new ioe(s.shape,a.shape,o,l,u);return n.runWebGLProgram(c,[s,a,i],"float32")},loe={kernelName:by,backendName:"webgl",kernelFunc:ooe};var Ud;(function(t){t.Prod="*",t.Sum="+"})(Ud||(Ud={}));let pC=class{constructor(t,e,n,r){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const s=this.outputShape.length,a=this.op===Ud.Prod?"1.0":"0.0",i=n?a:`getX(${fC(s,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1];let l="",u="";n?(l=r?`end != ${o-1}`:"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Ct(s)} coords = getOutputCoords();
        int end = ${mC(s,"coords",this.op)};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${u};
          ${mC(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${fC(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function fC(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.x, ${e}.y`;if(t===3)return`${e}.x, ${e}.y, ${e}.z`;if(t===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function mC(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.y`;if(t===3)return`${e}.z`;if(t===4)return`${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function gM(t,e,n,r,s,a){const i=e.shape.length,o=Tt([r],i);let l=e;o!=null&&(l=fr({inputs:{x:e},backend:n,attrs:{perm:o}}));const u=Ft(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const c=l.shape[u];let h=es({inputs:{x:l},backend:n});for(let d=0;d<=Math.ceil(Math.log2(c))-1;d++){const p=new pC(t,l.shape,!1,a),f=[[d]],m=h;h=n.runWebGLProgram(p,[h],h.dtype,f),n.disposeIntermediateTensorInfo(m)}if(s){const d=new pC(t,l.shape,s,a),p=h;h=n.runWebGLProgram(d,[h],h.dtype),n.disposeIntermediateTensorInfo(p)}if(o!=null){const d=Ha(o),p=fr({inputs:{x:h},backend:n,attrs:{perm:d}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(l),p}return h}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function uoe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:a,exclusive:i,reverse:o}=r;return gM(Ud.Prod,s,n,a,i,o)}const coe={kernelName:yy,backendName:"webgl",kernelFunc:uoe};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function hoe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:a,exclusive:i,reverse:o}=r;return gM(Ud.Sum,s,n,a,i,o)}const doe={kernelName:cp,backendName:"webgl",kernelFunc:hoe};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function poe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:a}=e,{size:i,binaryOutput:o}=r;if(s.shape.length===1){const l=n.readSync(s.dataId),u=n.readSync(a.dataId),c=YD(l,u,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,c)}else if(s.shape.length===2){const l=n.bufferSync(s),u=n.bufferSync(a),c=gre(l,u,i,o);return n.makeTensorInfo(c.shape,a.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const foe={kernelName:xy,backendName:"webgl",kernelFunc:poe};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let moe=class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${e};
      int offset_h = imod(h, ${e});
      int in_w = w / ${e};
      int offset_w = imod(w, ${e});
      int offset_d = (offset_h * ${e} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function goe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockSize:a,dataFormat:i}=r,o=s.shape[0],l=i==="NHWC"?s.shape[1]:s.shape[2],u=i==="NHWC"?s.shape[2]:s.shape[3],c=i==="NHWC"?s.shape[3]:s.shape[1],h=l*a,d=u*a,p=c/(a*a),f=i==="NHWC"?[o,h,d,p]:[o,p,h,d],m=new moe(f,a,i);return n.runWebGLProgram(m,[s],s.dtype)}const yoe={kernelName:vy,backendName:"webgl",kernelFunc:goe};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let yM=class{constructor(t,e=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=nr(this.outputShape.length);const a=t.filterHeight,i=t.filterWidth,o=t.outChannels/t.inChannels;let l="",u="";n&&(r?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:l=`
          float activation(float x) {
            ${n}
          }
        `,u="result = activation(result);");const c=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${c}
        ${u}
        setOutput(result);
      }
    `}};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class bM{constructor(e,n=!1,r=null,s=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=nr(this.outputShape.length);const i=e.outChannels/e.inChannels,o=e.padInfo.left,l=e.strideWidth,u=e.dilationWidth,c=e.filterHeight,h=e.filterWidth,d=h;let p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<h;g++)p+=`
          vec4 xTexelC${g*2};
          int xTexelC${g*2}Ready;
          vec4 xTexelC${g*2+1};
          int xTexelC${g*2+1}Ready;
          vec4 xC${g};`;p+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let g=0;g<h;g++)p+=`
          xTexelC${g*2} = vec4(0.0);
          xTexelC${g*2}Ready = 0;
          xTexelC${g*2+1} = vec4(0.0);
          xTexelC${g*2+1}Ready = 0;
          xC${g} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let g=0;g<(d+1)/2;g++){const b=g*2;if(p+=`
          xC = xCCorner + ${b*u};
          `,l===1){if(b<h&&(o%2===1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,u===1&&b>0?p+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<h)){const v=o%2===0?ny(u):u;u%2===0&&o%2===1||u%2!==0&&o%2!==1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${v};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,u>1?p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                    } else {
                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                    }
                    `:p+=`
                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                    `):v===1?p+=`
                    xC${b+1} = xTexelC${b};
                    `:p+=`
                    xCOffset = xC + ${v};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<h&&(o%2===1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<h&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<h&&(p+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<h&&(p+=`
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<h&&(p+=`
              wTexel = getW(r, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  `,p+=`
      }
    `;let f="",m="";r&&(s?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:a?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:f=`vec4 activation(vec4 x) {
          ${r}
        }`,m="result = activation(result);");const y=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${y}
        ${m}
        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function boe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:a}=e,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;let c=l;c==null&&(c=[1,1]),R(In(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const h=_t(s.shape,a.shape,i,c,o,u,!0);let d;Z().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?d=new bM(h):d=new yM(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[s,a],"float32",p)}const xoe={kernelName:hp,backendName:"webgl",kernelFunc:boe};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let voe=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,s=t.padInfo.left,a=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${r};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},woe=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,s=t.strideWidth,a=e-1-t.padInfo.top,i=n-1-t.padInfo.left,o=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${o}; dm++) {
              int d2 = d1 * ${o} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function koe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:a}=e,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r,h=_t(s.shape,c,i,o,l,u,!0),d=new voe(h);return n.runWebGLProgram(d,[s,a],"float32")}const Soe={kernelName:wy,backendName:"webgl",kernelFunc:koe};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ioe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:a}=e,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r,h=_t(c,a.shape,i,o,l,u,!0),d=new woe(h);return n.runWebGLProgram(d,[s,a],"float32")}const Noe={kernelName:ky,backendName:"webgl",kernelFunc:Ioe};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let Coe=class{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Toe(t){const{inputs:e,backend:n}=t,{x:r}=e,s=[...r.shape,...r.shape],a=Q(r.shape),i=be({inputs:{x:r},backend:n,attrs:{shape:[a]}}),o=new Coe(a),l=n.runWebGLProgram(o,[i],i.dtype),u=be({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}const Eoe={kernelName:Sy,backendName:"webgl",kernelFunc:Toe};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let $oe=class{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:n,padInfo:r,strideHeight:s,strideWidth:a,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=t,{top:c,left:h}=r;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${a});
      const ivec2 pads = ivec2(${c}, ${h});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${e}) {
            for (int w = 0; w < ${o}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Roe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:a}=e,{strides:i,pad:o,dilations:l}=r,u=xo(s.shape,a.shape,i,o,"NHWC",l);let c;const h=new $oe(u);c=n.runWebGLProgram(h,[s,a],"float32");const d=be({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),d}const Aoe={kernelName:dp,backendName:"webgl",kernelFunc:Roe};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _oe(t){const{inputs:e,backend:n,attrs:r}=t,{equation:s}=r,a=e,{allDims:i,summedDims:o,idDims:l}=Kb(s,a.length);Xb(i.length,l,a);const{path:u,steps:c}=Yb(o,l),h=c.length;let d=null,p=i.length;const f=[];for(let m=0;m<h;++m){for(const y of c[m]){const{permutationIndices:g,expandDims:b}=qb(p,l[y]);let v;Qb(g)?v=a[y]:(v=fr({inputs:{x:a[y]},backend:n,attrs:{perm:g}}),f.push(v));const w=v.shape.slice();for(let k=0;k<b.length;++k)w.splice(b[k],0,1);Je(v.shape,w)||(v=be({inputs:{x:v},backend:n,attrs:{shape:w}}),f.push(v)),d===null?d=v:(d=P2({inputs:{a:v,b:d},backend:n}),f.push(d))}m<h-1&&(u[m]>=0&&(d=y0({inputs:{x:d},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}const Foe={kernelName:Ny,backendName:"webgl",kernelFunc:_oe};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Ooe="return (x >= 0.0) ? x : (exp(x) - 1.0);",Doe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Moe=pt({opSnippet:Ooe,packedOpSnippet:Doe}),Poe={kernelName:uc,backendName:"webgl",kernelFunc:Moe};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Loe="return (b >= 0.0) ? a : a * (b + 1.0);",zoe=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Boe=t=>{const{inputs:e,backend:n}=t,{dy:r,y:s}=e,a=Z().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new rh(zoe,r.shape,s.shape):new wl(Loe,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],r.dtype)},Woe={kernelName:Cy,backendName:"webgl",kernelFunc:Boe};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Uoe=`
  return vec4(equal(a, b));
`,Voe="return float(a == b);",joe=Gn({opSnippet:Voe,packedOpSnippet:Uoe,dtype:"bool",cpuKernelImpl:wre}),Goe={kernelName:pp,backendName:"webgl",kernelFunc:joe};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Hoe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${Wb};
  float a1 = ${Ub};
  float a2 = ${Vb};
  float a3 = ${jb};
  float a4 = ${Gb};
  float a5 = ${Hb};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Koe=pt({opSnippet:Hoe}),qoe={kernelName:cc,backendName:"webgl",kernelFunc:Koe};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Xoe=sh+`
  return exp(x);
`,Yoe=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,xM=pt({opSnippet:Xoe,packedOpSnippet:Yoe,cpuKernelImpl:kre,dtype:"float32"}),Qoe={kernelName:hc,backendName:"webgl",kernelFunc:xM};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Tv(t){const{inputs:e,attrs:n,backend:r}=t,{dim:s}=n,{input:a}=e,i=a.shape.length,o=a.shape.slice();let l=s;return s<0&&(R(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),be({inputs:{x:a},backend:r,attrs:{shape:o}})}const Zoe={kernelName:fp,backendName:"webgl",kernelFunc:Tv};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const gC="return exp(x) - 1.0;",Joe=pt({opSnippet:gC,packedOpSnippet:gC,cpuKernelImpl:Sre}),ele={kernelName:dc,backendName:"webgl",kernelFunc:Joe};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let yC=class{constructor(t,e,n){this.variableNames=["real","imag"];const r=e[1];this.outputShape=e;const s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${r}.0`:"1.0";let i;if(t==="real")i="return real * expR - imag * expI;";else if(t==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function vM(t,e,n){const r=n.texData.get(t.dataId),s=Q(t.shape),a=t.shape[t.shape.length-1],i=s/a,o=be({inputs:{x:t},backend:n,attrs:{shape:[i,a]}}),l=o.shape,u=new yC("real",l,e),c=new yC("imag",l,e),h=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],d=n.runWebGLProgram(u,h,"float32"),p=n.runWebGLProgram(c,h,"float32"),f=Io({inputs:{real:d,imag:p},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p);const m=be({inputs:{x:f},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(f),m}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function tle(t){const{inputs:e,backend:n}=t,{input:r}=e;return vM(r,!1,n)}const nle={kernelName:Ty,backendName:"webgl",kernelFunc:tle};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let rle=class{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Sf(t){const{backend:e,attrs:n}=t,{shape:r,value:s}=n;let{dtype:a}=n;if(a=a||mo(s),a==="string"){const i=Ht(a,Q(r));return i.fill(s),e.makeTensorInfo(r,a,i)}else{const i=new rle(r,s),o=[[s]];return e.runWebGLProgram(i,[],a,o)}}const sle={kernelName:Ey,backendName:"webgl",kernelFunc:Sf};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let ale=class{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${e} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${e}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ile={kernelName:$y,backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,r=e,s=new ale(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const bC="return floor(x);",ole=pt({opSnippet:bC,packedOpSnippet:bC,cpuKernelImpl:Ire}),lle={kernelName:pc,backendName:"webgl",kernelFunc:ole};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ule=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,cle=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,hle=Gn({opSnippet:ule,packedOpSnippet:cle,dtype:"int32"}),dle={kernelName:fc,backendName:"webgl",kernelFunc:hle};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let ple=class{constructor(t){this.variableNames=["A"];const e=gr(),[n,r]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);

        vec4 values = ${e.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class fle{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const n=gr(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${s}.0, ${r}.0);
            vec4 values = ${n.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${n.output} = result;
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const mle={kernelName:og,backendName:"webgl",kernelFunc:gle};let Yl,$x=Z().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function gle(t){const{inputs:e,backend:n,attrs:r}=t;let{pixels:s}=e;const{numChannels:a}=r,i=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[l,u]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],h=[u,l,a];if(o||i){const m=Z().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Yl==null||m!==$x)&&($x=m,Yl=document.createElement("canvas").getContext("2d",{willReadFrequently:$x})),Yl.canvas.width=l,Yl.canvas.height=u,Yl.drawImage(s,0,0,l,u),s=Yl.canvas}const d=n.makeTensorInfo(c,"int32");n.texData.get(d.dataId).usage=us.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),s);const p=Z().getBool("WEBGL_PACK")?new fle(h):new ple(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function yle(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:a,bias:i,preluActivationWeights:o}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r,m=ss(c),y=_t(s.shape,a.shape,l,h,u,d,!1,m);let g;const b=[],v=i!=null,w=o!=null,k=p==="leakyrelu",N=()=>{const E=[s,a],_=(O,M)=>{if(M==="NCHW"&&O.shape.length===1&&O.shape[0]!==1){const V=be({inputs:{x:O},backend:n,attrs:{shape:[O.shape[0],1,1]}});return b.push(V),V}return O};if(v&&E.push(_(i,c)),w&&E.push(_(o,c)),k){const O=n.makeTensorInfo([],"float32",vi(f,"float32"));E.push(O),b.push(O)}return E};if(y.filterHeight===1&&y.filterWidth===1&&y.dilationHeight===1&&y.dilationWidth===1&&y.strideHeight===1&&y.strideWidth===1&&(y.padInfo.type==="SAME"||y.padInfo.type==="VALID"))g=fM({x:s,filter:a,convInfo:y,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else if(y.strideWidth<=2&&m==="channelsLast"&&Z().getBool("WEBGL_EXP_CONV")){const E=p?Bd(p,!0):null,_=new pM(y,v,E,w,k),O=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],M=N();g=n.runWebGLProgram(_,M,"float32",O)}else if(Z().getBool("WEBGL_CONV_IM2COL"))g=mM({x:s,filter:a,convInfo:y,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{const E=p?Bd(p,!1):null,_=new dM(y,v,E,w,k),O=N();g=n.runWebGLProgram(_,O,"float32")}const T=be({inputs:{x:g},backend:n,attrs:{shape:y.outShape}});return b.push(g),b.forEach(E=>n.disposeIntermediateTensorInfo(E)),T}const ble={kernelName:wd,backendName:"webgl",kernelFunc:yle};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function xle(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:a,bias:i,preluActivationWeights:o}=e,{strides:l,pad:u,dilations:c,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=r,f=[];let m=c;m==null&&(m=[1,1]),R(In(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const y=_t(s.shape,a.shape,l,m,u,h,!0),g=Z().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels===1,b=d?Bd(d,g):null,v=[s,a],w=i!=null,k=o!=null,N=d==="leakyrelu";if(w&&v.push(i),k&&v.push(o),N){const O=n.makeTensorInfo([],"float32",vi(p,"float32"));v.push(O),f.push(O)}let T;g?T=new bM(y,w,b,k,N):T=new yM(y,w,b,k,N);const E=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],_=n.runWebGLProgram(T,v,"float32",E);return f.forEach(O=>n.disposeIntermediateTensorInfo(O)),_}const vle={kernelName:kd,backendName:"webgl",kernelFunc:xle};let wle=class{constructor(t,e,n,r){this.sliceDim=t,this.strides=e,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const s=Ct(n.length);let a=`
    int index;`;for(let i=0;i<this.sliceDim;i++)a+=`
          index = round(getIndices(coords[0], ${i}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};
          flattenIndex += index * ${this.strides[i]};`;this.userCode=`
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${a}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function kle(t){const{inputs:e,backend:n}=t,{params:r,indices:s}=e,a=s.shape,i=a[a.length-1],o=Q(r.shape),[l,u,c,h]=of(r,s),d=be({inputs:{x:s},backend:n,attrs:{shape:[u,i]}}),p=be({inputs:{x:r},backend:n,attrs:{shape:[Q(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const g=n.readSync(s.dataId),b=n.bufferSync(r),v=Nre(g,b,r.dtype,u,i,c,h,r.shape,o);return n.makeTensorInfo(l,r.dtype,v.values)}const f=new wle(i,h,[u,c],r.shape),m=n.runWebGLProgram(f,[p,d],p.dtype),y=be({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),y}const Sle={kernelName:Ry,backendName:"webgl",kernelFunc:kle};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let Ile=class{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const n=Ct(this.rank),r=Nle(t);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}};function Nle(t,e){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<t.length;s++)s===2?r.push("index"):r.push(`${n[s]}`);return r.join()}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function wM(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,indices:a}=e,{axis:i,batchDims:o}=r,l=Ze(i,s.shape)[0];if(Z().get("DEBUG")){const b=n.readSync(a.dataId),v=s.shape[l];for(let w=0;w<b.length;++w){const k=b[w];R(k<=v-1&&k>=0,()=>`GatherV2: the index value ${k} is not in [0, ${v-1}]`)}}const u=Jb(s,a,l,o),c=Q(a.shape),h=[],d=be({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=be({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});h.push(d),h.push(p);const f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([s,a])||s.dtype==="string"){const b=n.bufferSync(p),v=n.bufferSync(d),w=Cre(v,b,f);return h.forEach(k=>n.disposeIntermediateTensorInfo(k)),n.makeTensorInfo(u.outputShape,w.dtype,w.values)}const m=new Ile(d.shape,f),y=n.runWebGLProgram(m,[d,p],d.dtype);h.push(y);const g=be({inputs:{x:y},backend:n,attrs:{shape:u.outputShape}});return h.forEach(b=>n.disposeIntermediateTensorInfo(b)),g}const Cle={kernelName:gp,backendName:"webgl",kernelFunc:wM};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Tle="return float(a > b);",Ele=`
  return vec4(greaterThan(a, b));
`,$le=Gn({opSnippet:Tle,packedOpSnippet:Ele,cpuKernelImpl:Tre,dtype:"bool"}),Rle={kernelName:yp,backendName:"webgl",kernelFunc:$le};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Ale="return float(a >= b);",_le=`
  return vec4(greaterThanEqual(a, b));
`,Fle=Gn({opSnippet:Ale,packedOpSnippet:_le,dtype:"bool",cpuKernelImpl:Ere}),Ole={kernelName:mc,backendName:"webgl",kernelFunc:Fle};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Dle(t){const{inputs:e,backend:n}=t,{input:r}=e;return vM(r,!0,n)}const Mle={kernelName:Ay,backendName:"webgl",kernelFunc:Dle};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Ple="return float(!isnan(x) && !isinf(x));",Lle=pt({opSnippet:Ple,dtype:"bool"}),zle={kernelName:yc,backendName:"webgl",kernelFunc:Lle};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Ble="return float(isinf(x));",Wle=pt({opSnippet:Ble,dtype:"bool"}),Ule={kernelName:bc,backendName:"webgl",kernelFunc:Wle};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Vle="return float(isnan(x));",jle=pt({opSnippet:Vle,dtype:"bool"}),Gle={kernelName:xc,backendName:"webgl",kernelFunc:jle};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Hle="return float(a < b);",Kle=`
  return vec4(lessThan(a, b));
`,qle=Gn({opSnippet:Hle,packedOpSnippet:Kle,cpuKernelImpl:$re,dtype:"bool"}),Xle={kernelName:xp,backendName:"webgl",kernelFunc:qle};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Yle="return float(a <= b);",Qle=`
  return vec4(lessThanEqual(a, b));
`,Zle=Gn({opSnippet:Yle,packedOpSnippet:Qle,cpuKernelImpl:Rre,dtype:"bool"}),Jle={kernelName:vp,backendName:"webgl",kernelFunc:Zle};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function eue(t){const{backend:e,attrs:n}=t,{start:r,stop:s,num:a}=n,i=Are(r,s,a);return e.makeTensorInfo([i.length],"float32",i)}const tue={kernelName:Fy,backendName:"webgl",kernelFunc:eue};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const nue=sh+`
  return x < 0.0 ? 0./0. : log(x);
`,rue=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,sue=pt({opSnippet:nue,packedOpSnippet:rue,cpuKernelImpl:_re}),aue={kernelName:vc,backendName:"webgl",kernelFunc:sue};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const iue=sh+`
  return log(1.0 + x);
`,oue=pt({opSnippet:iue}),lue={kernelName:wc,backendName:"webgl",kernelFunc:oue};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const uue="return float(a >= 1.0 && b >= 1.0);",cue=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,hue=Gn({opSnippet:uue,packedOpSnippet:cue,dtype:"bool"}),due={kernelName:wp,backendName:"webgl",kernelFunc:hue};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const pue="return float(!(x >= 1.0));",fue=pt({opSnippet:pue}),mue={kernelName:kp,backendName:"webgl",kernelFunc:fue};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const gue="return float(a >= 1.0 || b >= 1.0);",yue=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,bue=Gn({opSnippet:gue,packedOpSnippet:yue,dtype:"bool"}),xue={kernelName:Sp,backendName:"webgl",kernelFunc:bue};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let vue=class{constructor(t,e,n,r,s){this.variableNames=["x"],this.outputShape=[];const a=e,i=t[3]-1;this.outputShape=t;let o;const l=`float(${n}) + float(${r}) * sum`;s===.5?o=`inversesqrt(${l})`:s===1?o=`1.0/(${l})`:o=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${o};
        setOutput(val);
      }
    `}};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class wue{constructor(e,n,r,s,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=n,o=e[3]-1;this.outputShape=e;let l;const u=`float(${r}) + float(${s}) * sum`;a===.5?l=`inversesqrt(${u})`:a===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const kue=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{depthRadius:a,bias:i,alpha:o,beta:l}=r,u=Z().getBool("WEBGL_PACK_NORMALIZATION")?new wue(s.shape,a,i,o,l):new vue(s.shape,a,i,o,l);return n.runWebGLProgram(u,[s],s.dtype)},Sue={kernelName:Ip,backendName:"webgl",kernelFunc:kue};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let Iue=class{constructor(t,e,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${e})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${e} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${s})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Nue=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s,y:a,dy:i}=e,{depthRadius:o,bias:l,alpha:u,beta:c}=r,h=new Iue(s.shape,o,l,u,c);return n.runWebGLProgram(h,[s,a,i],s.dtype)},Cue={kernelName:Oy,backendName:"webgl",kernelFunc:Nue};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Tue(t,e,n,r){const s=Q(e),a=Q(t.shape)/s,i=be({inputs:{x:t},attrs:{shape:[a,s]},backend:r}),o=Wl(i,t.dtype,"max",r),l=be({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function kM(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reductionIndices:a,keepDims:i}=r,o=s.shape.length,l=Ze(a,s.shape);let u=l;const c=Tt(u,o),h=c!=null,d=n.shouldExecuteOnCPU([s]);let p=s;if(h){if(d){const b=n.texData.get(p.dataId).values,v=new Array(o);for(let N=0;N<v.length;N++)v[N]=s.shape[c[N]];const w=D2(b,s.shape,s.dtype,c,v);p=n.makeTensorInfo(v,s.dtype);const k=n.texData.get(p.dataId);k.values=w}else p=g0(s,c,n);u=Ft(u.length,o)}mn("max",u,o);const[f,m]=an(p.shape,u);let y=f;i&&(y=en(f,l));let g;if(d){const b=n.texData.get(p.dataId).values,v=Fre(b,Q(m),y,s.dtype);g=n.makeTensorInfo(y,s.dtype);const w=n.texData.get(g.dataId);w.values=v}else g=Tue(p,m,y,n);return h&&n.disposeIntermediateTensorInfo(p),g}const Eue={kernelName:Np,backendName:"webgl",kernelFunc:kM};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const $ue=M2+`
  return max(a, b);
`,Rue=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Bl+`
  return result;
`,Aue=Gn({opSnippet:$ue,packedOpSnippet:Rue,cpuKernelImpl:Ore}),_ue={kernelName:kc,backendName:"webgl",kernelFunc:Aue};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Fue(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;Zc(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;R(In(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=er(s.shape,a,i,u,o,l);if(c.filterWidth===1&&c.filterHeight===1&&Je(c.inShape,c.outShape))return es({inputs:{x:s},backend:n});const h=new Wd(c,"max",!1);return n.runWebGLProgram(h,[s],s.dtype)}const Oue={kernelName:Cp,backendName:"webgl",kernelFunc:Fue};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Due(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:a,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=[1,1,1],h=vs(s.shape,a,i,c,o,u,l),d=new L2(h,"max",!1);return n.runWebGLProgram(d,[s],s.dtype)}const Mue={kernelName:Tp,backendName:"webgl",kernelFunc:Due};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let Pue=class{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideHeight,n=t.strideWidth,r=t.dilationHeight,s=t.effectiveFilterHeight,a=t.effectiveFilterWidth,i=s-1-t.padInfo.top,o=a-1-t.padInfo.left,l=s*a-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${e}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},Lue=class{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,s=t.dilationDepth,a=t.dilationHeight,i=t.dilationWidth,o=t.effectiveFilterDepth,l=t.effectiveFilterHeight,u=t.effectiveFilterWidth,c=o-1-t.padInfo.front,h=l-1-t.padInfo.top,d=u-1-t.padInfo.left,p=o*l*u-1;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${h}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${o};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${p} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zue(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:a}=e,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,h=[1,1,1],d=vs(i.shape,o,l,h,u,c),p=new L2(d,"max",!0),f=n.runWebGLProgram(p,[i],i.dtype),m=new Lue(d),y=n.runWebGLProgram(m,[s,f],i.dtype);return n.disposeIntermediateTensorInfo(f),y}const Bue={kernelName:My,backendName:"webgl",kernelFunc:zue};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Wue(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:a,output:i}=e,o=a;Zc([a,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=r,d=er(o.shape,l,u,1,c,h),p=!0,f=new Wd(d,"max",p),m=n.runWebGLProgram(f,[o],o.dtype),y=new Pue(d),g=n.runWebGLProgram(y,[s,m],o.dtype);return n.disposeIntermediateTensorInfo(m),g}const Uue={kernelName:Dy,backendName:"webgl",kernelFunc:Wue};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Vue(t,e,n,r){let s=new Wd(n,"max",!1);const a=r.runWebGLProgram(s,[t],"float32");s=new Wd(n,"max",!0,!0,e);const i=r.runWebGLProgram(s,[t],"float32");return[a,i]}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const jue={kernelName:Py,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=e,l=n;R(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const u=[1,1];R(In(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);const c=er(r.shape,s,a,u,i),[h,d]=Vue(r,o,c,l);return[h,d]}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Gue(t,e,n,r){const s=Q(e),a=Q(t.shape)/s,i=be({inputs:{x:t},attrs:{shape:[a,s]},backend:r}),o=Wl(i,"float32","mean",r),l=be({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Hue={kernelName:Ep,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{keepDims:s,axis:a}=e,i=n,o=r.shape.length,l=Ze(a,r.shape);let u=l;const c=Tt(u,o),h=c!=null,d=i.shouldExecuteOnCPU([r]),p=[];let f=r;if(h){if(d){const v=i.texData.get(f.dataId).values,w=new Array(o);for(let T=0;T<w.length;T++)w[T]=r.shape[c[T]];const k=D2(v,r.shape,r.dtype,c,w);f=i.makeTensorInfo(w,r.dtype);const N=i.texData.get(f.dataId);N.values=k}else f=g0(r,c,i);p.push(f),u=Ft(u.length,o)}mn("sum",u,o);const[m,y]=an(f.shape,u);let g=m;s&&(g=en(m,l));const b=Gue(f,y,g,i);for(const v of p)i.disposeIntermediateTensorInfo(v);return b}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Kue(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:a,keepDims:i}=r,o=s.shape.length,l=Ze(a,s.shape);let u=l;const c=Tt(u,o);let h=s;c!=null&&(h=fr({inputs:{x:s},backend:n,attrs:{perm:c}}),u=Ft(u.length,s.shape.length)),mn("min",u,o);const[d,p]=an(h.shape,u),f=Q(p),m=be({inputs:{x:h},backend:n,attrs:{shape:[-1,f]}}),y=Wl(m,m.dtype,"min",n);let g;if(i){const b=en(d,l);g=be({inputs:{x:y},backend:n,attrs:{shape:b}})}else g=be({inputs:{x:y},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),c!=null&&n.disposeIntermediateTensorInfo(h),g}const que={kernelName:$p,backendName:"webgl",kernelFunc:Kue};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Xue=M2+`
  return min(a, b);
`,Yue=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Bl+`
  return result;
`,Que=Gn({opSnippet:Xue,packedOpSnippet:Yue,cpuKernelImpl:Dre}),Zue={kernelName:Sc,backendName:"webgl",kernelFunc:Que};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let Jue=class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map((u,c)=>u[0]+t[c]+u[1]);const r=t.length,s=Ct(r),a=e.map(u=>u[0]).join(","),i=e.map((u,c)=>u[0]+t[c]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l=n==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${i});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${o}));
      }
    `}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class ece{constructor(e,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.map((f,m)=>f[0]+e[m]+f[1]);const s=e.length,a=Ct(s),i=n.map(f=>f[0]).join(","),o=n.map((f,m)=>f[0]+e[m]).join(","),l=cr("rc",s),u=cr("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,h=s===1?"source":`vec2(${u.slice(-2).join()})`,d=r==="reflect"?0:1;let p="";if(s===1){const f=`
        ${a} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;p=`
        ${a} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${u.join()}), ${h});
        ${l[s-1]} += 1;
        if(${c}) {
          ${f}
          result[1] = getChannel(getX(${u.join()}), ${h});
        }
      `}else{const f=`
        ${a} source = rc;
        ${a} lt = ${a}(lessThan(source, start));
        ${a} gte = ${a}(greaterThanEqual(source, end));
        ${a} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;p=`
        ${a} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${u.join()}), ${h});
        ${l[s-1]} += 1;
        if(${c}) {
          ${f}
          result[1] = getChannel(getX(${u.join()}), ${h});
        }
        rc = outputLoc;
        ${l[s-2]} += 1;
        if(${l[s-2]} < ${this.outputShape[s-2]}) {
          ${f}
          result[2] = getChannel(getX(${u.join()}), ${h});
          ${l[s-1]} += 1;
          if(${c}) {
            ${f}
            result[3] = getChannel(getX(${u.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${a} start = ${a}(${i});
      const ${a} end = ${a}(${o});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const tce=({inputs:t,backend:e,attrs:n})=>{const{x:r}=t,{paddings:s,mode:a}=n,i=Z().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ece(r.shape,s,a):new Jue(r.shape,s,a);return e.runWebGLProgram(i,[r],r.dtype)},nce={kernelName:Rp,backendName:"webgl",kernelFunc:tce};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const rce=`if (b == 0.0) return NAN;
  return mod(a, b);`,sce=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Bl+`
  return result;
`,ace=Gn({opSnippet:rce,packedOpSnippet:sce}),ice={kernelName:Ic,backendName:"webgl",kernelFunc:ace};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let oce=class{constructor(t,e,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${e-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${e-1}));
      }
    `}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const lce=`
if (a == b) {
  return 1.0;
};
return a / b;`,uce=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,SM=Gn({opSnippet:lce,packedOpSnippet:uce,checkOutOfBounds:!0}),cce={kernelName:lc,backendName:"webgl",kernelFunc:SM};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const xC="return a - b;",IM=Gn({opSnippet:xC,packedOpSnippet:xC,supportsComplex:!0,cpuKernelImpl:nse}),hce={kernelName:Bc,backendName:"webgl",kernelFunc:IM};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function NM(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{dim:a}=r,i=Ze([a],s.shape),o=kM({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=en(o.shape,i),u=be({inputs:{x:o},backend:n,attrs:{shape:l}}),c=IM({inputs:{a:s,b:u},backend:n}),h=xM({inputs:{x:c},backend:n}),d=y0({inputs:{x:h},backend:n,attrs:{axis:i,keepDims:!1}}),p=be({inputs:{x:d},backend:n,attrs:{shape:l}}),f=SM({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}const dce={kernelName:qp,backendName:"webgl",kernelFunc:NM};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function pce(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{numSamples:a,seed:i,normalized:o}=r,l=o?s:NM({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),u=l.shape[0],c=l.shape[1],h=new oce(u,c,a),d=[[i]],p=n.runWebGLProgram(h,[l],"int32",d);return o||n.disposeIntermediateTensorInfo(l),p}const fce={kernelName:Ly,backendName:"webgl",kernelFunc:pce};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const mce=Ks+`
  return -x;
`,gce=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function yce(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])){const a=n.texData.get(r.dataId),[i,o]=Pre(a.values,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,i)}let s;return Z().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Pi(r.shape,gce):s=new Ma(r.shape,mce),n.runWebGLProgram(s,[r],r.dtype)}const bce={kernelName:Ap,backendName:"webgl",kernelFunc:yce};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const xce=Rb;function vce(t){is("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:a}=e,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),{selectedIndices:h}=xce(u,c,i,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}const wce={kernelName:zy,backendName:"webgl",kernelFunc:vce};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const kce=Fk;function Sce(t){is("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:a}=e,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(s.dataId),h=n.readSync(a.dataId),{selectedIndices:d,validOutputs:p}=kce(c,h,i,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}const Ice={kernelName:Dw,backendName:"webgl",kernelFunc:Sce};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Nce=Ab;function Cce(t){is("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:a}=e,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(s.dataId),h=n.readSync(a.dataId),d=i,p=o,f=l,m=u,{selectedIndices:y,selectedScores:g}=Nce(c,h,d,p,f,m);return[n.makeTensorInfo([y.length],"int32",new Int32Array(y)),n.makeTensorInfo([g.length],"float32",new Float32Array(g))]}const Tce={kernelName:By,backendName:"webgl",kernelFunc:Cce};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let Ece=class{constructor(t,e,n,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${n}),
                      float(index == coords.y)));
      }
    `}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const $ce=t=>{const{inputs:e,backend:n,attrs:r}=t,{indices:s}=e,{dtype:a,depth:i,onValue:o,offValue:l}=r,u=Q(s.shape),c=new Ece(u,i,o,l),h=be({inputs:{x:s},backend:n,attrs:{shape:[u]}}),d=n.runWebGLProgram(c,[h],a);n.disposeIntermediateTensorInfo(h);const p=[...s.shape,i],f=be({inputs:{x:d},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(d),f},Rce={kernelName:Op,backendName:"webgl",kernelFunc:$ce};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Og(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="complex64"){const s=kf({inputs:{input:r},backend:n}),a=Og({inputs:{x:s},backend:n}),i=b0({inputs:{input:r},backend:n}),o=Og({inputs:{x:i},backend:n}),l=Io({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return Sf({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}const Ace={kernelName:Qp,backendName:"webgl",kernelFunc:Og};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function CM(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const s=kf({inputs:{input:r},backend:n}),a=CM({inputs:{x:s},backend:n}),i=b0({inputs:{input:r},backend:n}),o=Og({inputs:{x:i},backend:n}),l=Io({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return Sf({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}const _ce={kernelName:Fp,backendName:"webgl",kernelFunc:CM};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Fce(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r;if(e.length===1)return Tv({inputs:{input:e[0]},backend:n,attrs:{dim:s}});const a=e[0].shape,i=e[0].dtype;e.forEach(c=>{Dn(a,c.shape,"All tensors passed to stack must have matching shapes"),R(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=e.map(c=>{const h=Tv({inputs:{input:c},backend:n,attrs:{dim:s}});return o.push(h),h}),u=hM({inputs:l,backend:n,attrs:{axis:s}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}const Oce={kernelName:Dp,backendName:"webgl",kernelFunc:Fce};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let Dce=class{constructor(t,e,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((l,u)=>l[0]+t[u]+l[1]);const r=t.length,s=Ct(r),a=e.map(l=>l[0]).join(","),i=e.map((l,u)=>l[0]+t[u]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${i});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${o}));
        }
      }
    `}};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Mce{constructor(e,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((m,y)=>m[0]+e[y]+m[1]);const s=e.length,a=Ct(s),i=n.map(m=>m[0]).join(","),o=n.map((m,y)=>m[0]+e[y]).join(","),l=cr("rc",s),u=cr("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,h=s===1?"source":`vec2(${u.slice(-2).join()})`,d=[`${a} rc = outputLoc;`,`${l[s-1]} += 1;
       if(${c}) {
      `,s===1?"":`}
       rc = outputLoc;
       ${l[s-2]} += 1;
       if(${l[s-2]} < ${this.outputShape[s-2]}) {`,s===1?"":`  ${l[s-1]} += 1;
         if(${c}) {`],p=s===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let m=0,y=s===1?2:4;m<y;m++)f+=`
        ${d[m]}
        if (${p}) {
          result[${m}] = float(value);
        } else {
          ${a} source = rc - start;
          result[${m}] = getChannel(getX(${u.join()}), ${h});
        }
      `;f+=s===1?"} ":"}}",this.userCode=`
      const ${a} start = ${a}(${i});
      const ${a} end = ${a}(${o});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const TM=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{paddings:a,constantValue:i}=r;if(Q(s.shape)===0){const u=a.map((c,h)=>c[0]+s.shape[h]+c[1]);return Sf({backend:n,attrs:{shape:u,value:i,dtype:s.dtype}})}const o=Z().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Mce(s.shape,a,i):new Dce(s.shape,a,i),l=[[i]];return n.runWebGLProgram(o,[s],s.dtype,l)},Pce={kernelName:Mp,backendName:"webgl",kernelFunc:TM};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Lce=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,zce=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Bl+`
  return result;
`,Bce=Gn({opSnippet:Lce,packedOpSnippet:zce}),Wce={kernelName:Cc,backendName:"webgl",kernelFunc:Bce};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Uce(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:a,keepDims:i}=r,o=s.shape.length,l=[],u=Ze(a,s.shape);let c=u;const h=Tt(c,o);let d=s;h!=null&&(d=fr({inputs:{x:s},backend:n,attrs:{perm:h}}),c=Ft(c.length,o),l.push(d)),mn("prod",c,o);let p;if(n.shouldExecuteOnCPU([d])){const f=n.texData.get(d.dataId).values,{outVals:m,outShape:y,outDtype:g}=zre(d.shape,d.dtype,f,c);p=n.makeTensorInfo(y,g,m)}else{const[f,m]=an(d.shape,c),y=Q(m),g=be({inputs:{x:d},backend:n,attrs:{shape:[-1,y]}}),b=ab(s.dtype),v=Wl(g,b,"prod",n);p=be({inputs:{x:v},backend:n,attrs:{shape:f}}),l.push(g),l.push(v)}if(i){l.push(p);const f=en(p.shape,u);p=be({inputs:{x:p},backend:n,attrs:{shape:f}})}return l.forEach(f=>n.disposeIntermediateTensorInfo(f)),p}const Vce={kernelName:Lp,backendName:"webgl",kernelFunc:Uce};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function jce(t){const{inputs:e,backend:n,attrs:r}=t,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=e,{outputRaggedRank:o}=r,l=s.map(g=>n.readSync(g.dataId)),u=s.map(g=>g.shape),c=n.readSync(a.dataId),h=n.readSync(i.dataId),[d,p,f]=Bre(l,u,c,a.shape,a.dtype,h,i.shape,o),m=d.map(g=>n.makeTensorInfo([g.length],"int32",g)),y=n.makeTensorInfo(f,a.dtype,p);return m.concat([y])}const Gce={kernelName:Mw,backendName:"webgl",kernelFunc:jce};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Hce(t){const{inputs:e,backend:n}=t,{starts:r,limits:s,deltas:a}=e,i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=Wre(i,r.shape,r.dtype,o,s.shape,l,a.shape),h=n.makeTensorInfo([u.length],"int32",u),d=n.makeTensorInfo([c.length],r.dtype,c);return[h,d]}const Kce={kernelName:Pw,backendName:"webgl",kernelFunc:Hce};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function qce(t){const{inputs:e,backend:n,attrs:r}=t,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=e,{rowPartitionTypes:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),h=n.readSync(i.dataId),d=o.map(y=>n.readSync(y.dataId)),p=o.map(y=>y.shape),[f,m]=Ure(u,s.shape,c,a.shape,a.dtype,h,i.shape,d,p,l);return n.makeTensorInfo(f,a.dtype,m)}const Xce={kernelName:Lw,backendName:"webgl",kernelFunc:qce};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const EM=t=>{const{backend:e,attrs:n}=t,{start:r,stop:s,step:a,dtype:i}=n,o=Vre(r,s,a,i);return e.makeTensorInfo([o.length],i,o)},Yce={kernelName:Wy,backendName:"webgl",kernelFunc:EM};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Qce="return 1.0 / x;",Zce=pt({opSnippet:Qce}),Jce={kernelName:Tc,backendName:"webgl",kernelFunc:Zce};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ehe=Ks+`
  return (x < 0.0) ? 0.0 : x;
`,the=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,nhe=pt({opSnippet:ehe,packedOpSnippet:the}),rhe={kernelName:Ec,backendName:"webgl",kernelFunc:nhe};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const she=Ks+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,ahe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ihe=pt({opSnippet:she,packedOpSnippet:ahe}),ohe={kernelName:$c,backendName:"webgl",kernelFunc:ihe};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let lhe=class{constructor(t,e,n,r,s){this.variableNames=["A"],this.outputShape=[];const[a,i,o,l]=t;this.outputShape=[a,e,n,l];const u=[r&&e>1?i-1:i,r&&n>1?o-1:o],c=[r&&e>1?e-1:e,r&&n>1?n-1:n];let h;s?h="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":h="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/c[0]},
          ${u[1]/c[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class uhe{constructor(e,n,r,s,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,o,l,u]=e;this.outputShape=[i,n,r,u];const c=[s&&n>1?o-1:o,s&&r>1?l-1:l],h=[s&&n>1?n-1:n,s&&r>1?r-1:r];let d;a?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/h[0]},
          ${c[1]/h[1]},
          ${c[1]/h[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function che(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=Z().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new uhe(s.shape,l,u,a,i):new lhe(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],"float32")}const hhe={kernelName:Wp,backendName:"webgl",kernelFunc:che};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let dhe=class{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,s]=e,[,a,i]=t,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],h=1/u,d=1/c,p=Math.ceil(h)*2+2,f=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${c});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${d});

        const int winHeight = int(${p});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function phe(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:a}=e,{alignCorners:i}=r,o=new dhe(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}const fhe={kernelName:jy,backendName:"webgl",kernelFunc:phe};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let mhe=class{constructor(t,e,n,r,s){this.variableNames=["A"],this.outputShape=[];const[a,i,o,l]=t;this.outputShape=[a,e,n,l];const u=[r&&e>1?i-1:i,r&&n>1?o-1:o],c=[r&&e>1?e-1:e,r&&n>1?n-1:n],h=r?"0.5":"0.0";let d;s?d="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/c[0]},
          ${u[1]/c[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class ghe{constructor(e,n,r,s,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,o,l,u]=e;this.outputShape=[i,n,r,u];const c=[s&&n>1?o-1:o,s&&r>1?l-1:l],h=[s&&n>1?n-1:n,s&&r>1?r-1:r],d=s?"0.5":"0.0";let p;a?p="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/h[0]},
          ${c[1]/h[1]},
          ${c[1]/h[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function yhe(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=Z().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ghe(s.shape,l,u,a,i):new mhe(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],s.dtype)}const bhe={kernelName:Bp,backendName:"webgl",kernelFunc:yhe};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let xhe=class{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,s]=e,[,a,i]=t,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],h=1/u,d=1/c,p=Math.ceil(h)*2+2,f=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${c});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${d});

        const int winHeight = int(${p});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${o[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${o[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function vhe(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:a}=e,{alignCorners:i}=r,o=new xhe(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}const whe={kernelName:Vy,backendName:"webgl",kernelFunc:vhe};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let khe=class{constructor(t,e){this.variableNames=["x"];const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=t,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}const r=i=>e.indexOf(i)!==-1&&t[i]!==1?`${t[i]} - coords[${i}] - 1`:`coords[${i}]`,s=t.map((i,o)=>r(o)).join(","),a=Ct(n);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class She{constructor(e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=e;const s=cr("rc",r),a=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,i=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,o=Ct(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${a}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(s.slice())};
          if(${a}){
            result.g = ${u(s.slice())};
          }
          if(${i}) {
            result.b = ${c(s.slice())};
            if(${a}) {
              result.a = ${h(s.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(f){return d(f)}function u(f){return f[r-1]="("+f[r-1]+" + 1)",d(f)}function c(f){return f[r-2]="("+f[r-2]+" + 1)",d(f)}function h(f){return f[r-1]="("+f[r-1]+" + 1)",f[r-2]="("+f[r-2]+" + 1)",d(f)}function d(f){const m=e.map((b,v)=>p(v,f)),y=m.join(","),g=m.slice(-2).join(",");return`getChannel(getX(${y}), vec2(${g}))`}function p(f,m){return n.indexOf(f)!==-1&&e[f]!==1?`${e[f]} - ${m[f]} - 1`:`${m[f]}`}}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ihe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dims:a}=r,i=s.shape.length,o=Ze(a,s.shape);if(i===0)return es({inputs:{x:s},backend:n});const l=Z().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new She(s.shape,o):new khe(s.shape,o);return n.runWebGLProgram(l,[s],s.dtype)}const Nhe={kernelName:Up,backendName:"webgl",kernelFunc:Ihe};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let Che=class{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=t[1],r=t[2];this.outputShape=t;let s="";typeof e=="number"?s=`float outputValue = ${e.toFixed(2)};`:s=`
        vec3 fill = vec3(${e.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const The={kernelName:rb,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:s,fillValue:a,center:i}=e,o=n,l=new Che(r.shape,a),[u,c]=Lb(i,r.shape[1],r.shape[2]),h=[[u,c,Math.sin(s),Math.cos(s)]];return o.runWebGLProgram(l,[r],r.dtype,h)}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Ehe=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,$he=pt({opSnippet:Ehe}),Rhe={kernelName:Rc,backendName:"webgl",kernelFunc:$he};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Ahe="return inversesqrt(x);",_he=pt({opSnippet:Ahe,cpuKernelImpl:jre}),Fhe={kernelName:Ac,backendName:"webgl",kernelFunc:_he};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let z2=class{constructor(t,e,n,r,s,a,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const l=Ct(s.length),u=Ct(a.length);let c="";n===1?c="i":n===2&&(c="i, j");const h=`getIndices(${c})`;let d="";r===1?d="i":r===2&&(d="i, coords[1]");const p=`getUpdates(${d})`;let f="";o&&(f="coords[0], coords[1]");const m=`getDefaultValue(${f})`,y=e>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${s});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${e}; j++) {
              int index = round(${h});
              flattenedIndex += index * ${y};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${p};
              found = true;
            }
          }
          setOutput(mix(${m}, sum, float(found)));
        }
      `}};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Ohe{constructor(e,n,r,s,a,i,o=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;const u=Ct(a.length),c=Ct(i.length);let h="";r===1?h="i":r===2&&(h="i, j");const d=`getIndices(${h})`;let p="";s===1?p="i":s===2&&(p="i, coords[1]");const f=`getUpdates(${p})`;let m="";l&&(m="coords[0], coords[1]");const y=`getDefaultValue(${m})`,g=n>1?"strides[j]":"strides",b=n>1?"strides[j + 1]":"strides";this.userCode=`
        ${u} strides = ${u}(${a});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${n}; j+=2) {
              ivec4 index = round(${d});
              flattenedIndex += index.xz * ${g};
              if (j + 1 < ${n}) {
                flattenedIndex += index.yw * ${b};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${f};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${y}, sum, found));
        }
      `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Dhe(t){const{inputs:e,backend:n,attrs:r}=t,{indices:s,updates:a}=e,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=ka(a,s,i),d=[h/u,u];if(h===0)return n.makeTensorInfo(i,s.dtype);const p=be({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=be({inputs:{x:a},backend:n,attrs:{shape:[l,u]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0]));let y;Z().getBool("WEBGL_PACK")?y=new Ohe(l,o,p.shape.length,f.shape.length,c,d):y=new z2(l,o,p.shape.length,f.shape.length,c,d);const g=n.runWebGLProgram(y,[f,p,m],f.dtype),b=be({inputs:{x:g},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(m),b}const Mhe={kernelName:Gy,backendName:"webgl",kernelFunc:Dhe};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let Phe=class{constructor(t,e,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,n];const s="while (left < right) {",a=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,i=Z().getNumber("WEBGL_VERSION")===2?s:a,o=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${i}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${o} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Lhe(t){const{inputs:e,backend:n,attrs:r}=t,{sortedSequence:s,values:a}=e,{side:i}=r,o=new Phe(s.shape[0],s.shape[1],a.shape[1],i),l=[[s.shape[1]]];return n.runWebGLProgram(o,[s,a],"int32",l)}const zhe={kernelName:Ky,backendName:"webgl",kernelFunc:Lhe};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let Bhe=class{constructor(t,e,n){this.variableNames=["c","a","b"],this.outputShape=e;let r,s;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)s="resRC",r="resRC";else{const i=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],l=[];for(let u=0;u<e.length;u++)l.push(`${i[u]}`),u<t&&o.push(`${i[u]}`);r=o.join(),s=l.join()}const a=Ct(n);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Whe(t){const{inputs:e,backend:n}=t,{condition:r,t:s,e:a}=e,i=new Bhe(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[r,s,a],On(s.dtype,a.dtype))}const Uhe={kernelName:Vp,backendName:"webgl",kernelFunc:Whe};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Vhe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${uf};
  float scale = ${cf};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,jhe=pt({opSnippet:Vhe}),Ghe={kernelName:_c,backendName:"webgl",kernelFunc:jhe};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Hhe=sh+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Khe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,qhe=pt({opSnippet:Hhe,packedOpSnippet:Khe,cpuKernelImpl:Hre}),Xhe={kernelName:Mc,backendName:"webgl",kernelFunc:qhe};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Yhe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Qhe=pt({opSnippet:Yhe}),Zhe={kernelName:Dc,backendName:"webgl",kernelFunc:Qhe};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Jhe=sh+`
  return sin(x);
`,ede=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Bl}
  return result;
`,tde=pt({opSnippet:Jhe,packedOpSnippet:ede}),nde={kernelName:Fc,backendName:"webgl",kernelFunc:tde};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const rde=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,sde=pt({opSnippet:rde}),ade={kernelName:Oc,backendName:"webgl",kernelFunc:sde};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ide=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,ode=pt({opSnippet:ide}),lde={kernelName:Pc,backendName:"webgl",kernelFunc:ode};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ude=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:a,paddings:i}=r;R(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce((g,b)=>g*b),l=[[0,0]];l.push(...i);for(let g=1+a.length;g<s.shape.length;++g)l.push([0,0]);const u=[],c=TM({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),h=Fl(c.shape,a,o,!1),d=Ol(h.length,a.length,!1),p=Dl(c.shape,a,o,!1),f=be({inputs:{x:c},backend:n,attrs:{shape:h}}),m=fr({inputs:{x:f},backend:n,attrs:{perm:d}}),y=be({inputs:{x:m},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach(g=>n.disposeIntermediateTensorInfo(g)),y},cde={kernelName:Hp,backendName:"webgl",kernelFunc:ude};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function hde(t){const{inputs:e,backend:n}=t,{indices:r,values:s,denseShape:a,defaultValue:i}=e;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${a.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const o=n.readSync(r.dataId),l=n.readSync(s.dataId),u=n.readSync(a.dataId),c=n.readSync(i.dataId)[0],[h,d,p,f,m]=qre(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(y=>Number(y)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}const dde={kernelName:zw,backendName:"webgl",kernelFunc:hde};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function pde(t){const{inputs:e,backend:n}=t,{inputIndices:r,inputShape:s,newShape:a}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.readSync(s.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(a.dataId)),[u,c,h]=Xre(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([h.length],a.dtype,new Int32Array(h))]}const fde={kernelName:Bw,backendName:"webgl",kernelFunc:pde};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function mde(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:a}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=ZD(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}const gde={kernelName:qy,backendName:"webgl",kernelFunc:mde};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function yde(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:a}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=ZD(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}const bde={kernelName:Xy,backendName:"webgl",kernelFunc:yde};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function xde(t){const{inputs:e,backend:n,attrs:r}=t,{sparseIndices:s,sparseValues:a,defaultValue:i}=e,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=ka(a,s,o),p=!1;if(a.dtype==="string"){const g=n.bufferSync(s),b=n.bufferSync(a),v=Vs(n.readSync(i.dataId)[0]),w=Gre(g,b,o,d,c,u,l,h,v,p);return n.makeTensorInfo(o,w.dtype,w.values)}const f=new z2(u,l,s.shape.length,a.shape.length,h,[d,1],p),m=n.runWebGLProgram(f,[a,s,i],a.dtype),y=be({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),y}const vde={kernelName:Yy,backendName:"webgl",kernelFunc:xde};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function wde(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{numOrSizeSplits:a,axis:i}=r,o=Ze(i,s.shape)[0],l=Zb(s,a,o),u=s.shape.length,c=new Array(u).fill(0),h=s.shape.slice();return l.map(d=>{const p=[...h];p[o]=d;const f=ah({inputs:{x:s},backend:n,attrs:{begin:c,size:p}});return c[o]+=d,f})}const kde={kernelName:Kp,backendName:"webgl",kernelFunc:wde};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const vC="return sqrt(x);",Sde=pt({opSnippet:vC,packedOpSnippet:vC,cpuKernelImpl:Yre}),Ide={kernelName:Lc,backendName:"webgl",kernelFunc:Sde};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Nde="return x * x;",Cde=pt({opSnippet:Nde}),Tde={kernelName:Qy,backendName:"webgl",kernelFunc:Cde};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const wC="return (a - b) * (a - b);",Ede=Gn({opSnippet:wC,packedOpSnippet:wC}),$de={kernelName:zc,backendName:"webgl",kernelFunc:Ede};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Rde(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");const a=n.readSync(s.dataId),i=ma(a),o=Qre(i,"string",r);return n.makeTensorInfo(s.shape,"string",o)}const Ade={kernelName:Zy,backendName:"webgl",kernelFunc:Rde};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _de({inputs:t,attrs:e,backend:n}){const{x:r}=t,s=Ks+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,a=new Ma(r.shape,s);return n.runWebGLProgram(a,[r],r.dtype)}const Fde={kernelName:jc,backendName:"webgl",kernelFunc:_de};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let Ode=class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,s=Ct(n.length),a=Ct(n.length);let i="";if(r===1)i="coords * strides + begin";else{let o=0;i=n.map((l,u)=>(o++,n.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${o-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${t});
      ${s} strides = ${s}(${e});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Dde(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:y,isSimpleSlice:g,begin:b,end:v,strides:w}=Db(s.shape,a,i,o,l,u,c,h,d);let k;if(m)k=be({inputs:{x:s},backend:n,attrs:{shape:f}});else if(y||g){R(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const T=Ob(b,v,w),E=ah({inputs:{x:s},backend:n,attrs:{begin:b,size:T}});k=be({inputs:{x:E},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(E)}else if(n.shouldExecuteOnCPU([s])){const T=n.readSync(s.dataId),E=Qe(s.shape,s.dtype,T),_=Zre(p,E,w,b);k=n.makeTensorInfo(f,s.dtype,_.values)}else{const T=new Ode(b,w,p);k=n.runWebGLProgram(T,[s],s.dtype)}const N=be({inputs:{x:k},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(k),N}const Mde={kernelName:Jy,backendName:"webgl",kernelFunc:Dde};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Pde(t){const{inputs:e,backend:n,attrs:r}=t,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:h}=e,d=n.readSync(c.dataId),p=n.readSync(h.dataId),[f,m]=Jre(d,p,s,a,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}const Lde={kernelName:eb,backendName:"webgl",kernelFunc:Pde};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zde(t){const{inputs:e,backend:n,attrs:r}=t,{skipEmpty:s}=r,{input:a,delimiter:i}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.readSync(a.dataId),l=n.readSync(i.dataId)[0],[u,c,h]=ese(o,l,s),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}const Bde={kernelName:Ww,backendName:"webgl",kernelFunc:zde};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Wde(t){const{inputs:e,backend:n,attrs:r}=t,{numBuckets:s}=r,{input:a}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(a.dataId),o=tse(i,s);return n.makeTensorInfo(a.shape,"int32",o)}const Ude={kernelName:Uw,backendName:"webgl",kernelFunc:Wde};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Vde="return tan(x);",jde=pt({opSnippet:Vde}),Gde={kernelName:Wc,backendName:"webgl",kernelFunc:jde};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Hde=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,Kde=pt({opSnippet:Hde}),qde={kernelName:Uc,backendName:"webgl",kernelFunc:Kde};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Xde(t){const{inputs:e,backend:n,attrs:r}=t,{tensor:s,indices:a,updates:i}=e,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=ka(i,a,s.shape),d=[h/u,u];if(h===0)return n.makeTensorInfo(s.shape,a.dtype);const p=be({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),f=be({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),m=be({inputs:{x:s},backend:n,attrs:{shape:d}}),y=new z2(l,o,p.shape.length,f.shape.length,c,d,!1,!0),g=n.runWebGLProgram(y,[f,p,m],m.dtype),b=be({inputs:{x:g},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),b}const Yde={kernelName:Hy,backendName:"webgl",kernelFunc:Xde};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let Qde=class{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let a=0;a<n.length;a++)n[a]=t[a]*e[a];this.outputShape=n,this.rank=n.length;const r=Ct(this.rank),s=Zde(t);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function Zde(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<t.length;s++)r.push(`imod(${n[s]}, ${t[s]})`);return r.join()}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function $M(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reps:a}=r;if(s.dtype==="string"||s.shape.length>5){const o=n.readSync(s.dataId),l=s.dtype==="string"?o.map(h=>Vs(h)):o,u=Qe(s.shape,s.dtype,l),c=rse(u,a);return n.makeTensorInfo(c.shape,c.dtype,c.values)}const i=new Qde(s.shape,a);return n.runWebGLProgram(i,[s],s.dtype)}const Jde={kernelName:Vc,backendName:"webgl",kernelFunc:$M};let epe=class{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},tpe=class{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ao(t,e){e!==null&&t.disposeIntermediateTensorInfo(e)}function kC(t){let e=1;for(;e<t;)e*=2;return e}function npe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{k:a,sorted:i}=r,o=Z().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Z().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=s.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([s])||c<o||a>l){const _=n.readSync(s.dataId),[O,M]=sse(_,u,s.dtype,a,i);return[n.makeTensorInfo(O.shape,O.dtype,O.values),n.makeTensorInfo(M.shape,M.dtype,M.values)]}if(a===0)return u[u.length-1]=0,[n.makeTensorInfo(u,s.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(c===1)return[s,Sf({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const h=n.texData.get(s.dataId),d=h!==null&&h.isPacked,p=d?n.unpackTensor(s):s,f=Q(u)/c,m=be({inputs:{x:p},attrs:{shape:[f,c]},backend:n});d&&Ao(n,p);const y=kC(a),g=kC(c);let b=null;const v=()=>b===null?[m,m]:[m,b],w=(_,O,M)=>{const V=v(),W=new epe(M),K=[[c],[b===null?1:0],[Number.NEGATIVE_INFINITY],[_],[O]],q=b;b=n.runWebGLProgram(W,V,"int32",K),Ao(n,q)};for(let _=1;_<y;_*=2){const O=_*2;for(let M=_;M>=1;M/=2)w(O,M,[f,g])}for(let _=g;_>y;_/=2){const O=v(),M=new tpe([f,_/2]),V=[[c],[b===null?1:0],[y]],W=b;b=n.runWebGLProgram(M,O,"int32",V),Ao(n,W);const K=y/2,q=K*2;for(let ee=K;ee>=1;ee/=2)w(q,ee,b.shape)}let k=b;b=ah({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,a]}}),Ao(n,k);let N=wM({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});Ao(n,m);const T=u.slice(0,-1);T.push(a),k=b,b=be({inputs:{x:b},attrs:{shape:T},backend:n}),Ao(n,k);const E=N;return N=be({inputs:{x:N},attrs:{shape:T},backend:n}),Ao(n,E),[N,b]}const rpe={kernelName:tb,backendName:"webgl",kernelFunc:npe};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let spe=class{constructor(t,e,n,r,s,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const i=n==="nearest"?1:2;let o;switch(r){case"constant":o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4;break;default:o=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${o} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${e}));
                float mapY = mapCoord(inY, float(${t}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ape(t){const{inputs:e,backend:n,attrs:r}=t,{image:s,transforms:a}=e,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[c,h,d,p]=s.shape,[f,m]=u??[h,d],y=[c,f,m,p],g=new spe(h,d,i,o,l,y);return n.runWebGLProgram(g,[s,a],"float32")}const ipe={kernelName:nb,backendName:"webgl",kernelFunc:ape};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ope(t){const{inputs:e,attrs:n,backend:r}=t,{axis:s}=n,{x:a}=e;Zc(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(a.dataId),{outputValues:o,outputShape:l,indices:u}=ase(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}const lpe={kernelName:Vw,backendName:"webgl",kernelFunc:ope};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function upe(t){const{inputs:e,backend:n,attrs:r}=t,{value:s}=e;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s,o=i.shape.length,l=s.shape[a],u=new Array(o-1);let c=0;for(let m=0;m<o;m++)m!==a&&(u[c++]=i.shape[m]);const h=[],d=new Array(o).fill(0),p=i.shape.slice();p[a]=1;const f=new Array(l);for(let m=0;m<f.length;m++){d[a]=m;const y=ah({inputs:{x:i},backend:n,attrs:{begin:d,size:p}}),g=be({inputs:{x:y},backend:n,attrs:{shape:u}});f[m]=g,h.push(y)}return h.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}const cpe={kernelName:Xp,backendName:"webgl",kernelFunc:upe};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class hpe{constructor(e,n){this.variableNames=["x","segmentIds"];const r=e.windowSize,s=e.batchSize,a=e.inSize,i=e.numSegments,o=i*Math.ceil(a/r);this.outputShape=[s,o];const l="0.0",u="sumValue",c=Math.floor(r/4)*4,h=r%4,d=`
        sumValue += dot(values, segFilter);
    `;let p="";a%r>0&&(p=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `);let f="";a%r>0&&(f=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${h===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${u});
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function dpe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,segmentIds:a}=e,{numSegments:i}=r,o=s.shape.length,l=[];let u=0;const c=Tt([u],o);let h=s;c!=null&&(h=fr({inputs:{x:s},backend:n,attrs:{perm:c}}),l.push(h),u=Ft(1,o)[0]);const d=Vk(h.shape,u,i),p=Q([h.shape[u]]),f=be({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});l.push(f);const m=ab(s.dtype),y=(w,k,N,T,E)=>{const _=w.shape[0],O=w.shape[1],M=bA(O,E),V={windowSize:M,inSize:O,batchSize:_,numSegments:E},W=new hpe(V,k),K=n.compileAndRun(W,[w,N],T);if(l.push(K),K.shape[1]===E)return K;const q=EM({backend:n,attrs:{start:0,stop:E,step:1,dtype:"float32"}}),ee=$M({inputs:{x:q},backend:n,attrs:{reps:[O/M]}});return l.push(q),l.push(ee),y(K,k,ee,T,E)},g=y(f,"unsortedSegmentSum",a,m,i),b=be({inputs:{x:g},backend:n,attrs:{shape:d}});let v=b;if(c!=null){l.push(b);const w=Ha(c);v=fr({inputs:{x:v},backend:n,attrs:{perm:w}})}return l.forEach(w=>n.disposeIntermediateTensorInfo(w)),v}const ppe={kernelName:Yp,backendName:"webgl",kernelFunc:dpe};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const fpe=[Qse,Jse,nae,aae,oae,cae,dae,fae,bae,vae,Sae,Cae,$ae,Fae,Mae,Lae,Bae,jae,Hae,qae,Zae,aie,oie,hie,pie,xie,wie,Nie,Ose,Eie,Fie,Pie,Vie,Hie,qie,Yie,Zie,noe,aoe,loe,coe,doe,foe,yoe,xoe,Soe,Noe,Eoe,Aoe,Foe,Poe,Woe,Goe,qoe,Qoe,Zoe,ele,nle,sle,ile,lle,dle,mle,ble,vle,Sle,Cle,Rle,Ole,Fse,Mle,Aie,zle,Ule,Gle,Mse,Xle,Jle,tue,aue,lue,due,mue,xue,Sue,Cue,Eue,_ue,Oue,Mue,Bue,Uue,jue,Hue,que,Zue,nce,ice,fce,zse,bce,wce,Ice,Tce,mie,Rce,_ce,Oce,Pce,Wce,Lse,Vce,Gce,Kce,Xce,Yce,gie,cce,Jce,rhe,ohe,Wse,hhe,fhe,bhe,whe,Nhe,The,Rhe,Fhe,Mhe,zhe,Uhe,Ghe,Xhe,Zhe,nde,ade,rie,dce,lde,cde,dde,fde,gde,bde,vde,kde,Ide,Tde,$de,Ade,Fde,Mde,Lde,Bde,Ude,hce,qse,Gde,qde,Yde,Jde,rpe,ipe,Xse,lpe,cpe,ppe,Ace];for(const t of fpe)sb(t);var mpe={};(function(){var t;function e(x){var S=0;return function(){return S<x.length?{done:!1,value:x[S++]}:{done:!0}}}var n=typeof Object.defineProperties=="function"?Object.defineProperty:function(x,S,C){return x==Array.prototype||x==Object.prototype||(x[S]=C.value),x};function r(x){x=[typeof globalThis=="object"&&globalThis,x,typeof window=="object"&&window,typeof self=="object"&&self,typeof aa=="object"&&aa];for(var S=0;S<x.length;++S){var C=x[S];if(C&&C.Math==Math)return C}throw Error("Cannot find global object")}var s=r(this);function a(x,S){if(S)e:{var C=s;x=x.split(".");for(var A=0;A<x.length-1;A++){var D=x[A];if(!(D in C))break e;C=C[D]}x=x[x.length-1],A=C[x],S=S(A),S!=A&&S!=null&&n(C,x,{configurable:!0,writable:!0,value:S})}}a("Symbol",function(x){function S(L){if(this instanceof S)throw new TypeError("Symbol is not a constructor");return new C(A+(L||"")+"_"+D++,L)}function C(L,P){this.h=L,n(this,"description",{configurable:!0,writable:!0,value:P})}if(x)return x;C.prototype.toString=function(){return this.h};var A="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",D=0;return S}),a("Symbol.iterator",function(x){if(x)return x;x=Symbol("Symbol.iterator");for(var S="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),C=0;C<S.length;C++){var A=s[S[C]];typeof A=="function"&&typeof A.prototype[x]!="function"&&n(A.prototype,x,{configurable:!0,writable:!0,value:function(){return i(e(this))}})}return x});function i(x){return x={next:x},x[Symbol.iterator]=function(){return this},x}function o(x){var S=typeof Symbol<"u"&&Symbol.iterator&&x[Symbol.iterator];return S?S.call(x):{next:e(x)}}function l(x){if(!(x instanceof Array)){x=o(x);for(var S,C=[];!(S=x.next()).done;)C.push(S.value);x=C}return x}var u=typeof Object.assign=="function"?Object.assign:function(x,S){for(var C=1;C<arguments.length;C++){var A=arguments[C];if(A)for(var D in A)Object.prototype.hasOwnProperty.call(A,D)&&(x[D]=A[D])}return x};a("Object.assign",function(x){return x||u});var c=typeof Object.create=="function"?Object.create:function(x){function S(){}return S.prototype=x,new S},h;if(typeof Object.setPrototypeOf=="function")h=Object.setPrototypeOf;else{var d;e:{var p={a:!0},f={};try{f.__proto__=p,d=f.a;break e}catch{}d=!1}h=d?function(x,S){if(x.__proto__=S,x.__proto__!==S)throw new TypeError(x+" is not extensible");return x}:null}var m=h;function y(x,S){if(x.prototype=c(S.prototype),x.prototype.constructor=x,m)m(x,S);else for(var C in S)if(C!="prototype")if(Object.defineProperties){var A=Object.getOwnPropertyDescriptor(S,C);A&&Object.defineProperty(x,C,A)}else x[C]=S[C];x.za=S.prototype}function g(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function b(x){if(x.m)throw new TypeError("Generator is already running");x.m=!0}g.prototype.u=function(x){this.i=x};function v(x,S){x.l={ma:S,na:!0},x.h=x.s||x.v}g.prototype.return=function(x){this.l={return:x},this.h=this.v};function w(x,S,C){return x.h=C,{value:S}}function k(x){this.h=new g,this.i=x}function N(x,S){b(x.h);var C=x.h.j;return C?T(x,"return"in C?C.return:function(A){return{value:A,done:!0}},S,x.h.return):(x.h.return(S),E(x))}function T(x,S,C,A){try{var D=S.call(x.h.j,C);if(!(D instanceof Object))throw new TypeError("Iterator result "+D+" is not an object");if(!D.done)return x.h.m=!1,D;var L=D.value}catch(P){return x.h.j=null,v(x.h,P),E(x)}return x.h.j=null,A.call(x.h,L),E(x)}function E(x){for(;x.h.h;)try{var S=x.i(x.h);if(S)return x.h.m=!1,{value:S.value,done:!1}}catch(C){x.h.i=void 0,v(x.h,C)}if(x.h.m=!1,x.h.l){if(S=x.h.l,x.h.l=null,S.na)throw S.ma;return{value:S.return,done:!0}}return{value:void 0,done:!0}}function _(x){this.next=function(S){return b(x.h),x.h.j?S=T(x,x.h.j.next,S,x.h.u):(x.h.u(S),S=E(x)),S},this.throw=function(S){return b(x.h),x.h.j?S=T(x,x.h.j.throw,S,x.h.u):(v(x.h,S),S=E(x)),S},this.return=function(S){return N(x,S)},this[Symbol.iterator]=function(){return this}}function O(x){function S(A){return x.next(A)}function C(A){return x.throw(A)}return new Promise(function(A,D){function L(P){P.done?A(P.value):Promise.resolve(P.value).then(S,C).then(L,D)}L(x.next())})}function M(x){return O(new _(new k(x)))}a("Promise",function(x){function S(P){this.i=0,this.j=void 0,this.h=[],this.u=!1;var X=this.l();try{P(X.resolve,X.reject)}catch(re){X.reject(re)}}function C(){this.h=null}function A(P){return P instanceof S?P:new S(function(X){X(P)})}if(x)return x;C.prototype.i=function(P){if(this.h==null){this.h=[];var X=this;this.j(function(){X.m()})}this.h.push(P)};var D=s.setTimeout;C.prototype.j=function(P){D(P,0)},C.prototype.m=function(){for(;this.h&&this.h.length;){var P=this.h;this.h=[];for(var X=0;X<P.length;++X){var re=P[X];P[X]=null;try{re()}catch(he){this.l(he)}}}this.h=null},C.prototype.l=function(P){this.j(function(){throw P})},S.prototype.l=function(){function P(he){return function(ve){re||(re=!0,he.call(X,ve))}}var X=this,re=!1;return{resolve:P(this.I),reject:P(this.m)}},S.prototype.I=function(P){if(P===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(P instanceof S)this.L(P);else{e:switch(typeof P){case"object":var X=P!=null;break e;case"function":X=!0;break e;default:X=!1}X?this.F(P):this.s(P)}},S.prototype.F=function(P){var X=void 0;try{X=P.then}catch(re){this.m(re);return}typeof X=="function"?this.M(X,P):this.s(P)},S.prototype.m=function(P){this.v(2,P)},S.prototype.s=function(P){this.v(1,P)},S.prototype.v=function(P,X){if(this.i!=0)throw Error("Cannot settle("+P+", "+X+"): Promise already settled in state"+this.i);this.i=P,this.j=X,this.i===2&&this.K(),this.H()},S.prototype.K=function(){var P=this;D(function(){if(P.D()){var X=s.console;typeof X<"u"&&X.error(P.j)}},1)},S.prototype.D=function(){if(this.u)return!1;var P=s.CustomEvent,X=s.Event,re=s.dispatchEvent;return typeof re>"u"?!0:(typeof P=="function"?P=new P("unhandledrejection",{cancelable:!0}):typeof X=="function"?P=new X("unhandledrejection",{cancelable:!0}):(P=s.document.createEvent("CustomEvent"),P.initCustomEvent("unhandledrejection",!1,!0,P)),P.promise=this,P.reason=this.j,re(P))},S.prototype.H=function(){if(this.h!=null){for(var P=0;P<this.h.length;++P)L.i(this.h[P]);this.h=null}};var L=new C;return S.prototype.L=function(P){var X=this.l();P.T(X.resolve,X.reject)},S.prototype.M=function(P,X){var re=this.l();try{P.call(X,re.resolve,re.reject)}catch(he){re.reject(he)}},S.prototype.then=function(P,X){function re(Le,Ce){return typeof Le=="function"?function(Ye){try{he(Le(Ye))}catch(it){ve(it)}}:Ce}var he,ve,Xe=new S(function(Le,Ce){he=Le,ve=Ce});return this.T(re(P,he),re(X,ve)),Xe},S.prototype.catch=function(P){return this.then(void 0,P)},S.prototype.T=function(P,X){function re(){switch(he.i){case 1:P(he.j);break;case 2:X(he.j);break;default:throw Error("Unexpected state: "+he.i)}}var he=this;this.h==null?L.i(re):this.h.push(re),this.u=!0},S.resolve=A,S.reject=function(P){return new S(function(X,re){re(P)})},S.race=function(P){return new S(function(X,re){for(var he=o(P),ve=he.next();!ve.done;ve=he.next())A(ve.value).T(X,re)})},S.all=function(P){var X=o(P),re=X.next();return re.done?A([]):new S(function(he,ve){function Xe(Ye){return function(it){Le[Ye]=it,Ce--,Ce==0&&he(Le)}}var Le=[],Ce=0;do Le.push(void 0),Ce++,A(re.value).T(Xe(Le.length-1),ve),re=X.next();while(!re.done)})},S});function V(x,S){x instanceof String&&(x+="");var C=0,A=!1,D={next:function(){if(!A&&C<x.length){var L=C++;return{value:S(L,x[L]),done:!1}}return A=!0,{done:!0,value:void 0}}};return D[Symbol.iterator]=function(){return D},D}a("Array.prototype.keys",function(x){return x||function(){return V(this,function(S){return S})}}),a("Array.prototype.fill",function(x){return x||function(S,C,A){var D=this.length||0;for(0>C&&(C=Math.max(0,D+C)),(A==null||A>D)&&(A=D),A=Number(A),0>A&&(A=Math.max(0,D+A)),C=Number(C||0);C<A;C++)this[C]=S;return this}});function W(x){return x||Array.prototype.fill}a("Int8Array.prototype.fill",W),a("Uint8Array.prototype.fill",W),a("Uint8ClampedArray.prototype.fill",W),a("Int16Array.prototype.fill",W),a("Uint16Array.prototype.fill",W),a("Int32Array.prototype.fill",W),a("Uint32Array.prototype.fill",W),a("Float32Array.prototype.fill",W),a("Float64Array.prototype.fill",W),a("Object.is",function(x){return x||function(S,C){return S===C?S!==0||1/S===1/C:S!==S&&C!==C}}),a("Array.prototype.includes",function(x){return x||function(S,C){var A=this;A instanceof String&&(A=String(A));var D=A.length;for(C=C||0,0>C&&(C=Math.max(C+D,0));C<D;C++){var L=A[C];if(L===S||Object.is(L,S))return!0}return!1}}),a("String.prototype.includes",function(x){return x||function(S,C){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(S instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(S,C||0)!==-1}});var K=this||self;function q(x,S){x=x.split(".");var C=K;x[0]in C||typeof C.execScript>"u"||C.execScript("var "+x[0]);for(var A;x.length&&(A=x.shift());)x.length||S===void 0?C[A]&&C[A]!==Object.prototype[A]?C=C[A]:C=C[A]={}:C[A]=S}function ee(x){var S;e:{if((S=K.navigator)&&(S=S.userAgent))break e;S=""}return S.indexOf(x)!=-1}var te=Array.prototype.map?function(x,S){return Array.prototype.map.call(x,S,void 0)}:function(x,S){for(var C=x.length,A=Array(C),D=typeof x=="string"?x.split(""):x,L=0;L<C;L++)L in D&&(A[L]=S.call(void 0,D[L],L,x));return A},G={},J=null;function ne(x){var S=x.length,C=3*S/4;C%3?C=Math.floor(C):"=.".indexOf(x[S-1])!=-1&&(C="=.".indexOf(x[S-2])!=-1?C-2:C-1);var A=new Uint8Array(C),D=0;return ae(x,function(L){A[D++]=L}),D!==C?A.subarray(0,D):A}function ae(x,S){function C(re){for(;A<x.length;){var he=x.charAt(A++),ve=J[he];if(ve!=null)return ve;if(!/^[\s\xa0]*$/.test(he))throw Error("Unknown base64 encoding at char: "+he)}return re}oe();for(var A=0;;){var D=C(-1),L=C(0),P=C(64),X=C(64);if(X===64&&D===-1)break;S(D<<2|L>>4),P!=64&&(S(L<<4&240|P>>2),X!=64&&S(P<<6&192|X))}}function oe(){if(!J){J={};for(var x="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),S=["+/=","+/","-_=","-_.","-_"],C=0;5>C;C++){var A=x.concat(S[C].split(""));G[C]=A;for(var D=0;D<A.length;D++){var L=A[D];J[L]===void 0&&(J[L]=D)}}}}var ue=typeof Uint8Array<"u",ce=!(ee("Trident")||ee("MSIE"))&&typeof K.btoa=="function";function de(x){if(!ce){var S;S===void 0&&(S=0),oe(),S=G[S];for(var C=Array(Math.floor(x.length/3)),A=S[64]||"",D=0,L=0;D<x.length-2;D+=3){var P=x[D],X=x[D+1],re=x[D+2],he=S[P>>2];P=S[(P&3)<<4|X>>4],X=S[(X&15)<<2|re>>6],re=S[re&63],C[L++]=he+P+X+re}switch(he=0,re=A,x.length-D){case 2:he=x[D+1],re=S[(he&15)<<2]||A;case 1:x=x[D],C[L]=S[x>>2]+S[(x&3)<<4|he>>4]+re+A}return C.join("")}for(S="";10240<x.length;)S+=String.fromCharCode.apply(null,x.subarray(0,10240)),x=x.subarray(10240);return S+=String.fromCharCode.apply(null,x),btoa(S)}var Te=RegExp("[-_.]","g");function Ee(x){switch(x){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function De(x){if(!ce)return ne(x);Te.test(x)&&(x=x.replace(Te,Ee)),x=atob(x);for(var S=new Uint8Array(x.length),C=0;C<x.length;C++)S[C]=x.charCodeAt(C);return S}var Be;function We(){return Be||(Be=new Uint8Array(0))}var Ke={},nt=typeof Uint8Array.prototype.slice=="function",qe=0,xe=0;function He(x){var S=0>x;x=Math.abs(x);var C=x>>>0;x=Math.floor((x-C)/4294967296),S&&(C=o(xt(C,x)),S=C.next().value,x=C.next().value,C=S),qe=C>>>0,xe=x>>>0}var tt=typeof BigInt=="function";function xt(x,S){return S=~S,x?x=~x+1:S+=1,[x,S]}function wt(x,S){this.i=x>>>0,this.h=S>>>0}function Fr(x){if(!x)return tn||(tn=new wt(0,0));if(!/^-?\d+$/.test(x))return null;if(16>x.length)He(Number(x));else if(tt)x=BigInt(x),qe=Number(x&BigInt(4294967295))>>>0,xe=Number(x>>BigInt(32)&BigInt(4294967295));else{var S=+(x[0]==="-");xe=qe=0;for(var C=x.length,A=S,D=(C-S)%6+S;D<=C;A=D,D+=6)A=Number(x.slice(A,D)),xe*=1e6,qe=1e6*qe+A,4294967296<=qe&&(xe+=qe/4294967296|0,qe%=4294967296);S&&(S=o(xt(qe,xe)),x=S.next().value,S=S.next().value,qe=x,xe=S)}return new wt(qe,xe)}var tn;function Or(x,S){return Error("Invalid wire type: "+x+" (at position "+S+")")}function gn(){return Error("Failed to read varint, encoding is invalid.")}function yr(x,S){return Error("Tried to read past the end of the data "+S+" > "+x)}function Cn(){throw Error("Invalid UTF8")}function br(x,S){return S=String.fromCharCode.apply(null,S),x==null?S:x+S}var Tn=void 0,Dr,Hn=typeof TextDecoder<"u",Kn,Ia=typeof TextEncoder<"u",Mr;function qs(x){if(x!==Ke)throw Error("illegal external caller")}function Pr(x,S){if(qs(S),this.V=x,x!=null&&x.length===0)throw Error("ByteString should be constructed with non-empty values")}function uh(){return Mr||(Mr=new Pr(null,Ke))}function Nf(x){qs(Ke);var S=x.V;return S=S==null||ue&&S!=null&&S instanceof Uint8Array?S:typeof S=="string"?De(S):null,S==null?S:x.V=S}function CP(x){if(typeof x=="string")return{buffer:De(x),C:!1};if(Array.isArray(x))return{buffer:new Uint8Array(x),C:!1};if(x.constructor===Uint8Array)return{buffer:x,C:!1};if(x.constructor===ArrayBuffer)return{buffer:new Uint8Array(x),C:!1};if(x.constructor===Pr)return{buffer:Nf(x)||We(),C:!0};if(x instanceof Uint8Array)return{buffer:new Uint8Array(x.buffer,x.byteOffset,x.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}function G2(x,S){this.i=null,this.m=!1,this.h=this.j=this.l=0,S0(this,x,S)}function S0(x,S,C){C=C===void 0?{}:C,x.S=C.S===void 0?!1:C.S,S&&(S=CP(S),x.i=S.buffer,x.m=S.C,x.l=0,x.j=x.i.length,x.h=x.l)}G2.prototype.reset=function(){this.h=this.l};function Co(x,S){if(x.h=S,S>x.j)throw yr(x.j,S)}function ch(x){var S=x.i,C=x.h,A=S[C++],D=A&127;if(A&128&&(A=S[C++],D|=(A&127)<<7,A&128&&(A=S[C++],D|=(A&127)<<14,A&128&&(A=S[C++],D|=(A&127)<<21,A&128&&(A=S[C++],D|=A<<28,A&128&&S[C++]&128&&S[C++]&128&&S[C++]&128&&S[C++]&128&&S[C++]&128)))))throw gn();return Co(x,C),D}function H2(x,S){if(0>S)throw Error("Tried to read a negative byte length: "+S);var C=x.h,A=C+S;if(A>x.j)throw yr(S,x.j-C);return x.h=A,C}var K2=[];function I0(){this.h=[]}I0.prototype.length=function(){return this.h.length},I0.prototype.end=function(){var x=this.h;return this.h=[],x};function q2(x,S,C){for(;0<C||127<S;)x.h.push(S&127|128),S=(S>>>7|C<<25)>>>0,C>>>=7;x.h.push(S)}function To(x,S){for(;127<S;)x.h.push(S&127|128),S>>>=7;x.h.push(S)}function N0(x,S){if(K2.length){var C=K2.pop();S0(C,x,S),x=C}else x=new G2(x,S);this.h=x,this.j=this.h.h,this.i=this.l=-1,this.setOptions(S)}N0.prototype.setOptions=function(x){x=x===void 0?{}:x,this.ca=x.ca===void 0?!1:x.ca},N0.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};function X2(x){var S=x.h;if(S.h==S.j)return!1;x.j=x.h.h;var C=ch(x.h)>>>0;if(S=C>>>3,C&=7,!(0<=C&&5>=C))throw Or(C,x.j);if(1>S)throw Error("Invalid field number: "+S+" (at position "+x.j+")");return x.l=S,x.i=C,!0}function Cf(x){switch(x.i){case 0:if(x.i!=0)Cf(x);else e:{x=x.h;for(var S=x.h,C=S+10,A=x.i;S<C;)if(!(A[S++]&128)){Co(x,S);break e}throw gn()}break;case 1:x=x.h,Co(x,x.h+8);break;case 2:x.i!=2?Cf(x):(S=ch(x.h)>>>0,x=x.h,Co(x,x.h+S));break;case 5:x=x.h,Co(x,x.h+4);break;case 3:S=x.l;do{if(!X2(x))throw Error("Unmatched start-group tag: stream EOF");if(x.i==4){if(x.l!=S)throw Error("Unmatched end-group tag");break}Cf(x)}while(!0);break;default:throw Or(x.i,x.j)}}var Tf=[];function TP(){this.j=[],this.i=0,this.h=new I0}function Gl(x,S){S.length!==0&&(x.j.push(S),x.i+=S.length)}function EP(x,S){if(S=S.R){Gl(x,x.h.end());for(var C=0;C<S.length;C++)Gl(x,Nf(S[C])||We())}}var Xa=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol():void 0;function Eo(x,S){return Xa?x[Xa]|=S:x.A!==void 0?x.A|=S:(Object.defineProperties(x,{A:{value:S,configurable:!0,writable:!0,enumerable:!1}}),S)}function Y2(x,S){Xa?x[Xa]&&(x[Xa]&=~S):x.A!==void 0&&(x.A&=~S)}function un(x){var S;return Xa?S=x[Xa]:S=x.A,S??0}function Na(x,S){Xa?x[Xa]=S:x.A!==void 0?x.A=S:Object.defineProperties(x,{A:{value:S,configurable:!0,writable:!0,enumerable:!1}})}function C0(x){return Eo(x,1),x}function $P(x,S){Na(S,(x|0)&-51)}function Ef(x,S){Na(S,(x|18)&-41)}var T0={};function $f(x){return x!==null&&typeof x=="object"&&!Array.isArray(x)&&x.constructor===Object}var hh,Q2=[];Na(Q2,23),hh=Object.freeze(Q2);function E0(x){if(un(x.o)&2)throw Error("Cannot mutate an immutable Message")}function $0(x){var S=x.length;(S=S?x[S-1]:void 0)&&$f(S)?S.g=1:(S={},x.push((S.g=1,S)))}function Z2(x){var S=x.i+x.G;return x.B||(x.B=x.o[S]={})}function Xs(x,S){return S===-1?null:S>=x.i?x.B?x.B[S]:void 0:x.o[S+x.G]}function Ca(x,S,C,A){E0(x),dh(x,S,C,A)}function dh(x,S,C,A){x.j&&(x.j=void 0),S>=x.i||A?Z2(x)[S]=C:(x.o[S+x.G]=C,(x=x.B)&&S in x&&delete x[S])}function R0(x,S,C,A){var D=Xs(x,S);Array.isArray(D)||(D=hh);var L=un(D);if(L&1||C0(D),A)L&2||Eo(D,2),C&1||Object.freeze(D);else{A=!(C&2);var P=L&2;C&1||!P?A&&L&16&&!P&&Y2(D,16):(D=C0(Array.prototype.slice.call(D)),dh(x,S,D))}return D}function A0(x,S){var C=Xs(x,S),A=C==null?C:typeof C=="number"||C==="NaN"||C==="Infinity"||C==="-Infinity"?Number(C):void 0;return A!=null&&A!==C&&dh(x,S,A),A}function J2(x,S,C,A,D){x.h||(x.h={});var L=x.h[C],P=R0(x,C,3,D);if(!L){var X=P;L=[];var re=!!(un(x.o)&16);P=!!(un(X)&2);var he=X;!D&&P&&(X=Array.prototype.slice.call(X));for(var ve=P,Xe=0;Xe<X.length;Xe++){var Le=X[Xe],Ce=S,Ye=!1;if(Ye=Ye===void 0?!1:Ye,Le=Array.isArray(Le)?new Ce(Le):Ye?new Ce:void 0,Le!==void 0){Ce=Le.o;var it=Ye=un(Ce);P&&(it|=2),re&&(it|=16),it!=Ye&&Na(Ce,it),Ce=it,ve=ve||!!(2&Ce),L.push(Le)}}return x.h[C]=L,re=un(X),S=re|33,S=ve?S&-9:S|8,re!=S&&(ve=X,Object.isFrozen(ve)&&(ve=Array.prototype.slice.call(ve)),Na(ve,S),X=ve),he!==X&&dh(x,C,X),(D||A&&P)&&Eo(L,2),A&&Object.freeze(L),L}return D||(D=Object.isFrozen(L),A&&!D?Object.freeze(L):!A&&D&&(L=Array.prototype.slice.call(L),x.h[C]=L)),L}function _0(x,S,C){var A=!!(un(x.o)&2);if(S=J2(x,S,C,A,A),x=R0(x,C,3,A),!(A||un(x)&8)){for(A=0;A<S.length;A++){if(C=S[A],un(C.o)&2){var D=aS(C,!1);D.j=C}else D=C;C!==D&&(S[A]=D,x[A]=D.o)}Eo(x,8)}return S}function Ta(x,S,C){if(C!=null&&typeof C!="number")throw Error("Value of float/double field must be a number|null|undefined, found "+typeof C+": "+C);Ca(x,S,C)}function eS(x,S,C,A,D){E0(x);var L=J2(x,C,S,!1,!1);return C=A??new C,x=R0(x,S,2,!1),D!=null?(L.splice(D,0,C),x.splice(D,0,C.o)):(L.push(C),x.push(C.o)),C.C()&&Y2(x,8),C}function Rf(x,S){return x??S}function Ea(x,S,C){return C=C===void 0?0:C,Rf(A0(x,S),C)}var Af;function RP(x){switch(typeof x){case"number":return isFinite(x)?x:String(x);case"object":if(x)if(Array.isArray(x)){if(un(x)&128)return x=Array.prototype.slice.call(x),$0(x),x}else{if(ue&&x!=null&&x instanceof Uint8Array)return de(x);if(x instanceof Pr){var S=x.V;return S==null?"":typeof S=="string"?S:x.V=de(S)}}}return x}function tS(x,S,C,A){if(x!=null){if(Array.isArray(x))x=F0(x,S,C,A!==void 0);else if($f(x)){var D={},L;for(L in x)D[L]=tS(x[L],S,C,A);x=D}else x=S(x,A);return x}}function F0(x,S,C,A){var D=un(x);A=A?!!(D&16):void 0,x=Array.prototype.slice.call(x);for(var L=0;L<x.length;L++)x[L]=tS(x[L],S,C,A);return C(D,x),x}function AP(x){return x.ja===T0?x.toJSON():RP(x)}function _P(x,S){x&128&&$0(S)}function nS(x,S,C){if(C=C===void 0?Ef:C,x!=null){if(ue&&x instanceof Uint8Array)return x.length?new Pr(new Uint8Array(x),Ke):uh();if(Array.isArray(x)){var A=un(x);return A&2?x:S&&!(A&32)&&(A&16||A===0)?(Na(x,A|2),x):(x=F0(x,nS,A&4?Ef:C,!0),S=un(x),S&4&&S&2&&Object.freeze(x),x)}return x.ja===T0?sS(x):x}}function rS(x,S,C,A,D,L,P){if(x=x.h&&x.h[C]){if(A=un(x),A&2?A=x:(L=te(x,sS),Ef(A,L),Object.freeze(L),A=L),E0(S),P=A==null?hh:C0([]),A!=null){for(L=!!A.length,x=0;x<A.length;x++){var X=A[x];L=L&&!(un(X.o)&2),P[x]=X.o}L=(L?8:0)|1,x=un(P),(x&L)!==L&&(Object.isFrozen(P)&&(P=Array.prototype.slice.call(P)),Na(P,x|L)),S.h||(S.h={}),S.h[C]=A}else S.h&&(S.h[C]=void 0);dh(S,C,P,D)}else Ca(S,C,nS(A,L,P),D)}function sS(x){return un(x.o)&2||(x=aS(x,!0),Eo(x.o,2)),x}function aS(x,S){var C=x.o,A=[];Eo(A,16);var D=x.constructor.h;if(D&&A.push(D),D=x.B,D){A.length=C.length,A.fill(void 0,A.length,C.length);var L={};A[A.length-1]=L}un(C)&128&&$0(A),S=S||x.C()?Ef:$P,L=x.constructor,Af=A,A=new L(A),Af=void 0,x.R&&(A.R=x.R.slice()),L=!!(un(C)&16);for(var P=D?C.length-1:C.length,X=0;X<P;X++)rS(x,A,X-x.G,C[X],!1,L,S);if(D)for(var re in D)rS(x,A,+re,D[re],!0,L,S);return A}function Lr(x,S,C){x==null&&(x=Af),Af=void 0;var A=this.constructor.i||0,D=0<A,L=this.constructor.h,P=!1;if(x==null){x=L?[L]:[];var X=48,re=!0;D&&(A=0,X|=128),Na(x,X)}else{if(!Array.isArray(x)||L&&L!==x[0])throw Error();var he=X=Eo(x,0);if((re=(16&he)!==0)&&((P=(32&he)!==0)||(he|=32)),D){if(128&he)A=0;else if(0<x.length){var ve=x[x.length-1];if($f(ve)&&"g"in ve){A=0,he|=128,delete ve.g;var Xe=!0,Le;for(Le in ve){Xe=!1;break}Xe&&x.pop()}}}else if(128&he)throw Error();X!==he&&Na(x,he)}this.G=(L?0:-1)-A,this.h=void 0,this.o=x;e:{if(L=this.o.length,A=L-1,L&&(L=this.o[A],$f(L))){this.B=L,this.i=A-this.G;break e}S!==void 0&&-1<S?(this.i=Math.max(S,A+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE}if(!D&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(C){S=re&&!P&&!0,D=this.i;var Ce;for(re=0;re<C.length;re++)P=C[re],P<D?(P+=this.G,(A=x[P])?iS(A,S):x[P]=hh):(Ce||(Ce=Z2(this)),(A=Ce[P])?iS(A,S):Ce[P]=hh)}}Lr.prototype.toJSON=function(){return F0(this.o,AP,_P)},Lr.prototype.C=function(){return!!(un(this.o)&2)};function iS(x,S){if(Array.isArray(x)){var C=un(x),A=1;!S||C&2||(A|=16),(C&A)!==A&&Na(x,C|A)}}Lr.prototype.ja=T0,Lr.prototype.toString=function(){return this.o.toString()};function oS(x,S,C){if(C){var A={},D;for(D in C){var L=C[D],P=L.ra;P||(A.J=L.xa||L.oa.W,L.ia?(A.aa=dS(L.ia),P=function(X){return function(re,he,ve){return X.J(re,he,ve,X.aa)}}(A)):L.ka?(A.Z=pS(L.da.P,L.ka),P=function(X){return function(re,he,ve){return X.J(re,he,ve,X.Z)}}(A)):P=A.J,L.ra=P),P(S,x,L.da),A={J:A.J,aa:A.aa,Z:A.Z}}}EP(S,x)}var _f=Symbol();function lS(x,S,C){return x[_f]||(x[_f]=function(A,D){return S(A,D,C)})}function uS(x){var S=x[_f];if(!S){var C=D0(x);S=function(A,D){return fS(A,D,C)},x[_f]=S}return S}function FP(x){var S=x.ia;if(S)return uS(S);if(S=x.wa)return lS(x.da.P,S,x.ka)}function OP(x){var S=FP(x),C=x.da,A=x.oa.U;return S?function(D,L){return A(D,L,C,S)}:function(D,L){return A(D,L,C)}}function cS(x,S){var C=x[S];return typeof C=="function"&&C.length===0&&(C=C(),x[S]=C),Array.isArray(C)&&(fh in C||ph in C||0<C.length&&typeof C[0]=="function")?C:void 0}function hS(x,S,C,A,D,L){S.P=x[0];var P=1;if(x.length>P&&typeof x[P]!="number"){var X=x[P++];C(S,X)}for(;P<x.length;){C=x[P++];for(var re=P+1;re<x.length&&typeof x[re]!="number";)re++;switch(X=x[P++],re-=P,re){case 0:A(S,C,X);break;case 1:(re=cS(x,P))?(P++,D(S,C,X,re)):A(S,C,X,x[P++]);break;case 2:re=P++,re=cS(x,re),D(S,C,X,re,x[P++]);break;case 3:L(S,C,X,x[P++],x[P++],x[P++]);break;case 4:L(S,C,X,x[P++],x[P++],x[P++],x[P++]);break;default:throw Error("unexpected number of binary field arguments: "+re)}}return S}var Ff=Symbol();function dS(x){var S=x[Ff];if(!S){var C=O0(x);S=function(A,D){return mS(A,D,C)},x[Ff]=S}return S}function pS(x,S){var C=x[Ff];return C||(C=function(A,D){return oS(A,D,S)},x[Ff]=C),C}var ph=Symbol();function DP(x,S){x.push(S)}function MP(x,S,C){x.push(S,C.W)}function PP(x,S,C,A){var D=dS(A),L=O0(A).P,P=C.W;x.push(S,function(X,re,he){return P(X,re,he,L,D)})}function LP(x,S,C,A,D,L){var P=pS(A,L),X=C.W;x.push(S,function(re,he,ve){return X(re,he,ve,A,P)})}function O0(x){var S=x[ph];return S||(S=hS(x,x[ph]=[],DP,MP,PP,LP),fh in x&&ph in x&&(x.length=0),S)}var fh=Symbol();function zP(x,S){x[0]=S}function BP(x,S,C,A){var D=C.U;x[S]=A?function(L,P,X){return D(L,P,X,A)}:D}function WP(x,S,C,A,D){var L=C.U,P=uS(A),X=D0(A).P;x[S]=function(re,he,ve){return L(re,he,ve,X,P,D)}}function UP(x,S,C,A,D,L,P){var X=C.U,re=lS(A,D,L);x[S]=function(he,ve,Xe){return X(he,ve,Xe,A,re,P)}}function D0(x){var S=x[fh];return S||(S=hS(x,x[fh]={},zP,BP,WP,UP),fh in x&&ph in x&&(x.length=0),S)}function fS(x,S,C){for(;X2(S)&&S.i!=4;){var A=S.l,D=C[A];if(!D){var L=C[0];L&&(L=L[A])&&(D=C[A]=OP(L))}if(!D||!D(S,x,A)){D=S,A=x,L=D.j,Cf(D);var P=D;if(!P.ca){if(D=P.h.h-L,P.h.h=L,P=P.h,D==0)D=uh();else{if(L=H2(P,D),P.S&&P.m)D=P.i.subarray(L,L+D);else{P=P.i;var X=L;D=L+D,D=X===D?We():nt?P.slice(X,D):new Uint8Array(P.subarray(X,D))}D=D.length==0?uh():new Pr(D,Ke)}(L=A.R)?L.push(D):A.R=[D]}}}return x}function mS(x,S,C){for(var A=C.length,D=A%2==1,L=D?1:0;L<A;L+=2)(0,C[L+1])(S,x,C[L]);oS(x,S,D?C[0]:void 0)}function mh(x,S){return{U:x,W:S}}var Ys=mh(function(x,S,C){if(x.i!==5)return!1;x=x.h;var A=x.i,D=x.h,L=A[D],P=A[D+1],X=A[D+2];return A=A[D+3],Co(x,x.h+4),P=(L<<0|P<<8|X<<16|A<<24)>>>0,x=2*(P>>31)+1,L=P>>>23&255,P&=8388607,Ca(S,C,L==255?P?NaN:1/0*x:L==0?x*Math.pow(2,-149)*P:x*Math.pow(2,L-150)*(P+Math.pow(2,23))),!0},function(x,S,C){if(S=A0(S,C),S!=null){To(x.h,8*C+5),x=x.h;var A=+S;A===0?0<1/A?qe=xe=0:(xe=0,qe=2147483648):isNaN(A)?(xe=0,qe=2147483647):(A=(C=0>A?-2147483648:0)?-A:A,34028234663852886e22<A?(xe=0,qe=(C|2139095040)>>>0):11754943508222875e-54>A?(A=Math.round(A/Math.pow(2,-149)),xe=0,qe=(C|A)>>>0):(S=Math.floor(Math.log(A)/Math.LN2),A*=Math.pow(2,-S),A=Math.round(8388608*A),16777216<=A&&++S,xe=0,qe=(C|S+127<<23|A&8388607)>>>0)),C=qe,x.h.push(C>>>0&255),x.h.push(C>>>8&255),x.h.push(C>>>16&255),x.h.push(C>>>24&255)}}),VP=mh(function(x,S,C){if(x.i!==0)return!1;var A=x.h,D=0,L=x=0,P=A.i,X=A.h;do{var re=P[X++];D|=(re&127)<<L,L+=7}while(32>L&&re&128);for(32<L&&(x|=(re&127)>>4),L=3;32>L&&re&128;L+=7)re=P[X++],x|=(re&127)<<L;if(Co(A,X),128>re)A=D>>>0,re=x>>>0,(x=re&2147483648)&&(A=~A+1>>>0,re=~re>>>0,A==0&&(re=re+1>>>0)),A=4294967296*re+(A>>>0);else throw gn();return Ca(S,C,x?-A:A),!0},function(x,S,C){S=Xs(S,C),S!=null&&(typeof S=="string"&&Fr(S),S!=null&&(To(x.h,8*C),typeof S=="number"?(x=x.h,He(S),q2(x,qe,xe)):(C=Fr(S),q2(x.h,C.i,C.h))))}),jP=mh(function(x,S,C){return x.i!==0?!1:(Ca(S,C,ch(x.h)),!0)},function(x,S,C){if(S=Xs(S,C),S!=null&&S!=null)if(To(x.h,8*C),x=x.h,C=S,0<=C)To(x,C);else{for(S=0;9>S;S++)x.h.push(C&127|128),C>>=7;x.h.push(1)}}),gS=mh(function(x,S,C){if(x.i!==2)return!1;var A=ch(x.h)>>>0;x=x.h;var D=H2(x,A);if(x=x.i,Hn){var L=x,P;(P=Dr)||(P=Dr=new TextDecoder("utf-8",{fatal:!0})),x=D+A,L=D===0&&x===L.length?L:L.subarray(D,x);try{var X=P.decode(L)}catch(Xe){if(Tn===void 0){try{P.decode(new Uint8Array([128]))}catch{}try{P.decode(new Uint8Array([97])),Tn=!0}catch{Tn=!1}}throw!Tn&&(Dr=void 0),Xe}}else{X=D,A=X+A,D=[];for(var re=null,he,ve;X<A;)he=x[X++],128>he?D.push(he):224>he?X>=A?Cn():(ve=x[X++],194>he||(ve&192)!==128?(X--,Cn()):D.push((he&31)<<6|ve&63)):240>he?X>=A-1?Cn():(ve=x[X++],(ve&192)!==128||he===224&&160>ve||he===237&&160<=ve||((L=x[X++])&192)!==128?(X--,Cn()):D.push((he&15)<<12|(ve&63)<<6|L&63)):244>=he?X>=A-2?Cn():(ve=x[X++],(ve&192)!==128||(he<<28)+(ve-144)>>30||((L=x[X++])&192)!==128||((P=x[X++])&192)!==128?(X--,Cn()):(he=(he&7)<<18|(ve&63)<<12|(L&63)<<6|P&63,he-=65536,D.push((he>>10&1023)+55296,(he&1023)+56320))):Cn(),8192<=D.length&&(re=br(re,D),D.length=0);X=br(re,D)}return Ca(S,C,X),!0},function(x,S,C){if(S=Xs(S,C),S!=null){var A=!1;if(A=A===void 0?!1:A,Ia){if(A&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(S))throw Error("Found an unpaired surrogate");S=(Kn||(Kn=new TextEncoder)).encode(S)}else{for(var D=0,L=new Uint8Array(3*S.length),P=0;P<S.length;P++){var X=S.charCodeAt(P);if(128>X)L[D++]=X;else{if(2048>X)L[D++]=X>>6|192;else{if(55296<=X&&57343>=X){if(56319>=X&&P<S.length){var re=S.charCodeAt(++P);if(56320<=re&&57343>=re){X=1024*(X-55296)+re-56320+65536,L[D++]=X>>18|240,L[D++]=X>>12&63|128,L[D++]=X>>6&63|128,L[D++]=X&63|128;continue}else P--}if(A)throw Error("Found an unpaired surrogate");X=65533}L[D++]=X>>12|224,L[D++]=X>>6&63|128}L[D++]=X&63|128}}S=D===L.length?L:L.subarray(0,D)}To(x.h,8*C+2),To(x.h,S.length),Gl(x,x.h.end()),Gl(x,S)}}),yS=mh(function(x,S,C,A,D){if(x.i!==2)return!1;S=eS(S,C,A),C=x.h.j,A=ch(x.h)>>>0;var L=x.h.h+A,P=L-C;if(0>=P&&(x.h.j=L,D(S,x,void 0,void 0,void 0),P=L-x.h.h),P)throw Error("Message parsing ended unexpectedly. Expected to read "+(A+" bytes, instead read "+(A-P)+" bytes, either the data ended unexpectedly or the message misreported its own length"));return x.h.h=L,x.h.j=C,!0},function(x,S,C,A,D){if(S=_0(S,A,C),S!=null)for(A=0;A<S.length;A++){var L=x;To(L.h,8*C+2);var P=L.h.end();Gl(L,P),P.push(L.i),L=P,D(S[A],x),P=x;var X=L.pop();for(X=P.i+P.h.length()-X;127<X;)L.push(X&127|128),X>>>=7,P.i++;L.push(X),P.i++}});function M0(x){return function(S,C){e:{if(Tf.length){var A=Tf.pop();A.setOptions(C),S0(A.h,S,C),S=A}else S=new N0(S,C);try{var D=D0(x),L=fS(new D.P,S,D);break e}finally{D=S.h,D.i=null,D.m=!1,D.l=0,D.j=0,D.h=0,D.S=!1,S.l=-1,S.i=-1,100>Tf.length&&Tf.push(S)}L=void 0}return L}}function P0(x){return function(){var S=new TP;mS(this,S,O0(x)),Gl(S,S.h.end());for(var C=new Uint8Array(S.i),A=S.j,D=A.length,L=0,P=0;P<D;P++){var X=A[P];C.set(X,L),L+=X.length}return S.j=[C],C}}function Hl(x){Lr.call(this,x)}y(Hl,Lr);var bS=[Hl,1,jP,2,Ys,3,gS,4,gS];Hl.prototype.l=P0(bS);function L0(x){Lr.call(this,x,-1,GP)}y(L0,Lr),L0.prototype.addClassification=function(x,S){return eS(this,1,Hl,x,S),this};var GP=[1],HP=M0([L0,1,yS,bS]);function gh(x){Lr.call(this,x)}y(gh,Lr);var xS=[gh,1,Ys,2,Ys,3,Ys,4,Ys,5,Ys];gh.prototype.l=P0(xS);function vS(x){Lr.call(this,x,-1,KP)}y(vS,Lr);var KP=[1],qP=M0([vS,1,yS,xS]);function Of(x){Lr.call(this,x)}y(Of,Lr);var wS=[Of,1,Ys,2,Ys,3,Ys,4,Ys,5,Ys,6,VP],XP=M0(wS);Of.prototype.l=P0(wS);function kS(x,S,C){if(C=x.createShader(C===0?x.VERTEX_SHADER:x.FRAGMENT_SHADER),x.shaderSource(C,S),x.compileShader(C),!x.getShaderParameter(C,x.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+x.getShaderInfoLog(C));return C}function YP(x){return _0(x,Hl,1).map(function(S){var C=Xs(S,1);return{index:C??0,qa:Ea(S,2),label:Xs(S,3)!=null?Rf(Xs(S,3),""):void 0,displayName:Xs(S,4)!=null?Rf(Xs(S,4),""):void 0}})}function QP(x){return{x:Ea(x,1),y:Ea(x,2),z:Ea(x,3),visibility:A0(x,4)!=null?Ea(x,4):void 0}}function z0(x){return _0(qP(x),gh,1).map(QP)}function B0(x,S){this.i=x,this.h=S,this.m=0}function SS(x,S,C){return ZP(x,S),typeof x.h.canvas.transferToImageBitmap=="function"?Promise.resolve(x.h.canvas.transferToImageBitmap()):C?Promise.resolve(x.h.canvas):typeof createImageBitmap=="function"?createImageBitmap(x.h.canvas):(x.j===void 0&&(x.j=document.createElement("canvas")),new Promise(function(A){x.j.height=x.h.canvas.height,x.j.width=x.h.canvas.width,x.j.getContext("2d",{}).drawImage(x.h.canvas,0,0,x.h.canvas.width,x.h.canvas.height),A(x.j)}))}function ZP(x,S){var C=x.h;if(x.s===void 0){var A=kS(C,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),D=kS(C,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),L=C.createProgram();if(C.attachShader(L,A),C.attachShader(L,D),C.linkProgram(L),!C.getProgramParameter(L,C.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+C.getProgramInfoLog(L));A=x.s=L,C.useProgram(A),D=C.getUniformLocation(A,"sampler0"),x.l={O:C.getAttribLocation(A,"aVertex"),N:C.getAttribLocation(A,"aTex"),ya:D},x.v=C.createBuffer(),C.bindBuffer(C.ARRAY_BUFFER,x.v),C.enableVertexAttribArray(x.l.O),C.vertexAttribPointer(x.l.O,2,C.FLOAT,!1,0,0),C.bufferData(C.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),C.STATIC_DRAW),C.bindBuffer(C.ARRAY_BUFFER,null),x.u=C.createBuffer(),C.bindBuffer(C.ARRAY_BUFFER,x.u),C.enableVertexAttribArray(x.l.N),C.vertexAttribPointer(x.l.N,2,C.FLOAT,!1,0,0),C.bufferData(C.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),C.STATIC_DRAW),C.bindBuffer(C.ARRAY_BUFFER,null),C.uniform1i(D,0)}A=x.l,C.useProgram(x.s),C.canvas.width=S.width,C.canvas.height=S.height,C.viewport(0,0,S.width,S.height),C.activeTexture(C.TEXTURE0),x.i.bindTexture2d(S.glName),C.enableVertexAttribArray(A.O),C.bindBuffer(C.ARRAY_BUFFER,x.v),C.vertexAttribPointer(A.O,2,C.FLOAT,!1,0,0),C.enableVertexAttribArray(A.N),C.bindBuffer(C.ARRAY_BUFFER,x.u),C.vertexAttribPointer(A.N,2,C.FLOAT,!1,0,0),C.bindFramebuffer(C.DRAW_FRAMEBUFFER?C.DRAW_FRAMEBUFFER:C.FRAMEBUFFER,null),C.clearColor(0,0,0,0),C.clear(C.COLOR_BUFFER_BIT),C.colorMask(!0,!0,!0,!0),C.drawArrays(C.TRIANGLE_FAN,0,4),C.disableVertexAttribArray(A.O),C.disableVertexAttribArray(A.N),C.bindBuffer(C.ARRAY_BUFFER,null),x.i.bindTexture2d(0)}function JP(x){this.h=x}var eL=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function tL(x,S){return S+x}function IS(x,S){window[x]=S}function nL(x){var S=document.createElement("script");return S.setAttribute("src",x),S.setAttribute("crossorigin","anonymous"),new Promise(function(C){S.addEventListener("load",function(){C()},!1),S.addEventListener("error",function(){C()},!1),document.body.appendChild(S)})}function rL(){return M(function(x){switch(x.h){case 1:return x.s=2,w(x,WebAssembly.instantiate(eL),4);case 4:x.h=3,x.s=0;break;case 2:return x.s=0,x.l=null,x.return(!1);case 3:return x.return(!0)}})}function W0(x){if(this.h=x,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=x&&x.locateFile||tL,typeof window=="object")var S=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")S=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.ha=S,x.options){S=o(Object.keys(x.options));for(var C=S.next();!C.done;C=S.next()){C=C.value;var A=x.options[C].default;A!==void 0&&(this.l[C]=typeof A=="function"?A():A)}}}t=W0.prototype,t.close=function(){return this.j&&this.j.delete(),Promise.resolve()};function sL(x){var S,C,A,D,L,P,X,re,he,ve,Xe;return M(function(Le){switch(Le.h){case 1:return x.ga?(S=x.h.files===void 0?[]:typeof x.h.files=="function"?x.h.files(x.l):x.h.files,w(Le,rL(),2)):Le.return();case 2:if(C=Le.i,typeof window=="object")return IS("createMediapipeSolutionsWasm",{locateFile:x.locateFile}),IS("createMediapipeSolutionsPackedAssets",{locateFile:x.locateFile}),P=S.filter(function(Ce){return Ce.data!==void 0}),X=S.filter(function(Ce){return Ce.data===void 0}),re=Promise.all(P.map(function(Ce){var Ye=Df(x,Ce.url);if(Ce.path!==void 0){var it=Ce.path;Ye=Ye.then(function(zt){return x.overrideFile(it,zt),Promise.resolve(zt)})}return Ye})),he=Promise.all(X.map(function(Ce){return Ce.simd===void 0||Ce.simd&&C||!Ce.simd&&!C?nL(x.locateFile(Ce.url,x.ha)):Promise.resolve()})).then(function(){var Ce,Ye,it;return M(function(zt){if(zt.h==1)return Ce=window.createMediapipeSolutionsWasm,Ye=window.createMediapipeSolutionsPackedAssets,it=x,w(zt,Ce(Ye),2);it.i=zt.i,zt.h=0})}),ve=function(){return M(function(Ce){return x.h.graph&&x.h.graph.url?Ce=w(Ce,Df(x,x.h.graph.url),0):(Ce.h=0,Ce=void 0),Ce})}(),w(Le,Promise.all([he,re,ve]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return A=S.filter(function(Ce){return Ce.simd===void 0||Ce.simd&&C||!Ce.simd&&!C}).map(function(Ce){return x.locateFile(Ce.url,x.ha)}),importScripts.apply(null,l(A)),D=x,w(Le,createMediapipeSolutionsWasm(Module),6);case 6:D.i=Le.i,x.m=new OffscreenCanvas(1,1),x.i.canvas=x.m,L=x.i.GL.createContext(x.m,{antialias:!1,alpha:!1,va:typeof WebGL2RenderingContext<"u"?2:1}),x.i.GL.makeContextCurrent(L),Le.h=4;break;case 7:if(x.m=document.createElement("canvas"),Xe=x.m.getContext("webgl2",{}),!Xe&&(Xe=x.m.getContext("webgl",{}),!Xe))return alert("Failed to create WebGL canvas context when passing video frame."),Le.return();x.K=Xe,x.i.canvas=x.m,x.i.createContext(x.m,!0,!0,{});case 4:x.j=new x.i.SolutionWasm,x.ga=!1,Le.h=0}})}function aL(x){var S,C,A,D,L,P,X,re;return M(function(he){if(he.h==1){if(x.h.graph&&x.h.graph.url&&x.fa===x.h.graph.url)return he.return();if(x.u=!0,!x.h.graph||!x.h.graph.url){he.h=2;return}return x.fa=x.h.graph.url,w(he,Df(x,x.h.graph.url),3)}for(he.h!=2&&(S=he.i,x.j.loadGraph(S)),C=o(Object.keys(x.D)),A=C.next();!A.done;A=C.next())D=A.value,x.j.overrideFile(D,x.D[D]);if(x.D={},x.h.listeners)for(L=o(x.h.listeners),P=L.next();!P.done;P=L.next())X=P.value,uL(x,X);re=x.l,x.l={},x.setOptions(re),he.h=0})}t.reset=function(){var x=this;return M(function(S){x.j&&(x.j.reset(),x.s={},x.v={}),S.h=0})},t.setOptions=function(x,S){var C=this;if(S=S||this.h.options){for(var A=[],D=[],L={},P=o(Object.keys(x)),X=P.next();!X.done;L={X:L.X,Y:L.Y},X=P.next())if(X=X.value,!(X in this.l&&this.l[X]===x[X])){this.l[X]=x[X];var re=S[X];re!==void 0&&(re.onChange&&(L.X=re.onChange,L.Y=x[X],A.push(function(he){return function(){var ve;return M(function(Xe){if(Xe.h==1)return w(Xe,he.X(he.Y),2);ve=Xe.i,ve===!0&&(C.u=!0),Xe.h=0})}}(L))),re.graphOptionXref&&(X=Object.assign({},{calculatorName:"",calculatorIndex:0},re.graphOptionXref,{valueNumber:re.type===1?x[X]:0,valueBoolean:re.type===0?x[X]:!1,valueString:re.type===2?x[X]:""}),D.push(X)))}(A.length!==0||D.length!==0)&&(this.u=!0,this.H=(this.H===void 0?[]:this.H).concat(D),this.F=(this.F===void 0?[]:this.F).concat(A))}};function iL(x){var S,C,A,D,L,P,X;return M(function(re){switch(re.h){case 1:if(!x.u)return re.return();if(!x.F){re.h=2;break}S=o(x.F),C=S.next();case 3:if(C.done){re.h=5;break}return A=C.value,w(re,A(),4);case 4:C=S.next(),re.h=3;break;case 5:x.F=void 0;case 2:if(x.H){for(D=new x.i.GraphOptionChangeRequestList,L=o(x.H),P=L.next();!P.done;P=L.next())X=P.value,D.push_back(X);x.j.changeOptions(D),D.delete(),x.H=void 0}x.u=!1,re.h=0}})}t.initialize=function(){var x=this;return M(function(S){return S.h==1?w(S,sL(x),2):S.h!=3?w(S,aL(x),3):w(S,iL(x),0)})};function Df(x,S){var C,A;return M(function(D){return S in x.L?D.return(x.L[S]):(C=x.locateFile(S,""),A=fetch(C).then(function(L){return L.arrayBuffer()}),x.L[S]=A,D.return(A))})}t.overrideFile=function(x,S){this.j?this.j.overrideFile(x,S):this.D[x]=S},t.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},t.send=function(x,S){var C=this,A,D,L,P,X,re,he,ve,Xe;return M(function(Le){switch(Le.h){case 1:return C.h.inputs?(A=1e3*(S??performance.now()),w(Le,C.I,2)):Le.return();case 2:return w(Le,C.initialize(),3);case 3:for(D=new C.i.PacketDataList,L=o(Object.keys(x)),P=L.next();!P.done;P=L.next())if(X=P.value,re=C.h.inputs[X]){e:{var Ce=x[X];switch(re.type){case"video":var Ye=C.s[re.stream];if(Ye||(Ye=new B0(C.i,C.K),C.s[re.stream]=Ye),Ye.m===0&&(Ye.m=Ye.i.createTexture()),typeof HTMLVideoElement<"u"&&Ce instanceof HTMLVideoElement)var it=Ce.videoWidth,zt=Ce.videoHeight;else typeof HTMLImageElement<"u"&&Ce instanceof HTMLImageElement?(it=Ce.naturalWidth,zt=Ce.naturalHeight):(it=Ce.width,zt=Ce.height);zt={glName:Ye.m,width:it,height:zt},it=Ye.h,it.canvas.width=zt.width,it.canvas.height=zt.height,it.activeTexture(it.TEXTURE0),Ye.i.bindTexture2d(Ye.m),it.texImage2D(it.TEXTURE_2D,0,it.RGBA,it.RGBA,it.UNSIGNED_BYTE,Ce),Ye.i.bindTexture2d(0),Ye=zt;break e;case"detections":for(Ye=C.s[re.stream],Ye||(Ye=new JP(C.i),C.s[re.stream]=Ye),Ye.data||(Ye.data=new Ye.h.DetectionListData),Ye.data.reset(Ce.length),zt=0;zt<Ce.length;++zt){it=Ce[zt];var Ot=Ye.data,qn=Ot.setBoundingBox,Ss=zt,zr=it.la,vt=new Of;if(Ta(vt,1,zr.sa),Ta(vt,2,zr.ta),Ta(vt,3,zr.height),Ta(vt,4,zr.width),Ta(vt,5,zr.rotation),Ca(vt,6,zr.pa),zr=vt.l(),qn.call(Ot,Ss,zr),it.ea)for(Ot=0;Ot<it.ea.length;++Ot){vt=it.ea[Ot],qn=Ye.data,Ss=qn.addNormalizedLandmark,zr=zt,vt=Object.assign({},vt,{visibility:vt.visibility?vt.visibility:0});var Xn=new gh;Ta(Xn,1,vt.x),Ta(Xn,2,vt.y),Ta(Xn,3,vt.z),vt.visibility&&Ta(Xn,4,vt.visibility),vt=Xn.l(),Ss.call(qn,zr,vt)}if(it.ba)for(Ot=0;Ot<it.ba.length;++Ot)qn=Ye.data,Ss=qn.addClassification,zr=zt,vt=it.ba[Ot],Xn=new Hl,Ta(Xn,2,vt.qa),vt.index&&Ca(Xn,1,vt.index),vt.label&&Ca(Xn,3,vt.label),vt.displayName&&Ca(Xn,4,vt.displayName),vt=Xn.l(),Ss.call(qn,zr,vt)}Ye=Ye.data;break e;default:Ye={}}}switch(he=Ye,ve=re.stream,re.type){case"video":D.pushTexture2d(Object.assign({},he,{stream:ve,timestamp:A}));break;case"detections":Xe=he,Xe.stream=ve,Xe.timestamp=A,D.pushDetectionList(Xe);break;default:throw Error("Unknown input config type: '"+re.type+"'")}}return C.j.send(D),w(Le,C.I,4);case 4:D.delete(),Le.h=0}})};function oL(x,S,C){var A,D,L,P,X,re,he,ve,Xe,Le,Ce,Ye,it,zt;return M(function(Ot){switch(Ot.h){case 1:if(!C)return Ot.return(S);for(A={},D=0,L=o(Object.keys(C)),P=L.next();!P.done;P=L.next())X=P.value,re=C[X],typeof re!="string"&&re.type==="texture"&&S[re.stream]!==void 0&&++D;1<D&&(x.M=!1),he=o(Object.keys(C)),P=he.next();case 2:if(P.done){Ot.h=4;break}if(ve=P.value,Xe=C[ve],typeof Xe=="string")return it=A,zt=ve,w(Ot,lL(x,ve,S[Xe]),14);if(Le=S[Xe.stream],Xe.type==="detection_list"){if(Le){for(var qn=Le.getRectList(),Ss=Le.getLandmarksList(),zr=Le.getClassificationsList(),vt=[],Xn=0;Xn<qn.size();++Xn){var Ni=XP(qn.get(Xn)),cL=Ea(Ni,1),hL=Ea(Ni,2),dL=Ea(Ni,3),pL=Ea(Ni,4),fL=Ea(Ni,5,0),Mf=void 0;Mf=Mf===void 0?0:Mf,Ni={la:{sa:cL,ta:hL,height:dL,width:pL,rotation:fL,pa:Rf(Xs(Ni,6),Mf)},ea:z0(Ss.get(Xn)),ba:YP(HP(zr.get(Xn)))},vt.push(Ni)}qn=vt}else qn=[];A[ve]=qn,Ot.h=7;break}if(Xe.type==="proto_list"){if(Le){for(qn=Array(Le.size()),Ss=0;Ss<Le.size();Ss++)qn[Ss]=Le.get(Ss);Le.delete()}else qn=[];A[ve]=qn,Ot.h=7;break}if(Le===void 0){Ot.h=3;break}if(Xe.type==="float_list"){A[ve]=Le,Ot.h=7;break}if(Xe.type==="proto"){A[ve]=Le,Ot.h=7;break}if(Xe.type!=="texture")throw Error("Unknown output config type: '"+Xe.type+"'");return Ce=x.v[ve],Ce||(Ce=new B0(x.i,x.K),x.v[ve]=Ce),w(Ot,SS(Ce,Le,x.M),13);case 13:Ye=Ot.i,A[ve]=Ye;case 7:Xe.transform&&A[ve]&&(A[ve]=Xe.transform(A[ve])),Ot.h=3;break;case 14:it[zt]=Ot.i;case 3:P=he.next(),Ot.h=2;break;case 4:return Ot.return(A)}})}function lL(x,S,C){var A;return M(function(D){return typeof C=="number"||C instanceof Uint8Array||C instanceof x.i.Uint8BlobList?D.return(C):C instanceof x.i.Texture2dDataOut?(A=x.v[S],A||(A=new B0(x.i,x.K),x.v[S]=A),D.return(SS(A,C,x.M))):D.return(void 0)})}function uL(x,S){for(var C=S.name||"$",A=[].concat(l(S.wants)),D=new x.i.StringList,L=o(S.wants),P=L.next();!P.done;P=L.next())D.push_back(P.value);L=x.i.PacketListener.implement({onResults:function(X){for(var re={},he=0;he<S.wants.length;++he)re[A[he]]=X.get(he);var ve=x.listeners[C];ve&&(x.I=oL(x,re,S.outs).then(function(Xe){Xe=ve(Xe);for(var Le=0;Le<S.wants.length;++Le){var Ce=re[A[Le]];typeof Ce=="object"&&Ce.hasOwnProperty&&Ce.hasOwnProperty("delete")&&Ce.delete()}Xe&&(x.I=Xe)}))}}),x.j.attachMultiListener(D,L),D.delete()}t.onResults=function(x,S){this.listeners[S||"$"]=x},q("Solution",W0),q("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"});function NS(x){switch(x===void 0&&(x=0),x){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function CS(x){var S=this;x=x||{},this.h=new W0({locateFile:x.locateFile,files:function(C){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:NS(C.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:z0},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:z0},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:typeof window!="object"||window.navigator===void 0?!1:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(C){var A,D,L;return M(function(P){return P.h==1?(A=NS(C),D="third_party/mediapipe/modules/pose_landmark/"+A,w(P,Df(S.h,A),2)):(L=P.i,S.h.overrideFile(D,L),P.return(!0))})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}t=CS.prototype,t.reset=function(){this.h.reset()},t.close=function(){return this.h.close(),Promise.resolve()},t.onResults=function(x){this.h.onResults(x)},t.initialize=function(){var x=this;return M(function(S){return w(S,x.h.initialize(),0)})},t.send=function(x,S){var C=this;return M(function(A){return w(A,C.h.send(x,S),0)})},t.setOptions=function(x){this.h.setOptions(x)},q("Pose",CS),q("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),q("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),q("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),q("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),q("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),q("VERSION","0.5.1675469404")}).call(aa);/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ks=Z();ks.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);ks.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);ks.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1);ks.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0);ks.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);ks.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);ks.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);ks.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);ks.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1);ks.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1);ks.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);ks.registerFlag("WEBGPU_PRINT_SHADER",()=>"");ks.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class gpe{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return this.vendor==="intel"}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class ype{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,n,r=!1,s=!0){let a;const i=SC(e,n);return s?(this.freeBuffers.has(i)||this.freeBuffers.set(i,[]),this.freeBuffers.get(i).length>0?(a=this.freeBuffers.get(i).pop(),this.numFreeBuffers--):(a=this.device.createBuffer({size:e,usage:n,mappedAtCreation:r}),this.numBytesAllocated+=e)):(a=this.device.createBuffer({size:e,usage:n,mappedAtCreation:r}),this.numBytesAllocated+=e),this.usedBuffers.has(i)||this.usedBuffers.set(i,[]),this.usedBuffers.get(i).push(a),this.numUsedBuffers++,this.numBytesUsed+=e,a}releaseBuffer(e,n=!0){if(this.freeBuffers.size===0)return;const r=e.size,s=e.usage,a=SC(r,s),i=this.usedBuffers.get(a),o=i.indexOf(e);if(o<0)throw new Error("Cannot find the buffer in buffer manager");i[o]=i[i.length-1],i.pop(),this.numUsedBuffers--,this.numBytesUsed-=r,n?(this.freeBuffers.get(a).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=r)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,n)=>{e.forEach(r=>{r.destroy()})}),this.usedBuffers.forEach((e,n)=>{e.forEach(r=>{r.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function SC(t,e){return`${t}_${e}`}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class bpe{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,n,r,s){const a=NC(r),i=e*n*a,o=IC(e,n,r,s);if(this.freeTextures.has(o)||this.freeTextures.set(o,[]),this.usedTextures.has(o)||this.usedTextures.set(o,[]),this.numBytesUsed+=i,this.numUsedTextures++,this.freeTextures.get(o).length>0){this.numFreeTextures--;const u=this.freeTextures.get(o).shift();return this.usedTextures.get(o).push(u),u}this.numBytesAllocated+=i;const l=this.device.createTexture({size:[e,n],format:r,usage:s});return this.usedTextures.get(o).push(l),l}releaseTexture(e){if(this.freeTextures.size===0)return;const n=e.width,r=e.height,s=e.format,a=e.usage,i=IC(n,r,s,a);this.freeTextures.has(i)||this.freeTextures.set(i,[]),this.freeTextures.get(i).push(e),this.numFreeTextures++,this.numUsedTextures--;const o=this.usedTextures.get(i),l=o.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");o.splice(l,1);const u=NC(s),c=n*r*u;this.numBytesUsed-=c}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,n)=>{e.forEach(r=>{r.destroy()})}),this.usedTextures.forEach((e,n)=>{e.forEach(r=>{r.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function IC(t,e,n,r){return`${t}_${e}_${n}_${r}`}function NC(t){if(t==="rgba8unorm")return 16;throw new Error(`${t} is not supported!`)}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function xpe(t,e){if(Math.max(...t)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const n=t.length,r="xyzwuv",s=t.map(i=>`${e}.${r[i]}`),a=new Array(n-1);a[n-2]=s[n-1];for(let i=n-3;i>=0;--i)a[i]=`(${a[i+1]} * ${s[i+1]})`;return a}const No=(t,e,n)=>n==="int32"?`atomicAdd(${t}, bitcast<i32>(${e}));`:`
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${e});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${t}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/var Gu;(function(t){t[t.FROM_PIXELS=0]="FROM_PIXELS",t[t.DRAW=1]="DRAW"})(Gu||(Gu={}));const vpe=(t,e,n,r,s)=>{const a={dtype:r.dtype,shape:r.shape},i=kpe(n,a,e),o=t.createShaderModule({code:i,label:e.constructor.name});let l=Z().get("WEBGPU_PRINT_SHADER");if(l!==""){l=l.toLowerCase();const u=l.split(",");(l==="all"||u.some(c=>e.shaderKey.toLowerCase().includes(c)))&&(console.group(e.shaderKey),console.debug(i),console.groupEnd())}return s?t.createComputePipelineAsync({compute:{module:o,entryPoint:"_start"},label:e.constructor.name,layout:"auto"}):t.createComputePipeline({compute:{module:o,entryPoint:"_start"},label:e.constructor.name,layout:"auto"})},rt=(t,e="f32")=>{switch(t){case 1:return`${e}`;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${t}-component ${e} is not supported.`)}};function sn(t){if(t<=1)return"i32";if(t===2)return"vec2<i32>";if(t===3)return"vec3<i32>";if(t===4)return"vec4<i32>";if(t===5)return"vec5";if(t===6)return"vec6";throw Error(`GPU for rank ${t} is not yet supported`)}function oi(t){if(t===0)return"x";if(t===1)return"y";if(t===2)return"z";if(t===3)return"w";if(t===4)return"u";if(t===5)return"v";throw Error(`Index ${t} is not yet supported`)}function ge(...t){let e;switch(t.length){case 0:e=`
        fn main()
      `;break;case 1:e=`
        fn main(${t[0]} : i32)
      `;break;default:throw Error("Unreachable")}return e}function CC(t,e){let n;return n=`
     ${wpe(e)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${t?"main(getGlobalIndex());":"main();"};
      }
    `,n}function wpe(t){return`
  @compute @workgroup_size(${t.workgroupSize[0]}, ${t.workgroupSize[1]}, ${t.workgroupSize[2]})
`}function kpe(t,e,n){const r=[],s=n.workgroupSize[0]*n.workgroupSize[1]*n.workgroupSize[2];if(n.outputComponent=n.outputComponent?n.outputComponent:1,r.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${RM(n)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${s}u +
                localIndex);
        `}
      }
    `),n.pixelsOpType!=null){const p=n.pixelsOpType===Gu.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${Bo(e.dtype,n.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${Bo(t[0].dtype,n.outputComponent)}>;`,f=e.shape.length===3?"vec2<i32>":"i32";r.push(`
        struct Uniform {
          outShapeStrides : ${f},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${p}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);const m=EC(n);return[TC,r.join(`
`),Am(e.shape),n.getUserCode(),CC(m,n)].join(`
`)}let a,i,o="struct Uniforms { NAN : f32, INFINITY : f32, ";n.variableNames.forEach((p,f)=>{const m=sn(t[f].shape.length);o+=`${p.charAt(0).toLowerCase()+p.slice(1)}Shape : ${m}, `,a=t[f].shape.length-1,i=sn(a),o+=`${p.charAt(0).toLowerCase()+p.slice(1)}ShapeStrides: ${i}, `});const l=sn(e.shape.length);o+=`outShape : ${l}, `,a=e.shape.length-1,i=sn(a),o+=`
         outShapeStrides: ${i}, `,n.size&&(o+="size : i32, "),n.uniforms&&(o+=n.uniforms),o+="};",o=Ape(o),r.push(o),n.atomic?r.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):r.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${Bo(e.dtype,n.outputComponent)}>;
    `),n.variableNames.forEach((p,f)=>{r.push(`
      @group(0) @binding(${1+f}) var<storage, read> ${p}: array<${n.variableComponents?Bo(t[f].dtype,n.variableComponents[f]):Bo(t[f].dtype,n.outputComponent)}>;
        `)}),o!==""&&r.push(`
      @group(0) @binding(${1+n.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);const u=Epe(e.shape,n.dispatchLayout),c=[TC,r.join(`
`)+Ipe,Am(e.shape),u,$pe(e.shape.length)];n.atomic||c.push(Rpe(e.shape,e.dtype,n.outputComponent)),n.variableNames.forEach((p,f)=>{c.push(`${Am(t[f].shape,p)}`)});const h=t.map((p,f)=>Tpe(p,e.shape,n.variableComponents?n.variableComponents[f]:n.outputComponent,n.dispatchLayout.x.length===e.shape.length)).join(`
`);c.push(h),c.push(n.getUserCode());const d=EC(n);return c.push(CC(d,n)),c.join(`
`)}function Spe(t,e,n){let r=t.shaderKey;if(t.pixelsOpType!=null)return r;const s=[],a=[];e.forEach(c=>{s.push(c.shape),a.push(c.dtype)}),s.push(n.shape),a.push(n.dtype);const i=e.map(c=>fi(c.shape,n.shape)),o=e.map(c=>Je(c.shape,n.shape)).join("_"),l=i.map(c=>c.join("_")).join(";"),u=RM(t)?"flatDispatch":"";return r+="_"+(t.workgroupSize?t.workgroupSize.join(","):"")+s.map(c=>c.length).join(",")+a.join(",")+t.variableNames.join(",")+l+o+u,r}const TC=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`,Ipe=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function Am(t,e=""){const n=t.length,r=e!==""?`get${e.charAt(0).toUpperCase()+e.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",s=e!==""?`${e.charAt(0).toLowerCase()+e.slice(1)}ShapeStrides`:"outShapeStrides";if(n<=1)return`fn ${r}(index : i32) -> i32 { return index; }`;const a=Fe(t),i=sn(n),o=[];for(let u=0;u<n;u++)o.push(`d${u}`);if(a.length===1)return`    fn ${r}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${s}; let d1 = index - d0 * uniforms.${s};
      return vec2<i32>(d0, d1);
    }`;let l;return l="var index2 = index;"+a.map((u,c)=>{const h=`let ${o[c]} = index2 / uniforms.${s}.${oi(c)}`,d=c===a.length-1?`let ${o[c+1]} = index2 - ${o[c]} * uniforms.${s}.${oi(c)}`:`index2 = index2 - ${o[c]} * uniforms.${s}.${oi(c)}`;return`${h}; ${d};`}).join(""),`
    fn ${r}(index : i32) -> ${i} {
      ${l}
      return ${i}(${o.join(",")});
    }
  `}function Npe(t,e){const n=t.name,r=t.shape.length,s=sn(r),a="get"+n.charAt(0).toUpperCase()+n.slice(1),i=["d0","d1","d2","d3","d4","d5"].slice(0,r),o=i.map(c=>`${c} : i32`).join(", ");if(r<1)return`
      fn ${a}() -> ${rt(e)} {
        return ${rt(e)}(${n}[0]);
      }
    `;const l=`uniforms.${n.charAt(0).toLowerCase()+n.slice(1)}Shape`;let u=`${r}D`;return r===0&&(u="1D"),`
    fn ${a}(${o}) -> ${rt(e)} {
      return ${rt(e)}(${n}[getIndexFromCoords${u}(${s}(${i.join(",")}),
        ${l})${e===1?"":` / ${e}`}]);
    }
   `}function Cpe(t,e,n,r){const s=t.name,a=s.charAt(0).toUpperCase()+s.slice(1),i="get"+a+"ByOutput",o=t.shape.length,l=e.length,u=sn(l);if(Je(t.shape,e)&&r)return`
    fn ${i}Index(globalIndex : i32) -> ${rt(n)} {
      return ${rt(n)}(${s}[globalIndex]);
    }

    fn ${i}Coords(coords : ${u}) -> ${rt(n)} {
      return ${rt(n)}(${s}[${l>1?"getOutputIndexFromCoords(coords)":"coords"}${n===1?"":` / ${n}`}]);
    }
    `;const c=fi(t.shape,e),h=l-o;let d="";if(o===0)return`
    fn ${i}Index(globalIndex : i32) -> ${rt(n)}{
      return get${a}();
    }

    fn ${i}Coords(coords : ${u}) -> ${rt(n)}{
      return get${a}();
    }
  `;l<2&&c.length>=1?d="coords = 0;":d=c.map(y=>`coords.${oi(y+h)} = 0;`).join(`
`);let p="";if(l<2&&o>0)p="coords";else if(l>1){const y=sn(o),g=t.shape.map((b,v)=>`coords.${oi(v+h)}`).join(", ");p=`${y}(${g})`}else p="coords";const f=`uniforms.${s.charAt(0).toLowerCase()+s.slice(1)}Shape`,m=`${o}D`;return`
  fn ${i}Index(globalIndex : i32) -> ${rt(n)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${d}
    return ${rt(n)}(${s}[getIndexFromCoords${m}(${p}, ${f})${n===1?"":` / ${n}`}]);
  }

  fn ${i}Coords(coordsIn : ${u}) -> ${rt(n)} {
    var coords = coordsIn;
    ${d}
    return ${rt(n)}(${s}[getIndexFromCoords${m}(${p}, ${f})${n===1?"":` / ${n}`}]);
  }
`}function Tpe(t,e,n,r){let s=Npe(t,n);return t.shape.length<=e.length&&(s+=Cpe(t,e,n,r)),s}function Epe(t,e){const{x:n,y:r=[],z:s=[]}=e,a=t.length,i=n.length+r.length+s.length;if(i!==a)return"";if(n.length===a)return`fn getOutputCoords() -> ${sn(a)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let o="";const l=[n,r,s];for(let d=0;d<l.length;d++){const p=l[d];if(p.length!==0)if(p.length===1)o+=`let d${p[0]} = i32(globalId[${d}]);`;else{const f=xpe(p,"uniforms.outShape");o+=`var index${d} = i32(globalId[${d}]);`;for(let m=0;m<f.length;m++)o+=`let d${p[m]} = index${d} / ${f[m]};`,m===f.length-1?o+=`let d${p[m+1]} = index${d} - d${p[m]} * ${f[m]};`:o+=`index${d} = index${d} - d${p[m]} * ${f[m]};`}}const u=[];for(let d=0;d<i;d++)u.push(`d${d}`);const c=sn(i);let h=`fn getOutputCoords() -> ${c} {
  ${o}
`;return u.length===0?h+=`return ${c}(0); }`:h+=`return ${c}(${u.join(",")}); }`,h}function $pe(t){let e="";switch(t){case 0:case 1:e+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:e+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:e+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:e+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:e+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:e+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:R(!1,()=>`Unsupported ${t}D shape`);break}return e}function RM(t){return t.dispatch[1]===1&&t.dispatch[2]===1}function Bo(t,e=1){if(t==="float32")return rt(e,"f32");if(t==="int32"||t==="bool")return rt(e,"i32");throw new Error(`type ${t} is not supported.`)}function Rpe(t,e,n){const r=t.length,s=Bo(e,n);let a=`fn setOutputAtIndex(flatIndex : i32, value : ${rt(n)}) {
      result[flatIndex] = ${s}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${rt(n,"i32")}) {
      result[flatIndex] = ${s}(value);
    }
    `;if(r>=2){const i=["d0","d1","d2","d3","d4","d5"].slice(0,r),o=sn(r);a+=`
      fn setOutputAtCoords(${i.map(l=>`${l} : i32`).join(", ")}, value : ${rt(n)}) {
        let flatIndex = getOutputIndexFromCoords(${o}(${i.join(", ")}));
        setOutputAtIndex(flatIndex${n===1?"":` / ${n}`}, value);
      }
      fn setOutputAtCoordsI32(${i.map(l=>`${l} : i32`).join(", ")}, value : ${rt(n,"i32")}) {
        let flatIndex = getOutputIndexFromCoords(${o}(${i.join(", ")}));
        setOutputAtIndexI32(flatIndex${n===1?"":` / ${n}`}, value);
      }
    `}return a}function Ape(t){const e=/(\w+)\s*:\s*vec(5|6)/g;t=t.replace(e,r=>"@align(16) "+r);const n=/vec(5|6)\s*,\s*(\w+)/g;return t=t.replace(n,(r,s,a)=>`vec${s}, @align(16) ${a}`),t}function EC(t){return!(t.dispatchLayout.hasOwnProperty("y")&&t.dispatchLayout.y.length!==0||t.dispatchLayout.hasOwnProperty("z")&&t.dispatchLayout.z.length!==0)}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const el=t=>{let e=1;for(let n=0;n<t.length;n++)e*=t[n];return e};function ye(t,e,n=[1,1,1],r=[1,1,1]){const[s,a,i]=[Math.ceil(el(t.x.map(o=>e[o]))/(n[0]*r[0])),t.y?Math.ceil(el(t.y.map(o=>e[o]))/(n[1]*r[1])):1,t.z?Math.ceil(el(t.z.map(o=>e[o]))/(n[2]*r[2])):1];return[s,a,i]}function _pe(t,e,n,r=!1){const s=[8,8,1],a=[4,4,1];return r||(t<=8&&(a[1]=1),e<=16&&n<=16&&(s[0]=4)),{workgroupSize:s,elementsPerThread:a}}function AM(t,e,n=!1){if(n)return[8,8,1];const r=el(t.x.map(a=>e[a])),s=el(t.y.map(a=>e[a]));return r<=4?[4,16,1]:s<=4?[16,4,1]:[16,16,1]}function _M(t,e,n=!1){if(n)return[4,4,1];const r=el(t.x.map(a=>e[a])),s=el(t.y.map(a=>e[a]));return r<=4?[1,2,1]:s<=4?[2,1,1]:[2,2,1]}function Ne(t){return{x:t.map((e,n)=>n)}}function $C(t){if(t==="float32"||t==="int32"||t==="bool"||t==="string")return 4;if(t==="complex64")return 8;throw new Error(`Unknown dtype ${t}`)}function FM(){return!!(typeof globalThis<"u"&&globalThis.navigator&&globalThis.navigator.gpu)}function OM(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&R(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGPU backend.`)})}var Aa;(function(t){t[t.MatMulReduceProgram=0]="MatMulReduceProgram",t[t.MatMulSplitKProgram=1]="MatMulSplitKProgram",t[t.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",t[t.MatMulPackedProgram=3]="MatMulPackedProgram",t[t.MatMulMax=4]="MatMulMax"})(Aa||(Aa={}));/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Fpe=Z().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),Ope=(t,e)=>{const n=t.limits.maxComputeWorkgroupsPerDimension,r=e.dispatchLayout,s=e.dispatch;if(s.every(i=>i<=n))return s;R(s[0]>n&&r.y===void 0&&r.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let a=Math.ceil(Math.sqrt(s[0]));return a>n?(a=Math.ceil(Math.cbrt(s[0])),R(a<=n,()=>"Total dispatch size exceeds WebGPU maximum."),[a,a,a]):[a,a,1]};class ih extends ty{nextDataId(){return ih.nextDataId++}constructor(e,n){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!FM())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new gpe(n),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new ype(this.device),this.textureManager=new bpe(this.device),this.tensorMap=new Rw(this,ir()),Z().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(e,n=!1){if(!this.tensorMap.has(e))return!0;const r=this.tensorMap.get(e);return n?r.refCount=0:r.refCount--,r.refCount>0?!1:(r.complexTensorInfos!=null&&(this.disposeData(r.complexTensorInfos.real.dataId),this.disposeData(r.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(e)?(this.tensorDataPendingDisposal.push(e),!0):(this.releaseResource(e),this.tensorMap.delete(e),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const n=this.tensorMap.get(e);if(!(!n||!n.resource)){if(n.external){n.resource=null;return}n.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(n.resource):n.resource instanceof GPUTexture&&this.textureManager.releaseTexture(n.resource),n.resource=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){const n=this.tensorMap.get(e);n.refCount++}decRef(e){if(this.tensorMap.has(e)){const n=this.tensorMap.get(e);n.refCount--}}write(e,n,r){if(r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.tensorMap.set(s,{dtype:r,shape:n,values:e,refCount:1}),s}move(e,n,r,s,a){if(s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:s,shape:r,values:n,refCount:a})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let e;try{e=await Promise.all(Object.values(this.pipelineCache))}catch(n){throw new Error(n.message)}Object.keys(this.pipelineCache).map((n,r)=>{this.pipelineCache[n]=e[r]})}async getBufferData(e){if(Z().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const n=e.size,r=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,r,0,n),this.submitQueue(),await r.mapAsync(GPUMapMode.READ);const s=r.getMappedRange().slice(0);return r.unmap(),r!=null&&this.bufferManager.releaseBuffer(r),Z().getBool("WEBGPU_USE_PROFILE_TOOL")&&(R(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),s}convertAndCacheOnCPU(e,n){const r=this.tensorMap.get(e);return r.values=n,r.values}readSync(e){const n=this.tensorMap.get(e),{values:r,complexTensorInfos:s}=n;if(r!=null||n.dtype==="string")return r;if(n.dtype==="complex64"){const m=this.readSync(s.real.dataId),y=this.readSync(s.imag.dataId),g=Jh(fa(m,y).buffer,"float32");return this.convertAndCacheOnCPU(e,g),g}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const a=["opaque","premultiplied"],i=n.resource,o=i.size;R(o%4===0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");const l=o/4,u=new ArrayBuffer(o),c=256,h=256,d=a.map(m=>new OffscreenCanvas(c,h)),p=new OffscreenCanvas(c,h);this.endComputePassEncoder(),d.map((m,y)=>{const g=m.getContext("webgpu");return g.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:a[y]}),g.getCurrentTexture()}).map((m,y)=>{const g=c*4,b=(E,_,O)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:i,bytesPerRow:g,offset:O},{texture:m},{width:E,height:_}),this.submitQueue();const M=p.getContext("2d",{willReadFrequently:!0});M.clearRect(0,0,E,_),M.drawImage(d[y],0,0);const V=M.getImageData(0,0,E,_).data,W=a[y],K=new Uint8ClampedArray(u,O,E*_*4);for(let q=0;q<K.length;q+=4)if(W==="premultiplied")K[q+3]=V[q+3];else{const ee=V[q];K[q]=V[q+2],K[q+1]=V[q+1],K[q+2]=ee}},v=Math.floor(l/(c*h));let w=c,k=h,N=0;for(let E=0;E<v;E++)b(w,k,N),N+=c*h*4;const T=l%(c*h);k=Math.floor(T/c),k>0&&(b(w,k,N),N+=k*(c*4)),w=T%c,w>0&&b(w,1,N)});const f=Jh(u,n.dtype);return this.convertAndCacheOnCPU(e,f),f}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const n=this.tensorMap.get(e),{values:r}=n;if(r!=null)return r;let s;if(n.dtype==="complex64"){const a=await Promise.all([this.read(n.complexTensorInfos.real.dataId),this.read(n.complexTensorInfos.imag.dataId)]),i=a[0],o=a[1];s=fa(i,o)}else{const a=await this.getBufferData(n.resource);s=Jh(a,n.dtype)}return this.convertAndCacheOnCPU(e,s),s}copyBuffer(e){const n=e.size,r=e.usage,s=this.bufferManager.acquireBuffer(n,r);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,s,0,n),this.submitQueue(),s}createTensorFromGPUData(e,n,r){let s=e.buffer;if(r==="complex64")throw new Error("Cannot write to a complex64 dtype. ");const a={id:this.nextDataId()};this.tensorMap.set(a,{dtype:r,shape:n,values:null,refCount:1,external:e.zeroCopy});const i=this.tensorMap.get(a),o=$C(i.dtype)*Q(i.shape);if(e.buffer.size<o)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${o})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!==(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return e.zeroCopy!==!0&&(s=this.copyBuffer(s)),i.resource=s,ir().makeTensorFromDataId(a,n,r,this)}readToGPU(e){const n=this.tensorMap.get(e),{values:r,dtype:s,shape:a,resource:i}=n;if(s==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(i==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const o=i,l=o.size,u=o.usage,c=this.bufferManager.acquireBuffer(l,u);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(i,0,c,0,l),this.submitQueue();const h=this.makeTensorInfo(a,s),d=ir().makeTensorFromTensorInfo(h),p=this.tensorMap.get(h.dataId);return p.resource=c,{tensorRef:d,buffer:c}}bufferSync(e){const n=this.readSync(e.dataId);if(e.dtype==="string")try{const r=n.map(s=>Vs(s));return Qe(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Qe(e.shape,e.dtype,n)}async time(e){!this.supportTimestampQuery&&!this.hasTimestampQueryWarned&&(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const n=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,e();const a=Wa(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),i=Wa(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=n,s&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},l=await Promise.all(a);return o.kernelMs=_w(l),o.getExtraProfileInfo=()=>l.map((u,c)=>({name:i[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,o}makeTensorInfo(e,n,r){return n==="string"&&r!=null&&r.length>0&&Nl(r[0])&&(r=r.map(s=>za(s))),{dataId:this.write(r,e,n),shape:e,dtype:n}}tensorToBinding(e){if(!e)return null;const n=this.tensorMap.get(e.dataId).resource;return n instanceof GPUBuffer?{buffer:n}:n instanceof GPUTexture?n.createView():n}uploadToGPU(e){const n=this.tensorMap.get(e);if(n.resource!=null)return;const r=$C(n.dtype)*Q(n.shape);let s;const a=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(n.values){if(s=this.bufferManager.acquireBuffer(r,a,!0),s.mapState==="unmapped"){const i=this.bufferManager.acquireBuffer(r,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),o=i.getMappedRange();n.dtype==="int32"||n.dtype==="bool"?new Int32Array(o).set(n.values):new Float32Array(o).set(n.values),i.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(i,0,s,0,r),this.stagingPendingDisposal.push(i)}else{const i=s.getMappedRange();n.dtype==="int32"||n.dtype==="bool"?new Int32Array(i).set(n.values):new Float32Array(i).set(n.values),s.unmap()}n.values=null}else s=this.bufferManager.acquireBuffer(r,a);n.resource=s}makeUniforms(e){let n=0,r=0;const s=[];let a=1;e.forEach(l=>{l.data.length===0&&(l.data=[1]);let u;switch(l.data.length){case 1:u=4;break;case 2:u=8;break;case 3:u=16;break;case 4:u=16;break;case 5:u=16;break;case 6:u=16;break;default:R(!1,()=>`Unsupported ${l.data.length}D shape`)}(r===5||r===6)&&(u=16),u>a&&(a=u),n=Math.ceil(n/u)*u,r=l.data.length,s.push(n),n+=l.data.length*4}),n=Math.ceil(n/a)*a;const i=new ArrayBuffer(n);e.forEach((l,u)=>{const c=s[u];l.type==="int32"?new Int32Array(i,c,l.data.length).set(l.data):l.type==="uint32"?new Uint32Array(i,c,l.data.length).set(l.data):new Float32Array(i,c,l.data.length).set(l.data)});const o=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(o,0,i,0,n),this.uniformPendingDisposal.push(o),{offset:0,size:n,buffer:o}}runWebGPUProgram(e,n,r,s,a){if(a||(a=this.makeTensorInfo(e.outputShape,r)),Q(a.shape)===0)return this.tensorMap.get(a.dataId).values=pn(a.dtype,0),a;this.uploadToGPU(a.dataId),e.dispatch=Ope(this.device,e);const i=n.map((l,u)=>{if(l.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(l.dataId),{dtype:this.tensorMap.get(l.dataId).dtype,shape:l.shape,name:e.variableNames[u]}});e.shaderKey=Spe(e,i,a);const o=Z().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return e.shaderKey in this.pipelineCache||(this.pipelineCache[e.shaderKey]=vpe(this.device,e,i,a,o)),e.pipeline=this.pipelineCache[e.shaderKey],o||this.recordAndSubmit(e,a,n,s),a}recordAndSubmit(e,n,r,s){if(e.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let a=[],i=[];const o="int32";if(e.pixelsOpType==null){a.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),i=r.concat(n).map(p=>p.shape);const d="int32";i.map(p=>{a.push({type:d,data:p});const f=Fe(p);a.push({type:d,data:f})})}else{const d=Fe(n.shape);a.push({type:o,data:d})}if(e.size){const d=Q(e.outputShape);a.push({type:o,data:[e.outputComponent?d/e.outputComponent:d]})}s&&(a=[...a,...s]);const l=[this.tensorToBinding(n),...r.map(d=>this.tensorToBinding(d)),this.makeUniforms(a)];r.forEach(d=>{this.commandQueueOwnedIds.add(d.dataId)}),this.commandQueueOwnedIds.add(n.dataId);const u=this.device.createBindGroup({layout:e.pipeline.getBindGroupLayout(0),entries:l.map((d,p)=>({binding:p,resource:d}))}),c=this.activeTimers!=null;this.ensureCommandEncoderReady();const h={};c&&this.supportTimestampQuery?(this.endComputePassEncoder(),this.querySet==null&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),h.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},this.computePassEncoder=this.commandEncoder.beginComputePass(h)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(h)),this.computePassEncoder.setPipeline(e.pipeline),this.computePassEncoder.setBindGroup(0,u),this.computePassEncoder.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),this.dispatchCountInPass++,(c||Z().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||e.pixelsOpType===Gu.DRAW)&&(this.endComputePassEncoder(),c?this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;this.queryResolveBuffer==null&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const e=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,this.querySetCount*8),this.submitQueue(),await e.mapAsync(GPUMapMode.READ);const n=new BigUint64Array(e.getMappedRange()),r=Number(n[1]-n[0])/1e6;return e.unmap(),this.bufferManager.releaseBuffer(e),r}shouldExecuteOnCPU(e,n=Fpe){return Z().getBool("WEBGPU_CPU_FORWARD")&&e.every(r=>this.tensorMap.get(r.dataId).resource==null&&Q(r.shape)<n)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.querySet!=null&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}ih.nextDataId=0;/**
* @license
* Copyright 2022 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/FM()&&qw("webgpu",async()=>{const t={powerPreference:Z().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},e=await navigator.gpu.requestAdapter(t),n={},r=[];e.features.has("timestamp-query")&&r.push("timestamp-query"),e.features.has("bgra8unorm-storage")&&r.push(["bgra8unorm-storage"]),n.requiredFeatures=r;const s=e.limits;n.requiredLimits={maxComputeWorkgroupStorageSize:s.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:s.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:s.maxStorageBufferBindingSize,maxBufferSize:s.maxBufferSize,maxComputeWorkgroupSizeX:s.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:s.maxComputeInvocationsPerWorkgroup};const a=await e.requestDevice(n),i="info"in e?e.info:"requestAdapterInfo"in e?await e.requestAdapterInfo():void 0;return new ih(a,i)},3);/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/var Ve;(function(t){t[t.ADD=0]="ADD",t[t.ATAN2=1]="ATAN2",t[t.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",t[t.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",t[t.DIV=4]="DIV",t[t.ELU_DER=5]="ELU_DER",t[t.EQUAL=6]="EQUAL",t[t.FLOOR_DIV=7]="FLOOR_DIV",t[t.GREATER=8]="GREATER",t[t.GREATER_EQUAL=9]="GREATER_EQUAL",t[t.LESS=10]="LESS",t[t.LESS_EQUAL=11]="LESS_EQUAL",t[t.LOGICAL_AND=12]="LOGICAL_AND",t[t.LOGICAL_OR=13]="LOGICAL_OR",t[t.MAX=14]="MAX",t[t.MIN=15]="MIN",t[t.MOD=16]="MOD",t[t.MUL=17]="MUL",t[t.NOT_EQUAL=18]="NOT_EQUAL",t[t.POW=19]="POW",t[t.PRELU=20]="PRELU",t[t.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",t[t.SUB=22]="SUB"})(Ve||(Ve={}));const Dpe="let resultTemp = a + b;",Mpe="let resultTemp = atan2(a, b);",Ppe="let resultTemp = areal * breal - aimag * bimag;",Lpe="let resultTemp = areal * bimag + aimag * breal;",zpe="let resultTemp = a / b;",Bpe="let resultTemp = select(a * (b + 1.0), a, b >= b - b);",Wpe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`,Upe=`
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`,Vpe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`,jpe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`,Gpe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`,Hpe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`,Kpe="return f32(a >= 1.0 && b >= 1.0);",qpe=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,Xpe="return f32(a >= 1.0 || b >= 1.0);",Ype=`return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`,Qpe="let resultTemp = max(a, b);",Zpe="let resultTemp = min(a, b);",Jpe=`
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`,efe=`
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`,tfe="let resultTemp = a * b;",nfe=`
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`,rfe=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`,sfe=`
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`,afe=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`,ife="if (a < 0.0) { return b * a; }  return a;",ofe=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,lfe="let resultTemp = (a - b) * (a - b);",ufe="let resultTemp = a - b;";function B2(t,e){let n;do{switch(t){case Ve.ATAN2:n=Mpe;break;case Ve.MAX:n=Qpe;break;case Ve.MIN:n=Zpe;break;case Ve.MOD:n=e?efe:Jpe;break;case Ve.NOT_EQUAL:n=e?rfe:nfe;break;case Ve.POW:n=e?afe:sfe;break;default:continue}let r,s,a;return e?(r="isnanVec4",s="vec4<f32>",a="vec4<bool>"):(r="isnan",s="f32",a="bool"),`
      let aIsNaN = ${r}(a);
      let aPostLegalization = select(a, ${s}(42), aIsNaN);
      let bIsNaN = ${r}(b);
      let bPostLegalization = select(b, ${s}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${n}
        return select(
            resultTemp, ${s}(valueForNaN),
            ${a}(isNaN) | aIsNaN | bIsNaN);
      }
    `}while(!1);switch(t){case Ve.ADD:n=Dpe;break;case Ve.COMPLEX_MULTIPLY_IMAG:n=Lpe;break;case Ve.COMPLEX_MULTIPLY_REAL:n=Ppe;break;case Ve.DIV:n=zpe;break;case Ve.ELU_DER:n=Bpe;break;case Ve.EQUAL:n=Wpe;break;case Ve.FLOOR_DIV:n=Upe;break;case Ve.GREATER:n=Vpe;break;case Ve.GREATER_EQUAL:n=jpe;break;case Ve.LESS:n=Gpe;break;case Ve.LESS_EQUAL:n=Hpe;break;case Ve.LOGICAL_AND:return e?qpe:Kpe;case Ve.LOGICAL_OR:return e?Ype:Xpe;case Ve.MUL:n=tfe;break;case Ve.PRELU:return e?ofe:ife;case Ve.SQUARED_DIFFERENCE:n=lfe;break;case Ve.SUB:n=ufe;break}return`
    ${n}
    return resultTemp;
  `}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/var fe;(function(t){t[t.ABS=0]="ABS",t[t.ACOS=1]="ACOS",t[t.ACOSH=2]="ACOSH",t[t.ASIN=3]="ASIN",t[t.ASINH=4]="ASINH",t[t.ATAN=5]="ATAN",t[t.ATANH=6]="ATANH",t[t.CEIL=7]="CEIL",t[t.COS=8]="COS",t[t.COSH=9]="COSH",t[t.ELU=10]="ELU",t[t.ERF=11]="ERF",t[t.EXP=12]="EXP",t[t.EXPM1=13]="EXPM1",t[t.FLOOR=14]="FLOOR",t[t.IS_FINITE=15]="IS_FINITE",t[t.IS_INF=16]="IS_INF",t[t.IS_NAN=17]="IS_NAN",t[t.LINEAR=18]="LINEAR",t[t.LOG=19]="LOG",t[t.LOG1P=20]="LOG1P",t[t.LOGICAL_NOT=21]="LOGICAL_NOT",t[t.NEG=22]="NEG",t[t.RELU=23]="RELU",t[t.RELU6=24]="RELU6",t[t.LEAKYRELU=25]="LEAKYRELU",t[t.RECIPROCAL=26]="RECIPROCAL",t[t.ROUND=27]="ROUND",t[t.RSQRT=28]="RSQRT",t[t.SELU=29]="SELU",t[t.SIGMOID=30]="SIGMOID",t[t.SIGN=31]="SIGN",t[t.SIN=32]="SIN",t[t.SINH=33]="SINH",t[t.SOFTPLUS=34]="SOFTPLUS",t[t.SQRT=35]="SQRT",t[t.SQUARE=36]="SQUARE",t[t.STEP=37]="STEP",t[t.TAN=38]="TAN",t[t.TANH=39]="TANH",t[t.TO_INT=40]="TO_INT"})(fe||(fe={}));const cfe="return abs(a);",hfe=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`,dfe=`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`,pfe=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`,ffe="return asinh(a);",mfe=`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`,gfe=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`,yfe="return ceil(a);",bfe="return cos(a);",xfe=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,vfe="return exp(a) - 1.0;",wfe="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",kfe=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,Sfe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${Wb};
  let a1 = ${Ub};
  let a2 = ${Vb};
  let a3 = ${jb};
  let a4 = ${Gb};
  let a5 = ${Hb};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,Ife="return exp(a);",Nfe="return floor(a);",Cfe="return f32(!isnan(a) && !isinf(a));",Tfe="return f32(isinf(a));",Efe="return f32(isnan(a));",$fe="return a;",Rfe=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,Afe=`
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`,_fe="return f32(!(a >= 1.0));",Ffe="return -a;",Ofe="if (a < 0.0) { return uniforms.alpha * a; } return a;",Dfe=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,Mfe="return 1.0 / a;",Pfe="return select(a, 0.0, a < 0.0);",Lfe="return clamp(a, 0.0, 6.0);",zfe="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",Bfe=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,Wfe="return round(a);",Ufe="return inverseSqrt(a);",Vfe=`
  if (a >= 0.0) {
    return ${cf} * a;
  } else {
    return ${uf} * (exp(a) - 1.0);
  }
`,jfe="return 1.0 / (1.0 + exp(-1.0 * a));",Gfe="return sign(a);",Hfe="return sin(a);",Kfe=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,qfe=`
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`,Xfe="return sqrt(a);",Yfe="return a * a;",Qfe=`
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`,Zfe="return tan(a);",Jfe=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,eme="return f32(i32((a)));";function Do(t,e){switch(t){case fe.ABS:return cfe;case fe.ACOS:return hfe;case fe.ACOSH:return dfe;case fe.ASIN:return pfe;case fe.ASINH:return ffe;case fe.ATAN:return mfe;case fe.ATANH:return gfe;case fe.COS:return bfe;case fe.COSH:return xfe;case fe.CEIL:return yfe;case fe.ELU:return e?kfe:wfe;case fe.ERF:return Sfe;case fe.EXP:return Ife;case fe.EXPM1:return vfe;case fe.FLOOR:return Nfe;case fe.IS_FINITE:return Cfe;case fe.IS_INF:return Tfe;case fe.IS_NAN:return Efe;case fe.LINEAR:return $fe;case fe.LOG:return Rfe;case fe.LOG1P:return Afe;case fe.LOGICAL_NOT:return _fe;case fe.NEG:return Ffe;case fe.LEAKYRELU:return e?Dfe:Ofe;case fe.RECIPROCAL:return Mfe;case fe.RELU:return e?Bfe:Pfe;case fe.RELU6:return e?zfe:Lfe;case fe.ROUND:return Wfe;case fe.RSQRT:return Ufe;case fe.SELU:return Vfe;case fe.SIGMOID:return jfe;case fe.SIGN:return Gfe;case fe.SIN:return Hfe;case fe.SINH:return Kfe;case fe.SOFTPLUS:return qfe;case fe.SQRT:return Xfe;case fe.SQUARE:return Yfe;case fe.STEP:return Qfe;case fe.TAN:return Zfe;case fe.TANH:return Jfe;case fe.TO_INT:return eme;default:throw new Error(`BinaryType ${t} is not implemented!`)}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ii(t,e=!1,n=!1,r=3){if(t===null)return"";let s="";if(t==="linear")s=Do(fe.LINEAR);else if(t==="relu")s=Do(fe.RELU,n);else if(t==="elu")s=Do(fe.ELU,n);else if(t==="relu6")s=Do(fe.RELU6,n);else if(t==="prelu")s=B2(Ve.PRELU,n);else if(t==="sigmoid")s=Do(fe.SIGMOID,n);else if(t==="leakyrelu")s=Do(fe.LEAKYRELU,n);else throw new Error(`Activation ${t} has not been implemented for the WebGPU backend.`);const a=rt(n?4:1);let i="";return e?i=`
      fn activation(a : ${a}, coords : vec${r}<i32>) -> ${a} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${s}
      }`:i=`
      fn activation(a : ${a}, coords : vec${r}<i32>) -> ${a} {
        ${s}
      }`,i}function Ul(t,e){return`
      ${t?"value = value + getBiasByOutputCoords(coords);":""}
      ${e?"value = activation(value, coords);":""}
      `}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function DM(t,e,n=!1,r=!1,s=!1,a=1){R(t&&a===1||!t,()=>`transposeA ${t} is not compatible with component size ${a}`);const i=`
      ${t?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,o=e?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${rt(a)} {
    var value = ${rt(a)}(0.0);
    ${n&&s?i:`
    ${t?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${i}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${rt(a)} {
    var value = ${rt(a)}(0.0);
    ${o}
    return value;
  }
  `}function W2(t,e,n,r,s=!1,a=!1,i=!1,o=1){return`
  ${DM(n,r,s,a,i,o)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${rt(o)}) {
    ${s&&a?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${Ul(t,e)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}const tme=(t,e)=>t?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${e});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${e});
        `,nme=(t,e,n,r)=>{if(t)return`
      for (var k = 0; k < ${r}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${n}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;{let s="",a="";for(let i=0;i<e;i++)s+=`let BCached${i} = mm_Bsub[k * ${e} + ${i}][tileCol];`,a+=`acc[i] = fma(BCached${i}, vec4<f32>(ACached[${i}]), acc[i]);`;return`
      for (var k = 0; k < ${r/e}; k++) {
        ${s}
        for (var i = 0; i < ${n}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${a}
        }
      }`}};function x0(t,e,n=!1,r=32,s=!1,a=32,i=!1){const o=e[1]*t[1],l=e[0]*t[0],u=n?o:r,c=n?r:o,h=u/e[0],d=r/e[1],p=t[1],f=t[0];return R((n&&h===4&&t[1]===4||!n&&(h===3||h===4))&&u%e[0]===0&&r%e[1]===0&&t[0]===4,()=>`If transposeA ${n} is true, innerElementSize ${h} and workPerThread[1] ${t[1]} must be 4.
          Otherwise, innerElementSize ${h} must be 3 or 4.
      tileAWidth ${u} must be divisible by workgroupSize[0]${e[0]}. tileInner ${r} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${t[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${h}<f32>, ${u/h}>, ${c}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${l/t[0]}>, ${r}>;

  ${ge()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${p};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${p};
    let globalCol = i32(globalId.x) * ${f};
    let batch = ${s?"0":"i32(globalId.z)"};
    let batchA = ${s||!i?"batch":"batch % uniforms.aShape[0]"};
    let batchB = ${s||!i?"batch":"batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${o};

    let numTiles = ${s?`${Math.ceil(a/r)}`:`(uniforms.dimInner - 1) / ${r} + 1`};
    var kStart = ${s?`i32(globalId.z) * ${a}`:"0"};

    var acc: array<vec4<f32>, ${p}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${d};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${p}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${tme(n,h)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${d}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${r};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${nme(n,h,p,r)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${p}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}const RC=t=>t?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,rme=t=>t?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function v0(t,e,n=!1,r=32,s=!1,a=32,i=!1,o=!1){const l=t[1]*e[1],u=t[0]*e[0],c=n?l:r,h=n?r:l;R(h%e[1]===0&&c%e[0]===0&&r%e[1]===0,()=>`tileAHight ${h} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${e[0]}, tileInner ${r} must be divisible by workgroupSize[1]${e[1]}`);const d=h/e[1],p=c/e[0],f=r/e[1],m=t[1],y=t[0],g=i?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${l};
      let globalColStart = i32(workgroupId.x) * ${u};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${e[1]}) {
          for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${e[0]}) {
            ${RC(n)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${e[1]}) {
              for (var inputCol = localCol; inputCol < ${u}; inputCol = inputCol + ${e[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${r};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${y}>;
        for (var k = 0; k < ${r}; k++) {
          for (var inner = 0; inner < ${y}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
          }
          for (var innerRow = 0; innerRow < ${m}; innerRow++) {
            let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
            for (var innerCol = 0; innerCol < ${y}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${m}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${e[1]};
        for (var innerCol = 0; innerCol < ${y}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${e[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * ${m};
  let tileCol = i32(localId.x) * ${y};

  let globalRow = i32(globalId.y) * ${m};
  let globalCol = i32(globalId.x) * ${y};
  let globalRowStart = i32(workgroupId.y) * ${l};

  let tileRowA = i32(localId.y) * ${d};
  let tileColA = i32(localId.x) * ${p};
  let tileRowB = i32(localId.y) * ${f};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${d}; innerRow++) {
      for (var innerCol = 0; innerCol < ${p}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${RC(n)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${f}; innerRow++) {
      for (var innerCol = 0; innerCol < ${y}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${r};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${y}>;
    for (var k = 0; k < ${r}; k++) {
      for (var inner = 0; inner < ${y}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${m}; innerRow++) {
        ${rme(n)}
        for (var innerCol = 0; innerCol < ${y}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${m}; innerRow++) {
    for (var innerCol = 0; innerCol < ${y}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${c}>, ${h}>;
    var<workgroup> mm_Bsub : array<array<f32, ${u}>, ${r}>;

    ${ge()} {
      let batch = ${s?"0":"i32(globalId.z)"};
      let batchA = ${s||!o?"batch":"batch % uniforms.aShape[0]"};
      let batchB = ${s||!o?"batch":"batch % uniforms.bShape[0]"};
      let numTiles = ${s?`${Math.ceil(a/r)}`:`(uniforms.dimInner - 1) / ${r} + 1`};
      var kStart = ${s?`i32(globalId.z) * ${a}`:"0"};

      var acc : array<array<f32, ${y}>, ${m}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${m}; innerRow++) {
        for (var innerCol = 0; innerCol < ${y}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${g}
    }
  `}const sme=t=>t?`
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  `:`
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;function ame(t,e=!1){R(t[1]===1&&t[2]===1,()=>`A linear work group size is required. But got ${t}.`);const n=t[0]*4;return`
    var<workgroup> mm_Asub : array<vec4<f32>, ${t[0]}>;

    ${ge()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${n} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${n} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${sme(e)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${n/4}; k++) {
          let rowB = t * ${n} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}class ime{constructor(e,n,r=!1,s=!1,a=null,i=null,o=null,l=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]};const u=r?e[1]:e[2];if(this.isVec4=(u%4===0&&!r||n[1]%4===0&&r)&&n[2]%4===0&&!s,this.outputComponent=this.isVec4?4:1,this.isVectorA=n[1]===1&&!r,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const d=_pe(n[1],u,n[2],r);this.workgroupSize=d.workgroupSize,this.elementsPerThread=d.elementsPerThread}this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const c=a!=null,h=o!=null;c&&this.variableNames.push("bias"),h&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=l,this.transposeA=r,this.transposeB=s,this.addBias=c,this.activation=i,this.hasPreluActivationWeights=h,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(n[1],n[2],u),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${r}_${s}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,n,r){const s=this.workgroupSize[1]*this.elementsPerThread[1],a=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workgroupSize[0]*4:this.tileInner=a;const i=e%s===0,o=n%a===0,l=r%this.tileInner===0;return[i,o,l]}getUserCode(){return`
      ${Ii(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${W2(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?x0(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?ame(this.workgroupSize,this.transposeA):v0(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}
    `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ome(t){return`
    var<workgroup> sumValues : array<f32, ${t}>;
    ${ge()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${t}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${t/2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}class lme{constructor(e,n=!1,r=!1,s=null,a=null,i=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize);const o=s!=null,l=i!=null;o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),this.transposeA=n,this.transposeB=r,this.addBias=o,this.activation=a,this.hasPreluActivationWeights=l,this.shaderKey=`matMulReduce_${this.activation}_${n}_${r}`}getUserCode(){return`
      ${Ii(this.activation,this.hasPreluActivationWeights)}
      ${W2(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${ome(this.workgroupSize[0])}
    `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ume(t){const e=t[1],n=t[0],r=e>n?e:n;return`
  var<workgroup> mm_Asub : array<array<f32, ${r}>, ${e}>;
  var<workgroup> mm_Bsub : array<array<f32, ${n}>, ${r}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${ge()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${r} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${r};
    globalRowB = globalRowB + ${r};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${r};
      globalRowB = globalRowB + ${r};

      for (var k = 0; k < ${r}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}class cme{constructor(e,n,r,s=!1,a=!1,i=null,o=null,l=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=r,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(r[2]/this.workgroupSize[0]),Math.ceil(r[1]/this.workgroupSize[1]),r[0]];const u=i!=null;u&&this.variableNames.push("bias");const c=l!=null;c&&this.variableNames.push("preluActivationWeights"),this.transposeA=s,this.transposeB=a,this.addBias=u,this.activation=o,this.hasPreluActivationWeights=c,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${s}_${a}`}getUserCode(){return`
      ${Ii(this.activation,this.hasPreluActivationWeights)}
      ${W2(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${ume(this.workgroupSize)}
    `}}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class hme{constructor(e,n,r=!1,s=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,R(e[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const a=(r&&this.outputShape[1]%4===0||!r&&n%4===0)&&this.outputShape[2]%4===0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=a?4:1,a||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=ye(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],n],this.workgroupSize,this.elementsPerThread),this.transposeA=r,this.transposeB=s,this.shaderKey=`matMulSplitK_${r}_${s}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const e=this.outputComponent;return`
      ${DM(!1,this.transposeB,!1,!1,!1,e)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${rt(e)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${e}; i = i + 1) {
            ${No("&result[flatIndex + i]",`${e>1?"value[i]":"value"}`,"float32")}
          }
        }
      }
      ${e===4?x0(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):v0(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}}class dme{constructor(e,n=null,r=null,s=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=n!=null,this.hasPreluActivationWeights=s!=null,this.activation=r,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${r}`}getUserCode(){return`
    ${Ii(this.activation,this.hasPreluActivationWeights)}
    ${ge("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${Ul(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class pme{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${ge("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ir(t){const{backend:e,attrs:n}=t,{shape:r,value:s}=n;let{dtype:a}=n;if(a=a||mo(s),a==="string"){const i=Ht(a,Q(r));return i.fill(s),e.makeTensorInfo(r,a,i)}else{const i=new pme(r),o=[{type:"float32",data:[s]}];return e.runWebGPUProgram(i,[],a,o)}}const fme={kernelName:Ey,backendName:"webgpu",kernelFunc:Ir};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ae(t){const{inputs:e,attrs:n}=t,{x:r}=e,{shape:s}=n,a=Q(r.shape),i=ry(s,a),o=Q(i);return R(a===o,()=>`The new shape (${i}) has ${o} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),t.backend.incRef(r.dataId),{dataId:r.dataId,shape:i,dtype:r.dtype}}const mme={kernelName:zp,backendName:"webgpu",kernelFunc:Ae};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function w0({a:t,b:e,transposeA:n,transposeB:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){const u=t.shape.length,c=e.shape.length,h=n?t.shape[u-2]:t.shape[u-1],d=r?e.shape[c-1]:e.shape[c-2],p=n?t.shape[u-1]:t.shape[u-2],f=r?e.shape[c-2]:e.shape[c-1],m=t.shape.slice(0,-2),y=e.shape.slice(0,-2),g=Q(m),b=Q(y),v=Ue(t.shape.slice(0,-2),e.shape.slice(0,-2)).concat([p,f]);R(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${r} must match.`);const w=n?[g,h,p]:[g,p,h],k=r?[b,f,d]:[b,d,f],N=Ae({inputs:{x:t},backend:s,attrs:{shape:w}}),T=Ae({inputs:{x:e},backend:s,attrs:{shape:k}}),E=[N,T],_=Math.max(g,b),O=[N,T],M=[{type:"int32",data:[p]},{type:"int32",data:[f]},{type:"int32",data:[h]}];let V,W;const K=[_,p,f];let q=Z().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(q<0){const te=Z().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),G=te>0?te:s.thresholdToIncreaseWorkgroups,J=_*Math.ceil(p/32)*Math.ceil(f/32);J<=G||p<=8&&J<=G*2?_*p*f<=128?q=Aa.MatMulReduceProgram:_===1&&d>=2e3?q=Aa.MatMulSplitKProgram:q=Aa.MatMulSmallOutputSizeProgram:q=Aa.MatMulPackedProgram}switch(q){case Aa.MatMulReduceProgram:V=new lme(K,n,r,a,l,i);break;case Aa.MatMulSplitKProgram:{if(W=Ir({backend:s,attrs:{shape:K,value:0,dtype:t.dtype}}),V=new hme(K,d,n,r),a||l){W=s.runWebGPUProgram(V,O,t.dtype,M,W);const G=new dme(W.shape,a,l,i);let J=null;const ne=[W];a&&ne.push(a),i&&ne.push(i),l==="leakyrelu"&&(J=[{type:"float32",data:[o]}],G.uniforms+=" alpha : f32,");const ae=s.runWebGPUProgram(G,ne,W.dtype,J);E.push(W);const oe=Ae({inputs:{x:ae},backend:s,attrs:{shape:v}});E.push(ae);for(const ue of E)s.disposeData(ue.dataId);return oe}break}case Aa.MatMulSmallOutputSizeProgram:V=new cme(w,k,K,n,r,a,l,i);break;case Aa.MatMulPackedProgram:const te=s.adapterInfo.isIntel();V=new ime(w,K,n,r,a,l,i,te);break;default:throw new Error(`Unsupported MatMulProgramType ${q}.`)}a&&O.push(a),i&&O.push(i),l==="leakyrelu"&&(M.push({type:"float32",data:[o]}),V.uniforms+=" alpha : f32,"),W=s.runWebGPUProgram(V,O,t.dtype,M,W);const ee=Ae({inputs:{x:W},backend:s,attrs:{shape:v}});E.push(W);for(const te of E)s.disposeData(te.dataId);return ee}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function gme(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:a,bias:i,preluActivationWeights:o}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=r;return w0({a:s,b:a,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:h,activation:c})}const yme={kernelName:vd,backendName:"webgpu",kernelFunc:gme};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class AC{constructor(e,n,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=Ue(n,r),this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${B2(this.op,!1)}
      }

      ${ge("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Dg{constructor(e,n,r){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=Ue(n,r),this.dispatchLayout=Ne(this.outputShape),this.op=e,this.useSharedMemoryWithA=n.length<=1&&r.length>1&&n[0]<128,this.useSharedMemoryWithB=r.length<=1&&n.length>1&&r[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?r[0]:n[0],this.shaderKey=`binary_${e}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const s=n.length>0&&n[n.length-1]%4===0,a=r.length>0&&r[r.length-1]%4===0;s&&a?(this.outputComponent=4,this.variableComponents=[4,4]):s&&(_1(r)||r[r.length-1]===1)||a&&(_1(n)||n[n.length-1]===1)?(this.outputComponent=4,this.variableComponents=s?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${e}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let e;const n=this.outputComponent===4?"vec4<f32>":"f32",r=`
    fn binaryOperation(a : ${n}, b : ${n}) -> ${n} {
      ${B2(this.op,this.outputComponent===4)}
    };
    `;if(this.type==="shared"){const s=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",a=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${s}];`:`let a = sharedBuf[${s}];
          let b = getBByOutputIndex(index);`;e=`
        ${r}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${ge("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${a}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else e=`
       ${r}
       ${ge("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${n}(getAByOutputCoords(coords));
           let b = ${n}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return e}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ts(t){const{inputs:e}=t,{x:n}=e;return t.backend.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const bme={kernelName:gc,backendName:"webgpu",kernelFunc:ts};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Vl(t){const{inputs:e,backend:n}=t,{real:r,imag:s}=e,a=n.makeTensorInfo(r.shape,"complex64"),i=n.tensorMap.get(a.dataId),o=ts({inputs:{x:r},backend:n}),l=ts({inputs:{x:s},backend:n});return i.complexTensorInfos={real:o,imag:l},a}const xme={kernelName:py,backendName:"webgpu",kernelFunc:Vl};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class oh{constructor(e,n,r=""){this.variableNames=["A"],this.size=!0;const s=128;this.workgroupSize=[s,1,1],this.outputShape=e,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=n,r!==""&&(this.uniforms=r),this.shaderKey=`unary_${n}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${Do(this.op,!1)}
      }
      ${ge("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ft({opType:t,cpuKernelImpl:e,dtype:n}){return({inputs:r,backend:s})=>{const{x:a}=r,i=s,o=n||a.dtype;if(i.shouldExecuteOnCPU([a])&&e!=null){const u=i.tensorMap.get(a.dataId),c=e(u.values,o);return i.makeTensorInfo(a.shape,o,c)}const l=new oh(a.shape,t);return i.runWebGPUProgram(l,[a],o)}}function Mn({opType:t,cpuKernelImpl:e,supportsComplex:n=!1,dtype:r}){return({inputs:s,backend:a})=>{const{a:i,b:o}=s,l=a;if(n&&i.dtype==="complex64"){const h=l.tensorMap.get(i.dataId),d=l.tensorMap.get(o.dataId);let p,f;if(t!==Ve.MUL)[p,f]=[[h.complexTensorInfos.real,d.complexTensorInfos.real],[h.complexTensorInfos.imag,d.complexTensorInfos.imag]].map(y=>{const[g,b]=y,v={dataId:g.dataId,dtype:g.dtype,shape:i.shape},w={dataId:b.dataId,dtype:b.dtype,shape:o.shape},k=new Dg(t,i.shape,o.shape);return l.runWebGPUProgram(k,[v,w],On(g.dtype,b.dtype))});else{const y=new AC(Ve.COMPLEX_MULTIPLY_REAL,i.shape,o.shape),g=new AC(Ve.COMPLEX_MULTIPLY_IMAG,i.shape,o.shape),b=[{dataId:h.complexTensorInfos.real.dataId,dtype:h.complexTensorInfos.real.dtype,shape:i.shape},{dataId:h.complexTensorInfos.imag.dataId,dtype:h.complexTensorInfos.imag.dtype,shape:i.shape},{dataId:d.complexTensorInfos.real.dataId,dtype:d.complexTensorInfos.real.dtype,shape:o.shape},{dataId:d.complexTensorInfos.imag.dataId,dtype:d.complexTensorInfos.imag.dtype,shape:o.shape}];p=l.runWebGPUProgram(y,b,"float32"),f=l.runWebGPUProgram(g,b,"float32")}const m=Vl({inputs:{real:p,imag:f},backend:l});return l.disposeData(p.dataId),l.disposeData(f.dataId),m}const u=r||On(i.dtype,o.dtype);if((i.dtype==="string"||o.dtype==="string"||l.shouldExecuteOnCPU([i,o]))&&e!=null){const h=l.tensorMap.get(i.dataId).values,d=l.tensorMap.get(o.dataId).values,p=i.dtype==="string"?ma(h):h,f=i.dtype==="string"?ma(d):d,[m,y]=e(i.shape,o.shape,p,f,u);return l.makeTensorInfo(y,u,m)}const c=new Dg(t,i.shape,o.shape);return l.runWebGPUProgram(c,[i,o],u)}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const{addImpl:vme,castImpl:wme,ceilImpl:kme,concatImpl:Sme,equalImpl:Ime,expImpl:Nme,expm1Impl:Cme,floorImpl:Tme,floorDivImpl:Eme,gatherNdImpl:$me,gatherV2Impl:Rme,greaterEqualImpl:Ame,greaterImpl:_me,lessEqualImpl:Fme,lessImpl:Ome,logImpl:Dme,maxImpl:Mme,maximumImpl:Pme,minimumImpl:Lme,multiplyImpl:zme,negImpl:Bme,notEqualImpl:Wme,prodImpl:Ume,rangeImpl:Vme,rsqrtImpl:jme,scatterImpl:Gme,simpleAbsImpl:Hme,sliceImpl:Kme,stridedSliceImpl:qme,stringNGramsImpl:Xme,subImpl:Yme,tileImpl:Qme,topKImpl:Zme,transposeImpl:Jme,uniqueImpl:s2e}=UO;/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ege=ft({opType:fe.ABS,cpuKernelImpl:Hme}),tge={kernelName:Qd,backendName:"webgpu",kernelFunc:ege};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const nge=ft({opType:fe.ACOS}),rge={kernelName:Yu,backendName:"webgpu",kernelFunc:nge};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const sge=ft({opType:fe.ACOSH}),age={kernelName:Qu,backendName:"webgpu",kernelFunc:sge};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ige=Mn({opType:Ve.ADD,cpuKernelImpl:vme,supportsComplex:!0}),oge={kernelName:Tl,backendName:"webgpu",kernelFunc:ige};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class lge{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((n,r)=>`T${r}`),this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach(r=>{e.push(`let v${r} = get${r}ByOutputCoords(coords);`)});const n=this.variableNames.map(r=>`v${r}`).join(" + ");return`
      ${ge("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputAtIndex(flatIndex, ${n});
          }
        }
      }
    `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function uge(t){const{inputs:e,backend:n}=t,r=e;if(r.length===1)return ts({inputs:{x:r[0]},backend:n});const s=r.map(o=>o.dtype).reduce((o,l)=>On(o,l)),a=r.map(o=>o.shape),i=new lge(a);return n.runWebGPUProgram(i,r,s)}const cge={kernelName:Zd,backendName:"webgpu",kernelFunc:uge};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class hge{constructor(e,n){this.variableNames=["A"],this.workgroupSize=[16,16,1];const r=new Array(e.length);for(let s=0;s<r.length;s++)r[s]=e[n[s]];this.outputShape=r,this.dispatchLayout={x:[0],y:[1]},this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){R(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);const e=this.workgroupSize[0];return`
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${ge()} {
        var x = i32(workgroupId.x) * ${e} + i32(localId.x);
        var y = i32(workgroupId.y) * ${e} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${e} + i32(localId.x);
        y = i32(workgroupId.x) * ${e} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class dge{constructor(e,n){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const r=new Array(e.length);for(let s=0;s<r.length;s++)r[s]=e[n[s]];this.outputShape=r,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=n,this.shaderKey=`transpose_${n}`}getUserCode(){const e=sn(this.outputShape.length),n=MM(this.newDim);return`
      ${ge("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${n}), uniforms.aShape)]);
          }
        }
      }
    `}}function MM(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=new Array(e);for(let r=0;r<t.length;r++)n[t[r]]=`coords.${oi(r)}`;return n.join()}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ja(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{perm:a}=r,i=n,o=s.shape.length,l=new Array(o);for(let c=0;c<l.length;c++)l[c]=s.shape[a[c]];if(n.shouldExecuteOnCPU([s])){const c=i.tensorMap.get(s.dataId).values,h=Jme(c,s.shape,s.dtype,a,l);return n.makeTensorInfo(l,s.dtype,h)}if(s.shape.length===2&&Je(a,[1,0])){const c=new hge(s.shape,a);return i.runWebGPUProgram(c,[s],s.dtype)}const u=new dge(s.shape,a);return i.runWebGPUProgram(u,[s],s.dtype)}const pge={kernelName:Qo,backendName:"webgpu",kernelFunc:ja};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class fge{constructor(e,n,r){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[s]=an(this.inputShape,[1]);this.outputShape=s.length===0?[1]:s,e.inSize>=32768&&r>=512?this.workgroupSize=[512,1,1]:e.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=n,this.shaderKey=`reduce_${n}`}getUserCode(){let e="",n="0.0";const r=this.workgroupSize[0];this.reduceType==="min"||this.reduceType==="max"?(e=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,n="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?e=" bestValue = bestValue + candidate; ":this.reduceType==="prod"?(e=" bestValue = bestValue * candidate; ",n="1.0"):this.reduceType==="all"?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",n="1.0"):this.reduceType==="any"&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",n="0.0");const s=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${r}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${ge("index")} {
         let outputIndex = index / ${r};
         let offset = getOffset(outputIndex);
         var bestValue = ${n};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${r}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${r}) {
           let candidate = f32(x[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${r}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${s}
        }
       }
     `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const mge={mean:"float32",all:"bool",any:"bool"};function jl(t,e,n,r,s){const a=t.shape.length,i=[],o=Ze(e,t.shape);let l=o;const u=Tt(l,a);let c=t;u!=null&&(c=ja({inputs:{x:t},attrs:{perm:u},backend:s}),l=Ft(l.length,a),i.push(c)),mn(r,l,a);const[h,d]=an(c.shape,l);let p=h;n&&(p=en(h,o));let f;if((r==="max"||r==="prod")&&s.shouldExecuteOnCPU([c])){const m=s.tensorMap.get(c.dataId).values;switch(r){case"max":const y=Mme(m,Q(d),p,t.dtype);f=s.makeTensorInfo(p,t.dtype,y);break;case"prod":const{outVals:g,outShape:b,outDtype:v}=Ume(c.shape,c.dtype,m,l);f=s.makeTensorInfo(b,v,g);break;default:throw new Error(`${r} CPU implementation is not yet supported.`)}}else{const m=Q(d),y=Q(c.shape)/m,g={windowSize:m,inSize:m,batchSize:y,outSize:1},b=mge[r]||ab(t.dtype),v=[{type:"int32",data:[m]}],w=new fge(g,r,s.device.limits.maxComputeWorkgroupSizeX),k=s.runWebGPUProgram(w,[c],b,v);i.push(k),f=Ae({inputs:{x:k},attrs:{shape:p},backend:s})}return i.forEach(m=>s.disposeData(m.dataId)),f}/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function gge(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{keepDims:a,axis:i}=r;return jl(s,i,a,"all",n)}const yge={kernelName:iy,backendName:"webgpu",kernelFunc:gge};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function bge(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{keepDims:a,axis:i}=r;return jl(s,i,a,"any",n)}const xge={kernelName:oy,backendName:"webgpu",kernelFunc:bge};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class PM{constructor(e,n,r){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const s=[n];this.op=r==="min"?"<":">";const[a,i]=an(e,s);this.outputShape=a.length===0?[1]:a,this.dispatchLayout=Ne(this.outputShape),Q(i)<32?(this.type="plain",this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=ye(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],n=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${oi(this.inputShape.length-1)}`,r=()=>{let s="";if(this.outputShape.length===1)this.inputShape.length!==1&&(s+="outputCoords,");else for(let a=0;a<this.outputShape.length;a++)s+=`outputCoords.${oi(a)},`;return s};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${e}>;
      var<workgroup> xBestValues : array<f32, ${e}>;
    `}

      ${ge("index")} {
        let outputIndex = index / ${e};
        let reduceLength = ${n()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${e}) {
          let candidate = getX(${r()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${e}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${ge("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${r()} 0);
          let reduceLength = ${n()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${r()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function vge(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:a}=r;let i=Ze(a,s.shape);const o=Tt(i,s.shape.length);let l=s;const u=[];o!=null&&(l=ja({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=Ft(i.length,l.shape.length)),mn("argMax",[i[0]],l.shape.length);const c=new PM(l.shape,i[0],"max"),h=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],d=n.runWebGPUProgram(c,[l],"int32",h);return u.forEach(p=>n.disposeData(p.dataId)),d}const wge={kernelName:Jd,backendName:"webgpu",kernelFunc:vge};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function kge(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:a}=r;let i=Ze(a,s.shape);const o=Tt(i,s.shape.length);let l=s;const u=[];o!=null&&(l=ja({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=Ft(i.length,l.shape.length)),mn("argMin",[i[0]],l.shape.length);const c=new PM(l.shape,i[0],"min"),h=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],d=n.runWebGPUProgram(c,[l],"int32",h);return u.forEach(p=>n.disposeData(p.dataId)),d}const Sge={kernelName:ep,backendName:"webgpu",kernelFunc:kge};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Ige=ft({opType:fe.ASIN}),Nge={kernelName:Zu,backendName:"webgpu",kernelFunc:Ige};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Cge=ft({opType:fe.ASINH}),Tge={kernelName:Ju,backendName:"webgpu",kernelFunc:Cge};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Ege=ft({opType:fe.ATAN}),$ge={kernelName:ec,backendName:"webgpu",kernelFunc:Ege};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Rge=Mn({opType:Ve.ATAN2}),Age={kernelName:nc,backendName:"webgpu",kernelFunc:Rge};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const _ge=ft({opType:fe.ATANH}),Fge={kernelName:tc,backendName:"webgpu",kernelFunc:_ge};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Oge{constructor(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${ge("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Vd{constructor(e,n,r=!1,s=!1,a=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=n,this.computePositions=r,this.flattenPositions=s,this.includeBatchIndex=a,this.shaderKey=`pool2D_${n}_${r}_${s}_${a}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue = resultValue + value; count = count + 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};
      }`:e="resultValue = max(value, resultValue);";let n="resultValue";return this.poolType==="avg"&&(n="resultValue / max(count, 1.0)"),`
      ${ge("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${e}
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${n});`}
        }
      }
    `}}class U2{constructor(e,n,r=!1,s=!1,a=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=n,this.computePositions=r,this.flattenPositions=s,this.includeBatchIndex=a,this.shaderKey=`pool3D_${n}_${r}_${s}_${a}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue += value; count += 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }`:e="resultValue = max(value, resultValue);";let n="resultValue";return this.poolType==="avg"&&(n="resultValue / max(count, 1.0)"),`
      ${ge("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${e}
              }
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${n});`}
        }
      }
    `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function LM(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reductionIndices:a,keepDims:i}=r;return jl(s,a,i,"max",n)}const Dge={kernelName:Np,backendName:"webgpu",kernelFunc:LM};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zM(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{keepDims:a,axis:i}=r;return jl(s,i,a,"mean",n)}const Mge={kernelName:Ep,backendName:"webgpu",kernelFunc:zM};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function BM(t,e,n,r){if(e.filterWidth===1&&e.filterHeight===1&&Je(e.inShape,e.outShape))return ts({inputs:{x:t},backend:r});if(e.filterWidth===e.inWidth&&e.filterHeight===e.inHeight&&e.batchSize===1&&e.padInfo.type==="VALID"){const i=t.shape.length,o=Ae({inputs:{x:t},backend:r,attrs:{shape:[t.shape[i-3]*t.shape[i-2],t.shape[i-1]]}});let l;n==="avg"?l=zM({inputs:{x:o},backend:r,attrs:{axis:0,keepDims:!1}}):(R(n==="max",()=>`Invalid pool type ${n}`),l=LM({inputs:{x:o},backend:r,attrs:{reductionIndices:0,keepDims:!1}}));const u=Ae({inputs:{x:l},backend:r,attrs:{shape:e.outShape}});return r.disposeData(o.dataId),r.disposeData(l.dataId),u}let s;const a=[{type:"int32",data:[e.strideHeight,e.strideWidth]}];return e.filterHeight===1&&e.filterWidth===1?s=new Oge(e):(n==="avg"?s=new Vd(e,"avg"):(R(n==="max",()=>`Invalid pool type ${n}`),s=new Vd(e,"max")),a.push({type:"int32",data:[e.padInfo.top,e.padInfo.left]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]},{type:"int32",data:[e.inHeight,e.inWidth]},{type:"int32",data:[e.effectiveFilterHeight,e.effectiveFilterWidth]})),r.runWebGPUProgram(s,[t],t.dtype,a)}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Pge(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=er(s.shape,a,i,1,o,l);return BM(s,u,"avg",n)}const Lge={kernelName:tp,backendName:"webgpu",kernelFunc:Pge};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zge(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:a,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=[1,1,1],h=vs(s.shape,a,i,c,o,u,l),d=new U2(h,"avg"),p=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];return n.runWebGPUProgram(d,[s],s.dtype,p)}const Bge={kernelName:np,backendName:"webgpu",kernelFunc:zge};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Wge{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`
      ${ge("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class Uge{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`
      ${ge("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Vge(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:a}=e,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,h=vs(i.shape,o,l,1,u,c),d=new Uge(h),p=1/(h.filterDepth*h.filterHeight*h.filterWidth),f=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterDepth-1-h.padInfo.front,h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outDepth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"float32",data:[p]}];return n.runWebGPUProgram(d,[s],i.dtype,f)}const jge={kernelName:uy,backendName:"webgpu",kernelFunc:Vge};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Gge(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:a}=e,i=a;OM([s,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=er(i.shape,o,l,1,u),h=new Wge(c),d=1/(c.filterHeight*c.filterWidth),p=[{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.effectiveFilterHeight-1-c.padInfo.top,c.effectiveFilterWidth-1-c.padInfo.left]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[c.effectiveFilterHeight,c.effectiveFilterWidth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"float32",data:[d]}];return n.runWebGPUProgram(h,[s],i.dtype,p)}const Hge={kernelName:ly,backendName:"webgpu",kernelFunc:Gge};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Kge(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:a}=e,{transposeA:i,transposeB:o}=r;return w0({a:s,b:a,transposeA:i,transposeB:o,backend:n})}const qge={kernelName:rp,backendName:"webgpu",kernelFunc:Kge};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Xge{constructor(e,n){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.rank=n.length,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${sn(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=sn(this.rank),n=Yge(this.rank);let r;return this.start.length===1?r=this.outputShape.map((s,a)=>"sourceLoc = uniforms.start + coords;"):r=this.outputShape.map((s,a)=>`sourceLoc.${Ev[a]} = uniforms.start.${oi(a)} + coords.${Ev[a]};`),`
      ${ge("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromIndex(index);
          ${r.join(`
`)}
          setOutputAtIndex(index, getSource(${n}));
        }
      }
    `}}const Ev=["x","y","z","w","u","v"];function Yge(t){if(t===1)return"sourceLoc";if(t<=6)return Ev.slice(0,t).map(e=>`sourceLoc.${e}`).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function lh(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:a,size:i}=r,[o,l]=lf(s,a,i);if(Fb(s,o,l),n.shouldExecuteOnCPU([s])||s.dtype==="string"){const h=n.tensorMap.get(s.dataId),d=Kme(h.values,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,d)}if(Q(l)===0)return n.makeTensorInfo(l,s.dtype,[]);const u=new Xge(o,l),c=[{type:"int32",data:o}];return n.runWebGPUProgram(u,[s],s.dtype,c)}const Qge={kernelName:jp,backendName:"webgpu",kernelFunc:lh};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Zge=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:a,crops:i}=r;R(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const o=a.reduce((b,v)=>b*v),l=Fl(s.shape,a,o),u=Ol(l.length,a.length),c=Dl(s.shape,a,o),h=zb(i,a.length),d=Bb(c,i,a.length),p=[],f=Ae({inputs:{x:s},backend:n,attrs:{shape:l}}),m=ja({inputs:{x:f},backend:n,attrs:{perm:u}}),y=Ae({inputs:{x:m},backend:n,attrs:{shape:c}}),g=lh({inputs:{x:y},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(y),p.forEach(b=>n.disposeData(b.dataId)),g},Jge={kernelName:sp,backendName:"webgpu",kernelFunc:Zge};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const eye=`
  fn bincount_write(index: i32, value: f32) {
    ${No("&result[index]","value","float32")}
  }
`,tye=`
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;class WM{constructor(e,n,r=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=r,r&&(this.atomic=!1),this.hasWeights=n,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`
    ${this.binaryOutput?tye:eye}
  ${ge("index")} {
    ${this.rank===1?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `}}/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function nye(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:a}=e,{size:i}=r,o=Q(s.shape),l=Q(a.shape)>0,u=[i],c=a.dtype,h=Ir({backend:n,attrs:{shape:u,value:0,dtype:c}}),d=new WM([o],l),p=[{type:"int32",data:[i]}],f=l?[s,a]:[s];return n.runWebGPUProgram(d,f,c,p,h)}const rye={kernelName:cy,backendName:"webgpu",kernelFunc:nye};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class sye{constructor(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`
  ${ge("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `}}/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function aye(t){const{inputs:e,backend:n}=t,{s0:r,s1:s}=e;if(n.shouldExecuteOnCPU([r,s])){const c=n.tensorMap.get(r.dataId),h=n.tensorMap.get(s.dataId),d=c.values,p=h.values,f=Ue(Array.from(d),Array.from(p));return n.makeTensorInfo([f.length],"int32",Int32Array.from(f))}const a=Q(r.shape),i=Q(s.shape),o=Math.max(a,i),l=new sye(o),u=[{type:"int32",data:[a]},{type:"int32",data:[i]}];return n.runWebGPUProgram(l,[r,s],"int32",u)}const iye={kernelName:dy,backendName:"webgpu",kernelFunc:aye};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const UM=Mn({opType:Ve.NOT_EQUAL,dtype:"bool",cpuKernelImpl:Wme}),oye={kernelName:_p,backendName:"webgpu",kernelFunc:UM};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function If(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.tensorMap.get(r.dataId);return ts({inputs:{x:s.complexTensorInfos.real},backend:n})}const lye={kernelName:Uy,backendName:"webgpu",kernelFunc:If};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function uye(t,e){const n=new oh(t.shape,fe.TO_INT),r=e.runWebGPUProgram(n,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function $v(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dtype:a}=r;if(a==="complex64"){if(s.dtype==="complex64")return ts({inputs:{x:s},backend:n});const i=rn(s.shape),o=$v({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),l=Vl({inputs:{real:o,imag:i},backend:n});return i.dispose(),n.disposeData(o.dataId),l}if(s.dtype==="complex64"){const i=If({inputs:{input:s},backend:n}),o=$v({inputs:{x:i},backend:n,attrs:{dtype:a}});return n.disposeData(i.dataId),o}if(!sy(s.dtype,a)){const i=ts({inputs:{x:s},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:a}}if(n.shouldExecuteOnCPU([s])){const i=n.tensorMap.get(s.dataId).values,[o,l,u]=wme(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,l,u)}if(a==="int32")return uye(s,n);if(a==="bool"){const i=n.makeTensorInfo([],"bool",pn("bool",1)),o=UM({inputs:{a:s,b:i},backend:n});return n.disposeData(i.dataId),o}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${a}`)}const cye={kernelName:rc,backendName:"webgpu",kernelFunc:$v};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const hye=ft({opType:fe.CEIL,cpuKernelImpl:kme}),dye={kernelName:sc,backendName:"webgpu",kernelFunc:hye};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class pye{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${ge("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class fye{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${ge("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function mye(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{clipValueMin:a,clipValueMax:i}=r;let o;const l=[{type:"float32",data:[a]},{type:"float32",data:[i]}];return Q(s.shape)%4===0?o=new pye(s.shape):o=new fye(s.shape),n.runWebGPUProgram(o,[s],s.dtype,l)}const gye={kernelName:ac,backendName:"webgpu",kernelFunc:mye};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class yye{constructor(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`
    ${ge("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `}}/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _C(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}function bye(t){const{inputs:e,backend:n}=t,{x:r}=e,s=n.tensorMap.get(r.dataId),a=new yye(r.shape),i=[_C(r,s.complexTensorInfos.real),_C(r,s.complexTensorInfos.imag)];return n.runWebGPUProgram(a,i,i[0].dtype)}const xye={kernelName:ap,backendName:"webgpu",kernelFunc:bye};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class vye{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=Sr(e,1),this.variableNames=e.map((n,r)=>`T${r}`),this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let n=0;n<this.offsetLength;n++)this.uniforms+=`offset${n} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let s=1;s<this.offsetLength;s++)e.push(`else if (yC < uniforms.offset${[s]}){ setOutputAtCoords(coords.x, coords.y, getT${s}(yR, yC - uniforms.offset${s-1})); }`);const n=this.offsetLength,r=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${n}(yR, yC - uniforms.offset${r})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${ge("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function k0(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.tensorMap.get(r.dataId);return ts({inputs:{x:s.complexTensorInfos.imag},backend:n})}const wye={kernelName:_y,backendName:"webgpu",kernelFunc:k0};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Vh(t,e,n){const r=t[0].dtype;if(r==="complex64"){const f=t.map(v=>If({inputs:{input:v},backend:n})),m=t.map(v=>k0({inputs:{input:v},backend:n})),y=Vh(f,e,n),g=Vh(m,e,n),b=Vl({inputs:{real:y,imag:g},backend:n});return f.forEach(v=>n.disposeData(v.dataId)),m.forEach(v=>n.disposeData(v.dataId)),n.disposeData(y.dataId),n.disposeData(g.dataId),b}let s=n.shouldExecuteOnCPU(t);if(r==="string"&&(s=!0),s){const f=t.map(k=>{const N=[-1,Q(k.shape.slice(e))];return Ae({inputs:{x:k},backend:n,attrs:{shape:N}})}),m=f.map(k=>({vals:n.readSync(k.dataId),shape:k.shape})),y=Sr(f.map(k=>k.shape),1),g=f[0].shape[0]===1,b=Sme(m,y,r,g),v=Sr(t.map(k=>k.shape),e),w=n.makeTensorInfo(v,r,b);return f.forEach(k=>n.disposeData(k.dataId)),w}const a=n.device.limits.maxStorageBuffersPerShaderStage-1;if(t.length>a){const f=[];for(let y=0;y<t.length;y+=a){const g=t.slice(y,y+a);f.push(Vh(g,e,n))}const m=Vh(f,e,n);for(const y of f)n.disposeData(y.dataId);return m}const{tensors2D:i,outShape:o}=kye(t,e,n),l=i.map(f=>f.shape),u=new vye(l),c=[],h=new Array(l.length-1);if(h.length>0){h[0]=l[0][1],c.push({type:"int32",data:[h[0]]});for(let f=1;f<h.length;f++)h[f]=h[f-1]+l[f][1],c.push({type:"int32",data:[h[f]]})}const d=n.runWebGPUProgram(u,i,i[0].dtype,c);i.forEach(f=>n.disposeData(f.dataId));const p=Ae({inputs:{x:d},backend:n,attrs:{shape:o}});return n.disposeData(d.dataId),p}function kye(t,e,n){const r=Sr(t.map(s=>s.shape),e);return{tensors2D:t.map(s=>Ae({inputs:{x:s},backend:n,attrs:{shape:[Q(s.shape.slice(0,e)),Q(s.shape.slice(e))]}})),outShape:r}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function VM(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r,a=Ze(s,e[0].shape)[0],i=e.map(u=>u.shape);Mb(i,a);const o=Sr(e.map(u=>u.shape),a);if(Q(o)===0)return n.makeTensorInfo(o,e[0].dtype,[]);const l=e.filter(u=>Q(u.shape)>0);return l.length===1?ts({inputs:{x:l[0]},backend:n}):Vh(l,a,n)}const Sye={kernelName:ip,backendName:"webgpu",kernelFunc:VM};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Iye(t,e,n,r,s=!1,a=null,i=!1,o=4,l=4,u=4){const c=E=>{switch(E){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${E} is not supported.`)}},h=E=>{switch(E){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${E} is not supported.`)}},d=t?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,p=t?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,f=t?"uniforms.xShape[1]":"uniforms.xShape[2]",m=t?"uniforms.xShape[2]":"uniforms.xShape[3]",y=t?"row":"col",g=t?"col":"row",b=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${t?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${y} / outWidth;
      let outCol = ${y} % outWidth;

      let WRow = ${g} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${g} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${g} % inChannels;
      var resData = ${rt(o)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${f} && xCol >= 0 && xCol < ${m}) {
        ${d}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${c(o)}
      }
      return resData;`,v=t?e&&r?`
      ${b}`:`
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${b}
      }
      return ${rt(o)}(0.0);`:r&&n?`
      ${b}`:`
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${b}
      }
      return ${rt(o)}(0.0);`,w=`${h(l)}`,k=rt(u),N=rt(t?o:l),T=rt(t?l:o);return`
      ${Ii(a,i,u===4,4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${N} {
        ${t?v:w}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${T} {
        ${t?w:v}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${k}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${t?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${p}
        ${Ul(s,a)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}class Nye{constructor(e,n,r,s,a=!1,i=null,o=!1,l=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=((e.inChannels%4===0||e.inChannels%3===0)&&this.isChannelsLast||e.outWidth%4===0&&!this.isChannelsLast)&&e.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=AM(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=_M(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!==0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),a&&(this.variableNames.push("bias"),this.variableComponents.push(4)),o&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],a&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=l,this.addBias=a,this.activation=i,this.hasPreluActivationWeights=o,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=n%this.tileAOuter===0,this.fitBOuter=r%this.tileBOuter===0,this.fitInner=s%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?x0(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):v0(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),n=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${Iye(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,n[0],n[1],n[2])}
    ${e}
  `}}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Cye{constructor(e,n=!1,r=null,s=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=n,this.activation=r,this.hasPreluActivationWeights=s,n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${Ii(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${Ul(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${ge("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}}/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Tye{constructor(e,n){this.variableNames=["x"],this.uniforms=`pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=n,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,n=this.isChannelsLast?2:3,r=this.isChannelsLast?"coords[1]":"coords[2]",s=this.isChannelsLast?"coords[2]":"coords[1]",a=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`
    ${ge("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${r};
        let col = ${s};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${n}] && xCol >= 0) {
            value = ${a};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Mg(t,e){const n=t.length;return n>=3?e?[...t.slice(0,-3),t[n-3]*t[n-2],t[n-1]]:[...t.slice(0,-3),t[n-3],t[n-2]*t[n-1]]:!e&&n===1&&t[0]>1?[t[0],1]:null}function Eye({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const l=n.dataFormat==="channelsLast",u=!l,c=!1,h=l&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&n.padInfo.type==="VALID",d=[];let p,f;if(h){const g=n.inHeight*n.inWidth*n.inChannels;p=Ae({inputs:{x:t},backend:r,attrs:{shape:[1,n.batchSize,g]}}),f=Ae({inputs:{x:e},backend:r,attrs:{shape:[1,g,n.outChannels]}})}else p=Ae({inputs:{x:t},backend:r,attrs:{shape:l?[n.batchSize,n.inHeight*n.inWidth,n.inChannels]:[n.batchSize,n.inChannels,n.inHeight*n.inWidth]}}),f=Ae({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});if(d.push(p),d.push(f),a!=null){const g=Mg(a.shape,l);g!=null&&(a=Ae({inputs:{x:a},backend:r,attrs:{shape:g}}),d.push(a))}if(s!=null){const g=Mg(s.shape,l);g!=null&&(s=Ae({inputs:{x:s},backend:r,attrs:{shape:g}}),d.push(s))}const m=w0({a:l?p:f,b:l?f:p,transposeA:u,transposeB:c,backend:r,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i}),y=Ae({inputs:{x:m},backend:r,attrs:{shape:n.outShape}});d.push(m);for(const g of d)r.disposeData(g.dataId);return y}function $ye({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const{filterWidth:l,filterHeight:u,inChannels:c,strideWidth:h,strideHeight:d,padInfo:p,outWidth:f,outHeight:m,dilationWidth:y,dilationHeight:g,dataFormat:b}=n,v=b==="channelsLast",w=l*u*c,k=m*f,N=v?[n.batchSize,k,w]:[n.batchSize,w,k],T=new Tye(N,v),E=[{type:"int32",data:[p.top,p.left]},{type:"int32",data:[d,h]},{type:"int32",data:[g,y]},{type:"int32",data:[f]},{type:"int32",data:[c*l]},{type:"int32",data:[c]}],_=r.runWebGPUProgram(T,[t],t.dtype,E),O=[];O.push(_);const M=Ae({inputs:{x:e},backend:r,attrs:{shape:[1,w,-1]}});if(O.push(M),a!=null){const K=Mg(a.shape,v);K!=null&&(a=Ae({inputs:{x:a},backend:r,attrs:{shape:K}}),O.push(a))}if(s!=null){const K=Mg(s.shape,v);K!=null&&(s=Ae({inputs:{x:s},backend:r,attrs:{shape:K}}),O.push(s))}const V=w0({a:v?_:M,b:v?M:_,transposeA:!v,transposeB:!1,backend:r,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i}),W=Ae({inputs:{x:V},backend:r,attrs:{shape:n.outShape}});O.push(V);for(const K of O)r.disposeData(K.dataId);return W}function jM({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const l=s!=null,u=a!=null,c=n.dataFormat==="channelsLast",h=c&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&n.padInfo.type==="VALID",d=Z().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!d&&(h||n.filterHeight===1&&n.filterWidth===1&&n.dilationHeight===1&&n.dilationWidth===1&&n.strideHeight===1&&n.strideWidth===1&&(n.padInfo.type==="SAME"||n.padInfo.type==="VALID")))return Eye({x:t,filter:e,convInfo:n,backend:r,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i});const p=Z().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),f=p>-1?p:r.thresholdToIncreaseWorkgroups,m=n.batchSize*Math.ceil(n.outHeight*n.outWidth/32)*Math.ceil(n.outChannels/32);if(Z().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||m<=f)return $ye({x:t,filter:e,convInfo:n,backend:r,bias:s,preluActivationWeights:a,leakyreluAlpha:i,activation:o});let y;const g=[n.padInfo.top,n.padInfo.left],b=[{type:"int32",data:[n.filterHeight,n.filterWidth]},{type:"int32",data:[...g]},{type:"int32",data:[n.strideHeight,n.strideWidth]},{type:"int32",data:[n.dilationHeight,n.dilationWidth]}];if(d)y=new Cye(n,l,o,u);else{const N=c?n.outHeight*n.outWidth:n.outChannels,T=c?n.outChannels:n.outHeight*n.outWidth,E=n.filterHeight*n.filterWidth*n.inChannels;b.push({type:"int32",data:[N]},{type:"int32",data:[T]},{type:"int32",data:[E]});const _=r.adapterInfo.isIntel();y=new Nye(n,N,T,E,l,o,u,_)}const v=[],w=[t,e];l&&(!c&&s.shape.length===1&&(s=Ae({inputs:{x:s},backend:r,attrs:{shape:[s.shape[0],1,1]}}),v.push(s)),w.push(s)),u&&(!c&&a.shape.length===1&&(a=Ae({inputs:{x:a},backend:r,attrs:{shape:[a.shape[0],1,1]}}),v.push(a)),w.push(a)),o==="leakyrelu"&&(b.push({type:"float32",data:[i]}),y.uniforms+=" alpha : f32,");const k=r.runWebGPUProgram(y,w,t.dtype,b);for(const N of v)r.disposeData(N.dataId);return k}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Rye(t){const{inputs:e,attrs:n,backend:r}=t,{x:s,filter:a}=e,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=n,h=ss(l),d=_t(s.shape,a.shape,i,u,o,c,!1,h);return jM({x:s,filter:a,convInfo:d,backend:r})}const Aye={kernelName:op,backendName:"webgpu",kernelFunc:Rye};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class _ye{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=this.isChannelsLast&&e.outChannels%4===0&&e.inChannels%4===0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const e=this.isChannelsLast?1:2,n=this.isChannelsLast?2:3,r=this.isChannelsLast?3:1,s=`
    ${ge()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;return this.isVec4?`
    ${s}
    `:`
    ${ge("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${r}];

        let dyCorner = vec2<i32>(coords[${e}], coords[${n}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class Fye{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`
    ${ge("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class Oye{constructor(e){this.variableNames=["x","dy"],this.uniforms=`pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`
    ${ge("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class Dye{constructor(e){this.variableNames=["dy","W"],this.uniforms=`filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`
    ${ge("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Mye(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:a}=e,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,h=ss(l),d=_t(s.shape,c,i,1,o,u,!1,h),p=new Fye(d),f=[{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.batchSize]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"int32",data:[d.inHeight]},{type:"int32",data:[d.inWidth]}];return n.runWebGPUProgram(p,[s,a],s.dtype,f)}const Pye={kernelName:fy,backendName:"webgpu",kernelFunc:Mye};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Lye(t=4){const e=r=>{switch(r){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${r} is not supported.`)}},n=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${rt(t)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${rt(t)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${t}];`}
      }
      return ${rt(t)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${rt(t)} {
    ${n}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${rt(t)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${e(t)}
    }
    return ${rt(t)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${rt(t)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${t}] = value;
    }
  }`}class zye{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,R(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4===0&&e.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=AM(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=_M(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?x0(this.elementsPerThread,this.workgroupSize):v0(this.elementsPerThread,this.workgroupSize);return`
    ${Lye(this.isVec4?4:1)}
    ${e}
    `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Bye(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:a}=e,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,h=ss(u),d=_t(i,a.shape,o,1,l,c,!1,h),p=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.filterHeight-1-d.padInfo.top,d.filterWidth-1-d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.batchSize,d.outHeight,d.outWidth,d.outChannels]}];let f;if(Z().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||d.dataFormat!=="channelsLast")f=new _ye(d);else{f=new zye(d);const m=d.inHeight*d.inWidth,y=d.inChannels,g=d.filterHeight*d.filterWidth*d.outChannels;p.push({type:"uint32",data:[m]},{type:"uint32",data:[y]},{type:"uint32",data:[g]})}return n.runWebGPUProgram(f,[s,a],"float32",p)}const Wye={kernelName:lp,backendName:"webgpu",kernelFunc:Bye};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Uye{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`
    ${ge("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`}}/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Vye(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:a}=e,{strides:i,pad:o,dilations:l}=r,u=wa(s.shape,a.shape,i,l,o),c=[u.padInfo.front,u.padInfo.top,u.padInfo.left],h=[{type:"int32",data:[u.filterDepth,u.filterHeight,u.filterWidth]},{type:"int32",data:[...c]},{type:"int32",data:[u.strideDepth,u.strideHeight,u.strideWidth]},{type:"int32",data:[u.dilationDepth,u.dilationHeight,u.dilationWidth]}],d=new Uye(u),p=On(s.dtype,a.dtype);return n.runWebGPUProgram(d,[s,a],p,h)}const jye={kernelName:up,backendName:"webgpu",kernelFunc:Vye};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Gye(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:a}=e,{strides:i,pad:o,filterShape:l}=r,u=wa(s.shape,l,i,1,o),c=new Oye(u),h=[{type:"int32",data:[u.padInfo.front,u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.strideDepth,u.strideHeight,u.strideWidth]},{type:"int32",data:[u.batchSize]},{type:"int32",data:[u.outDepth]},{type:"int32",data:[u.outHeight]},{type:"int32",data:[u.outWidth]},{type:"int32",data:[u.inDepth]},{type:"int32",data:[u.inHeight]},{type:"int32",data:[u.inWidth]}];return n.runWebGPUProgram(c,[s,a],a.dtype,h)}const Hye={kernelName:my,backendName:"webgpu",kernelFunc:Gye};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Kye(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:a}=e,{strides:i,pad:o,inputShape:l}=r,u=wa(l,a.shape,i,1,o),c=new Dye(u),h=[{type:"int32",data:[u.filterDepth,u.filterHeight,u.filterWidth]},{type:"int32",data:[u.filterDepth-1-u.padInfo.front,u.filterHeight-1-u.padInfo.top,u.filterWidth-1-u.padInfo.left]},{type:"int32",data:[u.strideDepth,u.strideHeight,u.strideWidth]},{type:"int32",data:[u.outDepth]},{type:"int32",data:[u.outHeight]},{type:"int32",data:[u.outWidth]},{type:"int32",data:[u.outChannels]}];return n.runWebGPUProgram(c,[s,a],s.dtype,h)}const qye={kernelName:gy,backendName:"webgpu",kernelFunc:Kye};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Xye=ft({opType:fe.COS}),Yye={kernelName:ic,backendName:"webgpu",kernelFunc:Xye};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Qye=ft({opType:fe.COSH}),Zye={kernelName:oc,backendName:"webgpu",kernelFunc:Qye};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Jye{constructor(e,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[a]=n;this.outputShape=[a,r[0],r[1],e],this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId=s==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,n]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[r,s,a]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[i,o,l]=this.cropWidthBiggerThan1?[`(${n} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${n} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${n}`];return`
    ${ge("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${r});
        let width_ratio = f32(${i});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${s};
        let width_scale = ${o};
        let in_y = ${a};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${l};
        if( in_x < 0.0 || in_x > ${n} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ebe=t=>{const{inputs:e,backend:n,attrs:r}=t,{image:s,boxes:a,boxInd:i}=e,{cropSize:o,method:l,extrapolationValue:u}=r,c=new Jye(s.shape[3],a.shape,o,l),h=[{type:"float32",data:[u]}];return n.runWebGPUProgram(c,[s,a,i],"float32",h)},tbe={kernelName:by,backendName:"webgpu",kernelFunc:ebe};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/var jd;(function(t){t.Prod="*",t.Sum="+"})(jd||(jd={}));class FC{constructor(e,n,r,s){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=n,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=r,this.reverse=s,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,n=this.op===jd.Prod?"1.0":"0.0",r=this.exclusive?n:`getX(${OC(e,"coords",this.op)})`,s=this.outputShape[this.outputShape.length-1];let a="",i="";return this.exclusive?(a=this.reverse?`end != ${s-1}`:"end != 0",i=this.reverse?"end + 1":"end - 1"):(a=this.reverse?`end + pow2 < ${s}`:"end >= pow2",i=this.reverse?"end + pow2":"end - pow2"),`
      ${ge("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${DC(e,"coords",this.op)};
         var val = ${r};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${a}) {
           let idx = ${i};
           ${DC(e,"coords",this.op)} = idx;
           val ${this.op}= getX(${OC(e,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}}function OC(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.x, ${e}.y`;if(t===3)return`${e}.x, ${e}.y, ${e}.z`;if(t===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function DC(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.y`;if(t===3)return`${e}.z`;if(t===4)return`${e}.w`;throw Error(`Cumulative ${n} for rank ${t} is not yet supported`)}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function GM(t,e,n,r,s,a){const i=e.shape.length,o=Tt([r],i);let l=e;o!=null&&(l=ja({inputs:{x:e},backend:n,attrs:{perm:o}}));const u=Ft(1,i)[0];if(u!==i-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const c=l.shape[u];let h=ts({inputs:{x:l},backend:n});for(let d=0;d<=Math.ceil(Math.log2(c))-1;d++){const p=new FC(t,l.shape,!1,a),f=h,m=[{type:"float32",data:[d]}];h=n.runWebGPUProgram(p,[h],h.dtype,m),n.disposeData(f.dataId)}if(s){const d=new FC(t,l.shape,s,a),p=h,f=[{type:"float32",data:[0]}];h=n.runWebGPUProgram(d,[h],h.dtype,f),n.disposeData(p.dataId)}if(o!=null){const d=Ha(o),p=ja({inputs:{x:h},backend:n,attrs:{perm:d}});return n.disposeData(h.dataId),n.disposeData(l.dataId),p}return h}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function nbe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:a,exclusive:i,reverse:o}=r;return GM(jd.Prod,s,n,a,i,o)}const rbe={kernelName:yy,backendName:"webgpu",kernelFunc:nbe};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function sbe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:a,exclusive:i,reverse:o}=r;return GM(jd.Sum,s,n,a,i,o)}const abe={kernelName:cp,backendName:"webgpu",kernelFunc:sbe};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ibe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:a}=e,{size:i,binaryOutput:o}=r,l=s.shape.length===1,u=Q(a.shape)>0,c=a.dtype,h=l?[s.shape[0]]:[s.shape[0],s.shape[1]],d=l?[i]:[s.shape[0],i],p=Ir({backend:n,attrs:{shape:d,value:0,dtype:c}}),f=new WM(h,u,o),m=[{type:"int32",data:[i]}],y=u?[s,a]:[s];return n.runWebGPUProgram(f,y,c,m,p)}const obe={kernelName:xy,backendName:"webgpu",kernelFunc:ibe};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class lbe{constructor(e,n){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${n}`,this.dataFormat=n}getUserCode(){return`
      ${ge("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ube(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockSize:a,dataFormat:i}=r,o=s.shape[0],l=i==="NHWC"?s.shape[1]:s.shape[2],u=i==="NHWC"?s.shape[2]:s.shape[3],c=i==="NHWC"?s.shape[3]:s.shape[1],h=l*a,d=u*a,p=c/(a*a),f=i==="NHWC"?[o,h,d,p]:[o,p,h,d],m=[{type:"int32",data:[a]}],y=new lbe(f,i);return n.runWebGPUProgram(y,[s],s.dtype,m)}const cbe={kernelName:vy,backendName:"webgpu",kernelFunc:ube};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class hbe{constructor(e,n,r,s=!1,a=null,i=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),s&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.addBias=s,this.activation=a,this.hasPreluActivation=i,this.filterHeight=n,this.filterWidth=r,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,n=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],r=this.workgroupSize[1]+this.filterHeight-1,s=this.workgroupSize[0]+this.filterWidth-1;return`
      ${Ii(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${s}>, ${r}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${ge()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${s}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${e<n?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${n})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${Ul(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class HM{constructor(e,n=!1,r=null,s=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const a=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=Ne(a),this.dispatch=ye(this.dispatchLayout,a,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),R(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=n,this.activation=r,this.hasPreluActivation=s,this.shaderKey=`depthwiseVec4_${r}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,n=this.convInfo.strideHeight,r=this.convInfo.strideWidth;return`
      ${Ii(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${ge("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${n}, ${r}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${r} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${Ul(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class KM{constructor(e,n=!1,r=null,s=!1){this.variableNames=["x","W"],this.uniforms=`pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`,this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=n,this.activation=r,this.hasPreluActivation=s,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${Ii(this.activation,this.hasPreluActivation,!1,4)}

      ${ge("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${Ul(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function dbe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:a}=e,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r,h=ss(l);let d=u;d==null&&(d=[1,1]);const p=_t(s.shape,a.shape,i,d,o,c,!0,h),f=[{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.inHeight,p.inWidth]}],m=p.dataFormat==="channelsLast";let y;return!m&&p.inHeight>16&&p.inWidth>16&&p.strideHeight===1&&p.strideWidth===1&&p.dilationWidth===1&&p.dilationHeight===1&&p.inChannels===p.outChannels?y=new hbe(p.outShape,p.filterHeight,p.filterWidth):m&&p.outHeight>4&&p.outWidth>4&&p.strideWidth<=2&&p.inChannels===p.outChannels&&p.dilationHeight===1&&p.dilationWidth===1&&p.inChannels%4===0?(y=new HM(p),f.push({type:"int32",data:[y.virtualWidth]})):(y=new KM(p),f.push({type:"int32",data:[p.filterHeight]},{type:"int32",data:[p.filterWidth]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]})),n.runWebGPUProgram(y,[s,a],s.dtype,f)}const pbe={kernelName:hp,backendName:"webgpu",kernelFunc:dbe};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class fbe{constructor(e){this.variableNames=["x","dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`
      ${ge("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class mbe{constructor(e){this.variableNames=["dy","W"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`
      ${ge("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function gbe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:a}=e,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r,h=_t(s.shape,c,i,o,l,u,!0),d=new fbe(h),p=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.inHeight]},{type:"int32",data:[h.inWidth]},{type:"int32",data:[h.batchSize]},{type:"int32",data:[h.outChannels/h.inChannels]}];return n.runWebGPUProgram(d,[s,a],"float32",p)}const ybe={kernelName:wy,backendName:"webgpu",kernelFunc:gbe};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function bbe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:a}=e,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r,h=_t(c,a.shape,i,o,l,u,!0),d=new mbe(h),p=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.filterHeight-1-h.padInfo.top,h.filterWidth-1-h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.outChannels/h.inChannels]}];return n.runWebGPUProgram(d,[s,a],s.dtype,p)}const xbe={kernelName:ky,backendName:"webgpu",kernelFunc:bbe};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class vbe{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`
      ${ge("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function wbe(t){const{inputs:e,backend:n}=t,{x:r}=e,s=[...r.shape,...r.shape],a=Q(r.shape),i=Ae({inputs:{x:r},backend:n,attrs:{shape:[a]}}),o=new vbe(a),l=n.runWebGPUProgram(o,[i],i.dtype),u=Ae({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeData(i.dataId),n.disposeData(l.dataId),u}const kbe={kernelName:Sy,backendName:"webgpu",kernelFunc:wbe};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Sbe{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`
       ${ge("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `}}/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ibe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:a}=e,{strides:i,pad:o,dilations:l}=r,u=xo(s.shape,a.shape,i,o,"NHWC",l),c=[u.padInfo.top,u.padInfo.left],h=[{type:"int32",data:[u.filterHeight,u.filterWidth]},{type:"int32",data:[...c]},{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]}],d=new Sbe(u);return n.runWebGPUProgram(d,[s,a],s.dtype,h)}const Nbe={kernelName:dp,backendName:"webgpu",kernelFunc:Ibe};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Cbe{constructor(e,n){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=Ne(e.outShape),this.dispatch=ye(this.dispatchLayout,e.outShape,this.workgroupSize),n!=="float32"&&n!=="int32")throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${n} type.`);this.type=n,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`
       ${ge("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${No("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}class Tbe{constructor(e,n,r){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=Ne(e.outShape),this.dispatch=ye(this.dispatchLayout,e.outShape,this.workgroupSize),r!=="float32"&&r!=="int32")throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${r} type.`);this.type=r,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`
       ${ge("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${No("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ebe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:a,dy:i}=e,{strides:o,pad:l,dilations:u}=r,c=xo(s.shape,a.shape,o,l,"NHWC",u),h=a.dtype,d=new Tbe(c,a.shape,h),p=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[Q(c.outShape)]}],f=Ir({backend:n,attrs:{shape:a.shape,value:0,dtype:h}});return n.runWebGPUProgram(d,[s,a,i],h,p,f)}const $be={kernelName:ig,backendName:"webgpu",kernelFunc:Ebe};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Rbe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:a,dy:i}=e,{strides:o,pad:l,dilations:u}=r,c=xo(s.shape,a.shape,o,l,"NHWC",u),h=s.dtype,d=new Cbe(c,h),p=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[Q(c.outShape)]}],f=Ir({backend:n,attrs:{shape:c.inShape,value:0,dtype:h}});return n.runWebGPUProgram(d,[s,a,i],h,p,f)}const Abe={kernelName:ag,backendName:"webgpu",kernelFunc:Rbe};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class _be{constructor(e,n,r){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=Gu.DRAW,this.size=!0,this.outputShape=e,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=n,this.textureFormat=r,this.shaderKey=`draw_${n}_${r}`}getUserCode(){let e;const n=this.type==="float32"?"value":"value / 255.0";return e=`
      if (uniforms.numChannels == 1) {
        rgba[0] = ${n};
        rgba[1] = ${n};
        rgba[2] = ${n};
      } else {
        rgba[d] = ${n};
      }`,`
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${ge("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${e}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `}}/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use backend file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Fbe(t){const{inputs:e,backend:n,attrs:r}=t,{image:s}=e,{canvas:a,options:i}=r,[o,l]=s.shape.slice(0,2),{imageOptions:u}=i||{},c=(u==null?void 0:u.alpha)||1,h=n.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",d=[o,l],p=new _be(d,s.dtype,h);a.width=l,a.height=o;const f="webgpu";let m=a.getContext(f),y;m||(y=new OffscreenCanvas(l,o),m=y.getContext(f));const g=s.shape.length===3?s.shape[2]:1;m.configure({device:n.device,format:h,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const b="int32",v=n.makeTensorInfo(d,b),w=n.tensorMap.get(v.dataId);w.resource=m.getCurrentTexture(),w.external=!0;const k=[{type:"uint32",data:[g]},{type:"float32",data:[c]}];if(n.runWebGPUProgram(p,[s],b,k,v),y){const N=a.getContext("2d");if(!N)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");N.drawImage(y,0,0)}return n.disposeData(v.dataId),s}const Obe={kernelName:Iy,backendName:"webgpu",kernelFunc:Fbe};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const qM=Mn({opType:Ve.MUL,cpuKernelImpl:zme,supportsComplex:!0}),Dbe={kernelName:Nc,backendName:"webgpu",kernelFunc:qM};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function XM(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:a,keepDims:i}=r;return jl(s,a,i,"sum",n)}const Mbe={kernelName:Gp,backendName:"webgpu",kernelFunc:XM};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Pbe(t){const{inputs:e,backend:n,attrs:r}=t,{equation:s}=r,a=e,{allDims:i,summedDims:o,idDims:l}=Kb(s,a.length);Xb(i.length,l,a);const{path:u,steps:c}=Yb(o,l),h=c.length;let d=null,p=i.length;const f=[];for(let m=0;m<h;++m){for(const y of c[m]){const{permutationIndices:g,expandDims:b}=qb(p,l[y]);let v;Qb(g)?v=a[y]:(v=ja({inputs:{x:a[y]},backend:n,attrs:{perm:g}}),f.push(v));const w=v.shape.slice();for(let k=0;k<b.length;++k)w.splice(b[k],0,1);Je(v.shape,w)||(v=Ae({inputs:{x:v},backend:n,attrs:{shape:w}}),f.push(v)),d===null?d=v:(d=qM({inputs:{a:v,b:d},backend:n}),f.push(d))}m<h-1&&(u[m]>=0&&(d=XM({inputs:{x:d},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeData(m.dataId);return d}const Lbe={kernelName:Ny,backendName:"webgpu",kernelFunc:Pbe};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const zbe=ft({opType:fe.ELU}),Bbe={kernelName:uc,backendName:"webgpu",kernelFunc:zbe};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Wbe=t=>{const{inputs:e,backend:n}=t,{dy:r,y:s}=e,a=new Dg(Ve.ELU_DER,r.shape,s.shape);return n.runWebGPUProgram(a,[r,s],r.dtype)},Ube={kernelName:Cy,backendName:"webgpu",kernelFunc:Wbe};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Vbe=Mn({opType:Ve.EQUAL,dtype:"bool",cpuKernelImpl:Ime}),jbe={kernelName:pp,backendName:"webgpu",kernelFunc:Vbe};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Gbe=ft({opType:fe.ERF}),Hbe={kernelName:cc,backendName:"webgpu",kernelFunc:Gbe};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Kbe=ft({opType:fe.EXP,cpuKernelImpl:Nme,dtype:"float32"}),qbe={kernelName:hc,backendName:"webgpu",kernelFunc:Kbe};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Rv(t){const{inputs:e,attrs:n,backend:r}=t,{dim:s}=n,{input:a}=e,i=a.shape.length,o=a.shape.slice();let l=s;return s<0&&(R(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),Ae({inputs:{x:a},backend:r,attrs:{shape:o}})}const Xbe={kernelName:fp,backendName:"webgpu",kernelFunc:Rv};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Ybe=ft({opType:fe.EXPM1,cpuKernelImpl:Cme}),Qbe={kernelName:dc,backendName:"webgpu",kernelFunc:Ybe};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class MC{constructor(e,n){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey=`fft_${e}`}getUserCode(){return`
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component==="real"?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${ge("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `}}/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function YM(t,e,n){const r=n.tensorMap.get(t.dataId),s=Q(t.shape),a=t.shape[t.shape.length-1],i=s/a,o=[],l=Ae({inputs:{x:t},backend:n,attrs:{shape:[i,a]}});o.push(l);const u=l.shape,c=new MC("real",u),h=new MC("imag",u),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:u},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:u}],p=e?2*Math.PI:-2*Math.PI,f=e?u[1]:1,m=[{type:"float32",data:[p]},{type:"float32",data:[f]}],y=n.runWebGPUProgram(c,d,"float32",m);o.push(y);const g=n.runWebGPUProgram(h,d,"float32",m);o.push(g);const b=Vl({inputs:{real:y,imag:g},backend:n});o.push(b);const v=Ae({inputs:{x:b},backend:n,attrs:{shape:t.shape}});return o.forEach(w=>n.disposeData(w.dataId)),v}/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Zbe(t){const{inputs:e,backend:n}=t,{input:r}=e;return YM(r,!1,n)}const Jbe={kernelName:Ty,backendName:"webgpu",kernelFunc:Zbe};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class e0e{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${ge("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const t0e={kernelName:$y,backendName:"webgpu",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,r=e,s=new e0e(n.shape);return r.runWebGPUProgram(s,[n],n.dtype)}};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const n0e=ft({opType:fe.FLOOR,cpuKernelImpl:Tme}),r0e={kernelName:pc,backendName:"webgpu",kernelFunc:n0e};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const s0e=Mn({opType:Ve.FLOOR_DIV,cpuKernelImpl:Eme,dtype:"int32"}),a0e={kernelName:fc,backendName:"webgpu",kernelFunc:s0e};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class i0e{constructor(e,n,r=!1){this.pixelsOpType=Gu.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize,[n,1,1]),this.importVideo=r,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${ge("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use backend file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const o0e={kernelName:og,backendName:"webgpu",kernelFunc:l0e};let Ql,Rx=Z().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function l0e(t){const{inputs:e,backend:n,attrs:r}=t;let{pixels:s}=e;const{numChannels:a}=r;if(s==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const i=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,l=typeof HTMLCanvasElement<"u"&&s instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&s instanceof OffscreenCanvas,u=typeof ImageBitmap<"u"&&s instanceof ImageBitmap,[c,h]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],d=[h,c,a],p=Z().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&i,f=i||o;if(u||l||f){let b;if(p)b=n.device.importExternalTexture({source:s});else{if(f){const V=Z().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Ql==null||V!==Rx)&&(Rx=V,Ql=document.createElement("canvas").getContext("2d",{willReadFrequently:Rx})),Ql.canvas.width=c,Ql.canvas.height=h,Ql.drawImage(s,0,0,c,h),s=Ql.canvas}const O=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,M=n.textureManager.acquireTexture(d[1],d[0],"rgba8unorm",O);n.queue.copyExternalImageToTexture({source:s},{texture:M},[d[1],d[0]]),b=M}const v=Q(d),w=Fe(d),k=new i0e(d,a,p),N=[{type:"uint32",data:[v]},{type:"uint32",data:[a]},{type:"uint32",data:[...w]}],T=n.makeTensorInfo([h,c],"int32"),E=n.tensorMap.get(T.dataId);E.resource=b;const _=n.runWebGPUProgram(k,[T],"int32",N);return n.disposeData(T.dataId),_}const m=s.data;let y=m;if(a!=null&&a!==4){y=new Uint8Array(s.width*s.height*a);const b=m.length;let v=0;for(let w=0;w<b;w++)w%4<a&&(y[v++]=m[w])}const g=n.makeTensorInfo(d,"int32",new Int32Array(y));return n.uploadToGPU(g.dataId),g}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class u0e{constructor(e,n,r,s,a){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],Ue(e,n),Ue(e,r),this.outputShape=e,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),s!=null&&(Ue(e,s),this.variableNames.push("offset")),a!=null&&(Ue(e,a),this.variableNames.push("scale")),this.offsetShape=s,this.scaleShape=a,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";this.offsetShape!=null&&(e="getOffsetByOutputIndex(index)");let n="1.0";return this.scaleShape!=null&&(n="getScaleByOutputIndex(index)"),`
      ${ge("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${n};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const c0e={kernelName:mp,backendName:"webgpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r,scale:s,offset:a,mean:i,variance:o}=t,{varianceEpsilon:l}=e,u=n,c=[r,i,o];let h=null;a!=null&&(h=a.shape,c.push(a));let d=null;s!=null&&(d=s.shape,c.push(s));const p=new u0e(r.shape,i.shape,o.shape,h,d),f=[{type:"float32",data:[l]}];return u.runWebGPUProgram(p,c,r.dtype,f)}};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function h0e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:a,bias:i,preluActivationWeights:o}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r,m=ss(c),y=_t(s.shape,a.shape,l,h,u,d,!1,m);return jM({x:s,filter:a,convInfo:y,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:f,activation:p})}const d0e={kernelName:wd,backendName:"webgpu",kernelFunc:h0e};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function p0e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:a,bias:i,preluActivationWeights:o}=e,{strides:l,pad:u,dilations:c,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=r;let f=c;f==null&&(f=[1,1]),R(In(l,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${f}'`);const m=_t(s.shape,a.shape,l,f,u,h,!0),y=[s,a],g=i!=null,b=o!=null;g&&y.push(i),b&&y.push(o);const v=[{type:"int32",data:[m.padInfo.top,m.padInfo.left]},{type:"int32",data:[m.inHeight,m.inWidth]}];let w;return m.outHeight>4&&m.outWidth>4&&m.strideWidth<=2&&m.inChannels===m.outChannels&&m.dilationHeight===1&&m.dilationWidth===1&&m.inChannels%4===0?(w=new HM(m,g,d,b),v.push({type:"int32",data:[w.virtualWidth]})):(w=new KM(m,g,d,b),v.push({type:"int32",data:[m.filterHeight]},{type:"int32",data:[m.filterWidth]},{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.dilationHeight,m.dilationWidth]})),d==="leakyrelu"&&(v.push({type:"float32",data:[p]}),w.uniforms+=" alpha : f32,"),n.runWebGPUProgram(w,y,"float32",v)}const f0e={kernelName:kd,backendName:"webgpu",kernelFunc:p0e};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class m0e{constructor(e,n){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${sn(e)},`}getUserCode(){let e;return this.sliceDim>1?e="uniforms.strides[j]":e="uniforms.strides",`
      ${ge("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function g0e(t){const{inputs:e,backend:n}=t,{params:r,indices:s}=e,a=s.shape,i=a[a.length-1],o=Q(r.shape),[l,u,c,h]=of(r,s),d=Ae({inputs:{x:s},backend:n,attrs:{shape:[u,i]}}),p=Ae({inputs:{x:r},backend:n,attrs:{shape:[Q(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const b=n.readSync(s.dataId),v=n.bufferSync(r),w=$me(b,v,r.dtype,u,i,c,h,r.shape,o);return n.makeTensorInfo(l,r.dtype,w.values)}const f=new m0e(i,[u,c]),m=[{type:"int32",data:[i]},{type:"int32",data:h}],y=n.runWebGPUProgram(f,[p,d],p.dtype,m),g=Ae({inputs:{x:y},backend:n,attrs:{shape:l}});return n.disposeData(d.dataId),n.disposeData(p.dataId),n.disposeData(y.dataId),g}const y0e={kernelName:Ry,backendName:"webgpu",kernelFunc:g0e};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class b0e{constructor(e,n){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=n,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=x0e(this.aShape);return`
      ${ge("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e}));
        }
      }
    `}}function x0e(t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<t.length;r++)r===2?n.push("indexZ"):n.push(`${e[r]}`);return n.join()}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function QM(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,indices:a}=e,{axis:i,batchDims:o}=r,l=Ze(i,s.shape)[0],u=Jb(s,a,l,o),c=Q(a.shape),h=[],d=Ae({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=Ae({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});h.push(d),h.push(p);const f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([s,a])){const b=n.tensorMap.get(p.dataId).values,v=Qe(p.shape,p.dtype,b),w=n.tensorMap.get(d.dataId).values,k=Qe(d.shape,d.dtype,w),N=Rme(k,v,f);return h.forEach(T=>n.disposeData(T.dataId)),n.makeTensorInfo(u.outputShape,N.dtype,N.values)}const m=new b0e(d.shape,f),y=n.runWebGPUProgram(m,[d,p],d.dtype);h.push(y);const g=Ae({inputs:{x:y},backend:n,attrs:{shape:u.outputShape}});return h.forEach(b=>n.disposeData(b.dataId)),g}const v0e={kernelName:gp,backendName:"webgpu",kernelFunc:QM};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const w0e=Mn({opType:Ve.GREATER,cpuKernelImpl:_me,dtype:"bool"}),k0e={kernelName:yp,backendName:"webgpu",kernelFunc:w0e};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const S0e=Mn({opType:Ve.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:Ame}),I0e={kernelName:mc,backendName:"webgpu",kernelFunc:S0e};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function N0e(t){const{inputs:e,backend:n}=t,{input:r}=e;return YM(r,!0,n)}const C0e={kernelName:Ay,backendName:"webgpu",kernelFunc:N0e};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const T0e=ft({opType:fe.IS_FINITE,dtype:"bool"}),E0e={kernelName:yc,backendName:"webgpu",kernelFunc:T0e};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const $0e=ft({opType:fe.IS_INF,dtype:"bool"}),R0e={kernelName:bc,backendName:"webgpu",kernelFunc:$0e};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const A0e=ft({opType:fe.IS_NAN,dtype:"bool"}),_0e={kernelName:xc,backendName:"webgpu",kernelFunc:A0e};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function F0e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{alpha:a}=r,i=[{type:"float32",data:[a]}],o=new oh(s.shape,fe.LEAKYRELU,"alpha : f32,");return n.runWebGPUProgram(o,[s],"float32",i)}const O0e={kernelName:bp,backendName:"webgpu",kernelFunc:F0e};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const D0e=Mn({opType:Ve.LESS,dtype:"bool",cpuKernelImpl:Ome}),M0e={kernelName:xp,backendName:"webgpu",kernelFunc:D0e};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const P0e=Mn({opType:Ve.LESS_EQUAL,dtype:"bool",cpuKernelImpl:Fme}),L0e={kernelName:vp,backendName:"webgpu",kernelFunc:P0e};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class z0e{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`
      ${ge("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `}}/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function B0e(t){const{backend:e,attrs:n}=t,{start:r,stop:s,num:a}=n,i=(s-r)/(a-1),o=new z0e(a),l=[{type:"float32",data:[r]},{type:"float32",data:[i]}];return e.runWebGPUProgram(o,[],"float32",l)}const W0e={kernelName:Fy,backendName:"webgpu",kernelFunc:B0e};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const U0e=ft({opType:fe.LOG,cpuKernelImpl:Dme}),V0e={kernelName:vc,backendName:"webgpu",kernelFunc:U0e};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const j0e=ft({opType:fe.LOG1P}),G0e={kernelName:wc,backendName:"webgpu",kernelFunc:j0e};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const H0e=Mn({opType:Ve.LOGICAL_AND,dtype:"bool"}),K0e={kernelName:wp,backendName:"webgpu",kernelFunc:H0e};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const q0e=ft({opType:fe.LOGICAL_NOT}),X0e={kernelName:kp,backendName:"webgpu",kernelFunc:q0e};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Y0e=Mn({opType:Ve.LOGICAL_OR}),Q0e={kernelName:Sp,backendName:"webgpu",kernelFunc:Y0e};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ZM=`
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;class Z0e{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`
    ${ge("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${ZM}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `}}class J0e{constructor(e,n){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,R(n<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${n}`),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=ye(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${ge()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${ZM}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `}}/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function exe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{depthRadius:a,bias:i,alpha:o,beta:l}=r;let u;a>16?u=new Z0e(s.shape):u=new J0e(s.shape,a);const c=[{type:"int32",data:[a]},{type:"float32",data:[i]},{type:"float32",data:[o]},{type:"float32",data:[l]}];return n.runWebGPUProgram(u,[s],s.dtype,c)}const txe={kernelName:Ip,backendName:"webgpu",kernelFunc:exe};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class nxe{constructor(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`
    ${ge("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `}}/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function rxe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,y:a,dy:i}=e,{depthRadius:o,bias:l,alpha:u,beta:c}=r,h=new nxe(s.shape),d=[{type:"int32",data:[o]},{type:"float32",data:[l]},{type:"float32",data:[u]},{type:"float32",data:[c]}];return n.runWebGPUProgram(h,[s,a,i],s.dtype,d)}const sxe={kernelName:Oy,backendName:"webgpu",kernelFunc:rxe};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const axe=Mn({opType:Ve.MAX,cpuKernelImpl:Pme}),ixe={kernelName:kc,backendName:"webgpu",kernelFunc:axe};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function oxe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=er(s.shape,a,i,1,o,l);return BM(s,u,"max",n)}const lxe={kernelName:Cp,backendName:"webgpu",kernelFunc:oxe};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function uxe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:a,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=[1,1,1],h=vs(s.shape,a,i,c,o,u,l),d=new U2(h,"max"),p=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];return n.runWebGPUProgram(d,[s],s.dtype,p)}const cxe={kernelName:Tp,backendName:"webgpu",kernelFunc:uxe};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class hxe{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`
      ${ge("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class dxe{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`
      ${ge("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function pxe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:a}=e,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,h=[1,1,1],d=vs(i.shape,o,l,h,u,c),p=new U2(d,"max",!0);let f=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.front,d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.inDepth,d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]}];const m=n.runWebGPUProgram(p,[i],"int32",f),y=new dxe(d);f=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterDepth-1-d.padInfo.front,d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outDepth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]}];const g=n.runWebGPUProgram(y,[s,m],i.dtype,f);return n.disposeData(m.dataId),g}const fxe={kernelName:My,backendName:"webgpu",kernelFunc:pxe};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function mxe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:a,output:i}=e,o=a;OM([a,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=r,d=er(o.shape,l,u,1,c,h),p=new Vd(d,"max",!0);let f=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]}];const m=n.runWebGPUProgram(p,[o],"int32",f),y=new hxe(d);f=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]}];const g=n.runWebGPUProgram(y,[s,m],o.dtype,f);return n.disposeData(m.dataId),g}const gxe={kernelName:Dy,backendName:"webgpu",kernelFunc:mxe};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function yxe(t){const{inputs:e,backend:n,attrs:r}=t,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=r,{x:l}=e;R(l.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${l.shape.length}.`);const u=[1,1];R(In(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);const c=er(l.shape,s,a,u,i),h=[{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[c.inHeight,c.inWidth]},{type:"int32",data:[c.effectiveFilterHeight,c.effectiveFilterWidth]}];let d=new Vd(c,"max",!1);const p=n.runWebGPUProgram(d,[l],l.dtype,h);d=new Vd(c,"max",!0,!0,o);const f=n.runWebGPUProgram(d,[l],"int32",h);return[p,f]}const bxe={kernelName:Py,backendName:"webgpu",kernelFunc:yxe};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function xxe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:a,keepDims:i}=r;return jl(s,a,i,"min",n)}const vxe={kernelName:$p,backendName:"webgpu",kernelFunc:xxe};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const wxe=Mn({opType:Ve.MIN,cpuKernelImpl:Lme}),kxe={kernelName:Sc,backendName:"webgpu",kernelFunc:wxe};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Sxe{constructor(e,n,r){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n.map((s,a)=>s[0]+e[a]+s[1]),this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,n.map((s,a)=>{this.uniforms+=` pad${a} : vec2<i32>,`}),this.offset=r==="reflect"?0:1,this.shaderKey=`mirrorPad_${r}`}getUserCode(){const e=this.xShape.length,n=this.xShape.map((u,c)=>`uniforms.pad${c}[0]`).join(","),r=this.xShape.map((u,c)=>`uniforms.pad${c}[0] + uniforms.xShape${e>1?`[${c}]`:""}`).join(","),s=e===1?"start":"start[i]",a=e===1?"end":"end[i]",i=e===1?"outC":"outC[i]",o=sn(e),l=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${ge("index")} {
        if (index < uniforms.size) {
          let start = ${o}(${n});
          let end = ${o}(${r});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${i} < ${s}) {
              ${i} = ${s} * 2 - ${i} - ${this.offset};
            } else if(${i} >= ${a}) {
              ${i} = (${a} - 1) * 2 - ${i} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${l}));
        }
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Ixe={kernelName:Rp,backendName:"webgpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{paddings:s,mode:a}=e,i=n,o=s.map(u=>({type:"int32",data:[u[0],u[1]]})),l=new Sxe(r.shape,s,a);return i.runWebGPUProgram(l,[r],r.dtype,o)}};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Nxe=Mn({opType:Ve.MOD}),Cxe={kernelName:Ic,backendName:"webgpu",kernelFunc:Nxe};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Txe{constructor(e,n){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,n],this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${ge("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `}}/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Exe{constructor(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=Ne(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${ge("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function JM(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{dim:a}=r,i=Ae({inputs:{x:s},backend:n,attrs:{shape:[Q(s.shape)/s.shape[a],s.shape[a]]}}),o=new Exe(i.shape),l=n.runWebGPUProgram(o,[i],s.dtype),u=Ae({inputs:{x:l},backend:n,attrs:{shape:s.shape}});return n.disposeData(i.dataId),n.disposeData(l.dataId),u}const $xe={kernelName:qp,backendName:"webgpu",kernelFunc:JM};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Rxe(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{numSamples:a,seed:i,normalized:o}=r,l=o?s:JM({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),u=l.shape[0],c=l.shape[1],h=new Txe(u,a),d=[{type:"float32",data:[i]},{type:"int32",data:[c]}],p=n.runWebGPUProgram(h,[l],"int32",d);return o||n.disposeData(l.dataId),p}const Axe={kernelName:Ly,backendName:"webgpu",kernelFunc:Rxe};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _xe(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])){const a=n.tensorMap.get(r.dataId),[i,o]=Bme(a.values,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,i)}const s=new oh(r.shape,fe.NEG);return n.runWebGPUProgram(s,[r],r.dtype)}const Fxe={kernelName:Ap,backendName:"webgpu",kernelFunc:_xe};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Oxe(t){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:a}=e,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),{selectedIndices:h}=Rb(u,c,i,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}const Dxe={kernelName:zy,backendName:"webgpu",kernelFunc:Oxe};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Mxe(t){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:a}=e,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(s.dataId),h=n.readSync(a.dataId),d=i,p=o,f=l,m=u,{selectedIndices:y,selectedScores:g}=Ab(c,h,d,p,f,m);return[n.makeTensorInfo([y.length],"int32",new Int32Array(y)),n.makeTensorInfo([g.length],"float32",new Float32Array(g))]}const Pxe={kernelName:By,backendName:"webgpu",kernelFunc:Mxe};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Lxe{constructor(e,n){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,n],this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`
      ${ge("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `}}/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zxe(t){const{inputs:e,backend:n,attrs:r}=t,{indices:s}=e,{dtype:a,depth:i,onValue:o,offValue:l}=r,u=Q(s.shape),c=new Lxe(u,i),h=Ae({inputs:{x:s},backend:n,attrs:{shape:[u]}}),d=[{type:"float32",data:[o]},{type:"float32",data:[l]}],p=n.runWebGPUProgram(c,[h],a,d);n.disposeData(h.dataId);const f=[...s.shape,i],m=Ae({inputs:{x:p},backend:n,attrs:{shape:f}});return n.disposeData(p.dataId),m}const Bxe={kernelName:Op,backendName:"webgpu",kernelFunc:zxe};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Pg(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="complex64"){const s=If({inputs:{input:r},backend:n}),a=Pg({inputs:{x:s},backend:n}),i=k0({inputs:{input:r},backend:n}),o=Pg({inputs:{x:i},backend:n}),l=Vl({inputs:{real:a,imag:o},backend:n});return n.disposeData(s.dataId),n.disposeData(a.dataId),n.disposeData(i.dataId),n.disposeData(o.dataId),l}else return Ir({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}const Wxe={kernelName:Qp,backendName:"webgpu",kernelFunc:Pg};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function eP(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const s=If({inputs:{input:r},backend:n}),a=eP({inputs:{x:s},backend:n}),i=k0({inputs:{input:r},backend:n}),o=Pg({inputs:{x:i},backend:n}),l=Vl({inputs:{real:a,imag:o},backend:n});return n.disposeData(s.dataId),n.disposeData(a.dataId),n.disposeData(i.dataId),n.disposeData(o.dataId),l}else return Ir({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}const Uxe={kernelName:Fp,backendName:"webgpu",kernelFunc:eP};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Vxe(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r;if(e.length===1)return Rv({inputs:{input:e[0]},backend:n,attrs:{dim:s}});const a=e[0].shape,i=e[0].dtype;e.forEach(c=>{Dn(a,c.shape,"All tensors passed to stack must have matching shapes"),R(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=e.map(c=>{const h=Rv({inputs:{input:c},backend:n,attrs:{dim:s}});return o.push(h),h}),u=VM({inputs:l,backend:n,attrs:{axis:s}});return o.forEach(c=>n.disposeData(c.dataId)),u}const jxe={kernelName:Dp,backendName:"webgpu",kernelFunc:Vxe};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function tP(t,e=!1){const n=t.length,r=sn(n),s=t.map((h,d)=>`uniforms.pad${d}[0]`).join(","),a=t.map((h,d)=>`uniforms.pad${d}[0] + uniforms.xShape${n>1?`[${d}]`:""}`).join(","),i=n>1?`${r}(${s})`:`${s}`,o=n>1?`${r}(${a})`:`${a}`,l=n>1?"any(paddedCoords < start)":"paddedCoords < start",u=n>1?"any(paddedCoords >= end)":"paddedCoords >= end",c=n>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,n):"coords";return`
        let start = ${i};
        let end = ${o};
        if (${l} || ${u}) {
          setOutputAtIndex(index, ${e?0:"uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${c}));
        }
  `}class Gxe{constructor(e,n){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n.map((r,s)=>r[0]+e[s]+r[1]),this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),n.map((r,s)=>{this.uniforms+=` pad${s} : vec2<i32>,`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){return`
      ${ge("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${tP(this.xShape)}
        }
      }
    `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Hxe=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{paddings:a,constantValue:i}=r;if(a.every(u=>Je(u,[0,0])))return ts({inputs:{x:s},backend:n});if(Q(s.shape)===0){const u=a.map((c,h)=>c[0]+s.shape[h]+c[1]);return Ir({backend:n,attrs:{shape:u,value:i,dtype:s.dtype}})}const o=[{type:"float32",data:[i]}];a.map(u=>o.push({type:"int32",data:[u[0],u[1]]}));const l=new Gxe(s.shape,a);return n.runWebGPUProgram(l,[s],s.dtype,o)},Kxe={kernelName:Mp,backendName:"webgpu",kernelFunc:Hxe};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const qxe=Mn({opType:Ve.POW}),Xxe={kernelName:Cc,backendName:"webgpu",kernelFunc:qxe};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Yxe(t){const{inputs:e,backend:n}=t,{x:r,alpha:s}=e,a=new Dg(Ve.PRELU,r.shape,s.shape);return n.runWebGPUProgram(a,[r,s],"float32")}const Qxe={kernelName:Pp,backendName:"webgpu",kernelFunc:Yxe};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Zxe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:a,keepDims:i}=r;return jl(s,a,i,"prod",n)}const Jxe={kernelName:Lp,backendName:"webgpu",kernelFunc:Zxe};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const e1e=t=>{const{backend:e,attrs:n}=t,{start:r,stop:s,step:a,dtype:i}=n,o=Vme(r,s,a,i);return e.makeTensorInfo([o.length],i,o)},t1e={kernelName:Wy,backendName:"webgpu",kernelFunc:e1e};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const n1e=Mn({opType:Ve.DIV}),r1e={kernelName:lc,backendName:"webgpu",kernelFunc:n1e};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const s1e=ft({opType:fe.RECIPROCAL}),a1e={kernelName:Tc,backendName:"webgpu",kernelFunc:s1e};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const i1e=ft({opType:fe.RELU}),o1e={kernelName:Ec,backendName:"webgpu",kernelFunc:i1e};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const l1e=ft({opType:fe.RELU6}),u1e={kernelName:$c,backendName:"webgpu",kernelFunc:l1e};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class c1e{constructor(e,n,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],n,r,e[3]],this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${ge("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function h1e(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:a,size:i,halfPixelCenters:o}=r,[l,u]=i,c=a&&l>1?1:0,h=a&&u>1?1:0,d=[{type:"float32",data:[c,h]},{type:"float32",data:[o?.5:0]}],p=new c1e(s.shape,l,u);return n.runWebGPUProgram(p,[s],"float32",d)}const d1e={kernelName:Wp,backendName:"webgpu",kernelFunc:h1e};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class p1e{constructor(e,n){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=n,this.shaderKey=`resizeBilinearBackprop_${n}`}getUserCode(){return`
      ${ge("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function f1e(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:a}=e,{alignCorners:i}=r,[,o,l]=s.shape,[,u,c]=a.shape,h=[i&&u>1?o-1:o,i&&c>1?l-1:l],d=[i&&u>1?u-1:u,i&&c>1?c-1:c],p=h[0]/d[0],f=h[1]/d[1],m=1/p,y=1/f,g=Math.ceil(m)*2+2,b=Math.ceil(y)*2+2,v=new p1e(s.shape,i),w=[{type:"int32",data:h},{type:"int32",data:d},{type:"float32",data:[p]},{type:"float32",data:[f]},{type:"float32",data:[m]},{type:"float32",data:[y]},{type:"int32",data:[g]},{type:"int32",data:[b]}];return n.runWebGPUProgram(v,[a],a.dtype,w)}const m1e={kernelName:jy,backendName:"webgpu",kernelFunc:f1e};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class g1e{constructor(e,n,r,s){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],n,r,e[3]],this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=s,this.shaderKey=`resizeNearest_${s}`}getUserCode(){let e;return this.halfPixelCenters?e="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":e="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${ge("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function y1e(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=a&&l>1?1:0,h=a&&u>1?1:0,d=[{type:"float32",data:[c,h]},{type:"float32",data:[a?.5:0]}],p=new g1e(s.shape,l,u,i);return n.runWebGPUProgram(p,[s],s.dtype,d)}const b1e={kernelName:Bp,backendName:"webgpu",kernelFunc:y1e};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class x1e{constructor(e,n){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=n,this.shaderKey=`resizeNearestNeigborBackprop_${n}`}getUserCode(){return`
      ${ge("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function v1e(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:a}=e,{alignCorners:i}=r,[,o,l]=s.shape,[,u,c]=a.shape,h=[i&&u>1?o-1:o,i&&c>1?l-1:l],d=[i&&u>1?u-1:u,i&&c>1?c-1:c],p=h[0]/d[0],f=h[1]/d[1],m=1/p,y=1/f,g=Math.ceil(m)*2+2,b=Math.ceil(y)*2+2,v=new x1e(s.shape,i),w=[{type:"int32",data:h},{type:"int32",data:d},{type:"float32",data:[m]},{type:"float32",data:[y]},{type:"int32",data:[g]},{type:"int32",data:[b]}];return n.runWebGPUProgram(v,[a],a.dtype,w)}const w1e={kernelName:Vy,backendName:"webgpu",kernelFunc:v1e};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class k1e{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${ge("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `}}/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function S1e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dims:a}=r,i=s.shape.length;if(i===0)return ts({inputs:{x:s},backend:n});const o=s.shape,l=[1,1,1,1];o.forEach((y,g)=>{const b=g+4-i;l[b]=y});const u=Ze(a,s.shape),c=[0,0,0,0];u.forEach(y=>{const g=y+4-i;c[g]=1});const h=[{type:"int32",data:c}],d=Ae({inputs:{x:s},backend:n,attrs:{shape:l}}),p=new k1e(l),f=n.runWebGPUProgram(p,[d],d.dtype,h);n.disposeData(d.dataId);const m=Ae({inputs:{x:f},backend:n,attrs:{shape:o}});return n.disposeData(f.dataId),m}const I1e={kernelName:Up,backendName:"webgpu",kernelFunc:S1e};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class N1e{constructor(e,n){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=e,typeof n=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${ge("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const C1e={kernelName:rb,backendName:"webgpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:s,fillValue:a,center:i}=e,o=n,l=new N1e(r.shape,a),[u,c]=Lb(i,r.shape[1],r.shape[2]),h=[{type:"float32",data:[u]},{type:"float32",data:[c]},{type:"float32",data:[Math.sin(s)]},{type:"float32",data:[Math.cos(s)]}];return typeof a=="number"?h.push({type:"float32",data:[Number.parseFloat(a.toFixed(2))]}):h.push({type:"float32",data:a}),o.runWebGPUProgram(l,[r],r.dtype,h)}};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const T1e=ft({opType:fe.ROUND}),E1e={kernelName:Rc,backendName:"webgpu",kernelFunc:T1e};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const $1e=ft({opType:fe.RSQRT,cpuKernelImpl:jme}),R1e={kernelName:Ac,backendName:"webgpu",kernelFunc:$1e};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class td{constructor(e,n,r,s,a,i,o,l=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=i,this.type=o,this.sumDupeIndices=l,this.dispatchLayout=Ne(e),this.dispatch=ye(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=n>1,this.shaderKey=`scatter_${r}_${s}_${this.sliceDimGreaterThanOne}_${o}_${l}_${a.length}`;const u=sn(a.length);this.uniforms=`sliceDim : i32, strides: ${u}, updatesSize: i32,`,this.updatesRank=s,this.indicesRank=r}getUserCode(){let e="";this.indicesRank===1?e="coords[0]":this.indicesRank===2&&(e="coords[0], j");const n=`getIndices(${e})`,r=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let s="",a="";this.dispatchLayout.x.length===1?(s="flattenedIndex",a=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(s="vec2<i32>(flattenedIndex, coords[1])",a=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);const i=`getUpdates(${Array.from({length:this.updatesRank},(o,l)=>`coords[${l}]`).join(", ")})`;return`
    ${a}
      ${ge("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${n}));
            flattenedIndex = flattenedIndex + indexInside * ${r};
          }
          let updateValue =
              ${Bo(this.type)}(${i});
          let flatIndex = getOutputIndexFromCoords(${s});

          ${this.sumDupeIndices?No("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function A1e(t){const{inputs:e,backend:n,attrs:r}=t,{indices:s,updates:a}=e,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=ka(a,s,i),d=[h/u,u];if(h===0)return n.makeTensorInfo(i,s.dtype);const p=Ae({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=Ae({inputs:{x:a},backend:n,attrs:{shape:[l,u]}}),m=f.dtype,y=Ir({backend:n,attrs:{shape:d,value:0,dtype:m}}),g=Q(f.shape),b=[{type:"int32",data:[o]},{type:"int32",data:c},{type:"int32",data:[g]}],v=new td(f.shape,o,p.shape.length,f.shape.length,c,d,m),w=n.runWebGPUProgram(v,[f,p],m,b,y),k=Ae({inputs:{x:w},backend:n,attrs:{shape:i}});return n.disposeData(p.dataId),n.disposeData(f.dataId),n.disposeData(w.dataId),k}const _1e={kernelName:Gy,backendName:"webgpu",kernelFunc:A1e};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class F1e{constructor(e,n){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=n,this.shaderKey=`search_sorted_${n}`}getUserCode(){return`
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side==="left"?"<":"<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${ge("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `}}/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function O1e(t){const{inputs:e,backend:n,attrs:r}=t,{sortedSequence:s,values:a}=e,{side:i}=r,o=new F1e([a.shape[0],a.shape[1]],i),l=[{type:"int32",data:[s.shape[1]]}];return n.runWebGPUProgram(o,[s,a],"int32",l)}const D1e={kernelName:Ky,backendName:"webgpu",kernelFunc:O1e};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class M1e{constructor(e,n,r){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=r,this.shaderKey="select"}getUserCode(){let e,n;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)n="resRC",e="resRC";else{const r=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],a=[];for(let i=0;i<this.outputShape.length;i++)a.push(`${r[i]}`),i<this.cRank&&s.push(`${r[i]}`);e=s.join(),n=a.join()}return`
      ${ge("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${n}));
          } else {
            setOutputAtIndex(index, getB(${n}));
          }
        }
      }
    `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function P1e(t){const{inputs:e,backend:n}=t,{condition:r,t:s,e:a}=e,i=new M1e(r.shape.length,s.shape,s.shape.length);return n.runWebGPUProgram(i,[r,s,a],On(s.dtype,a.dtype))}const L1e={kernelName:Vp,backendName:"webgpu",kernelFunc:P1e};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const z1e=ft({opType:fe.SELU}),B1e={kernelName:_c,backendName:"webgpu",kernelFunc:z1e};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const W1e=ft({opType:fe.SIGMOID}),U1e={kernelName:Mc,backendName:"webgpu",kernelFunc:W1e};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const V1e=ft({opType:fe.SIGN}),j1e={kernelName:Dc,backendName:"webgpu",kernelFunc:V1e};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const G1e=ft({opType:fe.SIN}),H1e={kernelName:Fc,backendName:"webgpu",kernelFunc:G1e};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const K1e=ft({opType:fe.SINH}),q1e={kernelName:Oc,backendName:"webgpu",kernelFunc:K1e};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const X1e=ft({opType:fe.SOFTPLUS}),Y1e={kernelName:Pc,backendName:"webgpu",kernelFunc:X1e};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Q1e{constructor(e,n,r,s,a,i){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const o=new Array(s.length);for(let l=0;l<o.length;l++)o[l]=s[a[l]];this.outputShape=o,this.newDim=a,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,this.paddedXShape=n,this.uniforms+=`reshapedPaddedXShape : ${sn(s.length)}, paddedXShapeStrides : ${sn(i)}, `,r.map((l,u)=>{this.uniforms+=` pad${u} : vec2<i32>,`}),this.shaderKey=`spaceToBatchND_${a}`}getUserCode(){const e=sn(this.outputShape.length),n=MM(this.newDim);return`
      ${Am(this.paddedXShape,"PaddedX")}
      ${ge("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e}(${n}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${tP(this.xShape,!0)}
        }
      }
    `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Z1e=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:a,paddings:i}=r;R(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const o=a.reduce((b,v)=>b*v),l=[[0,0]];l.push(...i);for(let b=1+a.length;b<s.shape.length;++b)l.push([0,0]);const u=l.map((b,v)=>b[0]+s.shape[v]+b[1]),c=Fl(u,a,o,!1),h=Ol(c.length,a.length,!1),d=Dl(u,a,o,!1),p=Fe(u),f=new Q1e(s.shape,u,l,c,h,p.length),m=[{type:"int32",data:c},{type:"int32",data:p}];l.map(b=>m.push({type:"int32",data:[b[0],b[1]]}));const y=n.runWebGPUProgram(f,[s],s.dtype,m),g=Ae({inputs:{x:y},backend:n,attrs:{shape:d}});return n.disposeData(y.dataId),g},J1e={kernelName:Hp,backendName:"webgpu",kernelFunc:Z1e};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class eve{constructor(e,n,r){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.type=r,this.dispatchLayout=Ne([n]),this.dispatch=ye(this.dispatchLayout,[n],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`
    ${ge("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${No("&result[outIndex]","value",this.type)}
      }
    }
  `}}class tve{constructor(e,n){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[e],this.dispatchLayout=Ne(n),this.dispatch=ye(this.dispatchLayout,n,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`
    ${ge("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${No("&result[segmentId]","1","int32")}
      }
    }
  `}}class nve{constructor(e,n){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.type=n,this.dispatchLayout=Ne(e),this.dispatch=ye(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`
    ${ge("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type==="float32"?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `}}/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function nP(t,e,n,r=!1,s){const a=Q(t.shape)/t.shape[0],i=t.dtype,o=Q(e.shape),l=s.readSync(n.dataId),u=o>0?l[o-1]+1:0;let c;const h=t.shape.slice();h[0]=u;const d=o*a,p=Ir({backend:s,attrs:{shape:h,value:0,dtype:i}});c=new eve(h,d,i);let f=[{type:"int32",data:[a]},{type:"int32",data:[d]}];const m=s.runWebGPUProgram(c,[t,e,n],i,f,p);if(r)return m;const y=Ir({backend:s,attrs:{shape:[u],value:0,dtype:"int32"}});c=new tve(u,n.shape);const g=s.runWebGPUProgram(c,[n],"int32",null,y),b=Ir({backend:s,attrs:{shape:h,value:0,dtype:i}});c=new nve(h,i),f=[{type:"int32",data:[a]}];const v=s.runWebGPUProgram(c,[m,g],i,f,b);return s.disposeData(m.dataId),s.disposeData(g.dataId),v}/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function rve(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:a}=e;return nP(r,s,a,!1,n)}const sve={kernelName:qy,backendName:"webgpu",kernelFunc:rve};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ave(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:a}=e;return nP(r,s,a,!0,n)}const ive={kernelName:Xy,backendName:"webgpu",kernelFunc:ave};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class ove{constructor(e,n){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const r=new Array(e.length);for(let s=0;s<r.length;s++)r[s]=e[s]*n[s];this.outputShape=r,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=lve(this.rank,"uniforms.");return`
      ${ge("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `}}function lve(t,e=""){if(t>=5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`(resRC % ${e}aShape)`;const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<t;s++)r.push(`(${n[s]} % ${e}aShape[${s}])`);return r.join()}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function V2(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reps:a}=r;if(n.shouldExecuteOnCPU([s])||s.dtype==="string"||s.shape.length>=5){const o=n.readSync(s.dataId),l=s.dtype==="string"?o.map(h=>Vs(h)):o,u=Qe(s.shape,s.dtype,l),c=Qme(u,a);return n.makeTensorInfo(c.shape,c.dtype,c.values)}const i=new ove(s.shape,a);return n.runWebGPUProgram(i,[s],s.dtype)}const uve={kernelName:Vc,backendName:"webgpu",kernelFunc:V2};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function cve(t){const{inputs:e,backend:n,attrs:r}=t,{sparseIndices:s,sparseValues:a,defaultValue:i}=e,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=ka(a,s,o),p=!1;if(a.dtype==="string"){const E=n.bufferSync(s),_=n.bufferSync(a),O=Vs(n.readSync(i.dataId)[0]),M=Gme(E,_,o,d,c,u,l,h,O,p);return n.makeTensorInfo(o,M.dtype,M.values)}const f=[d/c,c],m=Ae({inputs:{x:s},backend:n,attrs:{shape:[u,l]}}),y=a.shape.length?Ae({inputs:{x:a},backend:n,attrs:{shape:[u,c]}}):ts({inputs:{x:a},backend:n}),g=y.dtype,b=n.makeTensorInfo([],g,Fn(1,g)),v=Ae({inputs:{x:i},backend:n,attrs:{shape:Array(f.length).fill(1)}}),w=V2({inputs:{x:v},backend:n,attrs:{reps:f}}),k=Q([u,c]),N=[{type:"int32",data:[l]},{type:"int32",data:h},{type:"int32",data:[k]}];switch(u){case 0:break;case 1:{const E=new td([u,c],l,m.shape.length,y.shape.length,h,f,g,p);n.runWebGPUProgram(E,[y,m],g,N,w)}break;default:{const E=new td([u,c],l,m.shape.length,b.shape.length,h,f,g,p);n.runWebGPUProgram(E,[b,m],g,N,w)}{const E=new td([u,c],l,m.shape.length,y.shape.length,h,f,g);n.runWebGPUProgram(E,[y,m],g,N,w)}}const T=Ae({inputs:{x:w},backend:n,attrs:{shape:o}});return n.disposeData(m.dataId),n.disposeData(y.dataId),n.disposeData(v.dataId),n.disposeData(b.dataId),n.disposeData(w.dataId),T}const hve={kernelName:Yy,backendName:"webgpu",kernelFunc:cve};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function dve(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{numOrSizeSplits:a,axis:i}=r,o=Ze(i,s.shape)[0],l=Zb(s,a,o),u=s.shape.length,c=new Array(u).fill(0),h=s.shape.slice();return l.map(d=>{const p=[...h];p[o]=d;const f=lh({inputs:{x:s},backend:n,attrs:{begin:c,size:p}});return c[o]+=d,f})}const pve={kernelName:Kp,backendName:"webgpu",kernelFunc:dve};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const fve=ft({opType:fe.SQRT}),mve={kernelName:Lc,backendName:"webgpu",kernelFunc:fve};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const gve={kernelName:Qy,backendName:"webgpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,r=e,s=new oh(n.shape,fe.SQUARE);return r.runWebGPUProgram(s,[n],n.dtype)}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const yve=Mn({opType:Ve.SQUARED_DIFFERENCE}),bve={kernelName:zc,backendName:"webgpu",kernelFunc:yve};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function xve({inputs:t,attrs:e,backend:n}){const{x:r}=t,s=new oh(r.shape,fe.STEP,"stepAlpha : f32,"),a=[{type:"float32",data:[e.alpha]}];return n.runWebGPUProgram(s,[r],r.dtype,a)}const vve={kernelName:jc,backendName:"webgpu",kernelFunc:xve};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class wve{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const n=sn(this.outputShape.length);this.uniforms=`begin : ${n},  strides : ${n}, `,this.shaderKey="stridedSlice"}getUserCode(){const e=this.outputShape.length;let n="";if(e===1)n="coords * uniforms.strides + uniforms.begin";else{let r=0;n=this.outputShape.map((s,a)=>(r++,this.outputShape.length===1?`coords * uniforms.strides[${a}] + uniforms.begin[${a}]`:`coords[${r-1}] * uniforms.strides[${a}] + uniforms.begin[${a}]`)).join(",")}return`
       ${ge("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${n}));
         }
       }
     `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function kve(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:y,isSimpleSlice:g,begin:b,end:v,strides:w}=Db(s.shape,a,i,o,l,u,c,h,d);let k;if(m)k=Ae({inputs:{x:s},backend:n,attrs:{shape:f}});else if(y||g){R(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const N=Ob(b,v,w),T=lh({inputs:{x:s},backend:n,attrs:{begin:b,size:N}});k=Ae({inputs:{x:T},backend:n,attrs:{shape:f}}),n.disposeData(T.dataId)}else if(n.shouldExecuteOnCPU([s])){const N=n.readSync(s.dataId),T=Qe(s.shape,s.dtype,N),E=qme(p,T,w,b);k=n.makeTensorInfo(f,s.dtype,E.values)}else{const N=new wve(p),T=[{type:"int32",data:b},{type:"int32",data:w}],E=n.runWebGPUProgram(N,[s],s.dtype,T);k=Ae({inputs:{x:E},backend:n,attrs:{shape:f}}),n.disposeData(E.dataId)}return k}const Sve={kernelName:Jy,backendName:"webgpu",kernelFunc:kve};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ive(t){const{inputs:e,backend:n,attrs:r}=t,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:h}=e,d=n.readSync(c.dataId),p=n.readSync(h.dataId),[f,m]=Xme(d,p,s,a,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}const Nve={kernelName:eb,backendName:"webgpu",kernelFunc:Ive};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Cve=Mn({opType:Ve.SUB,cpuKernelImpl:Yme,supportsComplex:!0}),Tve={kernelName:Bc,backendName:"webgpu",kernelFunc:Cve};/**
* @license
* Copyright 2022 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Eve=ft({opType:fe.TAN}),$ve={kernelName:Wc,backendName:"webgpu",kernelFunc:Eve};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Rve=ft({opType:fe.TANH}),Ave={kernelName:Uc,backendName:"webgpu",kernelFunc:Rve};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _ve(t){const{inputs:e,backend:n,attrs:r}=t,{tensor:s,indices:a,updates:i}=e,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=ka(i,a,s.shape),d=[h/u,u];if(h===0)return n.makeTensorInfo(s.shape,a.dtype);const p=[],f=Ae({inputs:{x:a},backend:n,attrs:{shape:[l,o]}});p.push(f);const m=Ae({inputs:{x:i},backend:n,attrs:{shape:[l,u]}});p.push(m);const y=Ae({inputs:{x:s},backend:n,attrs:{shape:d}});p.push(y);const g=V2({inputs:{x:y},backend:n,attrs:{reps:Array(d.length).fill(1)}}),b=new td([l,u],o,f.shape.length,m.shape.length,c,d,s.dtype,!1),v=Q([l,u]),w=[{type:"int32",data:[o]},{type:"int32",data:c},{type:"int32",data:[v]}],k=n.runWebGPUProgram(b,[m,f],y.dtype,w,g);p.push(k);const N=Ae({inputs:{x:k},backend:n,attrs:{shape:s.shape}});return p.forEach(T=>n.disposeData(T.dataId)),N}const Fve={kernelName:Hy,backendName:"webgpu",kernelFunc:_ve};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Ove{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${ge("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}class Dve{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${ge("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Zl(t,e){e!==null&&t.disposeData(e.dataId)}function PC(t){let e=1;for(;e<t;)e*=2;return e}function Mve(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{k:a,sorted:i}=r,o=s.shape,l=o[o.length-1];if(n.shouldExecuteOnCPU([s])){const w=n.readSync(s.dataId),[k,N]=Zme(w,o,s.dtype,a,i);return[n.makeTensorInfo(k.shape,k.dtype,k.values),n.makeTensorInfo(N.shape,N.dtype,N.values)]}if(a===0)return o[o.length-1]=0,[n.makeTensorInfo(o,s.dtype,[]),n.makeTensorInfo(o,"int32",[])];if(l===1)return[s,Ir({attrs:{shape:o,dtype:"int32",value:0},backend:n})];const u=Q(o)/l,c=Ae({inputs:{x:s},attrs:{shape:[u,l]},backend:n}),h=PC(a),d=PC(l);let p=null;const f=()=>p===null?[c,c]:[c,p],m=(w,k,N)=>{const T=f(),E=new Ove(N),_=[{type:"int32",data:[l]},{type:"int32",data:[p===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[w]},{type:"int32",data:[k]}],O=p;p=n.runWebGPUProgram(E,T,"int32",_),Zl(n,O)};for(let w=1;w<h;w*=2){const k=w*2;for(let N=w;N>=1;N/=2)m(k,N,[u,d])}for(let w=d;w>h;w/=2){const k=f(),N=new Dve([u,w/2]),T=[{type:"int32",data:[l]},{type:"int32",data:[p===null?1:0]},{type:"int32",data:[h]}],E=p;p=n.runWebGPUProgram(N,k,"int32",T),Zl(n,E);const _=h/2,O=_*2;for(let M=_;M>=1;M/=2)m(O,M,p.shape)}let y=p;p=lh({inputs:{x:p},backend:n,attrs:{begin:0,size:[u,a]}}),Zl(n,y);let g=QM({inputs:{x:c,indices:p},backend:n,attrs:{axis:1,batchDims:1}});Zl(n,c);const b=o.slice(0,-1);b.push(a),y=p,p=Ae({inputs:{x:p},attrs:{shape:b},backend:n}),Zl(n,y);const v=g;return g=Ae({inputs:{x:g},attrs:{shape:b},backend:n}),Zl(n,v),[g,p]}const Pve={kernelName:tb,backendName:"webgpu",kernelFunc:Mve};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Lve{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${ge("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zve(t){const{inputs:e,backend:n,attrs:r}=t,{image:s,transforms:a}=e,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[c,h,d,p]=s.shape,[f,m]=u??[h,d],y=[c,f,m,p],g=new Lve(y),b=i==="nearest"?1:2;let v;switch(o){case"constant":v=1;break;case"reflect":v=2;break;case"wrap":v=3;break;case"nearest":v=4;break;default:v=1;break}const w=[{type:"int32",data:[b]},{type:"int32",data:[v]},{type:"float32",data:[l]}];return n.runWebGPUProgram(g,[s,a],"float32",w)}const Bve={kernelName:nb,backendName:"webgpu",kernelFunc:zve};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Wve(t){const{inputs:e,backend:n,attrs:r}=t,{value:s}=e;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s,o=i.shape.length,l=s.shape[a],u=new Array(o-1);let c=0;for(let m=0;m<o;m++)m!==a&&(u[c++]=i.shape[m]);const h=[],d=new Array(o).fill(0),p=i.shape.slice();p[a]=1;const f=new Array(l);for(let m=0;m<f.length;m++){d[a]=m;const y=lh({inputs:{x:i},backend:n,attrs:{begin:d,size:p}}),g=Ae({inputs:{x:y},backend:n,attrs:{shape:u}});f[m]=g,h.push(y)}return h.forEach(m=>n.disposeData(m.dataId)),f}const Uve={kernelName:Xp,backendName:"webgpu",kernelFunc:Wve};/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Vve{constructor(e,n,r){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=n,this.dispatchLayout=Ne(e),this.dispatch=ye(this.dispatchLayout,e,this.workgroupSize),r!=="float32"&&r!=="int32")throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${r} type.`);this.type=r,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`
    ${ge("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${No("&result[flatIndex]","value",this.type)}
        }
      }
    }
  `}}/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function jve(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,segmentIds:a}=e,{numSegments:i}=r,o=s.shape.length,l=[];let u=0;const c=Tt([u],o);let h=s;c!=null&&(h=ja({inputs:{x:s},backend:n,attrs:{perm:c}}),l.push(h),u=Ft(1,o)[0]);const d=Vk(h.shape,u,i),p=Q([h.shape[u]]),f=Ae({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});l.push(f);const m=s.dtype,y=[f.shape[0],i],g=Ir({backend:n,attrs:{shape:y,value:0,dtype:m}}),b=new Vve(f.shape,y,m),v=[{type:"int32",data:[i]},{type:"int32",data:[Q(f.shape)]}],w=n.runWebGPUProgram(b,[f,a],m,v,g),k=Ae({inputs:{x:w},backend:n,attrs:{shape:d}});l.push(w);let N=k;if(c!=null){l.push(k);const T=Ha(c);N=ja({inputs:{x:N},backend:n,attrs:{perm:T}})}return l.forEach(T=>n.disposeData(T.dataId)),N}const Gve={kernelName:Yp,backendName:"webgpu",kernelFunc:jve};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Hve=[yme,tge,rge,age,oge,cge,yge,xge,wge,Sge,Nge,Tge,$ge,Age,Fge,Lge,Bge,jge,Hge,qge,Jge,rye,iye,cye,dye,gye,xme,xye,Sye,Aye,Pye,Wye,jye,Hye,qye,Yye,Zye,tbe,rbe,abe,obe,cbe,ybe,xbe,pbe,kbe,Nbe,$be,Abe,Obe,Lbe,Bbe,Ube,jbe,Hbe,qbe,Xbe,Qbe,Jbe,fme,t0e,o0e,r0e,a0e,c0e,d0e,f0e,y0e,v0e,k0e,I0e,bme,C0e,wye,E0e,R0e,_0e,O0e,M0e,L0e,W0e,G0e,V0e,K0e,X0e,Q0e,txe,sxe,Dge,ixe,lxe,gxe,cxe,fxe,bxe,Mge,vxe,kxe,Ixe,Cxe,Axe,Dbe,Fxe,Dxe,Pxe,oye,Bxe,Uxe,jxe,Kxe,Xxe,Qxe,Jxe,t1e,lye,r1e,a1e,o1e,u1e,mme,d1e,m1e,b1e,w1e,I1e,C1e,E1e,R1e,_1e,D1e,L1e,B1e,U1e,j1e,H1e,q1e,Qge,vve,Sve,Nve,$xe,Y1e,J1e,sve,ive,hve,pve,mve,gve,bve,Tve,Mbe,$ve,Ave,Fve,uve,Pve,Bve,pge,Uve,Gve,Wxe];for(const t of Hve)sb(t);/**
* @license
* Copyright 2023 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/var rP=function(t,e){return(rP=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,r){n.__proto__=r}||function(n,r){for(var s in r)Object.prototype.hasOwnProperty.call(r,s)&&(n[s]=r[s])})(t,e)};function sP(t,e){if(typeof e!="function"&&e!==null)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function n(){this.constructor=t}rP(t,e),t.prototype=e===null?Object.create(e):(n.prototype=e.prototype,new n)}var $t=function(){return($t=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++)for(var s in e=arguments[n])Object.prototype.hasOwnProperty.call(e,s)&&(t[s]=e[s]);return t}).apply(this,arguments)};function ut(t,e,n,r){return new(n||(n=Promise))(function(s,a){function i(u){try{l(r.next(u))}catch(c){a(c)}}function o(u){try{l(r.throw(u))}catch(c){a(c)}}function l(u){var c;u.done?s(u.value):(c=u.value,c instanceof n?c:new n(function(h){h(c)})).then(i,o)}l((r=r.apply(t,[])).next())})}function ct(t,e){var n,r,s,a,i={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return a={next:o(0),throw:o(1),return:o(2)},typeof Symbol=="function"&&(a[Symbol.iterator]=function(){return this}),a;function o(l){return function(u){return function(c){if(n)throw new TypeError("Generator is already executing.");for(;i;)try{if(n=1,r&&(s=2&c[0]?r.return:c[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,c[1])).done)return s;switch(r=0,s&&(c=[2&c[0],s.value]),c[0]){case 0:case 1:s=c;break;case 4:return i.label++,{value:c[1],done:!1};case 5:i.label++,r=c[1],c=[0];continue;case 7:c=i.ops.pop(),i.trys.pop();continue;default:if(s=i.trys,!((s=s.length>0&&s[s.length-1])||c[0]!==6&&c[0]!==2)){i=0;continue}if(c[0]===3&&(!s||c[1]>s[0]&&c[1]<s[3])){i.label=c[1];break}if(c[0]===6&&i.label<s[1]){i.label=s[1],s=c;break}if(s&&i.label<s[2]){i.label=s[2],i.ops.push(c);break}s[2]&&i.ops.pop(),i.trys.pop();continue}c=e.call(t,i)}catch(h){c=[6,h],r=0}finally{n=s=0}if(5&c[0])throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}([l,u])}}}function Ko(t,e,n){if(n||arguments.length===2)for(var r,s=0,a=e.length;s<a;s++)!r&&s in e||(r||(r=Array.prototype.slice.call(e,0,s)),r[s]=e[s]);return t.concat(r||Array.prototype.slice.call(e))}var Ga=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],Gd=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"],Kve={left:[1,2,3,7,9,11,13,15,17,19,21,23,25,27,29,31],right:[4,5,6,8,10,12,14,16,18,20,22,24,26,28,30,32],middle:[0]},qve={left:[1,3,5,7,9,11,13,15],right:[2,4,6,8,10,12,14,16],middle:[0]},Xve=[[0,1],[0,2],[1,3],[2,4],[5,6],[5,7],[5,11],[6,8],[6,12],[7,9],[8,10],[11,12],[11,13],[12,14],[13,15],[14,16]],Yve=[[0,1],[0,4],[1,2],[2,3],[3,7],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[11,23],[12,14],[14,16],[12,24],[13,15],[15,17],[16,18],[16,20],[15,17],[15,19],[15,21],[16,22],[17,19],[18,20],[23,25],[23,24],[24,26],[25,27],[26,28],[27,29],[28,30],[27,31],[28,32],[29,31],[30,32]];function Lg(t){return t instanceof SVGAnimatedLength?t.baseVal.value:t}function aP(t){return ut(this,void 0,void 0,function(){var e,n;return ct(this,function(r){switch(r.label){case 0:return e=document.createElement("canvas"),t instanceof st?[4,_b(t,e)]:[3,2];case 1:return r.sent(),[3,3];case 2:e.width=Lg(t.width),e.height=Lg(t.height),n=e.getContext("2d"),t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0),r.label=3;case 3:return[2,e]}})})}function iP(t){return ut(this,void 0,void 0,function(){var e,n,r,s,a,i;return ct(this,function(o){switch(o.label){case 0:return t instanceof st?(e=t.shape.slice(0,2),n=e[0],r=e[1],s=ImageData.bind,[4,_b(t)]):[3,2];case 1:return[2,new(s.apply(ImageData,[void 0,o.sent(),r,n]))];case 2:return a=document.createElement("canvas"),i=a.getContext("2d"),a.width=Lg(t.width),a.height=Lg(t.height),i.drawImage(t,0,0),[2,i.getImageData(0,0,a.width,a.height)]}})})}function Qve(t){return ut(this,void 0,void 0,function(){var e,n;return ct(this,function(r){switch(r.label){case 0:return t instanceof SVGImageElement||t instanceof OffscreenCanvas?[4,aP(t)]:[3,2];case 1:return n=r.sent(),[3,3];case 2:n=t,r.label=3;case 3:return e=n,[2,Lk(e,4)]}})})}function oP(t){if(t<0||t>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(t));if(!Number.isInteger(t))throw new Error("Mask value must be an integer but got ".concat(t))}var $h={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},Zve=function(){function t(e){this.mask=e}return t.prototype.toCanvasImageSource=function(){return ut(this,void 0,void 0,function(){return ct(this,function(e){return[2,this.mask]})})},t.prototype.toImageData=function(){return ut(this,void 0,void 0,function(){return ct(this,function(e){return[2,iP(this.mask)]})})},t.prototype.toTensor=function(){return ut(this,void 0,void 0,function(){return ct(this,function(e){return[2,Qve(this.mask)]})})},t.prototype.getUnderlyingType=function(){return"canvasimagesource"},t}();function Jve(t){return oP(t),"person"}var ewe=function(){function t(e){var n,r=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new mpe.Pose({locateFile:function(s,a){if(e.solutionPath){var i=e.solutionPath.replace(/\/+$/,"");return"".concat(i,"/").concat(s)}return"".concat(a,"/").concat(s)}}),e.modelType){case"lite":n=0;break;case"heavy":n=2;break;case"full":default:n=1}this.poseSolution.setOptions({modelComplexity:n,smoothLandmarks:e.enableSmoothing,enableSegmentation:e.enableSegmentation,smoothSegmentation:e.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults(function(s){if(r.height=s.image.height,r.width=s.image.width,s.poseLandmarks==null)r.poses=[];else{var a=r.translateOutput(s.poseLandmarks,s.poseWorldLandmarks);s.segmentationMask&&(a.segmentation={maskValueToLabel:Jve,mask:new Zve(s.segmentationMask)}),r.poses=[a]}})}return t.prototype.translateOutput=function(e,n){var r=this,s={keypoints:e.map(function(a,i){return{x:a.x*r.width,y:a.y*r.height,z:a.z,score:a.visibility,name:Gd[i]}})};return n!=null&&(s.keypoints3D=n.map(function(a,i){return{x:a.x,y:a.y,z:a.z,score:a.visibility,name:Gd[i]}})),s},t.prototype.estimatePoses=function(e,n,r){return ut(this,void 0,void 0,function(){var s,a;return ct(this,function(i){switch(i.label){case 0:return n&&n.flipHorizontal&&n.flipHorizontal!==this.selfieMode&&(this.selfieMode=n.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),e instanceof st?(a=ImageData.bind,[4,_b(e)]):[3,2];case 1:return s=new(a.apply(ImageData,[void 0,i.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:s=e,i.label=3;case 3:return e=s,[4,this.poseSolution.send({image:e},r)];case 4:return i.sent(),[2,this.poses]}})})},t.prototype.dispose=function(){this.poseSolution.close()},t.prototype.reset=function(){this.poseSolution.reset()},t.prototype.initialize=function(){return this.poseSolution.initialize()},t}();function twe(t){return ut(this,void 0,void 0,function(){var e,n;return ct(this,function(r){switch(r.label){case 0:return e=function(s){if(s==null)return $t({},$h);var a=$t({},s);return a.runtime="mediapipe",a.enableSegmentation==null&&(a.enableSegmentation=$h.enableSegmentation),a.enableSmoothing==null&&(a.enableSmoothing=$h.enableSmoothing),a.smoothSegmentation==null&&(a.smoothSegmentation=$h.smoothSegmentation),a.modelType==null&&(a.modelType=$h.modelType),a}(t),[4,(n=new ewe(e)).initialize()];case 1:return r.sent(),[2,n]}})})}function Hu(t){return t instanceof st?{height:t.shape[0],width:t.shape[1]}:{height:t.height,width:t.width}}function lP(t){return t-2*Math.PI*Math.floor((t+Math.PI)/(2*Math.PI))}function j2(t){return t instanceof st?t:Lk(t)}function uP(t,e,n){return Av(n,"inputResolution"),[1/n.width*t[0][0]*e.width,1/n.height*t[0][1]*e.width,t[0][3]*e.width,1/n.width*t[1][0]*e.height,1/n.height*t[1][1]*e.height,t[1][3]*e.height,0,0]}function Av(t,e){R(t.width!==0,function(){return"".concat(e," width cannot be 0.")}),R(t.height!==0,function(){return"".concat(e," height cannot be 0.")})}function Ax(t,e,n){var r=n.rotationVectorStartKeypointIndex,s=n.rotationVectorEndKeypointIndex,a=t.locationData,i=a.relativeKeypoints[r].x*e.width,o=a.relativeKeypoints[r].y*e.height,l=a.relativeKeypoints[s].x*e.width,u=a.relativeKeypoints[s].y*e.height,c=2*Math.sqrt((l-i)*(l-i)+(u-o)*(u-o)),h=function(d,p,f){var m,y=d.locationData,g=f.rotationVectorStartKeypointIndex,b=f.rotationVectorEndKeypointIndex;m=f.rotationVectorTargetAngle?f.rotationVectorTargetAngle:Math.PI*f.rotationVectorTargetAngleDegree/180;var v=y.relativeKeypoints[g].x*p.width,w=y.relativeKeypoints[g].y*p.height,k=y.relativeKeypoints[b].x*p.width,N=y.relativeKeypoints[b].y*p.height;return lP(m-Math.atan2(-(N-w),k-v))}(t,e,n);return{xCenter:i/e.width,yCenter:o/e.height,width:c/e.width,height:c/e.height,rotation:h}}function cP(t){if(t.length!==16)throw new Error("Array length must be 16 but got ".concat(t.length));return[[t[0],t[1],t[2],t[3]],[t[4],t[5],t[6],t[7]],[t[8],t[9],t[10],t[11]],[t[12],t[13],t[14],t[15]]]}function _x(t,e,n,r,s,a,i){return t[e][s]*(t[n][a]*t[r][i]-t[n][i]*t[r][a])}function ar(t,e,n){var r=(e+1)%4,s=(e+2)%4,a=(e+3)%4,i=(n+1)%4,o=(n+2)%4,l=(n+3)%4;return _x(t,r,s,a,i,o,l)+_x(t,s,a,r,i,o,l)+_x(t,a,r,s,i,o,l)}function LC(t,e,n){n===void 0&&(n={ignoreRotation:!1});for(var r=[],s=0,a=t;s<a.length;s++){var i=a[s],o=i.x-.5,l=i.y-.5,u=n.ignoreRotation?0:e.rotation,c=Math.cos(u)*o-Math.sin(u)*l,h=Math.sin(u)*o+Math.cos(u)*l;c=c*e.width+e.xCenter,h=h*e.height+e.yCenter;var d=i.z*e.width,p=$t({},i);p.x=c,p.y=h,p.z=d,r.push(p)}return r}function hP(t,e){var n=function(r,s,a,i){var o=s-r,l=i-a,u=l/o;return{scale:u,offset:a-r*u}}(0,255,e[0],e[1]);return Y(function(){return ie(z(t,n.scale),n.offset)})}function _v(t,e,n){var r,s,a,i,o,l,u,c,h,d,p,f,m,y,g=e.outputTensorSize,b=e.keepAspectRatio,v=e.borderMode,w=e.outputTensorFloatRange,k=Hu(t),N=function(_,O){return O?{xCenter:O.xCenter*_.width,yCenter:O.yCenter*_.height,width:O.width*_.width,height:O.height*_.height,rotation:O.rotation}:{xCenter:.5*_.width,yCenter:.5*_.height,width:_.width,height:_.height,rotation:0}}(k,n),T=function(_,O,M){if(M===void 0&&(M=!1),!M)return{top:0,left:0,right:0,bottom:0};var V=O.height,W=O.width;Av(O,"targetSize"),Av(_,"roi");var K,q,ee=V/W,te=_.height/_.width,G=0,J=0;return ee>te?(K=_.width,q=_.width*ee,J=(1-te/ee)/2):(K=_.height/ee,q=_.height,G=(1-ee/te)/2),_.width=K,_.height=q,{top:J,left:G,right:G,bottom:J}}(N,g,b),E=(r=N,s=k.width,a=k.height,i=!1,o=r.width,l=r.height,u=i?-1:1,c=Math.cos(r.rotation),h=Math.sin(r.rotation),d=r.xCenter,p=r.yCenter,f=1/s,m=1/a,(y=new Array(16))[0]=o*c*u*f,y[1]=-l*h*f,y[2]=0,y[3]=(-.5*o*c*u+.5*l*h+d)*f,y[4]=o*h*u*m,y[5]=l*c*m,y[6]=0,y[7]=(-.5*l*c-.5*o*h*u+p)*m,y[8]=0,y[9]=0,y[10]=o*f,y[11]=0,y[12]=0,y[13]=0,y[14]=0,y[15]=1,cP(y));return{imageTensor:Y(function(){var _=j2(t),O=Bs(uP(E,k,g),[1,8]),M=v==="zero"?"constant":"nearest",V=hr.transform(hn(me(_,"float32")),O,"bilinear",M,0,[g.height,g.width]);return w!=null?hP(V,w):V}),padding:T,transformationMatrix:E}}function zC(t,e,n,r){return r===1?.5*(t+e):t+(e-t)*n/(r-1)}function nwe(t){return Y(function(){var e=function(s){return Y(function(){return[je(s,[0,0,0],[1,-1,1]),je(s,[0,0,1],[1,-1,-1])]})}(t),n=e[0],r=e[1];return{boxes:yt(r),logits:yt(n)}})}function dP(t){return t!=null&&t.currentTime!=null}function BC(t){for(var e={locationData:{relativeKeypoints:[]}},n=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,s=Number.MAX_SAFE_INTEGER,a=Number.MIN_SAFE_INTEGER,i=0;i<t.length;++i){var o=t[i];n=Math.min(n,o.x),r=Math.max(r,o.x),s=Math.min(s,o.y),a=Math.max(a,o.y),e.locationData.relativeKeypoints.push({x:o.x,y:o.y})}return e.locationData.relativeBoundingBox={xMin:n,yMin:s,xMax:r,yMax:a,width:r-n,height:a-s},e}function rwe(t,e,n,r){return ut(this,void 0,void 0,function(){var s,a,i,o,l;return ct(this,function(u){switch(u.label){case 0:return t.sort(function(c,h){return Math.max.apply(Math,h.score)-Math.max.apply(Math,c.score)}),s=Bs(t.map(function(c){return[c.locationData.relativeBoundingBox.yMin,c.locationData.relativeBoundingBox.xMin,c.locationData.relativeBoundingBox.yMax,c.locationData.relativeBoundingBox.xMax]})),a=dn(t.map(function(c){return c.score[0]})),[4,hr.nonMaxSuppressionAsync(s,a,e,n)];case 1:return[4,(i=u.sent()).array()];case 2:return o=u.sent(),l=t.filter(function(c,h){return o.indexOf(h)>-1}),Pe([s,a,i]),[2,l]}})})}function pP(t,e){return t.map(function(n){var r=$t($t({},n),{x:n.x*e.width,y:n.y*e.height});return n.z!=null&&(r.z=n.z*e.width),r})}function swe(t,e,n){return ut(this,void 0,void 0,function(){var r,s,a,i,o,l,u,c,h,d,p,f,m,y,g,b,v,w,k,N,T,E,_,O;return ct(this,function(M){switch(M.label){case 0:if(r=yt(e,[0]),s=r.shape,a=s[0],i=s[1],o=s[2],t.length!==o)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(t.length,", heatmap length: ").concat(o));return l=[],[4,r.buffer()];case 1:for(u=M.sent(),c=0;c<t.length;c++)if(h=t[c],d=$t({},h),l.push(d),p=Math.trunc(d.x*i),f=Math.trunc(d.y*a),!(p<0||p>=i||f<0||p>=a)){for(m=Math.trunc((n.kernelSize-1)/2),y=Math.max(0,p-m),g=Math.min(i,p+m+1),b=Math.max(0,f-m),v=Math.min(a,f+m+1),w=0,k=0,N=0,T=0,E=b;E<v;++E)for(_=y;_<g;++_)O=u.get(E,_,c),w+=O,T=Math.max(T,O),k+=_*O,N+=E*O;T>=n.minConfidenceToRefine&&w>0&&(d.x=k/i/w,d.y=N/a/w)}return r.dispose(),[2,l]}})})}function WC(t,e){var n=e.left,r=e.top,s=e.left+e.right,a=e.top+e.bottom;return t.map(function(i){return $t($t({},i),{x:(i.x-n)/(1-s),y:(i.y-r)/(1-a),z:i.z/(1-s)})})}function awe(t,e,n){return Nd()==="webgl"?function(r,s,a){var i=a.combineWithPreviousRatio.toFixed(2),o={variableNames:["prevMask","newMask"],outputShape:r.shape,userCode:`
  void main() {
      ivec2 coords = getOutputCoords();
      int height = coords[0];
      int width = coords[1];

      float prevMaskValue = getPrevMask(height, width);
      float newMaskValue = getNewMask(height, width);

      /*
      * Assume p := newMaskValue
      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)
      * uncertainty alpha(p) =
      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the
      * uncertainty]
      *
      * The following polynomial approximates uncertainty alpha as a
      * function of (p + 0.5):
      */
      const float c1 = 5.68842;
      const float c2 = -0.748699;
      const float c3 = -57.8051;
      const float c4 = 291.309;
      const float c5 = -624.717;
      float t = newMaskValue - 0.5;
      float x = t * t;

      float uncertainty =
        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));

      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *
                             (uncertainty * `.concat(i,`);

      setOutput(outputValue);
    }
`)},l=ll();return Y(function(){var u=l.compileAndRun(o,[r,s]);return ir().makeTensorFromDataId(u.dataId,u.shape,u.dtype)})}(t,e,n):Y(function(){var r=Ie(e,.5),s=It(r),a=Ie(1,ao(1,z(s,ie(5.68842,z(s,ie(-.748699,z(s,ie(-57.8051,z(s,ie(291.309,z(s,-624.717)))))))))));return ie(e,z(Ie(t,e),z(a,n.combineWithPreviousRatio)))})}function iwe(t,e,n){return ut(this,void 0,void 0,function(){var r,s,a,i,o;return ct(this,function(l){switch(l.label){case 0:return r=t[0],s=t[1],a=function(u,c,h){return Y(function(){var d,p,f,m;h.reverseOutputOrder?(p=yt(je(u,[0,h.boxCoordOffset+0],[-1,1])),d=yt(je(u,[0,h.boxCoordOffset+1],[-1,1])),m=yt(je(u,[0,h.boxCoordOffset+2],[-1,1])),f=yt(je(u,[0,h.boxCoordOffset+3],[-1,1]))):(d=yt(je(u,[0,h.boxCoordOffset+0],[-1,1])),p=yt(je(u,[0,h.boxCoordOffset+1],[-1,1])),f=yt(je(u,[0,h.boxCoordOffset+2],[-1,1])),m=yt(je(u,[0,h.boxCoordOffset+3],[-1,1]))),p=ie(z(Se(p,h.xScale),c.w),c.x),d=ie(z(Se(d,h.yScale),c.h),c.y),h.applyExponentialOnBoxSize?(f=z(pr(Se(f,h.hScale)),c.h),m=z(pr(Se(m,h.wScale)),c.w)):(f=z(Se(f,h.hScale),c.h),m=z(Se(m,h.wScale),c.h));var y=Ie(d,Se(f,2)),g=Ie(p,Se(m,2)),b=ie(d,Se(f,2)),v=ie(p,Se(m,2)),w=qt([j(y,[h.numBoxes,1]),j(g,[h.numBoxes,1]),j(b,[h.numBoxes,1]),j(v,[h.numBoxes,1])],1);if(h.numKeypoints)for(var k=0;k<h.numKeypoints;++k){var N=h.keypointCoordOffset+k*h.numValuesPerKeypoint,T=void 0,E=void 0;h.reverseOutputOrder?(T=yt(je(u,[0,N],[-1,1])),E=yt(je(u,[0,N+1],[-1,1]))):(E=yt(je(u,[0,N],[-1,1])),T=yt(je(u,[0,N+1],[-1,1])));var _=ie(z(Se(T,h.xScale),c.w),c.x),O=ie(z(Se(E,h.yScale),c.h),c.y);w=qt([w,j(_,[h.numBoxes,1]),j(O,[h.numBoxes,1])],1)}return w})}(s,e,n),i=Y(function(){var u=r;return n.sigmoidScore?(n.scoreClippingThresh!=null&&(u=Cr(r,-n.scoreClippingThresh,n.scoreClippingThresh)),u=ps(u)):u}),[4,owe(a,i,n)];case 1:return o=l.sent(),Pe([a,i]),[2,o]}})})}function owe(t,e,n){return ut(this,void 0,void 0,function(){var r,s,a,i,o,l,u,c,h,d,p,f;return ct(this,function(m){switch(m.label){case 0:return r=[],[4,t.data()];case 1:return s=m.sent(),[4,e.data()];case 2:for(a=m.sent(),i=0;i<n.numBoxes;++i)if(!(n.minScoreThresh!=null&&a[i]<n.minScoreThresh||(o=i*n.numCoords,l=lwe(s[o+0],s[o+1],s[o+2],s[o+3],a[i],n.flipVertically,i),(u=l.locationData.relativeBoundingBox).width<0||u.height<0))){if(n.numKeypoints>0)for((c=l.locationData).relativeKeypoints=[],h=n.numKeypoints*n.numValuesPerKeypoint,d=0;d<h;d+=n.numValuesPerKeypoint)p=o+n.keypointCoordOffset+d,f={x:s[p+0],y:n.flipVertically?1-s[p+1]:s[p+1]},c.relativeKeypoints.push(f);r.push(l)}return[2,r]}})})}function lwe(t,e,n,r,s,a,i){return{score:[s],ind:i,locationData:{relativeBoundingBox:{xMin:e,yMin:a?1-n:t,xMax:r,yMax:a?1-t:n,width:r-e,height:n-t}}}}function uwe(t,e){return t==="none"?e:function(n){return 1/(1+Math.exp(-n))}(e)}function UC(t,e,n,r){return ut(this,void 0,void 0,function(){var s,a,i,o,l,u,c,h;return ct(this,function(d){switch(d.label){case 0:return n=n||e.flipHorizontally||!1,r=r||e.flipVertically||!1,s=t.size,a=s/e.numLandmarks,[4,t.data()];case 1:for(i=d.sent(),o=[],l=0;l<e.numLandmarks;++l)u=l*a,(h={x:0,y:0}).x=n?e.inputImageWidth-i[u]:i[u],a>1&&(h.y=r?e.inputImageHeight-i[u+1]:i[u+1]),a>2&&(h.z=i[u+2]),a>3&&(h.score=uwe(e.visibilityActivation,i[u+3])),o.push(h);for(c=0;c<o.length;++c)(h=o[c]).x=h.x/e.inputImageWidth,h.y=h.y/e.inputImageHeight,h.z=h.z/e.inputImageWidth/(e.normalizeZ||1);return[2,o]}})})}function VC(t,e,n){var r=t.width,s=t.height,a=t.rotation;if(n.rotation==null&&n.rotationDegree==null||(a=function(u,c){return c.rotation!=null?u+=c.rotation:c.rotationDegree!=null&&(u+=Math.PI*c.rotationDegree/180),lP(u)}(a,n)),a===0)t.xCenter=t.xCenter+r*n.shiftX,t.yCenter=t.yCenter+s*n.shiftY;else{var i=(e.width*r*n.shiftX*Math.cos(a)-e.height*s*n.shiftY*Math.sin(a))/e.width,o=(e.width*r*n.shiftX*Math.sin(a)+e.height*s*n.shiftY*Math.cos(a))/e.height;t.xCenter=t.xCenter+i,t.yCenter=t.yCenter+o}{var l=Math.max(r*e.width,s*e.height);r=l/e.width,s=l/e.height}return t.width=r*n.scaleX,t.height=s*n.scaleY,t}function fP(t,e){return t.map(function(n){var r=$t($t({},n),{x:n.x/e.width,y:n.y/e.height});return n.z!=null&&(n.z=n.z/e.width),r})}var Li=function(){function t(e){this.alpha=e,this.initialized=!1}return t.prototype.apply=function(e,n){var r;return this.initialized?r=n==null?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*n*Math.asinh((e-this.storedValue)/n):(r=e,this.initialized=!0),this.rawValue=e,this.storedValue=r,r},t.prototype.applyWithAlpha=function(e,n,r){return this.alpha=n,this.apply(e,r)},t.prototype.hasLastRawValue=function(){return this.initialized},t.prototype.lastRawValue=function(){return this.rawValue},t.prototype.reset=function(){this.initialized=!1},t}(),Fx=function(){function t(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new Li(this.getAlpha(this.minCutOff)),this.dx=new Li(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return t.prototype.apply=function(e,n,r){if(e==null)return e;var s=Math.trunc(n);if(this.lastTimestamp>=s)return e;this.lastTimestamp!==0&&s!==0&&(this.frequency=1/(1e-6*(s-this.lastTimestamp))),this.lastTimestamp=s;var a=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*r*this.frequency:0,i=this.dx.applyWithAlpha(a,this.getAlpha(this.derivateCutOff)),o=this.minCutOff+this.beta*Math.abs(i),l=this.thresholdCutOff!=null?this.thresholdCutOff+this.thresholdBeta*Math.abs(i):null;return this.x.applyWithAlpha(e,this.getAlpha(o),l)},t.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},t}(),Fv=function(){function t(e){this.config=e}return t.prototype.apply=function(e,n,r){var s=this;if(e==null)return this.reset(),null;this.initializeFiltersIfEmpty(e);var a=1;if(!this.config.disableValueScaling){if(r<this.config.minAllowedObjectScale)return Ko([],e,!0);a=1/r}return e.map(function(i,o){var l=$t($t({},i),{x:s.xFilters[o].apply(i.x,n,a),y:s.yFilters[o].apply(i.y,n,a)});return i.z!=null&&(l.z=s.zFilters[o].apply(i.z,n,a)),l})},t.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},t.prototype.initializeFiltersIfEmpty=function(e){var n=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(r){return new Fx(n.config)}),this.yFilters=e.map(function(r){return new Fx(n.config)}),this.zFilters=e.map(function(r){return new Fx(n.config)}))},t}(),Ox=function(){function t(e){this.config=e,this.window=[],this.lowPassFilter=new Li(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return t.prototype.apply=function(e,n,r){if(e==null)return e;var s,a=Math.trunc(n);if(this.lastTimestamp>=a)return e;if(this.lastTimestamp===-1)s=1;else{for(var i=e*r-this.lastValue*this.lastValueScale,o=a-this.lastTimestamp,l=i,u=o,c=(1+this.window.length)*(1e6/30),h=0,d=this.window;h<d.length;h++){var p=d[h];if(u+p.duration>c)break;l+=p.distance,u+=p.duration}var f=l/(1e-6*u);s=1-1/(1+this.config.velocityScale*Math.abs(f)),this.window.unshift({distance:i,duration:o}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=r,this.lastTimestamp=a,this.lowPassFilter.applyWithAlpha(e,s)},t}(),cwe=function(){function t(e){this.config=e}return t.prototype.apply=function(e,n,r){var s=this;if(e==null)return this.reset(),null;var a=1;if(!this.config.disableValueScaling){if(r<this.config.minAllowedObjectScale)return Ko([],e,!0);a=1/r}return this.initializeFiltersIfEmpty(e),e.map(function(i,o){var l=$t($t({},i),{x:s.xFilters[o].apply(i.x,n,a),y:s.yFilters[o].apply(i.y,n,a)});return i.z!=null&&(l.z=s.zFilters[o].apply(i.z,n,a)),l})},t.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},t.prototype.initializeFiltersIfEmpty=function(e){var n=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(r){return new Ox(n.config)}),this.yFilters=e.map(function(r){return new Ox(n.config)}),this.zFilters=e.map(function(r){return new Ox(n.config)}))},t}(),Dx=function(){function t(e){if(e.velocityFilter!=null)this.keypointsFilter=new cwe(e.velocityFilter);else{if(e.oneEuroFilter==null)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(e,"."));this.keypointsFilter=new Fv(e.oneEuroFilter)}}return t.prototype.apply=function(e,n,r,s,a){if(s===void 0&&(s=!1),e==null)return this.keypointsFilter.reset(),null;var i=a!=null?function(u,c){return(u.width*c.width+u.height*c.height)/2}(a,r):1,o=s?pP(e,r):e,l=this.keypointsFilter.apply(o,n,i);return s?fP(l,r):l},t}(),jC=function(){function t(e){this.alpha=e.alpha}return t.prototype.apply=function(e){var n=this;if(e==null)return this.visibilityFilters=null,null;this.visibilityFilters!=null&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map(function(o){return new Li(n.alpha)}));for(var r=[],s=0;s<e.length;++s){var a=e[s],i=$t({},a);i.score=this.visibilityFilters[s].apply(a.score),r.push(i)}return r},t}(),hwe={reduceBoxesInLowestlayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},Jl={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},dwe={maxPoses:1,flipHorizontal:!1},pwe={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},fwe=.3,GC={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25,squareLong:!0},mwe={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},gwe={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},ywe={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},bwe={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},xwe={kernelSize:7,minConfidenceToRefine:.5},HC={alpha:.1},vwe={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},wwe={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},kwe={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},Swe={activation:"none"},Iwe={combineWithPreviousRatio:.7},Nwe=function(){function t(e){this.mask=e}return t.prototype.toCanvasImageSource=function(){return ut(this,void 0,void 0,function(){return ct(this,function(e){return[2,aP(this.mask)]})})},t.prototype.toImageData=function(){return ut(this,void 0,void 0,function(){return ct(this,function(e){return[2,iP(this.mask)]})})},t.prototype.toTensor=function(){return ut(this,void 0,void 0,function(){return ct(this,function(e){return[2,this.mask]})})},t.prototype.getUnderlyingType=function(){return"tensor"},t}();function Cwe(t){return oP(t),"person"}var Twe=function(){function t(e,n,r,s,a,i){this.detectorModel=e,this.landmarkModel=n,this.enableSmoothing=r,this.enableSegmentation=s,this.smoothSegmentation=a,this.modelType=i,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(h){h.reduceBoxesInLowestLayer==null&&(h.reduceBoxesInLowestLayer=!1),h.interpolatedScaleAspectRatio==null&&(h.interpolatedScaleAspectRatio=1),h.fixedAnchorSize==null&&(h.fixedAnchorSize=!1);for(var d=[],p=0;p<h.numLayers;){for(var f=[],m=[],y=[],g=[],b=p;b<h.strides.length&&h.strides[b]===h.strides[p];){var v=zC(h.minScale,h.maxScale,b,h.strides.length);if(b===0&&h.reduceBoxesInLowestLayer)y.push(1),y.push(2),y.push(.5),g.push(.1),g.push(v),g.push(v);else{for(var w=0;w<h.aspectRatios.length;++w)y.push(h.aspectRatios[w]),g.push(v);if(h.interpolatedScaleAspectRatio>0){var k=b===h.strides.length-1?1:zC(h.minScale,h.maxScale,b+1,h.strides.length);g.push(Math.sqrt(v*k)),y.push(h.interpolatedScaleAspectRatio)}}b++}for(var N=0;N<y.length;++N){var T=Math.sqrt(y[N]);f.push(g[N]/T),m.push(g[N]*T)}var E=0,_=0;if(h.featureMapHeight.length>0)E=h.featureMapHeight[p],_=h.featureMapWidth[p];else{var O=h.strides[p];E=Math.ceil(h.inputSizeHeight/O),_=Math.ceil(h.inputSizeWidth/O)}for(var M=0;M<E;++M)for(var V=0;V<_;++V)for(var W=0;W<f.length;++W){var K={xCenter:(V+h.anchorOffsetX)/_,yCenter:(M+h.anchorOffsetY)/E,width:0,height:0};h.fixedAnchorSize?(K.width=1,K.height=1):(K.width=m[W],K.height=f[W]),d.push(K)}p=b}return d}(hwe);var o=dn(this.anchors.map(function(h){return h.width})),l=dn(this.anchors.map(function(h){return h.height})),u=dn(this.anchors.map(function(h){return h.xCenter})),c=dn(this.anchors.map(function(h){return h.yCenter}));this.anchorTensor={x:u,y:c,w:o,h:l},this.prevFilteredSegmentationMask=this.enableSegmentation?Bs([],[0,0]):null}return t.prototype.estimatePoses=function(e,n,r){return ut(this,void 0,void 0,function(){var s,a,i,o,l,u,c,h,d,p,f,m,y,g,b,v,w,k,N,T,E,_,O;return ct(this,function(M){switch(M.label){case 0:return s=function(V){var W;if((W=V==null?dwe:$t({},V)).maxPoses==null&&(W.maxPoses=1),W.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(W.maxPoses,". Should be > 0."));if(W.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return W}(n),e==null?(this.reset(),[2,[]]):(this.maxPoses=s.maxPoses,this.timestamp=r!=null?1e3*r:dP(e)?1e6*e.currentTime:null,a=Hu(e),i=Y(function(){return me(j2(e),"float32")}),(o=this.regionOfInterest)!=null?[3,2]:[4,this.detectPose(i)]);case 1:if((l=M.sent()).length===0)return this.reset(),i.dispose(),[2,[]];u=l[0],o=this.poseDetectionToRoi(u,a),M.label=2;case 2:return[4,this.poseLandmarksByRoi(o,i)];case 3:return c=M.sent(),i.dispose(),c==null?(this.reset(),[2,[]]):(h=c.landmarks,d=c.auxiliaryLandmarks,p=c.poseScore,f=c.worldLandmarks,m=c.segmentationMask,y=this.poseLandmarkFiltering(h,d,f,a),g=y.actualLandmarksFiltered,b=y.auxiliaryLandmarksFiltered,v=y.actualWorldLandmarksFiltered,w=this.poseLandmarksToRoi(b,a),this.regionOfInterest=w,k=this.smoothSegmentation&&m!=null?this.poseSegmentationFiltering(m):m,(N=g!=null?pP(g,a):null)!=null&&N.forEach(function(V,W){V.name=Gd[W]}),(T=v)!=null&&T.forEach(function(V,W){V.name=Gd[W]}),E={score:p,keypoints:N,keypoints3D:T},k!==null&&(_=Y(function(){var V=hn(k,2),W=pa(V,[[0,0],[0,0],[0,1]]);return pk(W,[[0,0],[0,0],[0,2]],"symmetric")}),this.smoothSegmentation||Pe(k),O={maskValueToLabel:Cwe,mask:new Nwe(_)},E.segmentation=O),[2,[E]])}})})},t.prototype.poseSegmentationFiltering=function(e){var n=this.prevFilteredSegmentationMask;return n.size===0?this.prevFilteredSegmentationMask=e:(this.prevFilteredSegmentationMask=awe(n,e,Iwe),Pe(e)),Pe(n),this.prevFilteredSegmentationMask},t.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),Pe([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},t.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(Pe(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=Bs([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},t.prototype.detectPose=function(e){return ut(this,void 0,void 0,function(){var n,r,s,a,i,o,l,u,c,h;return ct(this,function(d){switch(d.label){case 0:return n=_v(e,mwe),r=n.imageTensor,s=n.padding,a=this.detectorModel.predict(r),i=nwe(a),o=i.boxes,[4,iwe([l=i.logits,o],this.anchorTensor,pwe)];case 1:return(u=d.sent()).length===0?(Pe([r,a,l,o]),[2,u]):[4,rwe(u,this.maxPoses,fwe)];case 2:return c=d.sent(),h=function(p,f){p===void 0&&(p=[]);for(var m=f.left,y=f.top,g=f.left+f.right,b=f.top+f.bottom,v=0;v<p.length;v++){var w=p[v],k=w.locationData.relativeBoundingBox,N=(k.xMin-m)/(1-g),T=(k.yMin-y)/(1-b),E=k.width/(1-g),_=k.height/(1-b);k.xMin=N,k.yMin=T,k.width=E,k.height=_,k.xMax=N+E,k.yMax=T+_;var O=w.locationData.relativeKeypoints;O&&O.forEach(function(M){var V=(M.x-m)/(1-g),W=(M.y-y)/(1-b);M.x=V,M.y=W})}return p}(c,s),Pe([r,a,l,o]),[2,h]}})})},t.prototype.poseDetectionToRoi=function(e,n){return VC(Ax(e,n,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),n,GC)},t.prototype.poseLandmarksByRoi=function(e,n){return ut(this,void 0,void 0,function(){var r,s,a,i,o,l,u,c,h,d,p,f,m,y;return ct(this,function(g){switch(g.label){case 0:if(r=Hu(n),s=_v(n,gwe,e),a=s.imageTensor,i=s.padding,o=s.transformationMatrix,this.modelType!=="lite"&&this.modelType!=="full"&&this.modelType!=="heavy")throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return l=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&l.push("activation_segmentation"),u=this.landmarkModel.execute(a,l),[4,this.tensorsToPoseLandmarksAndSegmentation(u)];case 1:return(c=g.sent())==null?(Pe(u),Pe(a),[2,null]):(h=c.landmarks,d=c.auxiliaryLandmarks,p=c.poseScore,f=c.worldLandmarks,m=c.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(r,e,i,o,h,d,f,m)]);case 2:return y=g.sent(),Pe(u),Pe(a),[2,$t({poseScore:p},y)]}})})},t.prototype.poseLandmarksAndSegmentationInverseProjection=function(e,n,r,s,a,i,o,l){return ut(this,void 0,void 0,function(){var u,c,h,d,p,f;return ct(this,function(m){return u=WC(a,r),c=WC(i,r),h=LC(u,n),d=LC(c,n),p=function(y,g){for(var b=[],v=0,w=y;v<w.length;v++){var k=w[v],N=k.x,T=k.y,E=g.rotation,_=Math.cos(E)*N-Math.sin(E)*T,O=Math.sin(E)*N+Math.cos(E)*T,M=$t({},k);M.x=_,M.y=O,b.push(M)}return b}(o,n),f=null,this.enableSegmentation&&(f=Y(function(){var y=l.shape,g=y[0],b=y[1],v=function(N){var T=cP(new Array(16).fill(0));T[0][0]=ar(N,0,0),T[1][0]=-ar(N,0,1),T[2][0]=ar(N,0,2),T[3][0]=-ar(N,0,3),T[0][2]=ar(N,2,0),T[1][2]=-ar(N,2,1),T[2][2]=ar(N,2,2),T[3][2]=-ar(N,2,3),T[0][1]=-ar(N,1,0),T[1][1]=ar(N,1,1),T[2][1]=-ar(N,1,2),T[3][1]=ar(N,1,3),T[0][3]=-ar(N,3,0),T[1][3]=ar(N,3,1),T[2][3]=-ar(N,3,2),T[3][3]=ar(N,3,3);for(var E=N[0][0]*T[0][0]+N[1][0]*T[0][1]+N[2][0]*T[0][2]+N[3][0]*T[0][3],_=0;_<T.length;_++)for(var O=0;O<T.length;O++)T[_][O]/=E;return T}(s),w=Bs(uP(v,{width:b,height:g},e),[1,8]),k=[1,g,b,1];return yt(hr.transform(j(l,k),w,"bilinear","constant",0,[e.height,e.width]),[0,3])}),Pe(l)),[2,{landmarks:h,auxiliaryLandmarks:d,worldLandmarks:p,segmentationMask:f}]})})},t.prototype.tensorsToPoseLandmarksAndSegmentation=function(e){return ut(this,void 0,void 0,function(){var n,r,s,a,i,o,l,u,c,h,d,p,f;return ct(this,function(m){switch(m.label){case 0:return n=e[0],r=e[1],s=e[2],a=e[3],i=this.enableSegmentation?e[4]:null,[4,r.data()];case 1:return(o=m.sent()[0])<.5?[2,null]:[4,UC(n,ywe)];case 2:return[4,swe(m.sent(),s,xwe)];case 3:return l=m.sent(),u=l.slice(0,33),c=l.slice(33,35),[4,UC(a,bwe)];case 4:return h=m.sent(),d=h.slice(0,33),p=function(y,g,b){for(var v=[],w=0;w<y.length;w++){var k=$t({},g[w]);k.score=y[w].score,v.push(k)}return v}(u,d),f=this.enableSegmentation?function(y,g,b){return Y(function(){var v=yt(y,[0]),w=v.shape[2];if(w===1){var k=v;switch(g.activation){case"none":break;case"sigmoid":k=ps(k);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(g.activation,")"))}var N=k;return yt(N,[2])}throw new Error("Unsupported number of tensor channels ".concat(w))})}(i,Swe):null,[2,{landmarks:u,auxiliaryLandmarks:c,poseScore:o,worldLandmarks:p,segmentationMask:f}]}})})},t.prototype.poseLandmarksToRoi=function(e,n){return VC(Ax(BC(e),n,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),n,GC)},t.prototype.poseLandmarkFiltering=function(e,n,r,s){var a,i,o;if(this.timestamp!=null&&this.enableSmoothing){var l=Ax(BC(n),s,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});this.visibilitySmoothingFilterActual==null&&(this.visibilitySmoothingFilterActual=new jC(HC)),a=this.visibilitySmoothingFilterActual.apply(e),this.visibilitySmoothingFilterAuxiliary==null&&(this.visibilitySmoothingFilterAuxiliary=new jC(HC)),i=this.visibilitySmoothingFilterAuxiliary.apply(n),o=this.visibilitySmoothingFilterActual.apply(r),this.landmarksSmoothingFilterActual==null&&(this.landmarksSmoothingFilterActual=new Dx(vwe)),a=this.landmarksSmoothingFilterActual.apply(a,this.timestamp,s,!0,l),this.landmarksSmoothingFilterAuxiliary==null&&(this.landmarksSmoothingFilterAuxiliary=new Dx(wwe)),i=this.landmarksSmoothingFilterAuxiliary.apply(i,this.timestamp,s,!0,l),this.worldLandmarksSmoothingFilterActual==null&&(this.worldLandmarksSmoothingFilterActual=new Dx(kwe)),o=this.worldLandmarksSmoothingFilterActual.apply(r,this.timestamp)}else a=e,i=n,o=r;return{actualLandmarksFiltered:a,auxiliaryLandmarksFiltered:i,actualWorldLandmarksFiltered:o}},t}();function Ewe(t){return ut(this,void 0,void 0,function(){var e,n,r,s,a,i;return ct(this,function(o){switch(o.label){case 0:return e=function(l){var u=$t({},l??Jl);if(u.enableSmoothing==null&&(u.enableSmoothing=Jl.enableSmoothing),u.enableSegmentation==null&&(u.enableSegmentation=Jl.enableSegmentation),u.smoothSegmentation==null&&(u.smoothSegmentation=Jl.smoothSegmentation),u.modelType==null&&(u.modelType=Jl.modelType),u.detectorModelUrl==null&&(u.detectorModelUrl=Jl.detectorModelUrl),u.landmarkModelUrl==null)switch(u.modelType){case"lite":u.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":u.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;case"full":default:u.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return u}(t),n=typeof e.detectorModelUrl=="string"&&e.detectorModelUrl.indexOf("https://tfhub.dev")>-1,r=typeof e.landmarkModelUrl=="string"&&e.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([Bu(e.detectorModelUrl,{fromTFHub:n}),Bu(e.landmarkModelUrl,{fromTFHub:r})])];case 1:return s=o.sent(),a=s[0],i=s[1],[2,new Twe(a,i,e.enableSmoothing,e.enableSegmentation,e.smoothSegmentation,e.modelType)]}})})}var Yi,Qn,mP=function(){function t(e){(function(n){if(n.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(n.maxTracks));if(n.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(n.maxAge));if(n.keypointTrackerParams!==void 0){if(n.keypointTrackerParams.keypointConfidenceThreshold<0||n.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(n.keypointTrackerParams.keypointConfidenceThreshold));if(n.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(n.keypointTrackerParams.minNumberOfKeypoints));for(var r=0,s=n.keypointTrackerParams.keypointFalloff;r<s.length;r++){var a=s[r];if(a<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(a))}}})(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return t.prototype.apply=function(e,n){this.filterOldTracks(n);var r=this.computeSimilarity(e);return this.assignTracks(e,r,n),this.updateTracks(n),e},t.prototype.getTracks=function(){return this.tracks.slice()},t.prototype.getTrackIDs=function(){return new Set(this.tracks.map(function(e){return e.id}))},t.prototype.filterOldTracks=function(e){var n=this;this.tracks=this.tracks.filter(function(r){return e-r.lastTimestamp<=n.maxAge})},t.prototype.assignTracks=function(e,n,r){for(var s=Array.from(Array(n[0].length).keys()),a=[],i=0,o=Array.from(Array(e.length).keys());i<o.length;i++){var l=o[i];if(s.length!==0){for(var u=-1,c=-1,h=0,d=s;h<d.length;h++){var p=d[h],f=n[l][p];f>=this.minSimilarity&&f>c&&(u=p,c=f)}if(u>=0){var m=this.tracks[u];m=Object.assign(m,this.createTrack(e[l],r,m.id)),e[l].id=m.id;var y=s.indexOf(u);s.splice(y,1)}else a.push(l)}else a.push(l)}for(var g=0,b=a;g<b.length;g++){l=b[g];var v=this.createTrack(e[l],r);this.tracks.push(v),e[l].id=v.id}},t.prototype.updateTracks=function(e){this.tracks.sort(function(n,r){return r.lastTimestamp-n.lastTimestamp}),this.tracks=this.tracks.slice(0,this.maxTracks)},t.prototype.createTrack=function(e,n,r){var s={id:r||this.nextTrackID(),lastTimestamp:n,keypoints:Ko([],e.keypoints,!0).map(function(a){return $t({},a)})};return e.box!==void 0&&(s.box=$t({},e.box)),s},t.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},t.prototype.remove=function(){for(var e=[],n=0;n<arguments.length;n++)e[n]=arguments[n];this.tracks=this.tracks.filter(function(r){return!e.includes(r.id)})},t.prototype.reset=function(){this.tracks=[]},t}(),$we=function(t){function e(n){return t.call(this,n)||this}return sP(e,t),e.prototype.computeSimilarity=function(n){var r=this;return n.length===0||this.tracks.length===0?[[]]:n.map(function(s){return r.tracks.map(function(a){return r.iou(s,a)})})},e.prototype.iou=function(n,r){var s=Math.max(n.box.xMin,r.box.xMin),a=Math.max(n.box.yMin,r.box.yMin),i=Math.min(n.box.xMax,r.box.xMax),o=Math.min(n.box.yMax,r.box.yMax);if(s>=i||a>=o)return 0;var l=(i-s)*(o-a);return l/(n.box.width*n.box.height+r.box.width*r.box.height-l)},e}(mP),Rwe=function(t){function e(n){var r=t.call(this,n)||this;return r.keypointThreshold=n.keypointTrackerParams.keypointConfidenceThreshold,r.keypointFalloff=n.keypointTrackerParams.keypointFalloff,r.minNumKeyoints=n.keypointTrackerParams.minNumberOfKeypoints,r}return sP(e,t),e.prototype.computeSimilarity=function(n){if(n.length===0||this.tracks.length===0)return[[]];for(var r=[],s=0,a=n;s<a.length;s++){for(var i=a[s],o=[],l=0,u=this.tracks;l<u.length;l++){var c=u[l];o.push(this.oks(i,c))}r.push(o)}return r},e.prototype.oks=function(n,r){for(var s=this.area(r.keypoints)+1e-6,a=0,i=0,o=0;o<n.keypoints.length;++o){var l=n.keypoints[o],u=r.keypoints[o];if(!(l.score<this.keypointThreshold||u.score<this.keypointThreshold)){i+=1;var c=Math.pow(l.x-u.x,2)+Math.pow(l.y-u.y,2),h=2*this.keypointFalloff[o];a+=Math.exp(-1*c/(2*s*Math.pow(h,2)))}}return i<this.minNumKeyoints?0:a/i},e.prototype.area=function(n){var r=this,s=n.filter(function(l){return l.score>r.keypointThreshold}),a=Math.min.apply(Math,Ko([1],s.map(function(l){return l.x}),!1)),i=Math.max.apply(Math,Ko([0],s.map(function(l){return l.x}),!1)),o=Math.min.apply(Math,Ko([1],s.map(function(l){return l.y}),!1));return(i-a)*(Math.max.apply(Math,Ko([0],s.map(function(l){return l.y}),!1))-o)},e}(mP);function gP(t){switch(t){case Qn.BlazePose:return Gd.reduce(function(e,n,r){return e[n]=r,e},{});case Qn.PoseNet:case Qn.MoveNet:return Ga.reduce(function(e,n,r){return e[n]=r,e},{});default:throw new Error("Model ".concat(t," is not supported."))}}(function(t){t.Keypoint="keypoint",t.BoundingBox="boundingBox"})(Yi||(Yi={})),function(t){t.MoveNet="MoveNet",t.BlazePose="BlazePose",t.PoseNet="PoseNet"}(Qn||(Qn={}));var Awe=Object.freeze({__proto__:null,getKeypointIndexBySide:function(t){switch(t){case Qn.BlazePose:return Kve;case Qn.PoseNet:case Qn.MoveNet:return qve;default:throw new Error("Model ".concat(t," is not supported."))}},getAdjacentPairs:function(t){switch(t){case Qn.BlazePose:return Yve;case Qn.PoseNet:case Qn.MoveNet:return Xve;default:throw new Error("Model ".concat(t," is not supported."))}},getKeypointIndexByName:gP}),KC=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],yP={modelType:"SinglePose.Lightning",enableSmoothing:!0},qC={},XC={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},Mx={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},YC={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function _we(t,e,n,r){for(var s={},a=0,i=Ga;a<i.length;a++){var o=i[a];s[o]=[e[n[o]].y*r.height,e[n[o]].x*r.width]}if(function(b,v){return(b[v.left_hip].score>.2||b[v.right_hip].score>.2)&&(b[v.left_shoulder].score>.2||b[v.right_shoulder].score>.2)}(e,n)){var l=(s.left_hip[0]+s.right_hip[0])/2,u=(s.left_hip[1]+s.right_hip[1])/2,c=function(b,v,w,k,N){for(var T=["left_shoulder","right_shoulder","left_hip","right_hip"],E=0,_=0,O=0;O<T.length;O++)(q=Math.abs(k-w[T[O]][0]))>E&&(E=q),(ee=Math.abs(N-w[T[O]][1]))>_&&(_=ee);for(var M=0,V=0,W=0,K=Object.keys(w);W<K.length;W++){var q,ee,te=K[W];b[v[te]].score<.2||((q=Math.abs(k-w[te][0]))>M&&(M=q),(ee=Math.abs(N-w[te][1]))>V&&(V=ee))}return[E,_,M,V]}(e,n,s,l,u),h=c[0],d=c[1],p=c[2],f=c[3],m=Math.max(1.9*d,1.9*h,1.2*p,1.2*f),y=[l-(m=Math.min(m,Math.max(u,r.width-u,l,r.height-l))),u-m];if(m>Math.max(r.width,r.height)/2)return Ov(t==null,r);var g=2*m;return{yMin:y[0]/r.height,xMin:y[1]/r.width,yMax:(y[0]+g)/r.height,xMax:(y[1]+g)/r.width,height:(y[0]+g)/r.height-y[0]/r.height,width:(y[1]+g)/r.width-y[1]/r.width}}return Ov(t==null,r)}function Ov(t,e){var n,r,s,a;return t?e.width>e.height?(n=1,r=e.height/e.width,s=0,a=(e.width/2-e.height/2)/e.width):(n=e.width/e.height,r=1,s=(e.height/2-e.width/2)/e.height,a=0):e.width>e.height?(n=e.width/e.height,r=1,s=(e.height/2-e.width/2)/e.height,a=0):(n=1,r=e.height/e.width,s=0,a=(e.width/2-e.height/2)/e.width),{yMin:s,xMin:a,yMax:s+n,xMax:a+r,height:n,width:r}}function Fwe(t){var e,n=t==null?yP:$t({},t);if(n.modelType==null)n.modelType="SinglePose.Lightning";else if(KC.indexOf(n.modelType)<0)throw new Error("Invalid architecture ".concat(n.modelType,". ")+"Should be one of ".concat(KC));if(n.enableSmoothing==null&&(n.enableSmoothing=!0),n.minPoseScore!=null&&(n.minPoseScore<0||n.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(n.multiPoseMaxDimension!=null&&(n.multiPoseMaxDimension%32!=0||n.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if(n.modelType==="MultiPose.Lightning"&&n.enableTracking==null&&(n.enableTracking=!0),n.modelType==="MultiPose.Lightning"&&n.enableTracking===!0)if(n.trackerType==null&&(n.trackerType=Yi.BoundingBox),n.trackerType===Yi.Keypoint)n.trackerConfig!=null?n.trackerConfig=function(r){var s=QC(Mx,r);return s.keypointTrackerParams=$t({},Mx.keypointTrackerParams),r.keypointTrackerParams!=null&&(r.keypointTrackerParams.keypointConfidenceThreshold!=null&&(s.keypointTrackerParams.keypointConfidenceThreshold=r.keypointTrackerParams.keypointConfidenceThreshold),r.keypointTrackerParams.keypointFalloff!=null&&(s.keypointTrackerParams.keypointFalloff=r.keypointTrackerParams.keypointFalloff),r.keypointTrackerParams.minNumberOfKeypoints!=null&&(s.keypointTrackerParams.minNumberOfKeypoints=r.keypointTrackerParams.minNumberOfKeypoints)),s}(n.trackerConfig):n.trackerConfig=Mx;else{if(n.trackerType!==Yi.BoundingBox)throw new Error("Tracker type not supported by MoveNet");n.trackerConfig!=null?n.trackerConfig=(e=n.trackerConfig,QC(YC,e)):n.trackerConfig=YC}return n}function QC(t,e){var n={maxTracks:t.maxTracks,maxAge:t.maxAge,minSimilarity:t.minSimilarity};return e.maxTracks!=null&&(n.maxTracks=e.maxTracks),e.maxAge!=null&&(n.maxAge=e.maxAge),e.minSimilarity!=null&&(n.minSimilarity=e.minSimilarity),n}var Owe=function(){function t(e,n){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=gP(Qn.MoveNet),n.modelType==="SinglePose.Lightning"?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):n.modelType==="SinglePose.Thunder"&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel=n.modelType==="MultiPose.Lightning",this.multiPoseModel||(this.keypointFilter=new Fv(XC),this.cropRegionFilterYMin=new Li(.9),this.cropRegionFilterXMin=new Li(.9),this.cropRegionFilterYMax=new Li(.9),this.cropRegionFilterXMax=new Li(.9)),this.enableSmoothing=n.enableSmoothing,n.minPoseScore?this.minPoseScore=n.minPoseScore:this.minPoseScore=.25,n.multiPoseMaxDimension?this.multiPoseMaxDimension=n.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=n.enableTracking,this.multiPoseModel&&this.enableTracking&&(n.trackerType===Yi.Keypoint?this.tracker=new Rwe(n.trackerConfig):n.trackerType===Yi.BoundingBox&&(this.tracker=new $we(n.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return t.prototype.runSinglePersonPoseModel=function(e){return ut(this,void 0,void 0,function(){var n,r,s,a,i;return ct(this,function(o){switch(o.label){case 0:if((n=this.moveNetModel.execute(e)).shape.length!==4||n.shape[0]!==1||n.shape[1]!==1||n.shape[2]!==17||n.shape[3]!==3)throw n.dispose(),new Error("Unexpected output shape from model: [".concat(n.shape,"]"));return Nd()==="webgpu"?[3,1]:(r=n.dataSync(),[3,3]);case 1:return[4,n.data()];case 2:r=o.sent(),o.label=3;case 3:for(n.dispose(),s={keypoints:[],score:0},a=0,i=0;i<17;++i)s.keypoints[i]={y:r[3*i],x:r[3*i+1],score:r[3*i+2]},s.keypoints[i].score>.2&&(++a,s.score+=s.keypoints[i].score);return a>0&&(s.score/=a),[2,s]}})})},t.prototype.runMultiPersonPoseModel=function(e){return ut(this,void 0,void 0,function(){var n,r,s,a,i,o,l,u;return ct(this,function(c){switch(c.label){case 0:if((n=this.moveNetModel.execute(e)).shape.length!==3||n.shape[0]!==1||n.shape[2]!==56)throw n.dispose(),new Error("Unexpected output shape from model: [".concat(n.shape,"]"));return Nd()==="webgpu"?[3,1]:(r=n.dataSync(),[3,3]);case 1:return[4,n.data()];case 2:r=c.sent(),c.label=3;case 3:for(n.dispose(),s=[],a=r.length/56,i=0;i<a;++i)for(s[i]={keypoints:[]},o=56*i+51,s[i].box={yMin:r[o],xMin:r[o+1],yMax:r[o+2],xMax:r[o+3],width:r[o+3]-r[o+1],height:r[o+2]-r[o]},l=56*i+55,s[i].score=r[l],s[i].keypoints=[],u=0;u<17;++u)s[i].keypoints[u]={y:r[56*i+3*u],x:r[56*i+3*u+1],score:r[56*i+3*u+2]};return[2,s]}})})},t.prototype.estimatePoses=function(e,n,r){return n===void 0&&(n=qC),ut(this,void 0,void 0,function(){var s,a,i,o,l,u;return ct(this,function(c){switch(c.label){case 0:return n=function(h){return h==null?qC:$t({},h)}(n),e==null?(this.reset(),[2,[]]):(r==null?dP(e)&&(r=1e6*e.currentTime):r*=1e3,s=j2(e),a=Hu(s),i=hn(s,0),e instanceof st||s.dispose(),o=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(i,a,r)]);case 1:return o=c.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(i,a,r)];case 3:o=c.sent(),c.label=4;case 4:for(l=0;l<o.length;++l)for(u=0;u<o[l].keypoints.length;++u)o[l].keypoints[u].name=Ga[u],o[l].keypoints[u].y*=a.height,o[l].keypoints[u].x*=a.width;return[2,o]}})})},t.prototype.estimateSinglePose=function(e,n,r){return ut(this,void 0,void 0,function(){var s,a,i,o,l=this;return ct(this,function(u){switch(u.label){case 0:return this.cropRegion||(this.cropRegion=Ov(this.cropRegion==null,n)),s=Y(function(){var c=Bs([[l.cropRegion.yMin,l.cropRegion.xMin,l.cropRegion.yMax,l.cropRegion.xMax]]),h=rn([1],"int32"),d=[l.modelInputResolution.height,l.modelInputResolution.width];return me(hr.cropAndResize(e,c,h,d,"bilinear",0),"int32")}),e.dispose(),[4,this.runSinglePersonPoseModel(s)];case 1:if(a=u.sent(),s.dispose(),a.score<this.minPoseScore)return this.reset(),[2,[]];for(i=0;i<a.keypoints.length;++i)a.keypoints[i].y=this.cropRegion.yMin+a.keypoints[i].y*this.cropRegion.height,a.keypoints[i].x=this.cropRegion.xMin+a.keypoints[i].x*this.cropRegion.width;return r!=null&&this.enableSmoothing&&(a.keypoints=this.keypointFilter.apply(a.keypoints,r,1)),o=_we(this.cropRegion,a.keypoints,this.keypointIndexByName,n),this.cropRegion=this.filterCropRegion(o),[2,[a]]}})})},t.prototype.estimateMultiplePoses=function(e,n,r){return ut(this,void 0,void 0,function(){var s,a,i,o,l,u,c,h,d,p,f,m=this;return ct(this,function(y){switch(y.label){case 0:return n.width>n.height?(a=this.multiPoseMaxDimension,i=Math.round(this.multiPoseMaxDimension*n.height/n.width),s=hr.resizeBilinear(e,[i,a]),l=a,u=32*Math.ceil(i/32),o=pa(s,[[0,0],[0,u-i],[0,0],[0,0]])):(a=Math.round(this.multiPoseMaxDimension*n.width/n.height),i=this.multiPoseMaxDimension,s=hr.resizeBilinear(e,[i,a]),l=32*Math.ceil(a/32),u=i,o=pa(s,[[0,0],[0,0],[0,l-a],[0,0]])),s.dispose(),e.dispose(),c=me(o,"int32"),o.dispose(),[4,this.runMultiPersonPoseModel(c)];case 1:for(h=y.sent(),c.dispose(),h=h.filter(function(g){return g.score>=m.minPoseScore}),p=0;p<h.length;++p)for(d=0;d<h[p].keypoints.length;++d)h[p].keypoints[d].y*=u/i,h[p].keypoints[d].x*=l/a;if(this.enableTracking&&(this.tracker.apply(h,r),this.enableSmoothing)){for(p=0;p<h.length;++p)this.keypointFilterMap.has(h[p].id)||this.keypointFilterMap.set(h[p].id,new Fv(XC)),h[p].keypoints=this.keypointFilterMap.get(h[p].id).apply(h[p].keypoints,r,1);f=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach(function(g,b){f.has(b)||m.keypointFilterMap.delete(b)})}return[2,h]}})})},t.prototype.filterCropRegion=function(e){if(e){var n=this.cropRegionFilterYMin.apply(e.yMin),r=this.cropRegionFilterXMin.apply(e.xMin),s=this.cropRegionFilterYMax.apply(e.yMax),a=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:n,xMin:r,yMax:s,xMax:a,height:s-n,width:a-r}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},t.prototype.dispose=function(){this.moveNetModel.dispose()},t.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},t.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},t}();function Dwe(t){return t===void 0&&(t=yP),ut(this,void 0,void 0,function(){var e,n,r,s;return ct(this,function(a){switch(a.label){case 0:return e=Fwe(t),r=!0,e.modelUrl?(r=typeof e.modelUrl=="string"&&e.modelUrl.indexOf("https://tfhub.dev")>-1,[4,Bu(e.modelUrl,{fromTFHub:r})]):[3,2];case 1:return n=a.sent(),[3,4];case 2:return s=void 0,e.modelType==="SinglePose.Lightning"?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":e.modelType==="SinglePose.Thunder"?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":e.modelType==="MultiPose.Lightning"&&(s="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,Bu(s,{fromTFHub:r})];case 3:n=a.sent(),a.label=4;case 4:return Nd()==="webgl"&&Z().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new Owe(n,e)]}})})}var ZC={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},JC=["MobileNetV1","ResNet50"],eT={MobileNetV1:[8,16],ResNet50:[16]},Mwe=[8,16,32],tT={MobileNetV1:[.5,.75,1],ResNet50:[1]},nT=[1,2,4],rT={maxPoses:1,flipHorizontal:!1},Pwe={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},Lwe=[-123.15,-115.9,-103.06];function Px(t){return Math.floor(t/2)}var zwe=function(){function t(e,n){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=n}return t.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},t.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},t.prototype.empty=function(){return this.numberOfElements===-1},t.prototype.size=function(){return this.numberOfElements+1},t.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},t.prototype.max=function(){return this.priorityQueue[0]},t.prototype.swim=function(e){for(;e>0&&this.less(Px(e),e);)this.exchange(e,Px(e)),e=Px(e)},t.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var n=2*e;if(n<this.numberOfElements&&this.less(n,n+1)&&n++,!this.less(e,n))break;this.exchange(e,n),e=n}},t.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},t.prototype.less=function(e,n){return this.getValueAt(e)<this.getValueAt(n)},t.prototype.exchange=function(e,n){var r=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[n],this.priorityQueue[n]=r},t}();function Bwe(t,e,n,r,s,a){for(var i=a.shape,o=i[0],l=i[1],u=!0,c=Math.max(n-s,0),h=Math.min(n+s+1,o),d=c;d<h;++d){for(var p=Math.max(r-s,0),f=Math.min(r+s+1,l),m=p;m<f;++m)if(a.get(d,m,t)>e){u=!1;break}if(!u)break}return u}function Wwe(t){return ut(this,void 0,void 0,function(){return ct(this,function(e){return[2,Promise.all(t.map(function(n){return n.buffer()}))]})})}function bP(t,e,n,r){return{y:r.get(t,e,n),x:r.get(t,e,n+17)}}function xP(t,e,n){var r=bP(t.heatmapY,t.heatmapX,t.id,n),s=r.y,a=r.x;return{x:t.heatmapX*e+a,y:t.heatmapY*e+s}}function vP(t,e,n,r){var s=n.x,a=n.y;return t.some(function(i){var o,l,u,c,h,d,p=i.keypoints;return o=a,l=s,u=p[r].y,c=p[r].x,(h=u-o)*h+(d=c-l)*d<=e})}var sT=Ga.reduce(function(t,e,n){return t[e]=n,t},{}),wP=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(t){var e=t[0],n=t[1];return[sT[e],sT[n]]}),Lx=wP.map(function(t){return t[1]}),aT=wP.map(function(t){return t[0]});function iT(t,e,n){return t<e?e:t>n?n:t}function zx(t,e,n,r){return{y:iT(Math.round(t.y/e),0,n-1),x:iT(Math.round(t.x/e),0,r-1)}}function oT(t,e){return{x:t.x+e.x,y:t.y+e.y}}function lT(t,e,n,r,s,a,i,o){o===void 0&&(o=2);for(var l=r.shape,u=l[0],c=l[1],h={y:e.y,x:e.x},d=oT(h,function(b,v,w){var k=w.shape[2]/2;return{y:w.get(v.y,v.x,b),x:w.get(v.y,v.x,k+b)}}(t,zx(h,a,u,c),i)),p=0;p<o;p++){var f=zx(d,a,u,c),m=bP(f.y,f.x,n,s);d=oT({x:f.x*a,y:f.y*a},{x:m.x,y:m.y})}var y=zx(d,a,u,c),g=r.get(y.y,y.x,n);return{y:d.y,x:d.x,name:Ga[n],score:g}}function Uwe(t,e,n,r,s,a){var i=e.shape[2],o=Lx.length,l=new Array(i),u=t.part,c=t.score,h=xP(u,r,n);l[u.id]={score:c,name:Ga[u.id],y:h.y,x:h.x};for(var d=o-1;d>=0;--d){var p=Lx[d],f=aT[d];l[p]&&!l[f]&&(l[f]=lT(d,l[p],f,e,n,r,a))}for(d=0;d<o;++d)p=aT[d],f=Lx[d],l[p]&&!l[f]&&(l[f]=lT(d,l[p],f,e,n,r,s));return l}function Vwe(t,e,n){return n.reduce(function(r,s,a){var i=s.y,o=s.x,l=s.score;return vP(t,e,{y:i,x:o},a)||(r+=l),r},0)/n.length}function jwe(t,e,n,r,s,a,i,o){return i===void 0&&(i=.5),o===void 0&&(o=20),ut(this,void 0,void 0,function(){var l,u,c,h,d,p,f,m,y,g,b,v;return ct(this,function(w){switch(w.label){case 0:return[4,Wwe([t,e,n,r])];case 1:for(l=w.sent(),u=l[0],c=l[1],h=l[2],d=l[3],p=[],f=function(k,N,T){for(var E=T.shape,_=E[0],O=E[1],M=E[2],V=new zwe(_*O*M,function(te){return te.score}),W=0;W<_;++W)for(var K=0;K<O;++K)for(var q=0;q<M;++q){var ee=T.get(W,K,q);ee<k||Bwe(q,ee,W,K,N,T)&&V.enqueue({score:ee,part:{heatmapY:W,heatmapX:K,id:q}})}return V}(i,1,u),m=o*o;p.length<a&&!f.empty();)y=f.dequeue(),g=xP(y.part,s,c),vP(p,m,g,y.part.id)||(b=Uwe(y,u,c,s,h,d),v=Vwe(p,m,b),p.push({keypoints:b,score:v}));return[2,p]}})})}function kP(){for(var t,e=[],n=0;n<arguments.length;n++)e[n]=arguments[n];switch(e.length){case 0:t="fn main() ";break;case 1:t="fn main(".concat(e[0]," : i32)");break;default:throw Error("Unreachable")}return t}var Gwe=function(){function t(e){this.variableNames=["A","B"],this.size=!0,this.workgroupSize=[32,1,1],this.outputShape=[e[0],1],this.dispatchLayout=Ne(this.outputShape),this.dispatch=ye(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return t.prototype.getUserCode=function(){return`
        `.concat(kP("index"),` {
          if (index < uniforms.size) {
            let y = B[index * 2];
            let x = B[index * 2 + 1];
            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;
            result[index] = A[outIndex];
          }
        }
        `)},t}();function Hwe(t,e){if(ll()instanceof ih)return function(n,r){var s=ll(),a=new Gwe(r.shape),i=s.runWebGPUProgram(a,[n,r],"float32");return ir().makeTensorFromTensorInfo(i)}(t,e);throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}var Kwe=function(){function t(e){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,e.length!==2||e[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(e));this.workgroupSize=[32,1,1],this.outputShape=e;var n=[e[0],1];this.dispatchLayout=Ne(n),this.dispatch=ye(this.dispatchLayout,n,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return t.prototype.getUserCode=function(){return`
    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {
      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;
      let outIndexX = outIndexY + uniforms.bShape.z;
      let outY = i32(B[outIndexY]);
      let outX = i32(B[outIndexX]);
      return vec2<i32>(outY, outX);
    }

    `.concat(kP("index"),` {
      if (index < uniforms.size) {
        let indexY = index * `).concat(this.supportedLastDimension,`;
        let indexX = indexY + 1;
        let heatmapY = A[indexY];
        let heatmapX = A[indexX];
        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);
        result[indexY] = f32(out[0]);
        result[indexX] = f32(out[1]);
      }
    }
    `)},t}();function qwe(t,e){if(ll()instanceof ih)return function(n,r){var s=ll(),a=new Kwe(n.shape),i=s.runWebGPUProgram(a,[n,r],"float32");return ir().makeTensorFromTensorInfo(i)}(t,e);throw new Error("getOffsetVectorsGPU is not supported in this backend!")}function SP(t){var e=t.shape,n=e[0],r=e[1],s=e[2];return Y(function(){var a,i,o=j(t,[n*r,s]),l=hl(o,0),u=hn(Se(l,Me(r,"int32")),1),c=hn((a=l,i=r,Y(function(){var h=Se(a,Me(i,"int32"));return Ie(a,z(h,Me(i,"int32")))})),1);return qt([u,c],1)})}function Xwe(t,e,n){return Y(function(){var r=function(s,a){for(var i=[],o=0;o<Ga.length;o++){var l=s.get(o,0).valueOf(),u=s.get(o,1).valueOf(),c=Ywe(l,u,o,a),h=c.x,d=c.y;i.push(d),i.push(h)}return Bs(i,[Ga.length,2])}(t,n);return ie(me(z(t.toTensor(),Me(e,"int32")),"float32"),r)})}function Ywe(t,e,n,r){return{y:r.get(t,e,n),x:r.get(t,e,n+Ga.length)}}function Qwe(t,e,n){return ut(this,void 0,void 0,function(){var r,s,a,i,o,l,u,c,h,d;return ct(this,function(p){switch(p.label){case 0:return r=0,s=SP(t),[4,Promise.all([t.buffer(),e.buffer(),s.buffer()])];case 1:return a=p.sent(),i=a[0],o=a[1],l=a[2],[4,(u=Xwe(l,n,o)).buffer()];case 2:return c=p.sent(),h=Array.from(function(f,m){for(var y=m.shape[0],g=new Float32Array(y),b=0;b<y;b++){var v=m.get(b,0),w=m.get(b,1);g[b]=f.get(v,w,b)}return g}(i,l)),d=h.map(function(f,m){return r+=f,{y:c.get(m,0),x:c.get(m,1),score:f,name:Ga[m]}}),s.dispose(),u.dispose(),[2,{keypoints:d,score:r/d.length}]}})})}function Zwe(t,e,n){return ut(this,void 0,void 0,function(){var r,s,a;return ct(this,function(i){return r=SP(t),s=function(o,l,u){return Y(function(){var c=qwe(o,u);return ie(me(z(o,Me(l,"int32")),"float32"),c)})}(r,n,e),a=Hwe(t,r),[2,[s,a]]})})}function uT(t,e){return(t-1)%e==0}var cT="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",hT="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function dT(t,e){return function(n,r){return(n-1)%r==0}(t,e)?t:Math.floor(t/e)*e+1}var pT=function(){function t(e,n){this.posenetModel=e;var r=this.posenetModel.inputs[0].shape;R(r[1]===-1&&r[2]===-1,function(){return"Input shape [".concat(r[1],", ").concat(r[2],"] ")+"must both be equal to or -1"});var s,a,i=(s=n.inputResolution,a=n.outputStride,{height:dT(s.height,a),width:dT(s.width,a)});(function(o){R(Mwe.indexOf(o)>=0,function(){return"outputStride of ".concat(o," is invalid. ")+"It must be either 8 or 16."})})(n.outputStride),function(o,l){R(uT(o.height,l),function(){return"height of ".concat(o.height," is invalid for output stride ")+"".concat(l,".")}),R(uT(o.width,l),function(){return"width of ".concat(o.width," is invalid for output stride ")+"".concat(l,".")})}(i,n.outputStride),this.inputResolution=i,this.outputStride=n.outputStride,this.architecture=n.architecture}return t.prototype.estimatePoses=function(e,n){return n===void 0&&(n=rT),ut(this,void 0,void 0,function(){return ct(this,function(r){return[2,this.estimatePosesGPU(e,n,!1)]})})},t.prototype.estimatePosesGPU=function(e,n,r){return n===void 0&&(n=rT),r===void 0&&(r=!1),ut(this,void 0,void 0,function(){var s,a,i,o,l,u,c,h,d,p,f,m,y,g,b,v,w,k;return ct(this,function(N){switch(N.label){case 0:return s=function(T){var E=T;if(E.maxPoses==null&&(E.maxPoses=1),E.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(E.maxPoses,". Should be > 0."));if(E.maxPoses>1){if((E=$t($t({},Pwe),E)).scoreThreshold<0||E.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(E.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(E.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(E.nmsRadius,"."))}return E}(n),e==null?[2,r?[[],[]]:[]]:(this.maxPoses=s.maxPoses,a=_v(e,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),i=a.imageTensor,o=a.padding,l=this.architecture==="ResNet50"?ie(i,Lwe):hP(i,[-1,1]),u=this.posenetModel.predict(l),this.architecture==="ResNet50"?(c=yt(u[2],[0]),h=yt(u[3],[0]),d=yt(u[0],[0]),p=yt(u[1],[0])):(c=yt(u[0],[0]),h=yt(u[1],[0]),d=yt(u[2],[0]),p=yt(u[3],[0])),f=ps(h),this.maxPoses!==1?[3,5]:r?[4,Zwe(f,c,this.outputStride)]:[3,2]);case 1:return y=N.sent(),b=y[0],g=y[1],m=[b,g],[3,4];case 2:return[4,Qwe(f,c,this.outputStride)];case 3:b=N.sent(),m=[b],N.label=4;case 4:return[3,7];case 5:if(r)throw new Error("GPU renderer only supports single pose!");return[4,jwe(f,c,d,p,this.outputStride,this.maxPoses,s.scoreThreshold,s.nmsRadius)];case 6:m=N.sent(),N.label=7;case 7:if(r){if(s.flipHorizontal===!0)throw new Error("flipHorizontal is not supported!");v=this.getCanvasInfo(Hu(e),this.inputResolution,o)}else k=Hu(e),w=function(T,E,_,O){var M=E.height,V=E.width,W=M/(_.height*(1-O.top-O.bottom)),K=V/(_.width*(1-O.left-O.right)),q=-O.top*_.height,ee=-O.left*_.width;if(K===1&&W===1&&q===0&&ee===0)return T;for(var te=0,G=T;te<G.length;te++)for(var J=0,ne=G[te].keypoints;J<ne.length;J++){var ae=ne[J];ae.x=(ae.x+ee)*K,ae.y=(ae.y+q)*W}return T}(m,k,this.inputResolution,o),s.flipHorizontal&&(w=function(T,E){for(var _=0,O=T;_<O.length;_++)for(var M=0,V=O[_].keypoints;M<V.length;M++){var W=V[M];W.x=E.width-1-W.x}return T}(w,k));return i.dispose(),l.dispose(),Pe(u),c.dispose(),h.dispose(),d.dispose(),p.dispose(),f.dispose(),[2,r?[m,v]:w]}})})},t.prototype.getCanvasInfo=function(e,n,r){var s=e.height,a=e.width,i=s/(n.height*(1-r.top-r.bottom)),o=a/(n.width*(1-r.left-r.right)),l=-r.top*n.height;return[-r.left*n.width,l,o,i,e.width,e.height]},t.prototype.dispose=function(){this.posenetModel.dispose()},t.prototype.reset=function(){},t}();function Jwe(t){return t===void 0&&(t=ZC),ut(this,void 0,void 0,function(){var e,n,r,s,a;return ct(this,function(i){switch(i.label){case 0:return(e=function(c){var h=c||ZC;if(h.architecture==null&&(h.architecture="MobileNetV1"),JC.indexOf(h.architecture)<0)throw new Error("Invalid architecture ".concat(h.architecture,". ")+"Should be one of ".concat(JC));if(h.inputResolution==null&&(h.inputResolution={height:257,width:257}),h.outputStride==null&&(h.outputStride=16),eT[h.architecture].indexOf(h.outputStride)<0)throw new Error("Invalid outputStride ".concat(h.outputStride,". ")+"Should be one of ".concat(eT[h.architecture]," ")+"for architecture ".concat(h.architecture,"."));if(h.multiplier==null&&(h.multiplier=1),tT[h.architecture].indexOf(h.multiplier)<0)throw new Error("Invalid multiplier ".concat(h.multiplier,". ")+"Should be one of ".concat(tT[h.architecture]," ")+"for architecture ".concat(h.architecture,"."));if(h.quantBytes==null&&(h.quantBytes=4),nT.indexOf(h.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(h.quantBytes,". ")+"Should be one of ".concat(nT," ")+"for architecture ".concat(h.architecture,"."));if(h.architecture==="MobileNetV1"&&h.outputStride===32&&h.multiplier!==1)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return h}(t)).architecture!=="ResNet50"?[3,2]:(o=e.outputStride,l=e.quantBytes,u="model-stride".concat(o,".json"),n=l===4?hT+"float/"+u:hT+"quant".concat(l,"/")+u,[4,Bu(e.modelUrl||n)]);case 1:return r=i.sent(),[2,new pT(r,e)];case 2:return s=function(c,h,d){var p={1:"100",.75:"075",.5:"050"},f="model-stride".concat(c,".json");return d===4?cT+"float/".concat(p[h],"/")+f:cT+"quant".concat(d,"/").concat(p[h],"/")+f}(e.outputStride,e.multiplier,e.quantBytes),[4,Bu(e.modelUrl||s)];case 3:return a=i.sent(),[2,new pT(a,e)]}var o,l,u})})}function IP(t,e){return ut(this,void 0,void 0,function(){var n,r;return ct(this,function(s){switch(t){case Qn.PoseNet:return[2,Jwe(e)];case Qn.BlazePose:if(r=void 0,(n=e)!=null){if(n.runtime==="tfjs")return[2,Ewe(e)];if(n.runtime==="mediapipe")return[2,twe(e)];r=n.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(r));case Qn.MoveNet:return[2,Dwe(e)];default:throw new Error("".concat(t," is not a supported model name."))}})})}var eke={keypointsToNormalizedKeypoints:fP},NP={modelType:{SINGLEPOSE_LIGHTNING:"SinglePose.Lightning",SINGLEPOSE_THUNDER:"SinglePose.Thunder",MULTIPOSE_LIGHTNING:"MultiPose.Lightning"}};const tke=Object.freeze(Object.defineProperty({__proto__:null,get SupportedModels(){return Qn},get TrackerType(){return Yi},calculators:eke,createDetector:IP,movenet:NP,util:Awe},Symbol.toStringTag,{value:"Module"}));class nke{constructor(e,n){mt(this,"detector",null),mt(this,"videoElement",null),mt(this,"isInitialized",!1),mt(this,"onPostureUpdate"),mt(this,"onError"),mt(this,"currentAnalysis",null),mt(this,"animationFrame",null),mt(this,"lastUpdateTime",0),mt(this,"isPageVisible",!0),mt(this,"postureHistory",[]),mt(this,"landmarkHistory",[]),mt(this,"UPDATE_INTERVAL",2e3),mt(this,"SMOOTHING_WINDOW",12),mt(this,"LANDMARK_SMOOTHING_WINDOW",6),mt(this,"CONSISTENCY_THRESHOLD",3),mt(this,"issueConsistency",{}),this.onPostureUpdate=e,this.onError=n,this.setupVisibilityListener()}async initialize(e){try{this.videoElement=e,console.log("Initializing TensorFlow.js with MoveNet..."),location.protocol==="https:"||location.hostname==="localhost"||console.warn("TensorFlow.js works best on HTTPS. Current protocol:",location.protocol),await QB(),console.log("TensorFlow.js backend ready");const n=Qn.MoveNet,r={modelType:NP.modelType.SINGLEPOSE_LIGHTNING,enableSmoothing:!0,minPoseScore:.1};this.detector=await IP(n,r),console.log("MoveNet detector created successfully"),this.isInitialized=!0,console.log("TensorFlow.js MoveNet initialized successfully"),this.startDetectionLoop()}catch(n){throw console.error("TensorFlow.js initialization error:",n),this.onError(`TensorFlow.js initialization failed: ${n}. This app requires TensorFlow.js to function. Please check your network connection and try again.`),this.isInitialized=!1,n}}async startDetectionLoop(){if(!this.detector||!this.videoElement||!this.isInitialized)return;const e=async()=>{try{if(!this.detector||!this.videoElement)return;const n=await this.detector.estimatePoses(this.videoElement);if(n&&n.length>0){const r=n[0],s=this.extractLandmarks(r.keypoints);this.landmarkHistory.push(s),this.landmarkHistory.length>this.LANDMARK_SMOOTHING_WINDOW&&this.landmarkHistory.shift();const a=this.smoothLandmarks();console.log("Pose detection debug:",{nose:a.nose.visibility,leftShoulder:a.leftShoulder.visibility,rightShoulder:a.rightShoulder.visibility,leftEar:a.leftEar.visibility,rightEar:a.rightEar.visibility});const i=this.analyzePosture(a);this.postureHistory.push(i),this.postureHistory.length>this.SMOOTHING_WINDOW&&this.postureHistory.shift();const o=Date.now();if(o-this.lastUpdateTime>=this.UPDATE_INTERVAL){const l=this.smoothPostureAnalysis();this.currentAnalysis=l,this.onPostureUpdate(l),this.lastUpdateTime=o}}else console.log("No poses detected")}catch(n){console.error("Error during pose detection:",n)}this.isPageVisible?this.animationFrame=requestAnimationFrame(e):this.animationFrame=setTimeout(e,100)};e()}getCurrentPostureAnalysis(){return this.currentAnalysis}smoothLandmarks(){return this.landmarkHistory.length===0?this.landmarkHistory[0]||this.extractLandmarks([]):this.landmarkHistory.length<2?this.landmarkHistory[this.landmarkHistory.length-1]:{nose:this.averageLandmark(this.landmarkHistory.map(e=>e.nose)),leftEye:this.averageLandmark(this.landmarkHistory.map(e=>e.leftEye)),rightEye:this.averageLandmark(this.landmarkHistory.map(e=>e.rightEye)),leftEar:this.averageLandmark(this.landmarkHistory.map(e=>e.leftEar)),rightEar:this.averageLandmark(this.landmarkHistory.map(e=>e.rightEar)),leftShoulder:this.averageLandmark(this.landmarkHistory.map(e=>e.leftShoulder)),rightShoulder:this.averageLandmark(this.landmarkHistory.map(e=>e.rightShoulder)),leftElbow:this.averageLandmark(this.landmarkHistory.map(e=>e.leftElbow)),rightElbow:this.averageLandmark(this.landmarkHistory.map(e=>e.rightElbow)),leftWrist:this.averageLandmark(this.landmarkHistory.map(e=>e.leftWrist)),rightWrist:this.averageLandmark(this.landmarkHistory.map(e=>e.rightWrist)),leftHip:this.averageLandmark(this.landmarkHistory.map(e=>e.leftHip)),rightHip:this.averageLandmark(this.landmarkHistory.map(e=>e.rightHip)),leftKnee:this.averageLandmark(this.landmarkHistory.map(e=>e.leftKnee)),rightKnee:this.averageLandmark(this.landmarkHistory.map(e=>e.rightKnee)),leftAnkle:this.averageLandmark(this.landmarkHistory.map(e=>e.leftAnkle)),rightAnkle:this.averageLandmark(this.landmarkHistory.map(e=>e.rightAnkle))}}averageLandmark(e){const n=e.filter(o=>o.visibility>.1);if(n.length===0)return e[0]||{x:0,y:0,z:0,visibility:0};const r=n.reduce((o,l)=>o+l.x,0)/n.length,s=n.reduce((o,l)=>o+l.y,0)/n.length,a=n.reduce((o,l)=>o+l.z,0)/n.length,i=n.reduce((o,l)=>o+l.visibility,0)/n.length;return{x:r,y:s,z:a,visibility:i}}smoothPostureAnalysis(){if(this.postureHistory.length===0)return this.currentAnalysis||{score:85,issues:["Initializing posture analysis..."],neckAngle:0,shoulderAlignment:0,spineAlignment:0,headPosition:0,shoulderHeight:0};const e=this.postureHistory.reduce((l,u)=>l+u.score,0)/this.postureHistory.length,n=this.postureHistory.reduce((l,u)=>l+u.neckAngle,0)/this.postureHistory.length,r=this.postureHistory.reduce((l,u)=>l+u.shoulderAlignment,0)/this.postureHistory.length,s=this.postureHistory.reduce((l,u)=>l+u.spineAlignment,0)/this.postureHistory.length,a=this.postureHistory.reduce((l,u)=>l+u.headPosition,0)/this.postureHistory.length,i=this.postureHistory.reduce((l,u)=>l+u.shoulderHeight,0)/this.postureHistory.length,o=this.postureHistory[this.postureHistory.length-1].issues;e>8&&(this.issueConsistency={});for(const[l,u]of Object.entries(this.issueConsistency))u===0&&delete this.issueConsistency[l];return{score:Math.round(e),issues:o,neckAngle:Math.round(n*10)/10,shoulderAlignment:Math.round(r*10)/10,spineAlignment:Math.round(s*10)/10,headPosition:Math.round(a*10)/10,shoulderHeight:Math.round(i*10)/10}}stop(){try{this.animationFrame&&(this.isPageVisible?cancelAnimationFrame(this.animationFrame):clearTimeout(this.animationFrame),this.animationFrame=null),this.currentAnalysis=null,this.isInitialized=!1}catch(e){console.error("Error stopping TensorFlow pose detection:",e)}}setupVisibilityListener(){document.addEventListener("visibilitychange",()=>{this.isPageVisible=!document.hidden,console.log("TensorFlow: Page visibility changed:",this.isPageVisible?"visible":"hidden"),this.isPageVisible||console.log("TensorFlow: Continuing pose detection in background")})}extractLandmarks(e){const n={nose:0,leftEye:1,rightEye:2,leftEar:3,rightEar:4,leftShoulder:5,rightShoulder:6,leftElbow:7,rightElbow:8,leftWrist:9,rightWrist:10,leftHip:11,rightHip:12,leftKnee:13,rightKnee:14,leftAnkle:15,rightAnkle:16},r=s=>{const a=e[s];return{x:a.x,y:a.y,z:0,visibility:a.score}};return{nose:r(n.nose),leftEye:r(n.leftEye),rightEye:r(n.rightEye),leftEar:r(n.leftEar),rightEar:r(n.rightEar),leftShoulder:r(n.leftShoulder),rightShoulder:r(n.rightShoulder),leftElbow:r(n.leftElbow),rightElbow:r(n.rightElbow),leftWrist:r(n.leftWrist),rightWrist:r(n.rightWrist),leftHip:r(n.leftHip),rightHip:r(n.rightHip),leftKnee:r(n.leftKnee),rightKnee:r(n.rightKnee),leftAnkle:r(n.leftAnkle),rightAnkle:r(n.rightAnkle)}}analyzePosture(e){let n=10;const r=e.nose.visibility>.2,s=e.leftShoulder.visibility>.2,a=e.rightShoulder.visibility>.2,i=[r,s,a].filter(Boolean).length;if(i<2){console.log("Person detection debug:",{nose:e.nose.visibility,leftShoulder:e.leftShoulder.visibility,rightShoulder:e.rightShoulder.visibility,visibleCount:i});const b=e.leftShoulder,v=e.rightShoulder;return b.visibility>.1&&v.visibility>.1&&Math.sqrt(Math.pow(b.x-v.x,2)+Math.pow(b.y-v.y,2))<.1?{score:5,issues:["Too far from camera - Move closer for better posture detection"],neckAngle:0,shoulderAlignment:0,spineAlignment:0,headPosition:0,shoulderHeight:0}:{score:7.5,issues:["Position yourself more clearly in front of the camera for better detection"],neckAngle:0,shoulderAlignment:0,spineAlignment:0,headPosition:0,shoulderHeight:0}}const o=this.calculateNeckAngle(e),l=this.calculateShoulderAlignment(e),u=this.calculateHeadPosition(e),c=this.calculateShoulderHeight(e),h=this.calculateSpineAlignment(e),d=this.detectSlouching(e),p=this.calculateHeadNeckScore(e),f=this.detectTooCloseToCamera(e),m=this.detectTooFarFromCamera(e),y={};o>30?(y.forward_head=!0,n-=Math.min(2,o*.08)):o>20&&(y.slight_forward_head=!0,n-=Math.min(.8,o*.04)),l>20?(y.uneven_shoulders=!0,n-=Math.min(1.5,l*.08)):l>12&&(y.slight_shoulder_imbalance=!0,n-=Math.min(.6,l*.04)),u>25?(y.head_tilt=!0,n-=Math.min(1.8,u*.08)):u>15&&(y.slight_head_tilt=!0,n-=Math.min(.7,u*.04)),c>30?(y.shoulder_height_imbalance=!0,n-=Math.min(1.2,c*.05)):c>22&&(y.slight_shoulder_height=!0,n-=Math.min(.4,c*.015)),h>40?(y.spine_alignment=!0,n-=Math.min(1,h*.04)):h>32&&(y.slight_spine_deviation=!0,n-=Math.min(.4,h*.015)),d&&(y.slouching=!0,n-=1.3),p<60?(y.head_neck_alignment=!0,n-=1):p<70&&(y.slight_head_neck=!0,n-=.5),f&&(y.too_close_to_camera=!0,n-=2),m&&(y.too_far_from_camera=!0,n-=2);for(const[b,v]of Object.entries(this.issueConsistency))y[b]||(this.issueConsistency[b]=Math.max(0,v-3));for(const[b,v]of Object.entries(y))v&&(this.issueConsistency[b]=(this.issueConsistency[b]||0)+1);const g=[];for(const[b,v]of Object.entries(this.issueConsistency))if(v>=this.CONSISTENCY_THRESHOLD&&y[b])switch(b){case"forward_head":g.push("Forward head posture - Try pulling your chin back and aligning your ears over your shoulders");break;case"slight_forward_head":g.push("Slight forward head - Gently tuck your chin and lengthen the back of your neck");break;case"uneven_shoulders":g.push("Uneven shoulders - Try to level your shoulders by relaxing the higher one");break;case"slight_shoulder_imbalance":g.push("Slight shoulder imbalance - Focus on keeping both shoulders at the same height");break;case"head_tilt":g.push("Head tilted - Try to keep your head level and centered");break;case"slight_head_tilt":g.push("Slight head tilt - Gently straighten your head to center");break;case"shoulder_height_imbalance":g.push("Shoulder height imbalance - Relax your shoulders and let them hang naturally");break;case"slight_shoulder_height":g.push("Slight shoulder height difference - Focus on keeping shoulders level");break;case"spine_alignment":g.push("Poor spine alignment - Sit up straight, imagine a string pulling you up from the top of your head");break;case"slight_spine_deviation":g.push("Slight spine deviation - Gently straighten your back and engage your core");break;case"slouching":g.push("Slouching detected - Roll your shoulders back and down, open your chest");break;case"head_neck_alignment":g.push("Poor head and neck alignment - Try to align your head directly over your shoulders");break;case"slight_head_neck":g.push("Slight head/neck misalignment - Gently adjust your head position");break;case"too_close_to_camera":g.push("Too close to camera - Move back to get better posture detection");break;case"too_far_from_camera":g.push("Too far from camera - Move closer for better posture detection");break}return n>=8?g.push("Excellent posture! Keep it up!"):n>=7?g.push("Good posture overall, minor adjustments needed"):n>=6&&g.push("Posture is improving, keep working on it"),{score:Math.max(2,Math.min(10,n)),issues:g,neckAngle:o,shoulderAlignment:l,spineAlignment:h,headPosition:u,shoulderHeight:c}}calculateNeckAngle(e){const n=e.nose,r=e.leftEar,s=e.leftShoulder;if(n.visibility<.5||r.visibility<.5||s.visibility<.5)return 0;const a=r.x-s.x,i=r.y-s.y,o=n.x-r.x,l=n.y-r.y,u=a*o+i*l,c=Math.sqrt(a*a+i*i),h=Math.sqrt(o*o+l*l);if(c===0||h===0)return 0;const d=Math.acos(Math.max(-1,Math.min(1,u/(c*h))))*180/Math.PI;return Math.max(0,180-d)}calculateShoulderAlignment(e){const n=e.leftShoulder,r=e.rightShoulder;if(n.visibility<.5||r.visibility<.5)return 0;const s=Math.atan2(r.y-n.y,r.x-n.x);return Math.abs(s*180/Math.PI)}calculateSpineAlignment(e){const n=e.leftShoulder,r=e.rightShoulder,s=e.leftHip,a=e.rightHip;if(n.visibility<.5||r.visibility<.5||s.visibility<.5||a.visibility<.5)return 0;const i=(n.x+r.x)/2,o=(n.y+r.y)/2,l=(s.x+a.x)/2,u=(s.y+a.y)/2,c=Math.atan2(l-i,u-o);return Math.abs(c*180/Math.PI)}calculateHeadPosition(e){const n=e.leftEar,r=e.rightEar,s=e.nose;if(n.visibility<.5||r.visibility<.5||s.visibility<.5)return 0;const a=Math.atan2(r.y-n.y,r.x-n.x);return Math.abs(a*180/Math.PI)}calculateShoulderHeight(e){const n=e.leftShoulder,r=e.rightShoulder;return n.visibility<.5||r.visibility<.5?0:Math.abs(n.y-r.y)*10}detectSlouching(e){const n=e.leftShoulder,r=e.rightShoulder,s=e.leftHip,a=e.rightHip;if(n.visibility<.5||r.visibility<.5||s.visibility<.5||a.visibility<.5)return!1;const i=(n.x+r.x)/2,o=(s.x+a.x)/2;return i>o+.1}calculateHeadNeckScore(e){const n=e.nose,r=e.leftEar,s=e.rightEar,a=e.leftShoulder,i=e.rightShoulder;if(n.visibility<.5||r.visibility<.5||s.visibility<.5||a.visibility<.5||i.visibility<.5)return 0;let o=10;const l=(r.y+s.y)/2,u=(a.y+i.y)/2,c=Math.abs(l-u);c>.15&&(o-=Math.min(2,c*15));const h=Math.abs(r.y-s.y);h>.08&&(o-=Math.min(1.8,h*20));const d=Math.abs(n.x-(a.x+i.x)/2);return d>.2&&(o-=Math.min(2.5,d*10)),Math.max(0,o)}detectTooCloseToCamera(e){const n=e.leftShoulder,r=e.rightShoulder,s=e.nose;if(n.visibility<.5||r.visibility<.5||s.visibility<.5)return!1;const a=Math.sqrt(Math.pow(n.x-r.x,2)+Math.pow(n.y-r.y,2)),i=(n.x+r.x)/2,o=(n.y+r.y)/2,l=Math.sqrt(Math.pow(s.x-i,2)+Math.pow(s.y-o,2))/a;return a>.8||l<.3}detectTooFarFromCamera(e){const n=e.leftShoulder,r=e.rightShoulder,s=e.nose;if(n.visibility<.5||r.visibility<.5||s.visibility<.5)return!1;const a=Math.sqrt(Math.pow(n.x-r.x,2)+Math.pow(n.y-r.y,2)),i=(n.x+r.x)/2,o=(n.y+r.y)/2,l=Math.sqrt(Math.pow(s.x-i,2)+Math.pow(s.y-o,2))/a;return a<.15||l>.8}}const rke="modulepreload",ske=function(t){return"/"+t},fT={},mT=function(t,e,n){let r=Promise.resolve();if(e&&e.length>0){document.getElementsByTagName("link");const a=document.querySelector("meta[property=csp-nonce]"),i=(a==null?void 0:a.nonce)||(a==null?void 0:a.getAttribute("nonce"));r=Promise.allSettled(e.map(o=>{if(o=ske(o),o in fT)return;fT[o]=!0;const l=o.endsWith(".css"),u=l?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${o}"]${u}`))return;const c=document.createElement("link");if(c.rel=l?"stylesheet":rke,l||(c.as="script"),c.crossOrigin="",c.href=o,i&&c.setAttribute("nonce",i),document.head.appendChild(c),l)return new Promise((h,d)=>{c.addEventListener("load",h),c.addEventListener("error",()=>d(new Error(`Unable to preload CSS for ${o}`)))})}))}function s(a){const i=new Event("vite:preloadError",{cancelable:!0});if(i.payload=a,window.dispatchEvent(i),!i.defaultPrevented)throw a}return r.then(a=>{for(const i of a||[])i.status==="rejected"&&s(i.reason);return t().catch(s)})},ake=({onClose:t})=>{const[e,n]=ze.useState([]),[r,s]=ze.useState(!0);return ze.useEffect(()=>{(async()=>{const a=[];location.protocol==="https:"||location.hostname==="localhost"?a.push("✅ HTTPS/Localhost: OK"):a.push("❌ HTTPS/Localhost: Not secure (TensorFlow.js works best on HTTPS in production)");try{const l=await navigator.permissions.query({name:"camera"});l.state==="granted"?a.push("✅ Camera Permission: Granted"):l.state==="prompt"?a.push("⚠️ Camera Permission: Prompting (please allow access)"):a.push("❌ Camera Permission: Denied")}catch(l){a.push(`❌ Camera Permission: Error (${l})`)}const i=document.createElement("canvas"),o=i.getContext("webgl")||i.getContext("experimental-webgl");o&&o instanceof WebGLRenderingContext?a.push("✅ WebGL: Supported"):a.push("❌ WebGL: Not supported (required for TensorFlow.js)");try{const l=await mT(()=>SL(()=>vL(()=>yL(()=>import("./index-BNvRUCG6-DkHLmlYM-QRR5vN5j-mFUaLwpd.js"),[]),[]),[]),[]);a.push("✅ TensorFlow.js: Available"),await l.ready(),a.push("✅ TensorFlow.js Backend: Ready")}catch(l){a.push(`❌ TensorFlow.js: Not available (${l})`)}try{const l=await mT(()=>Promise.resolve().then(()=>tke),void 0);a.push("✅ MoveNet Model: Available")}catch(l){a.push(`❌ MoveNet Model: Not available (${l})`)}if("memory"in performance){const l=performance.memory,u=Math.round(l.usedJSHeapSize/1048576),c=Math.round(l.totalJSHeapSize/1048576);a.push(`📊 Memory Usage: ${u}MB / ${c}MB`),u>100&&a.push("⚠️ High memory usage detected")}n(a),s(!1)})()},[]),$.jsx("div",{className:"fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 p-4",children:$.jsxs("div",{className:"bg-white rounded-xl shadow-2xl p-6 w-full max-w-md relative",children:[$.jsx("button",{onClick:t,className:"absolute top-3 right-3 text-gray-500 hover:text-gray-800 text-xl",children:"×"}),$.jsx("h2",{className:"text-2xl font-bold text-gray-800 mb-4",children:"TensorFlow.js Diagnostics"}),r?$.jsx("p",{className:"text-gray-600",children:"Running diagnostics..."}):$.jsx("div",{className:"space-y-2",children:e.map((a,i)=>$.jsx("div",{className:`p-2 rounded-md ${a.startsWith("✅")?"bg-green-50 text-green-800":a.startsWith("⚠️")?"bg-yellow-50 text-yellow-800":a.startsWith("📊")?"bg-blue-50 text-blue-800":"bg-red-50 text-red-800"}`,children:a},i))}),$.jsxs("div",{className:"mt-6 p-4 bg-blue-50 rounded-lg",children:[$.jsx("h3",{className:"font-semibold text-blue-800 mb-2",children:"TensorFlow.js Benefits:"}),$.jsxs("ul",{className:"text-sm text-blue-700 space-y-1",children:[$.jsx("li",{children:"• More reliable than MediaPipe CDN"}),$.jsx("li",{children:"• Better browser compatibility"}),$.jsx("li",{children:"• Faster initialization"}),$.jsx("li",{children:"• More accurate pose detection"}),$.jsx("li",{children:"• Better performance on modern browsers"}),$.jsx("li",{children:"• No external CDN dependencies"})]})]}),$.jsxs("div",{className:"mt-4 p-4 bg-green-50 rounded-lg",children:[$.jsx("h3",{className:"font-semibold text-green-800 mb-2",children:"Common Solutions:"}),$.jsxs("ul",{className:"text-sm text-green-700 space-y-1",children:[$.jsx("li",{children:"• Use HTTPS or localhost for best performance"}),$.jsx("li",{children:"• Grant camera permissions when prompted"}),$.jsx("li",{children:"• Ensure WebGL is enabled in your browser"}),$.jsx("li",{children:"• Check browser console for detailed error messages"}),$.jsx("li",{children:"• Try refreshing the page if TensorFlow fails to load"}),$.jsx("li",{children:"• Clear browser cache and cookies"}),$.jsx("li",{children:"• Try a different browser (Chrome recommended)"})]})]}),$.jsxs("div",{className:"mt-4 p-4 bg-yellow-50 rounded-lg",children:[$.jsx("h3",{className:"font-semibold text-yellow-800 mb-2",children:"Performance Tips:"}),$.jsxs("ul",{className:"text-sm text-yellow-700 space-y-1",children:[$.jsx("li",{children:"• Close other tabs to free up memory"}),$.jsx("li",{children:"• Use a modern browser with hardware acceleration"}),$.jsx("li",{children:"• Ensure stable internet connection for model loading"}),$.jsx("li",{children:"• Restart browser if memory usage is high"})]})]})]})})},ike=({onPostureUpdate:t,onError:e,isActive:n})=>{const r=ze.useRef(null),[s,a]=ze.useState("pending"),[i,o]=ze.useState(!1),[l,u]=ze.useState(null),[c,h]=ze.useState(null),[d,p]=ze.useState(!1),[f,m]=ze.useState(null),[y,g]=ze.useState(!1),b={width:640,height:480,facingMode:"user"},v=ze.useCallback(async()=>{try{o(!0),u(null);const N=await navigator.mediaDevices.getUserMedia({video:{width:640,height:480,facingMode:"user"}});a("granted"),o(!1),N.getTracks().forEach(T=>T.stop())}catch(N){console.error("Camera access error:",N),a("denied"),u(`Camera access denied: ${N.message}`),o(!1)}},[]);ze.useEffect(()=>{n&&v()},[n,v]),ze.useEffect(()=>()=>{if(c&&typeof c.stop=="function")try{c.stop()}catch(N){console.error("Error stopping pose service on unmount:",N)}},[c]),ze.useEffect(()=>{if(!n&&c&&typeof c.stop=="function")try{c.stop()}catch(N){console.error("Error stopping pose service:",N)}finally{h(null),p(!1),m(null)}},[n,c]);const w=ze.useCallback(async N=>{var T;if(console.log("Camera stream received:",N),a("granted"),u(null),(T=r.current)!=null&&T.video&&n)try{const E=r.current.video;E.readyState<2&&(console.log("Waiting for video to be ready..."),await new Promise(O=>{E.addEventListener("loadeddata",O,{once:!0})})),console.log("Video ready, initializing TensorFlow pose detection...");const _=new nke(O=>{m(O),t(O)},O=>{console.error("TensorFlow pose detection error:",O),e(O)});await _.initialize(E),h(_),p(!0),console.log("TensorFlow pose detection service initialized successfully")}catch(E){console.error("Error initializing TensorFlow pose detection:",E),e(`TensorFlow.js is required for this app to function. Failed to initialize: ${E}`),h(null),p(!1)}},[n,t,e]),k=ze.useCallback(N=>{console.error("Camera error:",N),a("denied"),u(`Camera error: ${N}`)},[]);return s==="denied"||l?$.jsx("div",{className:"bg-red-50 border border-red-200 rounded-xl p-6 shadow-lg",children:$.jsxs("div",{className:"text-center",children:[$.jsx("div",{className:"w-16 h-16 mx-auto mb-4 bg-red-100 rounded-full flex items-center justify-center",children:$.jsx("span",{className:"text-red-600 text-2xl",children:"📷"})}),$.jsx("h3",{className:"text-lg font-semibold text-red-800 mb-2",children:"Camera Access Required"}),$.jsx("p",{className:"text-red-600 text-sm mb-4",children:l||"Please allow camera access to enable posture monitoring."}),$.jsxs("div",{className:"space-y-2 text-sm text-red-600",children:[$.jsx("p",{children:"• Click the camera icon in your browser's address bar"}),$.jsx("p",{children:"• Go to browser settings and allow camera access"}),$.jsx("p",{children:"• Make sure no other app is using the camera"})]}),$.jsx("button",{onClick:()=>{u(null),a("pending"),v()},className:"mt-4 bg-red-600 hover:bg-red-700 text-white font-medium py-2 px-4 rounded-lg transition-colors",children:"Retry Camera Access"})]})}):s==="pending"||i?$.jsx("div",{className:"bg-blue-50 border border-blue-200 rounded-xl p-6 shadow-lg",children:$.jsxs("div",{className:"text-center",children:[$.jsx("div",{className:"w-16 h-16 mx-auto mb-4 bg-blue-100 rounded-full flex items-center justify-center",children:$.jsx("div",{className:"animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"})}),$.jsx("h3",{className:"text-lg font-semibold text-blue-800 mb-2",children:"Initializing Camera"}),$.jsx("p",{className:"text-blue-600 text-sm",children:"Requesting camera access and setting up posture detection..."})]})}):$.jsxs("div",{className:"bg-white rounded-xl shadow-lg border border-gray-200 overflow-hidden",children:[$.jsx("div",{className:"bg-gradient-to-r from-blue-600 to-purple-600 p-4 text-white",children:$.jsxs("div",{className:"flex items-center justify-between",children:[$.jsxs("div",{children:[$.jsx("h3",{className:"text-lg font-semibold",children:"Live Posture Monitor"}),$.jsx("p",{className:"text-blue-100 text-sm",children:"AI-Powered Analysis"})]}),$.jsxs("div",{className:"text-right",children:[$.jsx("div",{className:"text-2xl font-bold text-green-300",children:n?"🟢":"⚪"}),$.jsx("div",{className:"text-blue-100 text-sm",children:n?"Active":"Inactive"})]})]})}),$.jsxs("div",{className:"relative bg-gray-900",children:[$.jsx(lB,{ref:r,audio:!1,width:640,height:480,screenshotFormat:"image/jpeg",videoConstraints:b,className:"w-full h-auto",style:{transform:"scaleX(-1)"},onUserMedia:w,onUserMediaError:k}),$.jsx("div",{className:"absolute top-4 left-4",children:$.jsx("div",{className:`px-3 py-1 rounded-full text-xs font-medium ${n&&d?"bg-green-500 text-white":n?"bg-yellow-500 text-white":"bg-gray-500 text-white"}`,children:n&&d?"● AI Active":n?"● Initializing":"○ Paused"})}),f&&$.jsx("div",{className:"absolute top-4 right-4",children:$.jsxs("div",{className:`px-3 py-1 rounded-full text-xs font-medium ${f.score>=8?"bg-green-500 text-white":f.score>=6?"bg-yellow-500 text-white":"bg-red-500 text-white"}`,children:[f.score,"/10"]})})]}),y&&$.jsx(ake,{onClose:()=>g(!1)})]})},oke=({trackingData:t,postureAnalysis:e,isMonitoring:n,onGenerateSuggestions:r,onTakeBreak:s,isGeneratingSuggestions:a,onOpenSettings:i})=>{const o=u=>u>=8?"text-green-600":u>=6?"text-yellow-600":"text-red-600",l=u=>u>=8?"Excellent":u>=6?"Good":u>=4?"Fair":"Poor";return $.jsxs("div",{className:"space-y-6",children:[$.jsxs("div",{className:"text-center relative",children:[$.jsx("button",{onClick:i,className:"absolute top-0 right-0 bg-gray-100 hover:bg-gray-200 text-gray-600 hover:text-gray-800 p-2 rounded-lg transition-colors",title:"Settings",children:$.jsxs("svg",{className:"w-5 h-5",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:[$.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"}),$.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M15 12a3 3 0 11-6 0 3 3 0 016 0z"})]})}),$.jsx("h1",{className:"text-4xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent mb-2",children:"PostureGuard"})]}),$.jsxs("div",{className:"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6",children:[$.jsx("div",{className:"bg-white rounded-lg border border-gray-200 p-6",children:$.jsxs("div",{className:"flex items-center justify-between",children:[$.jsxs("div",{children:[$.jsx("p",{className:"text-sm font-medium text-gray-600 mb-1",children:"Screen Time"}),$.jsxs("p",{className:"text-3xl font-bold text-gray-800",children:[(t==null?void 0:t.screenTime)||0,"m"]}),$.jsx("p",{className:"text-xs text-gray-500 mt-1",children:"Total today"})]}),$.jsx("div",{className:"w-12 h-12 bg-blue-100 rounded-lg flex items-center justify-center",children:$.jsx("svg",{className:"w-6 h-6 text-blue-600",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:$.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"})})})]})}),$.jsx("div",{className:"bg-white rounded-lg border border-gray-200 p-6",children:$.jsxs("div",{className:"flex items-center justify-between",children:[$.jsxs("div",{children:[$.jsx("p",{className:"text-sm font-medium text-gray-600 mb-1",children:"Posture Score"}),$.jsxs("p",{className:`text-3xl font-bold ${o((t==null?void 0:t.postureScore)||0)}`,children:[(t==null?void 0:t.postureScore)||0,"/10"]}),$.jsx("p",{className:"text-xs text-gray-500 mt-1",children:"Current status"})]}),$.jsx("div",{className:"w-12 h-12 bg-green-100 rounded-lg flex items-center justify-center",children:$.jsx("svg",{className:"w-6 h-6 text-green-600",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:$.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"})})})]})}),$.jsx("div",{className:"bg-white rounded-lg border border-gray-200 p-6",children:$.jsxs("div",{className:"flex items-center justify-between",children:[$.jsxs("div",{children:[$.jsx("p",{className:"text-sm font-medium text-gray-600 mb-1",children:"Breaks Taken"}),$.jsx("p",{className:"text-3xl font-bold text-gray-800",children:(t==null?void 0:t.breakCount)||0}),$.jsx("p",{className:"text-xs text-gray-500 mt-1",children:"Today"})]}),$.jsx("div",{className:"w-12 h-12 bg-orange-100 rounded-lg flex items-center justify-center",children:$.jsx("svg",{className:"w-6 h-6 text-orange-600",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:$.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"})})})]})}),$.jsx("div",{className:"bg-white rounded-lg border border-gray-200 p-6",children:$.jsxs("div",{className:"flex items-center justify-between",children:[$.jsxs("div",{children:[$.jsx("p",{className:"text-sm font-medium text-gray-600 mb-1",children:"Session Time"}),$.jsxs("p",{className:"text-3xl font-bold text-gray-800",children:[(t==null?void 0:t.sessionTime)||0,"m"]}),$.jsx("p",{className:"text-xs text-gray-500 mt-1",children:"Total session"})]}),$.jsx("div",{className:"w-12 h-12 bg-purple-100 rounded-lg flex items-center justify-center",children:$.jsx("svg",{className:"w-6 h-6 text-purple-600",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:$.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"})})})]})})]}),e&&$.jsxs("div",{className:"bg-white rounded-xl shadow-lg border border-gray-200 p-6",children:[$.jsxs("div",{className:"flex items-center justify-between mb-6",children:[$.jsx("h3",{className:"text-xl font-semibold text-gray-900",children:"Real-time Posture Analysis"}),$.jsxs("div",{className:"flex items-center gap-2",children:[$.jsx("div",{className:`w-3 h-3 rounded-full ${e.score>=80?"bg-green-500":e.score>=60?"bg-yellow-500":"bg-red-500"}`}),$.jsx("span",{className:"text-sm text-gray-600",children:"Live monitoring"})]})]}),$.jsxs("div",{className:"grid grid-cols-1 lg:grid-cols-2 gap-8",children:[$.jsxs("div",{children:[$.jsxs("div",{className:"mb-6",children:[$.jsxs("div",{className:"flex items-center justify-between mb-3",children:[$.jsx("span",{className:"text-sm font-medium text-gray-600",children:"Posture Quality"}),$.jsxs("span",{className:`text-2xl font-bold ${o(e.score)}`,children:[e.score,"/10"]})]}),$.jsx("div",{className:"w-full bg-gray-200 rounded-full h-3",children:$.jsx("div",{className:`h-3 rounded-full transition-all duration-500 ${e.score>=8?"bg-green-500":e.score>=6?"bg-yellow-500":"bg-red-500"}`,style:{width:`${e.score/10*100}%`}})}),$.jsxs("div",{className:"flex justify-between text-xs text-gray-500 mt-2",children:[$.jsx("span",{children:"Poor"}),$.jsx("span",{children:"Good"}),$.jsx("span",{children:"Excellent"})]})]}),$.jsxs("div",{className:"space-y-4",children:[$.jsxs("div",{className:"flex items-center justify-between",children:[$.jsx("span",{className:"text-sm text-gray-600",children:"Status"}),$.jsx("span",{className:`font-medium ${o(e.score)}`,children:l(e.score)})]}),t&&$.jsx("div",{className:"flex items-center justify-between"}),t&&$.jsxs("div",{className:"flex items-center justify-between",children:[$.jsx("span",{className:"text-sm text-gray-600",children:"Average"}),$.jsxs("span",{className:"text-sm font-medium text-gray-900",children:[Math.round(t.averagePostureScore),"/10"]})]})]})]}),$.jsxs("div",{children:[$.jsx("h4",{className:"text-sm font-medium text-gray-700 mb-3",children:"Detected Issues"}),e.issues.length>0?$.jsx("div",{className:"space-y-2",children:e.issues.map((u,c)=>$.jsxs("div",{className:"flex items-center gap-2",children:[$.jsx("div",{className:"w-2 h-2 bg-red-500 rounded-full"}),$.jsx("span",{className:"text-sm text-gray-700",children:u})]},c))}):$.jsxs("div",{className:"text-center py-4",children:[$.jsx("div",{className:"w-8 h-8 bg-green-100 rounded-full flex items-center justify-center mx-auto mb-2",children:$.jsx("div",{className:"w-4 h-4 bg-green-500 rounded-full"})}),$.jsx("p",{className:"text-green-600 font-medium",children:"No issues detected!"}),$.jsx("p",{className:"text-sm text-gray-500",children:"Keep up the good posture!"})]})]})]})]}),$.jsxs("div",{className:"grid grid-cols-1 md:grid-cols-2 gap-6",children:[$.jsx("button",{onClick:r,disabled:a,className:"bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 text-white font-medium py-4 px-6 rounded-lg transition-colors duration-200 flex items-center justify-center",children:a?$.jsxs($.Fragment,{children:[$.jsx("div",{className:"animate-spin rounded-full h-5 w-5 border-b-2 border-white mr-3"}),"Generating Suggestions..."]}):$.jsxs($.Fragment,{children:[$.jsx("svg",{className:"w-5 h-5 mr-3",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:$.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"})}),"Get Stretch Suggestions"]})}),$.jsxs("button",{onClick:s,className:"bg-green-600 hover:bg-green-700 text-white font-medium py-4 px-6 rounded-lg transition-colors duration-200 flex items-center justify-center",children:[$.jsx("svg",{className:"w-5 h-5 mr-3",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:$.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"})}),"Take a Break"]})]}),$.jsxs("div",{className:"mt-6 grid grid-cols-1 md:grid-cols-2 gap-4 text-center",children:[$.jsxs("div",{className:"text-sm text-gray-600",children:[$.jsx("p",{className:"font-medium text-gray-800 mb-1",children:"AI Suggestions"}),$.jsx("p",{children:"Get personalized stretch recommendations"})]}),$.jsxs("div",{className:"text-sm text-gray-600",children:[$.jsx("p",{className:"font-medium text-gray-800 mb-1",children:"Take Break"}),$.jsx("p",{children:"Start a break timer to rest your eyes and body"})]})]})]})},lke=({isOpen:t,onClose:e,onSave:n,currentSettings:r})=>{const[s,a]=ze.useState(r);ze.useEffect(()=>{a(r)},[r]);const i=()=>{n(s),e()},o=h=>{a(d=>({...d,reminderInterval:h}))},l=h=>{a(d=>({...d,postureCheckInterval:h}))},u=h=>{a(d=>({...d,enableNotifications:h}))},c=h=>{a(d=>({...d,enableBreakAlerts:h}))};return t?$.jsx("div",{className:"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50",children:$.jsx("div",{className:"bg-white rounded-lg shadow-xl max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto",children:$.jsxs("div",{className:"p-6",children:[$.jsxs("div",{className:"flex justify-between items-center mb-6",children:[$.jsx("h2",{className:"text-2xl font-bold text-gray-800",children:"Settings"}),$.jsx("button",{onClick:e,className:"text-gray-500 hover:text-gray-700 text-2xl",children:"×"})]}),$.jsxs("div",{className:"space-y-6",children:[$.jsxs("div",{className:"bg-gray-50 rounded-lg p-4",children:[$.jsx("h3",{className:"text-lg font-semibold text-gray-800 mb-3",children:"Break Reminders"}),$.jsx("div",{className:"space-y-3",children:$.jsxs("div",{children:[$.jsx("label",{className:"block text-sm font-medium text-gray-700 mb-2",children:"Reminder Interval (minutes)"}),$.jsx("div",{className:"flex gap-2",children:[15,30,45,60,90,120].map(h=>$.jsxs("button",{onClick:()=>o(h),className:`px-4 py-2 rounded-lg text-sm font-medium transition-colors ${s.reminderInterval===h?"bg-blue-600 text-white":"bg-white text-gray-700 border border-gray-300 hover:bg-gray-50"}`,children:[h,"m"]},h))}),$.jsx("div",{className:"mt-2",children:$.jsx("input",{type:"number",min:"5",max:"240",value:s.reminderInterval,onChange:h=>o(parseInt(h.target.value)||30),className:"w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500",placeholder:"Custom interval"})})]})})]}),$.jsxs("div",{className:"bg-gray-50 rounded-lg p-4",children:[$.jsx("h3",{className:"text-lg font-semibold text-gray-800 mb-3",children:"Posture Analysis"}),$.jsx("div",{className:"space-y-3",children:$.jsxs("div",{children:[$.jsx("label",{className:"block text-sm font-medium text-gray-700 mb-2",children:"Posture Check Frequency (seconds)"}),$.jsx("div",{className:"flex gap-2",children:[15,30,45,60,90].map(h=>$.jsxs("button",{onClick:()=>l(h),className:`px-4 py-2 rounded-lg text-sm font-medium transition-colors ${s.postureCheckInterval===h?"bg-green-600 text-white":"bg-white text-gray-700 border border-gray-300 hover:bg-gray-50"}`,children:[h,"s"]},h))}),$.jsx("div",{className:"mt-2",children:$.jsx("input",{type:"number",min:"1",max:"300",value:s.postureCheckInterval,onChange:h=>l(parseInt(h.target.value)||60),className:"w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-green-500",placeholder:"Custom interval"})})]})})]}),$.jsxs("div",{className:"bg-gray-50 rounded-lg p-4",children:[$.jsx("h3",{className:"text-lg font-semibold text-gray-800 mb-3",children:"Notifications"}),$.jsxs("div",{className:"space-y-3",children:[$.jsxs("div",{className:"flex items-center justify-between",children:[$.jsxs("div",{children:[$.jsx("label",{className:"text-sm font-medium text-gray-700",children:"Browser Notifications"}),$.jsx("p",{className:"text-xs text-gray-500",children:"Show system notifications for break reminders"})]}),$.jsx("button",{onClick:()=>u(!s.enableNotifications),className:`relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${s.enableNotifications?"bg-blue-600":"bg-gray-200"}`,children:$.jsx("span",{className:`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${s.enableNotifications?"translate-x-6":"translate-x-1"}`})})]}),$.jsxs("div",{className:"flex items-center justify-between",children:[$.jsxs("div",{children:[$.jsx("label",{className:"text-sm font-medium text-gray-700",children:"Break Alerts"}),$.jsx("p",{className:"text-xs text-gray-500",children:"Show alerts when it's time to take a break"})]}),$.jsx("button",{onClick:()=>c(!s.enableBreakAlerts),className:`relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${s.enableBreakAlerts?"bg-green-600":"bg-gray-200"}`,children:$.jsx("span",{className:`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${s.enableBreakAlerts?"translate-x-6":"translate-x-1"}`})})]})]})]}),$.jsxs("div",{className:"bg-blue-50 rounded-lg p-4",children:[$.jsx("h3",{className:"text-lg font-semibold text-blue-800 mb-3",children:"Current Settings"}),$.jsxs("div",{className:"grid grid-cols-1 md:grid-cols-2 gap-4 text-sm",children:[$.jsxs("div",{children:[$.jsx("span",{className:"font-medium text-blue-700",children:"Break Reminders:"}),$.jsxs("span",{className:"ml-2 text-blue-600",children:[s.reminderInterval," minutes"]})]}),$.jsxs("div",{children:[$.jsx("span",{className:"font-medium text-blue-700",children:"Posture Checks:"}),$.jsxs("span",{className:"ml-2 text-blue-600",children:["Every ",s.postureCheckInterval," seconds"]})]}),$.jsxs("div",{children:[$.jsx("span",{className:"font-medium text-blue-700",children:"Notifications:"}),$.jsx("span",{className:"ml-2 text-blue-600",children:s.enableNotifications?"Enabled":"Disabled"})]}),$.jsxs("div",{children:[$.jsx("span",{className:"font-medium text-blue-700",children:"Break Alerts:"}),$.jsx("span",{className:"ml-2 text-blue-600",children:s.enableBreakAlerts?"Enabled":"Disabled"})]})]})]})]}),$.jsxs("div",{className:"flex justify-end gap-3 mt-6",children:[$.jsx("button",{onClick:e,className:"px-4 py-2 text-gray-700 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors",children:"Cancel"}),$.jsx("button",{onClick:i,className:"px-4 py-2 bg-blue-600 text-white hover:bg-blue-700 rounded-lg transition-colors",children:"Save Settings"})]})]})})}):null},uke=({isOpen:t,onClose:e,issues:n,score:r,onGetStretch:s})=>{const a=()=>{try{const l=new(window.AudioContext||window.webkitAudioContext),u=l.createOscillator(),c=l.createGain();u.connect(c),c.connect(l.destination),u.frequency.setValueAtTime(800,l.currentTime),u.frequency.setValueAtTime(600,l.currentTime+.1),u.frequency.setValueAtTime(800,l.currentTime+.2),c.gain.setValueAtTime(.3,l.currentTime),c.gain.exponentialRampToValueAtTime(.01,l.currentTime+.3),u.start(l.currentTime),u.stop(l.currentTime+.3)}catch(l){console.log("Could not play alarm sound:",l)}};if(ze.useEffect(()=>{t&&a()},[t]),!t)return null;const i=l=>l>=6?"text-yellow-600":"text-red-600",o=l=>l>=6?"bg-yellow-50 border-yellow-200":"bg-red-50 border-red-200";return $.jsx("div",{className:"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4",children:$.jsxs("div",{className:`${o(r)} border-2 rounded-xl shadow-2xl max-w-md w-full p-6 animate-in slide-in-from-bottom-4 duration-300`,children:[$.jsxs("div",{className:"flex items-center justify-between mb-4",children:[$.jsxs("div",{className:"flex items-center gap-3",children:[$.jsx("div",{className:`w-12 h-12 rounded-full flex items-center justify-center ${r>=60?"bg-yellow-100":"bg-red-100"}`,children:$.jsx("span",{className:`text-2xl ${r>=60?"text-yellow-600":"text-red-600"}`,children:r>=60?"⚠️":"🚨"})}),$.jsxs("div",{children:[$.jsx("h3",{className:`text-lg font-bold ${i(r)}`,children:"Posture Alert"}),$.jsxs("p",{className:"text-sm text-gray-600",children:["Score: ",$.jsxs("span",{className:`font-semibold ${i(r)}`,children:[r,"/10"]})]})]})]}),$.jsx("button",{onClick:e,className:"text-gray-400 hover:text-gray-600 text-2xl font-bold",children:"×"})]}),$.jsxs("div",{className:"mb-4",children:[$.jsx("h4",{className:"font-semibold text-gray-800 mb-2",children:"Main Issue:"}),$.jsx("p",{className:`text-sm ${i(r)} font-medium bg-white rounded-lg p-3 border`,children:n[0]})]}),$.jsxs("div",{className:"mb-4 p-3 bg-white rounded-lg border",children:[$.jsx("h4",{className:"font-semibold text-gray-800 mb-2 text-sm",children:"Quick Fix:"}),$.jsx("p",{className:"text-sm text-gray-600",children:r<5?"Sit up straight, pull your shoulders back, and align your head over your shoulders.":"Make small adjustments to improve your posture - you're on the right track!"})]}),$.jsxs("div",{className:"flex gap-2",children:[$.jsx("button",{onClick:e,className:"flex-1 bg-gray-600 hover:bg-gray-700 text-white font-medium py-2 px-4 rounded-lg transition-colors text-sm",children:"Got it"}),$.jsx("button",{onClick:()=>{s&&s(),e()},className:"flex-1 bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-lg transition-colors text-sm",children:"Get Stretch"})]})]})})},cke=({isOpen:t,onClose:e,onTakeBreak:n,screenTime:r})=>{if(ze.useEffect(()=>{if(t){const a=setTimeout(()=>{e()},1e4);return()=>clearTimeout(a)}},[t,e]),!t)return null;const s=()=>{n(),e()};return $.jsx("div",{className:"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4",children:$.jsxs("div",{className:"bg-gradient-to-br from-orange-50 to-red-50 border-2 border-orange-200 rounded-xl shadow-2xl max-w-md w-full p-6 animate-in slide-in-from-bottom-4 duration-300",children:[$.jsxs("div",{className:"flex justify-between items-start mb-4",children:[$.jsxs("div",{className:"flex items-center gap-3",children:[$.jsx("div",{className:"w-12 h-12 bg-orange-100 rounded-full flex items-center justify-center",children:$.jsx("span",{className:"text-2xl",children:"⏰"})}),$.jsxs("div",{children:[$.jsx("h3",{className:"text-xl font-bold text-orange-800",children:"Break Time!"}),$.jsxs("p",{className:"text-sm text-orange-600",children:["You've been working for ",r," minutes"]})]})]}),$.jsx("button",{onClick:e,className:"text-orange-400 hover:text-orange-600 text-2xl font-bold",children:"×"})]}),$.jsxs("div",{className:"mb-6",children:[$.jsx("p",{className:"text-orange-700 text-base font-medium mb-3",children:"It's time to take a break! Your body needs rest to maintain good posture and prevent strain."}),$.jsxs("div",{className:"bg-white rounded-lg p-3 border border-orange-200",children:[$.jsx("h4",{className:"font-semibold text-orange-800 mb-2 text-sm",children:"Benefits of taking breaks:"}),$.jsxs("ul",{className:"text-sm text-orange-700 space-y-1",children:[$.jsx("li",{children:"• Reduces eye strain and fatigue"}),$.jsx("li",{children:"• Improves circulation and posture"}),$.jsx("li",{children:"• Boosts productivity and focus"}),$.jsx("li",{children:"• Prevents repetitive strain injuries"})]})]})]}),$.jsxs("div",{className:"flex gap-3",children:[$.jsx("button",{onClick:e,className:"flex-1 bg-gray-600 hover:bg-gray-700 text-white font-medium py-3 px-4 rounded-lg transition-colors text-sm",children:"Dismiss"}),$.jsx("button",{onClick:s,className:"flex-1 bg-orange-600 hover:bg-orange-700 text-white font-medium py-3 px-4 rounded-lg transition-colors text-sm",children:"Take Break"})]}),$.jsx("div",{className:"mt-4 text-xs text-orange-500 text-center",children:"This alert will auto-close in 10 seconds"})]})})};function hke(){const[t,e]=ze.useState(!1),[n,r]=ze.useState(null),[s,a]=ze.useState([]),[i,o]=ze.useState([]),[l,u]=ze.useState(null),[c,h]=ze.useState(!1),[d,p]=ze.useState(!1),[f,m]=ze.useState(null),[y,g]=ze.useState(null),[b,v]=ze.useState(null),[w,k]=ze.useState(null),[N,T]=ze.useState(!1),[E,_]=ze.useState({reminderInterval:30,postureCheckInterval:15,enableNotifications:!0,enableBreakAlerts:!0}),[O,M]=ze.useState(!1),[V,W]=ze.useState(null),[K,q]=ze.useState(!1);ze.useEffect(()=>{console.log("App: Initializing Gemini service...");try{const xe=new rB;console.log("App: Gemini service created successfully:",!!xe),g(xe)}catch(xe){console.error("App: Failed to initialize Gemini service:",xe)}},[]);const ee=ze.useCallback(xe=>{r(He=>He?{...He,postureScore:xe}:null)},[]),te=ze.useCallback(xe=>{r(He=>He?{...He,screenTime:xe}:null)},[]),G=ze.useCallback(xe=>{v(xe),f&&(f.updatePostureScore(xe.score,xe.issues),r(f.getCurrentData()))},[f]),J=ze.useCallback(xe=>{k(xe)},[]),ne=ze.useCallback(()=>{q(!0)},[]),ae=ze.useCallback((xe,He)=>{W({issues:xe,score:He}),M(!0)},[]),oe=()=>{if(!y){alert("Gemini service not initialized!");return}const xe=new sB(ee,te,ne,ae,E);m(xe),xe.startTracking(),r(xe.getCurrentData()),e(!0),k(null)},ue=()=>{f&&f.stopTracking(),e(!1),v(null)},ce=()=>{f&&(f.takeBreak(),r(f.getCurrentData()))},de=async()=>{if(console.log("=== GENERATE STRETCH SUGGESTIONS CALLED ==="),console.log("Generating stretch suggestions...",{geminiService:!!y,trackingData:!!n}),console.log("Current posture analysis:",b),console.log("Gemini service details:",y),!y){console.log("Missing Gemini service"),alert("Gemini service not available. Please refresh the page.");return}console.log("Gemini service is available, proceeding with generation...");const xe=n||{screenTime:0,postureScore:7.5,lastBreakTime:Date.now(),commonIssues:["General posture improvement"]};p(!0);try{console.log("Calling Gemini service...");const He=await y.generateStretchSuggestions({screenTime:xe.screenTime,postureScore:xe.postureScore,lastBreakTime:xe.lastBreakTime,commonIssues:xe.commonIssues,poseLandmarks:b?{neckAngle:b.neckAngle,shoulderAlignment:b.shoulderAlignment,spineAlignment:b.spineAlignment,headPosition:b.headPosition,shoulderHeight:b.shoulderHeight,slouching:b.issues.some(tt=>tt.toLowerCase().includes("slouching")||tt.toLowerCase().includes("forward"))}:void 0});console.log("Got suggestions:",He),a(tt=>[...tt,...He]),o(tt=>[...tt,He]),h(!0)}catch(He){console.error("Error generating suggestions:",He),alert("Failed to generate stretch suggestions. Please try again.")}finally{p(!1)}},Te=ze.useCallback(()=>{M(!1),de()},[de]),Ee=ze.useCallback(()=>{q(!1),f&&f.dismissBreakAlert()},[f]),De=ze.useCallback(()=>{q(!1),ce()},[ce]),Be=xe=>{u(xe),h(!1)},We=()=>{console.log("Stretch completed, returning to dashboard"),u(null),ce()},Ke=()=>{console.log("Stretch skipped, returning to dashboard"),u(null)},nt=xe=>{_(xe),f&&f.updateSettings(xe)},qe=()=>{f&&_(f.getCurrentSettings()),T(!0)};return l?$.jsx("div",{className:"min-h-screen bg-gray-50 flex items-center justify-center p-4",children:$.jsx("div",{className:"w-full",children:$.jsx(iB,{duration:l.duration,instructions:l.instructions,name:l.name,description:l.description,onComplete:We,onCancel:Ke})})}):c?$.jsx("div",{className:"min-h-screen bg-gray-50 p-4",children:$.jsxs("div",{className:"max-w-2xl mx-auto",children:[$.jsxs("div",{className:"bg-white rounded-lg shadow-md p-6 mb-4",children:[$.jsx("h2",{className:"text-2xl font-bold text-gray-800 mb-4",children:"AI-Generated Stretch Suggestions"}),$.jsxs("p",{className:"text-gray-600 mb-4",children:["Based on your current posture score (",n==null?void 0:n.postureScore,"/10) and screen time (",n==null?void 0:n.screenTime," minutes)"]}),$.jsxs("div",{className:"flex gap-3",children:[$.jsx("button",{onClick:()=>h(!1),className:"bg-gray-600 hover:bg-gray-700 text-white font-medium py-2 px-4 rounded-md transition-colors",children:"Back to Dashboard"}),$.jsx("button",{onClick:de,disabled:d,className:"bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-700 hover:to-indigo-700 disabled:from-gray-400 disabled:to-gray-400 text-white font-medium py-2 px-4 rounded-md transition-all duration-200 flex items-center shadow-lg hover:shadow-xl",children:d?$.jsxs($.Fragment,{children:[$.jsx("div",{className:"animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2"}),"Gemini 2.5 Generating..."]}):$.jsxs($.Fragment,{children:[$.jsx("svg",{className:"w-4 h-4 mr-2",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:$.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"})}),"Generate New Stretches"]})})]})]}),s.map((xe,He)=>$.jsx(aB,{suggestion:xe,onStart:()=>Be(xe),onSkip:()=>h(!1),onDelete:()=>{a(tt=>tt.filter((xt,wt)=>wt!==He))}},`${xe.name}-${He}`))]})}):$.jsxs($.Fragment,{children:[$.jsx("div",{className:"min-h-screen bg-gradient-to-br from-gray-50 to-blue-50",children:$.jsx("div",{className:"max-w-7xl mx-auto p-6",children:$.jsxs("div",{className:"grid grid-cols-1 lg:grid-cols-3 gap-8",children:[$.jsx("div",{className:"lg:col-span-1",children:$.jsxs("div",{className:"sticky top-6",children:[$.jsx(ike,{onPostureUpdate:G,onError:J,isActive:t}),$.jsxs("div",{className:"mt-6 space-y-3",children:[$.jsx("button",{onClick:oe,disabled:t,className:"w-full bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 text-white font-medium py-3 px-4 rounded-lg transition-colors duration-200",children:t?"Monitoring Active":"Start Monitoring"}),$.jsx("button",{onClick:ue,disabled:!t,className:"w-full bg-gray-600 hover:bg-gray-700 disabled:bg-gray-400 text-white font-medium py-3 px-4 rounded-lg transition-colors duration-200",children:"Pause Monitoring"})]}),$.jsx("div",{className:"mt-6 bg-white rounded-lg border border-gray-200 p-4",children:$.jsxs("div",{className:"text-center",children:[$.jsx("div",{className:`w-3 h-3 mx-auto mb-3 rounded-full ${t?"bg-green-500":"bg-gray-400"}`}),$.jsx("p",{className:"text-sm text-gray-600 mb-1",children:"System Status"}),$.jsx("p",{className:`text-lg font-semibold ${t?"text-green-600":"text-gray-500"}`,children:t?"Active":"Inactive"}),$.jsx("p",{className:"text-xs text-gray-500 mt-1",children:t?"Posture monitoring enabled":"Click start to begin monitoring"})]})})]})}),$.jsxs("div",{className:"lg:col-span-2",children:[$.jsx(oke,{trackingData:n,postureAnalysis:b,isMonitoring:t,onGenerateSuggestions:de,onTakeBreak:ce,isGeneratingSuggestions:d,onOpenSettings:qe}),w&&$.jsx("div",{className:"mt-6 bg-gradient-to-r from-red-50 to-pink-50 border border-red-200 rounded-xl p-6 shadow-lg",children:$.jsxs("div",{className:"flex items-center gap-3",children:[$.jsx("div",{className:"w-10 h-10 bg-red-100 rounded-full flex items-center justify-center",children:$.jsx("span",{className:"text-red-600 text-lg",children:"⚠️"})}),$.jsxs("div",{children:[$.jsx("h3",{className:"text-lg font-semibold text-red-800",children:"Camera Error"}),$.jsx("p",{className:"text-red-600",children:w})]})]})}),$.jsx("div",{className:"mt-12 bg-gray-50 rounded-lg p-8 border border-gray-200",children:$.jsxs("div",{className:"max-w-4xl mx-auto",children:[$.jsxs("div",{className:"text-center mb-8",children:[$.jsx("h2",{className:"text-2xl font-semibold text-gray-800 mb-4",children:"Health Impact of Desk Work"}),$.jsx("p",{className:"text-gray-600",children:"Understanding the health effects of prolonged sitting and screen time"})]}),$.jsxs("div",{className:"grid md:grid-cols-2 gap-8",children:[$.jsxs("div",{className:"bg-white rounded-lg p-6 border border-gray-200",children:[$.jsxs("div",{className:"flex items-center gap-3 mb-4",children:[$.jsx("div",{className:"w-8 h-8 bg-red-100 rounded flex items-center justify-center",children:$.jsx("div",{className:"w-4 h-4 bg-red-500 rounded-sm"})}),$.jsx("h3",{className:"text-lg font-semibold text-gray-800",children:"Posture-Related Health Issues"})]}),$.jsxs("div",{className:"space-y-4",children:[$.jsxs("div",{className:"border-l-4 border-red-400 pl-4",children:[$.jsx("h4",{className:"font-semibold text-gray-800 mb-2",children:"Musculoskeletal Issues"}),$.jsxs("ul",{className:"text-sm text-gray-600 space-y-1",children:[$.jsx("li",{children:"• Chronic neck and shoulder pain"}),$.jsx("li",{children:"• Lower back problems and disc degeneration"}),$.jsx("li",{children:'• Forward head posture leading to "tech neck"'}),$.jsx("li",{children:"• Rounded shoulders and upper back pain"})]})]}),$.jsxs("div",{className:"border-l-4 border-orange-400 pl-4",children:[$.jsx("h4",{className:"font-semibold text-gray-800 mb-2",children:"Long-term Consequences"}),$.jsxs("ul",{className:"text-sm text-gray-600 space-y-1",children:[$.jsx("li",{children:"• Permanent spinal misalignment"}),$.jsx("li",{children:"• Reduced lung capacity and breathing issues"}),$.jsx("li",{children:"• Increased risk of arthritis and joint problems"}),$.jsx("li",{children:"• Chronic headaches and migraines"})]})]})]})]}),$.jsxs("div",{className:"bg-white rounded-lg p-6 border border-gray-200",children:[$.jsxs("div",{className:"flex items-center gap-3 mb-4",children:[$.jsx("div",{className:"w-8 h-8 bg-blue-100 rounded flex items-center justify-center",children:$.jsx("div",{className:"w-4 h-4 bg-blue-500 rounded-sm"})}),$.jsx("h3",{className:"text-lg font-semibold text-gray-800",children:"Screen Time Health Effects"})]}),$.jsxs("div",{className:"space-y-4",children:[$.jsxs("div",{className:"border-l-4 border-blue-400 pl-4",children:[$.jsx("h4",{className:"font-semibold text-gray-800 mb-2",children:"Eye Strain & Vision"}),$.jsxs("ul",{className:"text-sm text-gray-600 space-y-1",children:[$.jsx("li",{children:"• Digital eye strain and dry eyes"}),$.jsx("li",{children:"• Blurred vision and difficulty focusing"}),$.jsx("li",{children:"• Increased risk of myopia (nearsightedness)"}),$.jsx("li",{children:"• Computer vision syndrome"})]})]}),$.jsxs("div",{className:"border-l-4 border-purple-400 pl-4",children:[$.jsx("h4",{className:"font-semibold text-gray-800 mb-2",children:"Mental & Physical Health"}),$.jsxs("ul",{className:"text-sm text-gray-600 space-y-1",children:[$.jsx("li",{children:"• Sleep disruption and circadian rhythm issues"}),$.jsx("li",{children:"• Increased stress and anxiety levels"}),$.jsx("li",{children:"• Reduced physical activity and fitness"}),$.jsx("li",{children:"• Social isolation and decreased well-being"})]})]})]})]})]}),$.jsxs("div",{className:"mt-8 bg-white rounded-lg p-6 border border-gray-200",children:[$.jsxs("div",{className:"flex items-center gap-3 mb-6",children:[$.jsx("div",{className:"w-8 h-8 bg-green-100 rounded flex items-center justify-center",children:$.jsx("div",{className:"w-4 h-4 bg-green-500 rounded-sm"})}),$.jsx("h3",{className:"text-lg font-semibold text-gray-800",children:"Prevention Strategies"})]}),$.jsxs("div",{className:"grid md:grid-cols-3 gap-6",children:[$.jsxs("div",{className:"text-center",children:[$.jsx("div",{className:"w-12 h-12 bg-gray-100 rounded-lg flex items-center justify-center mx-auto mb-3",children:$.jsx("div",{className:"w-6 h-6 bg-gray-600 rounded"})}),$.jsx("h4",{className:"font-medium text-gray-800 mb-2",children:"Regular Breaks"}),$.jsx("p",{className:"text-sm text-gray-600",children:"Take breaks every 45-60 minutes to stretch, walk, and rest your eyes"})]}),$.jsxs("div",{className:"text-center",children:[$.jsx("div",{className:"w-12 h-12 bg-gray-100 rounded-lg flex items-center justify-center mx-auto mb-3",children:$.jsx("div",{className:"w-6 h-6 bg-gray-600 rounded"})}),$.jsx("h4",{className:"font-medium text-gray-800 mb-2",children:"Posture Awareness"}),$.jsx("p",{className:"text-sm text-gray-600",children:"Maintain neutral spine, keep shoulders relaxed, and head aligned"})]}),$.jsxs("div",{className:"text-center",children:[$.jsx("div",{className:"w-12 h-12 bg-gray-100 rounded-lg flex items-center justify-center mx-auto mb-3",children:$.jsx("div",{className:"w-6 h-6 bg-gray-600 rounded"})}),$.jsx("h4",{className:"font-medium text-gray-800 mb-2",children:"Strengthening"}),$.jsx("p",{className:"text-sm text-gray-600",children:"Regular exercise and stretching to counteract desk work effects"})]})]})]}),$.jsxs("div",{className:"mt-8 text-center",children:[$.jsxs("p",{className:"text-gray-600 mb-4",children:[$.jsx("strong",{children:"PostureGuard"})," helps you maintain healthy habits and prevent these long-term health issues."]}),$.jsxs("div",{className:"flex flex-wrap gap-4 justify-center",children:[$.jsx("div",{className:"bg-white rounded-lg px-4 py-2 border border-gray-200",children:$.jsx("span",{className:"text-sm font-medium text-gray-700",children:"Real-time posture monitoring"})}),$.jsx("div",{className:"bg-white rounded-lg px-4 py-2 border border-gray-200",children:$.jsx("span",{className:"text-sm font-medium text-gray-700",children:"Smart break reminders"})}),$.jsx("div",{className:"bg-white rounded-lg px-4 py-2 border border-gray-200",children:$.jsx("span",{className:"text-sm font-medium text-gray-700",children:"Personalized stretch suggestions"})})]})]})]})})]})]})})}),$.jsx(lke,{isOpen:N,onClose:()=>T(!1),onSave:nt,currentSettings:E}),$.jsx(uke,{isOpen:O,onClose:()=>{M(!1),f&&f.dismissPostureAlert()},issues:(V==null?void 0:V.issues)||[],score:(V==null?void 0:V.score)||0,onGetStretch:Te}),$.jsx(cke,{isOpen:K,onClose:Ee,onTakeBreak:De,screenTime:(n==null?void 0:n.screenTime)||0})]})}Bx.createRoot(document.getElementById("root")).render($.jsx(VL.StrictMode,{children:$.jsx(hke,{})}));export{N_ as $,Ab as A,B,PA as C,MA as D,Jr as E,Fk as F,Xk as G,Yk as H,Zk as I,Zr as J,Jk as K,za as L,Md as M,Nu as N,DA as O,e2 as P,Qk as Q,Rb as R,LA as S,Ts as T,U,mf as V,Wa as W,Jke as X,e2e as Y,e_ as Z,FA as _,Rk as a,qA as a$,k_ as a0,S_ as a1,I_ as a2,T_ as a3,C_ as a4,o0 as a5,yf as a6,$_ as a7,bf as a8,R_ as a9,kF as aA,NF as aB,SF as aC,CF as aD,pF as aE,gF as aF,xF as aG,z_ as aH,u2 as aI,B_ as aJ,u0 as aK,L_ as aL,l2 as aM,U_ as aN,h2 as aO,c2 as aP,$F as aQ,EF as aR,aF as aS,iF as aT,oF as aU,Y_ as aV,RF as aW,AF as aX,FF as aY,_F as aZ,MF as a_,__ as aa,F_ as ab,O_ as ac,D_ as ad,H_ as ae,j_ as af,d2 as ag,V_ as ah,G_ as ai,K_ as aj,q_ as ak,X_ as al,Q_ as am,Z_ as an,eF as ao,rF as ap,tF as aq,nF as ar,J_ as as,sF as at,lF as au,uF as av,cF as aw,fF as ax,yF as ay,vF as az,at as b,ip as b$,Uq as b0,Vq as b1,XA as b2,QA as b3,Wq as b4,jke as b5,KA as b6,r2 as b7,s2 as b8,r0 as b9,Tl as bA,Zd as bB,iy as bC,oy as bD,Jd as bE,ep as bF,Zu as bG,Ju as bH,ec as bI,nc as bJ,tc as bK,tp as bL,np as bM,uy as bN,ly as bO,rp as bP,sp as bQ,cy as bR,hy as bS,dy as bT,kB as bU,Tq as bV,rc as bW,sc as bX,ac as bY,py as bZ,ap as b_,Gke as ba,a0 as bb,qke as bc,Xke as bd,Z as be,f9 as bf,Cs as bg,Er as bh,Q as bi,Ls as bj,dn as bk,Bs as bl,Lk as bm,Y as bn,hn as bo,hr as bp,j as bq,FB as br,C9 as bs,Qd as bt,Yu as bu,Qu as bv,T3 as bw,E3 as bx,$3 as by,R3 as bz,Hke as c,Fy as c$,op as c0,fy as c1,lp as c2,up as c3,my as c4,gy as c5,ic as c6,oc as c7,by as c8,yy as c9,pc as cA,fc as cB,og as cC,mp as cD,wd as cE,kd as cF,Tx as cG,Ry as cH,gp as cI,BF as cJ,yp as cK,mc as cL,$q as cM,Ay as cN,gc as cO,_y as cP,vn as cQ,yc as cR,bc as cS,xc as cT,ty as cU,Ip as cV,Oy as cW,hq as cX,bp as cY,xp as cZ,vp as c_,cp as ca,Rq as cb,Rw as cc,xy as cd,vy as ce,hp as cf,wy as cg,ky as ch,Sy as ci,dp as cj,ig as ck,ag as cl,Iy as cm,M$ as cn,Ny as co,uc as cp,Cy as cq,gB as cr,pp as cs,cc as ct,hc as cu,fp as cv,dc as cw,Ty as cx,Ey as cy,$y as cz,Fd as d,Ac as d$,vc as d0,wc as d1,SB as d2,wp as d3,kp as d4,Sp as d5,dke as d6,pke as d7,d0 as d8,m0 as d9,A5 as dA,Dp as dB,Mp as dC,mke as dD,Cc as dE,Pp as dF,Lp as dG,_3 as dH,Mw as dI,Pw as dJ,Lw as dK,Wy as dL,qI as dM,Uy as dN,lc as dO,Tc as dP,wr as dQ,Ec as dR,$c as dS,zp as dT,Wp as dU,jy as dV,Bp as dW,Vy as dX,Up as dY,rb as dZ,Rc as d_,fke as da,Np as db,Cp as dc,Tp as dd,My as de,Dy as df,Py as dg,kc as dh,Ep as di,$p as dj,Sc as dk,Rp as dl,Ic as dm,A3 as dn,Ly as dp,Nc as dq,Ap as dr,zy as ds,Dw as dt,By as du,_p as dv,tR as dw,Op as dx,Fp as dy,wo as dz,et as e,ll as e$,Dk as e0,Gy as e1,Ky as e2,Vp as e3,_c as e4,Mc as e5,Dc as e6,Fc as e7,Oc as e8,jp as e9,Vc as eA,tb as eB,nb as eC,Qo as eD,Vw as eE,Xp as eF,Yp as eG,gke as eH,cg as eI,Qp as eJ,vd as eK,yn as eL,gR as eM,yR as eN,ie as eO,LW as eP,ek as eQ,dg as eR,hl as eS,bR as eT,xR as eU,vR as eV,wR as eW,kR as eX,SR as eY,ob as eZ,IR as e_,qp as ea,Pc as eb,Hp as ec,zw as ed,Bw as ee,qy as ef,Xy as eg,Yy as eh,Kp as ei,Lc as ej,Qy as ek,zc as el,Zy as em,jc as en,Jy as eo,eb as ep,Ww as eq,Uw as er,Bc as es,Gp as et,Ua as eu,Wc as ev,Uc as ew,st as ex,wn as ey,Hy as ez,Ro as f,uk as f$,M5 as f0,oU as f1,ef as f2,NR as f3,CR as f4,TR as f5,lb as f6,ER as f7,gU as f8,ZG as f9,K1 as fA,Cke as fB,PR as fC,tf as fD,Qke as fE,kke as fF,WU as fG,LR as fH,Nke as fI,Pe as fJ,Tke as fK,Se as fL,zR as fM,BR as fN,y3 as fO,nu as fP,nf as fQ,Ike as fR,Ske as fS,b3 as fT,ir as fU,QU as fV,ms as fW,ok as fX,VR as fY,pr as fZ,jR as f_,bU as fa,Iu as fb,Dke as fc,Uke as fd,Qe as fe,$R as ff,Cr as fg,ii as fh,to as fi,qt as fj,RR as fk,AR as fl,_R as fm,FR as fn,nk as fo,so as fp,sk as fq,OR as fr,MR as fs,xke as ft,ub as fu,ak as fv,Ak as fw,pg as fx,ik as fy,gi as fz,m2 as g,z as g$,Sb as g0,Gc as g1,_ke as g2,Fke as g3,sf as g4,Jw as g5,_se as g6,v6 as g7,af as g8,l6 as g9,Kke as gA,qR as gB,gs as gC,db as gD,XR as gE,ck as gF,fb as gG,da as gH,mb as gI,hk as gJ,YR as gK,QH as gL,zV as gM,zs as gN,gb as gO,QR as gP,VV as gQ,wi as gR,Qt as gS,QI as gT,HV as gU,Ed as gV,ao as gW,pk as gX,ZR as gY,yb as gZ,t6 as g_,Vke as ga,Nd as gb,BI as gc,lg as gd,O1 as ge,n2e as gf,Mke as gg,Pke as gh,_r as gi,vo as gj,_d as gk,cb as gl,d6 as gm,z3 as gn,Nk as go,GR as gp,HR as gq,KR as gr,An as gs,hb as gt,$d as gu,$l as gv,C3 as gw,SV as gx,Bu as gy,Zke as gz,Je as h,kk as h$,ZV as h0,ej as h1,Lt as h2,Y3 as h3,rf as h4,Pu as h5,Kr as h6,ys as h7,aj as h8,pa as h9,Yke as hA,Ka as hB,yk as hC,Ake as hD,js as hE,oG as hF,uG as hG,hG as hH,pG as hI,Ib as hJ,bk as hK,xk as hL,Me as hM,r6 as hN,Bke as hO,dk as hP,vk as hQ,wk as hR,Wke as hS,Rke as hT,Oke as hU,ine as hV,xG as hW,UO as hX,ps as hY,u3 as hZ,YH as h_,lj as ha,cj as hb,dj as hc,fj as hd,JR as he,mi as hf,xb as hg,mR as hh,e3 as hi,Eke as hj,kj as hk,Ij as hl,Cj as hm,Ej as hn,qj as ho,gk as hp,Qj as hq,Al as hr,eG as hs,Lu as ht,QB as hu,Rd as hv,l3 as hw,qw as hx,NB as hy,sb as hz,Nl as i,Sk as i0,je as i1,vb as i2,Ik as i3,wb as i4,Ad as i5,R5 as i6,kb as i7,Hc as i8,bb as i9,$ke as iA,p3 as iB,ql as iC,Ek as iD,f3 as iE,bke as iF,yke as iG,$k as iH,Gs as iI,On as iJ,XG as iK,vke as iL,Lke as iM,zke as iN,m3 as iO,TV as iP,r2e as iQ,t2e as iR,Un as iS,g3 as iT,rn as iU,dt as iV,ZH as ia,i6 as ib,XH as ic,Qr as id,Vn as ie,It as ig,Ck as ih,yt as ii,Tr as ij,qc as ik,c3 as il,JH as im,Ie as io,Re as ip,ab as iq,h3 as ir,pl as is,d3 as it,zG as iu,BG as iv,WG as iw,VG as ix,wke as iy,Ds as iz,F as j,ko as k,l0 as l,xq as m,R as n,fk as o,me as p,ht as q,ot as r,BA as s,WA as t,UA as u,VA as v,_A as w,qk as x,yo as y,OA as z};
